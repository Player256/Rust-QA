<!DOCTYPE html><html>
<head>
<title></title>
<style type="text/css">
<!--
.xflip {
    -moz-transform: scaleX(-1);
    -webkit-transform: scaleX(-1);
    -o-transform: scaleX(-1);
    transform: scaleX(-1);
    filter: fliph;
}
.yflip {
    -moz-transform: scaleY(-1);
    -webkit-transform: scaleY(-1);
    -o-transform: scaleY(-1);
    transform: scaleY(-1);
    filter: flipv;
}
.xyflip {
    -moz-transform: scaleX(-1) scaleY(-1);
    -webkit-transform: scaleX(-1) scaleY(-1);
    -o-transform: scaleX(-1) scaleY(-1);
    transform: scaleX(-1) scaleY(-1);
    filter: fliph + flipv;
}
-->
</style>
</head>
<body>
<a name=1></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#1"><b>The Rust Programming Language</b></a><br/>
<i>by Steve Klabnik and Carol Nichols, with contributions from the Rust Community</i><br/>
This version of the text assumes you’re using Rust 1.67.1 (released 2023-02-09) or later. See<br/>the&#160;<a href="https://doc.rust-lang.org/book/ch01-01-installation.html">“Installation” section of Chapter 1</a>&#160;to install or update Rust.<br/>
<a href="https://doc.rust-lang.org/stable/book/">The HTML format is available online at&#160;https://doc.rust-lang.org/stable/book/</a>&#160;and oﬄine<br/>with installations of Rust made with&#160;&#160;rustup&#160;; run&#160;&#160;rustup&#160;docs&#160;--book&#160;&#160;to open.<br/>
Several community&#160;<a href="https://doc.rust-lang.org/book/appendix-06-translation.html">translations</a>&#160;are also available.<br/>
This text is available in&#160;<a href="https://nostarch.com/rust-programming-language-2nd-edition">paperback and ebook format from No Starch Press.</a><br/>
<b>&#160;Want a more interactive learning experience? Try out a diﬀerent version of the</b><br/>
<a href="https://rust-book.cs.brown.edu/"><b>Rust Book, featuring: quizzes, highlighting, visualizations, and more</b>:&#160;https://rust-<br/>book.cs.brown.edu</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
1/627<br/>
<hr/>
<a name=2></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#2"><b>Foreword</b></a><br/>
It wasn’t always so clear, but the Rust programming language is fundamentally about<br/><i>empowerment</i>: no matter what kind of code you are writing now, Rust empowers you to<br/>reach farther, to program with conﬁdence in a wider variety of domains than you did<br/>before.<br/>
Take, for example, “systems-level” work that deals with low-level details of memory<br/>management, data representation, and concurrency. Traditionally, this realm of<br/>programming is seen as arcane, accessible only to a select few who have devoted the<br/>necessary years learning to avoid its infamous pitfalls. And even those who practice it do so<br/>with caution, lest their code be open to exploits, crashes, or corruption.<br/>
Rust breaks down these barriers by eliminating the old pitfalls and providing a friendly,<br/>polished set of tools to help you along the way. Programmers who need to “dip down” into<br/>lower-level control can do so with Rust, without taking on the customary risk of crashes or<br/>security holes, and without having to learn the&#160;ﬁne points of a&#160;ﬁckle toolchain. Better yet,<br/>the language is designed to guide you naturally towards reliable code that is eﬃcient in<br/>terms of speed and memory usage.<br/>
Programmers who are already working with low-level code can use Rust to raise their<br/>ambitions. For example, introducing parallelism in Rust is a relatively low-risk operation: the<br/>compiler will catch the classical mistakes for you. And you can tackle more aggressive<br/>optimizations in your code with the conﬁdence that you won’t accidentally introduce<br/>crashes or vulnerabilities.<br/>
But Rust isn’t limited to low-level systems programming. It’s expressive and ergonomic<br/>enough to make CLI apps, web servers, and many other kinds of code quite pleasant to<br/>write — you’ll&#160;ﬁnd simple examples of both later in the book. Working with Rust allows you<br/>to build skills that transfer from one domain to another; you can learn Rust by writing a web<br/>app, then apply those same skills to target your Raspberry Pi.<br/>
This book fully embraces the potential of Rust to empower its users. It’s a friendly and<br/>approachable text intended to help you level up not just your knowledge of Rust, but also<br/>your reach and conﬁdence as a programmer in general. So dive in, get ready to learn—and<br/>welcome to the Rust community!<br/>
— Nicholas Matsakis and Aaron Turon<br/>
https://doc.rust-lang.org/book/print.html<br/>
2/627<br/>
<hr/>
<a name=3></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#3"><b>Introduction</b></a><br/>
Note: This edition of the book is the same as&#160;<a href="https://nostarch.com/rust-programming-language-2nd-edition">The Rust Programming Language<br/></a><a href="https://nostarch.com/">available in print and ebook format from&#160;No Starch Press.</a><br/>
Welcome to&#160;<i>The Rust Programming Language</i>, an introductory book about Rust. The Rust<br/>programming language helps you write faster, more reliable software. High-level<br/>ergonomics and low-level control are often at odds in programming language design; Rust<br/>challenges that conﬂict. Through balancing powerful technical capacity and a great<br/>developer experience, Rust gives you the option to control low-level details (such as<br/>memory usage) without all the hassle traditionally associated with such control.<br/>
<a href="tests.html#3"><b>Who Rust Is For</b></a><br/>
Rust is ideal for many people for a variety of reasons. Let’s look at a few of the most<br/>important groups.<br/>
<a href="tests.html#3"><b>Teams&#160;of&#160;Developers</b></a><br/>
Rust is proving to be a productive tool for collaborating among large teams of developers<br/>with varying levels of systems programming knowledge. Low-level code is prone to various<br/>subtle bugs, which in most other languages can be caught only through extensive testing<br/>and careful code review by experienced developers. In Rust, the compiler plays a<br/>gatekeeper role by refusing to compile code with these elusive bugs, including concurrency<br/>bugs. By working alongside the compiler, the team can spend their time focusing on the<br/>program’s logic rather than chasing down bugs.<br/>
Rust also brings contemporary developer tools to the systems programming world:<br/>
Cargo, the included dependency manager and build tool, makes adding, compiling,<br/>and managing dependencies painless and consistent across the Rust ecosystem.<br/>The Rustfmt formatting tool ensures a consistent coding style across developers.<br/>The Rust Language Server powers Integrated Development Environment (IDE)<br/>integration for code completion and inline error messages.<br/>
By using these and other tools in the Rust ecosystem, developers can be productive while<br/>writing systems-level code.<br/>
https://doc.rust-lang.org/book/print.html<br/>
3/627<br/>
<hr/>
<a name=4></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#4"><b>Students</b></a><br/>
Rust is for students and those who are interested in learning about systems concepts. Using<br/>Rust, many people have learned about topics like operating systems development. The<br/>community is very welcoming and happy to answer student questions. Through eﬀorts such<br/>as this book, the Rust teams want to make systems concepts more accessible to more<br/>people, especially those new to programming.<br/>
<a href="tests.html#4"><b>Companies</b></a><br/>
Hundreds of companies, large and small, use Rust in production for a variety of tasks,<br/>including command line tools, web services, DevOps tooling, embedded devices, audio and<br/>video analysis and transcoding, cryptocurrencies, bioinformatics, search engines, Internet of<br/>Things applications, machine learning, and even major parts of the Firefox web browser.<br/>
<a href="tests.html#4"><b>Open&#160;Source&#160;Developers</b></a><br/>
Rust is for people who want to build the Rust programming language, community,<br/>developer tools, and libraries. We’d love to have you contribute to the Rust language.<br/>
<a href="tests.html#4"><b>People&#160;Who&#160;Value&#160;Speed&#160;and&#160;Stability</b></a><br/>
Rust is for people who crave speed and stability in a language. By speed, we mean both how<br/>quickly Rust code can run and the speed at which Rust lets you write programs. The Rust<br/>compiler’s checks ensure stability through feature additions and refactoring. This is in<br/>contrast to the brittle legacy code in languages without these checks, which developers are<br/>often afraid to modify. By striving for zero-cost abstractions, higher-level features that<br/>compile to lower-level code as fast as code written manually, Rust endeavors to make safe<br/>code be fast code as well.<br/>
The Rust language hopes to support many other users as well; those mentioned here are<br/>merely some of the biggest stakeholders. Overall, Rust’s greatest ambition is to eliminate<br/>the trade-oﬀs that programmers have accepted for decades by providing safety&#160;<i>and<br/></i>productivity, speed&#160;<i>and</i>&#160;ergonomics. Give Rust a try and see if its choices work for you.<br/>
<a href="tests.html#4"><b>Who This Book Is For</b></a><br/>
This book assumes that you’ve written code in another programming language but doesn’t<br/>make any assumptions about which one. We’ve tried to make the material broadly<br/>accessible to those from a wide variety of programming backgrounds. We don’t spend a lot<br/>
https://doc.rust-lang.org/book/print.html<br/>
4/627<br/>
<hr/>
<a name=5></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
of time talking about what programming&#160;<i>is</i>&#160;or how to think about it. If you’re entirely new to<br/>programming, you would be better served by reading a book that speciﬁcally provides an<br/>introduction to programming.<br/>
<a href="tests.html#5"><b>How to Use This Book</b></a><br/>
In general, this book assumes that you’re reading it in sequence from front to back. Later<br/>chapters build on concepts in earlier chapters, and earlier chapters might not delve into<br/>details on a particular topic but will revisit the topic in a later chapter.<br/>
You’ll&#160;ﬁnd two kinds of chapters in this book: concept chapters and project chapters. In<br/>concept chapters, you’ll learn about an aspect of Rust. In project chapters, we’ll build small<br/>programs together, applying what you’ve learned so far. Chapters 2, 12, and 20 are project<br/>chapters; the rest are concept chapters.<br/>
Chapter 1 explains how to install Rust, how to write a “Hello, world!” program, and how to<br/>use Cargo, Rust’s package manager and build tool. Chapter 2 is a hands-on introduction to<br/>writing a program in Rust, having you build up a number guessing game. Here we cover<br/>concepts at a high level, and later chapters will provide additional detail. If you want to get<br/>your hands dirty right away, Chapter 2 is the place for that. Chapter 3 covers Rust features<br/>that are similar to those of other programming languages, and in Chapter 4 you’ll learn<br/>about Rust’s ownership system. If you’re a particularly meticulous learner who prefers to<br/>learn every detail before moving on to the next, you might want to skip Chapter 2 and go<br/>straight to Chapter 3, returning to Chapter 2 when you’d like to work on a project applying<br/>the details you’ve learned.<br/>
Chapter 5 discusses structs and methods, and Chapter 6 covers enums,&#160;&#160;match&#160;&#160;expressions,<br/>and the&#160;&#160;if&#160;let&#160;&#160;control&#160;ﬂow construct. You’ll use structs and enums to make custom types<br/>in Rust.<br/>
In Chapter 7, you’ll learn about Rust’s module system and about privacy rules for organizing<br/>your code and its public Application Programming Interface (API). Chapter 8 discusses some<br/>common collection data structures that the standard library provides, such as vectors,<br/>strings, and hash maps. Chapter 9 explores Rust’s error-handling philosophy and<br/>techniques.<br/>
Chapter 10 digs into generics, traits, and lifetimes, which give you the power to deﬁne code<br/>that applies to multiple types. Chapter 11 is all about testing, which even with Rust’s safety<br/>guarantees is necessary to ensure your program’s logic is correct. In Chapter 12, we’ll build<br/>our own implementation of a subset of functionality from the&#160;&#160;grep&#160;&#160;command line tool that<br/>searches for text within&#160;ﬁles. For this, we’ll use many of the concepts we discussed in the<br/>previous chapters.<br/>
https://doc.rust-lang.org/book/print.html<br/>
5/627<br/>
<hr/>
<a name=6></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Chapter 13 explores closures and iterators: features of Rust that come from functional<br/>programming languages. In Chapter 14, we’ll examine Cargo in more depth and talk about<br/>best practices for sharing your libraries with others. Chapter 15 discusses smart pointers<br/>that the standard library provides and the traits that enable their functionality.<br/>
In Chapter 16, we’ll walk through diﬀerent models of concurrent programming and talk<br/>about how Rust helps you to program in multiple threads fearlessly. Chapter 17 looks at<br/>how Rust idioms compare to object-oriented programming principles you might be familiar<br/>with.<br/>
Chapter 18 is a reference on patterns and pattern matching, which are powerful ways of<br/>expressing ideas throughout Rust programs. Chapter 19 contains a smorgasbord of<br/>advanced topics of interest, including unsafe Rust, macros, and more about lifetimes, traits,<br/>types, functions, and closures.<br/>
In Chapter 20, we’ll complete a project in which we’ll implement a low-level multithreaded<br/>web server!<br/>
Finally, some appendices contain useful information about the language in a more<br/>reference-like format. Appendix A covers Rust’s keywords, Appendix B covers Rust’s<br/>operators and symbols, Appendix C covers derivable traits provided by the standard library,<br/>Appendix D covers some useful development tools, and Appendix E explains Rust editions.<br/>In Appendix F, you can&#160;ﬁnd translations of the book, and in Appendix G we’ll cover how Rust<br/>is made and what nightly Rust is.<br/>
There is no wrong way to read this book: if you want to skip ahead, go for it! You might have<br/>to jump back to earlier chapters if you experience any confusion. But do whatever works for<br/>you.<br/>
An important part of the process of learning Rust is learning how to read the error<br/>messages the compiler displays: these will guide you toward working code. As such, we’ll<br/>provide many examples that don’t compile along with the error message the compiler will<br/>show you in each situation. Know that if you enter and run a random example, it may not<br/>compile! Make sure you read the surrounding text to see whether the example you’re trying<br/>to run is meant to error. Ferris will also help you distinguish code that isn’t meant to work:<br/>
<b>Ferris</b><br/>
<b>Meaning</b><br/>
This code does not compile!<br/>
This code panics!<br/>
https://doc.rust-lang.org/book/print.html<br/>
6/627<br/>
<hr/>
<a name=7></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Ferris</b><br/>
<b>Meaning</b><br/>
This code does not produce the desired behavior.<br/>
In most situations, we’ll lead you to the correct version of any code that doesn’t compile.<br/>
<a href="tests.html#7"><b>Source Code</b></a><br/>
The source&#160;ﬁles from which this book is generated can be found on&#160;<a href="https://github.com/rust-lang/book/tree/main/src">GitHub</a>.<br/>
https://doc.rust-lang.org/book/print.html<br/>
7/627<br/>
<hr/>
<a name=8></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#8"><b>Getting Started</b></a><br/>
Let’s start your Rust journey! There’s a lot to learn, but every journey starts somewhere. In<br/>this chapter, we’ll discuss:<br/>
Installing Rust on Linux, macOS, and Windows<br/>Writing a program that prints&#160;&#160;Hello,&#160;world!<br/>Using&#160;&#160;cargo&#160;, Rust’s package manager and build system<br/>
https://doc.rust-lang.org/book/print.html<br/>
8/627<br/>
<hr/>
<a name=9></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#9"><b>Installation</b></a><br/>
The&#160;ﬁrst step is to install Rust. We’ll download Rust through&#160;&#160;rustup&#160;, a command line tool<br/>for managing Rust versions and associated tools. You’ll need an internet connection for the<br/>download.<br/>
<a href="https://forge.rust-lang.org/infra/other-installation-methods.html">Note: If you prefer not to use&#160;&#160;rustup&#160;&#160;for some reason, please see the&#160;Other Rust<br/>Installation Methods page&#160;for more options.</a><br/>
The following steps install the latest stable version of the Rust compiler. Rust’s stability<br/>guarantees ensure that all the examples in the book that compile will continue to compile<br/>with newer Rust versions. The output might diﬀer slightly between versions because Rust<br/>often improves error messages and warnings. In other words, any newer, stable version of<br/>Rust you install using these steps should work as expected with the content of this book.<br/>
<a href="tests.html#9"><b>Command&#160;Line&#160;Notation</b></a><br/>
In this chapter and throughout the book, we’ll show some commands used in the<br/>terminal. Lines that you should enter in a terminal all start with&#160;&#160;$&#160;. You don’t need to<br/>type the&#160;&#160;$&#160;&#160;character; it’s the command line prompt shown to indicate the start of each<br/>command. Lines that don’t start with&#160;&#160;$&#160;&#160;typically show the output of the previous<br/>command. Additionally, PowerShell-speciﬁc examples will use&#160;&#160;&gt;&#160;&#160;rather than&#160;&#160;$&#160;.<br/>
<a href="tests.html#9"><b>Installing&#160;</b>rustup<b>&#160;on&#160;Linux&#160;or&#160;macOS</b></a><br/>
If you’re using Linux or macOS, open a terminal and enter the following command:<br/>
$&#160;curl&#160;--proto&#160;'=https'&#160;--tlsv1.2&#160;https://sh.rustup.rs&#160;-sSf&#160;|&#160;sh<br/>
The command downloads a script and starts the installation of the&#160;&#160;rustup&#160;&#160;tool, which<br/>installs the latest stable version of Rust. You might be prompted for your password. If the<br/>install is successful, the following line will appear:<br/>
Rust&#160;is&#160;installed&#160;now.&#160;Great!<br/>
You will also need a&#160;<i>linker</i>, which is a program that Rust uses to join its compiled outputs<br/>into one&#160;ﬁle. It is likely you already have one. If you get linker errors, you should install a C<br/>
https://doc.rust-lang.org/book/print.html<br/>
9/627<br/>
<hr/>
<a name=10></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
compiler, which will typically include a linker. A C compiler is also useful because some<br/>common Rust packages depend on C code and will need a C compiler.<br/>
On macOS, you can get a C compiler by running:<br/>
$&#160;xcode-select&#160;--install<br/>
Linux users should generally install GCC or Clang, according to their distribution’s<br/>documentation. For example, if you use Ubuntu, you can install the&#160;&#160;build-essential<br/>package.<br/>
<a href="tests.html#10"><b>Installing&#160;</b>rustup<b>&#160;on&#160;Windows</b></a><br/>
On Windows, go to&#160;<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a>&#160;and follow the instructions for<br/>installing Rust. At some point in the installation, you’ll receive a message explaining that<br/>you’ll also need the MSVC build tools for Visual Studio 2013 or later.<br/>
To acquire the build tools, you’ll need to install&#160;<a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2022</a>. When asked which<br/>workloads to install, include:<br/>
“Desktop Development with C++”<br/>The Windows 10 or 11 SDK<br/>The English language pack component, along with any other language pack of your<br/>choosing<br/>
The rest of this book uses commands that work in both&#160;<i>cmd.exe</i>&#160;and PowerShell. If there are<br/>speciﬁc diﬀerences, we’ll explain which to use.<br/>
<a href="tests.html#10"><b>Troubleshooting</b></a><br/>
To check whether you have Rust installed correctly, open a shell and enter this line:<br/>
$&#160;rustc&#160;--version<br/>
You should see the version number, commit hash, and commit date for the latest stable<br/>version that has been released, in the following format:<br/>
rustc&#160;x.y.z&#160;(abcabcabc&#160;yyyy-mm-dd)<br/>
If you see this information, you have installed Rust successfully! If you don’t see this<br/>information, check that Rust is in your&#160;&#160;%PATH%&#160;&#160;system variable as follows.<br/>
In Windows CMD, use:<br/>
https://doc.rust-lang.org/book/print.html<br/>
10/627<br/>
<hr/>
<a name=11></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&gt;&#160;echo&#160;%PATH%<br/>
In PowerShell, use:<br/>
&gt;&#160;echo&#160;$env:Path<br/>
In Linux and macOS, use:<br/>
$&#160;echo&#160;$PATH<br/>
If that’s all correct and Rust still isn’t working, there are a number of places you can get help.<br/>Find out how to get in touch with other Rustaceans (a silly nickname we call ourselves) on<br/><a href="https://www.rust-lang.org/community">the community page.</a><br/>
<a href="tests.html#11"><b>Updating&#160;and&#160;Uninstalling</b></a><br/>
Once Rust is installed via&#160;&#160;rustup&#160;, updating to a newly released version is easy. From your<br/>shell, run the following update script:<br/>
$&#160;rustup&#160;update<br/>
To uninstall Rust and&#160;&#160;rustup&#160;, run the following uninstall script from your shell:<br/>
$&#160;rustup&#160;self&#160;uninstall<br/>
<a href="tests.html#11"><b>Local&#160;Documentation</b></a><br/>
The installation of Rust also includes a local copy of the documentation so that you can read<br/>it oﬄine. Run&#160;&#160;rustup&#160;doc&#160;&#160;to open the local documentation in your browser.<br/>
Any time a type or function is provided by the standard library and you’re not sure what it<br/>does or how to use it, use the application programming interface (API) documentation to<br/>ﬁnd out!<br/>
https://doc.rust-lang.org/book/print.html<br/>
11/627<br/>
<hr/>
<a name=12></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#12"><b>Hello, World!</b></a><br/>
Now that you’ve installed Rust, it’s time to write your&#160;ﬁrst Rust program. It’s traditional when<br/>learning a new language to write a little program that prints the text&#160;&#160;Hello,&#160;world!&#160;&#160;to the<br/>screen, so we’ll do the same here!<br/>
Note: This book assumes basic familiarity with the command line. Rust makes no<br/>speciﬁc demands about your editing or tooling or where your code lives, so if you<br/>prefer to use an integrated development environment (IDE) instead of the command<br/>line, feel free to use your favorite IDE. Many IDEs now have some degree of Rust<br/>support; check the IDE’s documentation for details. The Rust team has been focusing<br/>on enabling great IDE support via&#160;&#160;rust-analyzer&#160;<a href="https://doc.rust-lang.org/book/appendix-04-useful-development-tools.html">. See&#160;Appendix D&#160;for more details.</a><br/>
<a href="tests.html#12"><b>Creating&#160;a&#160;Project&#160;Directory</b></a><br/>
You’ll start by making a directory to store your Rust code. It doesn’t matter to Rust where<br/>your code lives, but for the exercises and projects in this book, we suggest making a&#160;<i>projects<br/></i>directory in your home directory and keeping all your projects there.<br/>
Open a terminal and enter the following commands to make a&#160;<i>projects</i>&#160;directory and a<br/>directory for the “Hello, world!” project within the&#160;<i>projects</i>&#160;directory.<br/>
For Linux, macOS, and PowerShell on Windows, enter this:<br/>
$&#160;mkdir&#160;~/projects<br/>$&#160;cd&#160;~/projects<br/>$&#160;mkdir&#160;hello_world<br/>$&#160;cd&#160;hello_world<br/>
For Windows CMD, enter this:<br/>
&gt;&#160;mkdir&#160;&#34;%USERPROFILE%\projects&#34;<br/>&gt;&#160;cd&#160;/d&#160;&#34;%USERPROFILE%\projects&#34;<br/>&gt;&#160;mkdir&#160;hello_world<br/>&gt;&#160;cd&#160;hello_world<br/>
<a href="tests.html#12"><b>Writing&#160;and&#160;Running&#160;a&#160;Rust&#160;Program</b></a><br/>
Next, make a new source&#160;ﬁle and call it&#160;<i>main.rs</i>. Rust&#160;ﬁles always end with the&#160;<i>.rs</i>&#160;extension.<br/>If you’re using more than one word in your&#160;ﬁlename, the convention is to use an underscore<br/>
https://doc.rust-lang.org/book/print.html<br/>
12/627<br/>
<hr/>
<a name=13></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
to separate them. For example, use&#160;<i>hello_world.rs</i>&#160;rather than&#160;<i>helloworld.rs</i>.<br/>
Now open the&#160;<i>main.rs</i>&#160;ﬁle you just created and enter the code in Listing 1-1.<br/>
Filename: main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Hello,&#160;world!&#34;);<br/>}<br/>
<b>Listing&#160;1-1:&#160;A&#160;program&#160;that&#160;prints&#160;&#160;</b>Hello,&#160;world!<br/>
Save the&#160;ﬁle and go back to your terminal window in the&#160;<i>~/projects/hello_world</i>&#160;directory. On<br/>Linux or macOS, enter the following commands to compile and run the&#160;ﬁle:<br/>
$&#160;rustc&#160;main.rs<br/>$&#160;./main<br/>Hello,&#160;world!<br/>
On Windows, enter the command&#160;&#160;.\main.exe&#160;&#160;instead of&#160;&#160;./main&#160;:<br/>
&gt;&#160;rustc&#160;main.rs<br/>&gt;&#160;.\main.exe<br/>Hello,&#160;world!<br/>
Regardless of your operating system, the string&#160;&#160;Hello,&#160;world!&#160;&#160;should print to the<br/><a href="https://doc.rust-lang.org/book/ch01-01-installation.html#troubleshooting">terminal. If you don’t see this output, refer back to the&#160;“Troubleshooting”</a>&#160;part of the<br/>Installation section for ways to get help.<br/>
If&#160;&#160;Hello,&#160;world!&#160;&#160;did print, congratulations! You’ve oﬃcially written a Rust program. That<br/>makes you a Rust programmer—welcome!<br/>
<a href="tests.html#13"><b>Anatomy&#160;of&#160;a&#160;Rust&#160;Program</b></a><br/>
Let’s review this “Hello, world!” program in detail. Here’s the&#160;ﬁrst piece of the puzzle:<br/>
fn&#160;main()&#160;{<br/>
}<br/>
These lines deﬁne a function named&#160;&#160;main&#160;. The&#160;&#160;main&#160;&#160;function is special: it is always the&#160;ﬁrst<br/>code that runs in every executable Rust program. Here, the&#160;ﬁrst line declares a function<br/>named&#160;&#160;main&#160;&#160;that has no parameters and returns nothing. If there were parameters, they<br/>would go inside the parentheses&#160;&#160;()&#160;.<br/>
The function body is wrapped in&#160;&#160;{}&#160;. Rust requires curly brackets around all function<br/>bodies. It’s good style to place the opening curly bracket on the same line as the function<br/>
https://doc.rust-lang.org/book/print.html<br/>
13/627<br/>
<hr/>
<a name=14></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
declaration, adding one space in between.<br/>
Note: If you want to stick to a standard style across Rust projects, you can use an<br/>automatic formatter tool called&#160;&#160;rustfmt&#160;&#160;to format your code in a particular style<br/>(more on&#160;&#160;rustfmt&#160;<a href="https://doc.rust-lang.org/book/appendix-04-useful-development-tools.html">&#160;in&#160;Appendix D). The Rust team has included this tool with the<br/></a>standard Rust distribution, as&#160;&#160;rustc&#160;&#160;is, so it should already be installed on your<br/>computer!<br/>
The body of the&#160;&#160;main&#160;&#160;function holds the following code:<br/>
&#160;&#160;&#160;&#160;println!(&#34;Hello,&#160;world!&#34;);<br/>
This line does all the work in this little program: it prints text to the screen. There are four<br/>important details to notice here.<br/>
First, Rust style is to indent with four spaces, not a tab.<br/>
Second,&#160;&#160;println!&#160;&#160;calls a Rust macro. If it had called a function instead, it would be entered<br/>as&#160;&#160;println&#160;&#160;(without the&#160;&#160;!&#160;). We’ll discuss Rust macros in more detail in Chapter 19. For<br/>now, you just need to know that using a&#160;&#160;!&#160;&#160;means that you’re calling a macro instead of a<br/>normal function and that macros don’t always follow the same rules as functions.<br/>
Third, you see the&#160;&#160;&#34;Hello,&#160;world!&#34;&#160;&#160;string. We pass this string as an argument to<br/>
println!&#160;, and the string is printed to the screen.<br/>
Fourth, we end the line with a semicolon (&#160;;&#160;), which indicates that this expression is over<br/>and the next one is ready to begin. Most lines of Rust code end with a semicolon.<br/>
<a href="tests.html#14"><b>Compiling&#160;and&#160;Running&#160;Are&#160;Separate&#160;Steps</b></a><br/>
You’ve just run a newly created program, so let’s examine each step in the process.<br/>
Before running a Rust program, you must compile it using the Rust compiler by entering the<br/>
rustc&#160;&#160;command and passing it the name of your source&#160;ﬁle, like this:<br/>
$&#160;rustc&#160;main.rs<br/>
If you have a C or C++ background, you’ll notice that this is similar to&#160;&#160;gcc&#160;&#160;or&#160;&#160;clang&#160;. After<br/>compiling successfully, Rust outputs a binary executable.<br/>
On Linux, macOS, and PowerShell on Windows, you can see the executable by entering the<br/>
ls&#160;&#160;command in your shell:<br/>
https://doc.rust-lang.org/book/print.html<br/>
14/627<br/>
<hr/>
<a name=15></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;ls<br/>main&#160;&#160;main.rs<br/>
On Linux and macOS, you’ll see two&#160;ﬁles. With PowerShell on Windows, you’ll see the same<br/>three&#160;ﬁles that you would see using CMD. With CMD on Windows, you would enter the<br/>following:<br/>
&gt;&#160;dir&#160;/B&#160;%=&#160;the&#160;/B&#160;option&#160;says&#160;to&#160;only&#160;show&#160;the&#160;file&#160;names&#160;=%<br/>main.exe<br/>main.pdb<br/>main.rs<br/>
This shows the source code&#160;ﬁle with the&#160;<i>.rs</i>&#160;extension, the executable&#160;ﬁle (<i>main.exe</i>&#160;on<br/>Windows, but&#160;<i>main</i>&#160;on all other platforms), and, when using Windows, a&#160;ﬁle containing<br/>debugging information with the&#160;<i>.pdb</i>&#160;extension. From here, you run the&#160;<i>main</i>&#160;or&#160;<i>main.exe<br/></i>ﬁle, like this:<br/>
$&#160;./main&#160;#&#160;or&#160;.\main.exe&#160;on&#160;Windows<br/>
If your&#160;<i>main.rs</i>&#160;is your “Hello, world!” program, this line prints&#160;&#160;Hello,&#160;world!&#160;&#160;to your<br/>terminal.<br/>
If you’re more familiar with a dynamic language, such as Ruby, Python, or JavaScript, you<br/>might not be used to compiling and running a program as separate steps. Rust is an&#160;<i>ahead-<br/>of-time compiled</i>&#160;language, meaning you can compile a program and give the executable to<br/>someone else, and they can run it even without having Rust installed. If you give someone a<br/><i>.rb</i>,&#160;<i>.py</i>, or&#160;<i>.js</i>&#160;ﬁle, they need to have a Ruby, Python, or JavaScript implementation installed<br/>(respectively). But in those languages, you only need one command to compile and run your<br/>program. Everything is a trade-oﬀ&#160;in language design.<br/>
Just compiling with&#160;&#160;rustc&#160;&#160;is&#160;ﬁne for simple programs, but as your project grows, you’ll want<br/>to manage all the options and make it easy to share your code. Next, we’ll introduce you to<br/>the Cargo tool, which will help you write real-world Rust programs.<br/>
https://doc.rust-lang.org/book/print.html<br/>
15/627<br/>
<hr/>
<a name=16></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#16"><b>Hello, Cargo!</b></a><br/>
Cargo is Rust’s build system and package manager. Most Rustaceans use this tool to<br/>manage their Rust projects because Cargo handles a lot of tasks for you, such as building<br/>your code, downloading the libraries your code depends on, and building those libraries.<br/>(We call the libraries that your code needs&#160;<i>dependencies</i>.)<br/>
The simplest Rust programs, like the one we’ve written so far, don’t have any dependencies.<br/>If we had built the “Hello, world!” project with Cargo, it would only use the part of Cargo that<br/>handles building your code. As you write more complex Rust programs, you’ll add<br/>dependencies, and if you start a project using Cargo, adding dependencies will be much<br/>easier to do.<br/>
Because the vast majority of Rust projects use Cargo, the rest of this book assumes that<br/>you’re using Cargo too. Cargo comes installed with Rust if you used the oﬃcial installers<br/>discussed in the&#160;<a href="https://doc.rust-lang.org/book/ch01-01-installation.html#installation">“Installation”&#160;section. If you installed Rust through some other means,<br/></a>check whether Cargo is installed by entering the following in your terminal:<br/>
$&#160;cargo&#160;--version<br/>
If you see a version number, you have it! If you see an error, such as&#160;&#160;command&#160;not&#160;found&#160;,<br/>look at the documentation for your method of installation to determine how to install Cargo<br/>separately.<br/>
<a href="tests.html#16"><b>Creating&#160;a&#160;Project&#160;with&#160;Cargo</b></a><br/>
Let’s create a new project using Cargo and look at how it diﬀers from our original “Hello,<br/>world!” project. Navigate back to your&#160;<i>projects</i>&#160;directory (or wherever you decided to store<br/>your code). Then, on any operating system, run the following:<br/>
$&#160;cargo&#160;new&#160;hello_cargo<br/>$&#160;cd&#160;hello_cargo<br/>
The&#160;ﬁrst command creates a new directory and project called&#160;<i>hello_cargo</i>. We’ve named our<br/>project&#160;<i>hello_cargo</i>, and Cargo creates its&#160;ﬁles in a directory of the same name.<br/>
Go into the&#160;<i>hello_cargo</i>&#160;directory and list the&#160;ﬁles. You’ll see that Cargo has generated two<br/>ﬁles and one directory for us: a&#160;<i>Cargo.toml</i>&#160;ﬁle and a&#160;<i>src</i>&#160;directory with a&#160;<i>main.rs</i>&#160;ﬁle inside.<br/>
It has also initialized a new Git repository along with a&#160;<i>.gitignore</i>&#160;ﬁle. Git&#160;ﬁles won’t be<br/>generated if you run&#160;&#160;cargo&#160;new&#160;&#160;within an existing Git repository; you can override this<br/>behavior by using&#160;&#160;cargo&#160;new&#160;--vcs=git&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
16/627<br/>
<hr/>
<a name=17></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Note: Git is a common version control system. You can change&#160;&#160;cargo&#160;new&#160;&#160;to use a<br/>diﬀerent version control system or no version control system by using the&#160;&#160;--vcs&#160;&#160;ﬂag.<br/>Run&#160;&#160;cargo&#160;new&#160;--help&#160;&#160;to see the available options.<br/>
Open&#160;<i>Cargo.toml</i>&#160;in your text editor of choice. It should look similar to the code in Listing 1-2.<br/>
Filename: Cargo.toml<br/>
[package]<br/>name&#160;=&#160;&#34;hello_cargo&#34;<br/>version&#160;=&#160;&#34;0.1.0&#34;<br/>edition&#160;=&#160;&#34;2021&#34;<br/>
#&#160;See&#160;more&#160;keys&#160;and&#160;their&#160;definitions&#160;at&#160;https://doc.rust-<br/>lang.org/cargo/reference/manifest.html<br/>
[dependencies]<br/>
<b>Listing&#160;1-2:&#160;Contents&#160;of&#160;<i>Cargo.toml</i></b><b>&#160;generated&#160;by&#160;&#160;</b>cargo&#160;new<br/>
This&#160;ﬁle is in the&#160;<a href="https://toml.io/"><i>TOML</i></a>&#160;(<i>Tom’s Obvious, Minimal Language</i>) format, which is Cargo’s<br/>conﬁguration format.<br/>
The&#160;ﬁrst line,&#160;&#160;[package]&#160;, is a section heading that indicates that the following statements<br/>are conﬁguring a package. As we add more information to this&#160;ﬁle, we’ll add other sections.<br/>
The next three lines set the conﬁguration information Cargo needs to compile your<br/>program: the name, the version, and the edition of Rust to use. We’ll talk about the&#160;&#160;edition<br/>key in&#160;<a href="https://doc.rust-lang.org/book/appendix-05-editions.html">Appendix E</a>.<br/>
The last line,&#160;&#160;[dependencies]&#160;, is the start of a section for you to list any of your project’s<br/>dependencies. In Rust, packages of code are referred to as&#160;<i>crates</i>. We won’t need any other<br/>crates for this project, but we will in the&#160;ﬁrst project in Chapter 2, so we’ll use this<br/>dependencies section then.<br/>
Now open&#160;<i>src/main.rs</i>&#160;and take a look:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Hello,&#160;world!&#34;);<br/>}<br/>
Cargo has generated a “Hello, world!” program for you, just like the one we wrote in Listing<br/>1-1! So far, the diﬀerences between our project and the project Cargo generated are that<br/>Cargo placed the code in the&#160;<i>src</i>&#160;directory and we have a&#160;<i>Cargo.toml</i>&#160;conﬁguration&#160;ﬁle in the<br/>top directory.<br/>
https://doc.rust-lang.org/book/print.html<br/>
17/627<br/>
<hr/>
<a name=18></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Cargo expects your source&#160;ﬁles to live inside the&#160;<i>src</i>&#160;directory. The top-level project directory<br/>is just for README&#160;ﬁles, license information, conﬁguration&#160;ﬁles, and anything else not<br/>related to your code. Using Cargo helps you organize your projects. There’s a place for<br/>everything, and everything is in its place.<br/>
If you started a project that doesn’t use Cargo, as we did with the “Hello, world!” project, you<br/>can convert it to a project that does use Cargo. Move the project code into the&#160;<i>src</i>&#160;directory<br/>and create an appropriate&#160;<i>Cargo.toml</i>&#160;ﬁle.<br/>
<a href="tests.html#18"><b>Building&#160;and&#160;Running&#160;a&#160;Cargo&#160;Project</b></a><br/>
Now let’s look at what’s diﬀerent when we build and run the “Hello, world!” program with<br/>Cargo! From your&#160;<i>hello_cargo</i>&#160;directory, build your project by entering the following<br/>command:<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;Compiling&#160;hello_cargo&#160;v0.1.0&#160;(file:///projects/hello_cargo)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;2.85&#160;secs<br/>
This command creates an executable&#160;ﬁle in&#160;<i>target/debug/hello_cargo</i>&#160;(or<br/><i>target\debug\hello_cargo.exe</i>&#160;on Windows) rather than in your current directory. Because the<br/>default build is a debug build, Cargo puts the binary in a directory named&#160;<i>debug</i>. You can<br/>run the executable with this command:<br/>
$&#160;./target/debug/hello_cargo&#160;#&#160;or&#160;.\target\debug\hello_cargo.exe&#160;on&#160;Windows<br/>Hello,&#160;world!<br/>
If all goes well,&#160;&#160;Hello,&#160;world!&#160;&#160;should print to the terminal. Running&#160;&#160;cargo&#160;build&#160;&#160;for the<br/>ﬁrst time also causes Cargo to create a new&#160;ﬁle at the top level:&#160;<i>Cargo.lock</i>. This&#160;ﬁle keeps<br/>track of the exact versions of dependencies in your project. This project doesn’t have<br/>dependencies, so the&#160;ﬁle is a bit sparse. You won’t ever need to change this&#160;ﬁle manually;<br/>Cargo manages its contents for you.<br/>
We just built a project with&#160;&#160;cargo&#160;build&#160;&#160;and ran it with&#160;&#160;./target/debug/hello_cargo&#160;, but<br/>we can also use&#160;&#160;cargo&#160;run&#160;&#160;to compile the code and then run the resultant executable all in<br/>one command:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.0&#160;secs<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/hello_cargo`<br/>Hello,&#160;world!<br/>
Using&#160;&#160;cargo&#160;run&#160;&#160;is more convenient than having to remember to run&#160;&#160;cargo&#160;build&#160;&#160;and<br/>then use the whole path to the binary, so most developers use&#160;&#160;cargo&#160;run&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
18/627<br/>
<hr/>
<a name=19></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Notice that this time we didn’t see output indicating that Cargo was compiling&#160;&#160;hello_cargo&#160;.<br/>Cargo&#160;ﬁgured out that the&#160;ﬁles hadn’t changed, so it didn’t rebuild but just ran the binary. If<br/>you had modiﬁed your source code, Cargo would have rebuilt the project before running it,<br/>and you would have seen this output:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;hello_cargo&#160;v0.1.0&#160;(file:///projects/hello_cargo)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.33&#160;secs<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/hello_cargo`<br/>Hello,&#160;world!<br/>
Cargo also provides a command called&#160;&#160;cargo&#160;check&#160;. This command quickly checks your<br/>code to make sure it compiles but doesn’t produce an executable:<br/>
$&#160;cargo&#160;check<br/>&#160;&#160;&#160;Checking&#160;hello_cargo&#160;v0.1.0&#160;(file:///projects/hello_cargo)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.32&#160;secs<br/>
Why would you not want an executable? Often,&#160;&#160;cargo&#160;check&#160;&#160;is much faster than&#160;&#160;cargo&#160;<br/>build&#160;&#160;because it skips the step of producing an executable. If you’re continually checking<br/>your work while writing the code, using&#160;&#160;cargo&#160;check&#160;&#160;will speed up the process of letting<br/>you know if your project is still compiling! As such, many Rustaceans run&#160;&#160;cargo&#160;check<br/>periodically as they write their program to make sure it compiles. Then they run&#160;&#160;cargo&#160;<br/>build&#160;&#160;when they’re ready to use the executable.<br/>
Let’s recap what we’ve learned so far about Cargo:<br/>
We can create a project using&#160;&#160;cargo&#160;new&#160;.<br/>We can build a project using&#160;&#160;cargo&#160;build&#160;.<br/>We can build and run a project in one step using&#160;&#160;cargo&#160;run&#160;.<br/>We can build a project without producing a binary to check for errors using&#160;&#160;cargo&#160;<br/>check&#160;.<br/>Instead of saving the result of the build in the same directory as our code, Cargo stores<br/>it in the&#160;<i>target/debug</i>&#160;directory.<br/>
An additional advantage of using Cargo is that the commands are the same no matter which<br/>operating system you’re working on. So, at this point, we’ll no longer provide speciﬁc<br/>instructions for Linux and macOS versus Windows.<br/>
<a href="tests.html#19"><b>Building&#160;for&#160;Release</b></a><br/>
When your project is&#160;ﬁnally ready for release, you can use&#160;&#160;cargo&#160;build&#160;--release&#160;&#160;to<br/>compile it with optimizations. This command will create an executable in&#160;<i>target/release<br/></i>instead of&#160;<i>target/debug</i>. The optimizations make your Rust code run faster, but turning them<br/>on lengthens the time it takes for your program to compile. This is why there are two<br/>
https://doc.rust-lang.org/book/print.html<br/>
19/627<br/>
<hr/>
<a name=20></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
diﬀerent proﬁles: one for development, when you want to rebuild quickly and often, and<br/>another for building the&#160;ﬁnal program you’ll give to a user that won’t be rebuilt repeatedly<br/>and that will run as fast as possible. If you’re benchmarking your code’s running time, be<br/>sure to run&#160;&#160;cargo&#160;build&#160;--release&#160;&#160;and benchmark with the executable in&#160;<i>target/release</i>.<br/>
<a href="tests.html#20"><b>Cargo&#160;as&#160;Convention</b></a><br/>
With simple projects, Cargo doesn’t provide a lot of value over just using&#160;&#160;rustc&#160;, but it will<br/>prove its worth as your programs become more intricate. Once programs grow to multiple<br/>ﬁles or need a dependency, it’s much easier to let Cargo coordinate the build.<br/>
Even though the&#160;&#160;hello_cargo&#160;&#160;project is simple, it now uses much of the real tooling you’ll<br/>use in the rest of your Rust career. In fact, to work on any existing projects, you can use the<br/>following commands to check out the code using Git, change to that project’s directory, and<br/>build:<br/>
$&#160;git&#160;clone&#160;example.org/someproject<br/>$&#160;cd&#160;someproject<br/>$&#160;cargo&#160;build<br/>
<a href="https://doc.rust-lang.org/cargo/">For more information about Cargo, check out&#160;its documentation</a>.<br/>
<a href="tests.html#20"><b>Summary</b></a><br/>
You’re already oﬀ&#160;to a great start on your Rust journey! In this chapter, you’ve learned how<br/>to:<br/>
Install the latest stable version of Rust using&#160;&#160;rustup<br/>Update to a newer Rust version<br/>Open locally installed documentation<br/>Write and run a “Hello, world!” program using&#160;&#160;rustc&#160;&#160;directly<br/>Create and run a new project using the conventions of Cargo<br/>
This is a great time to build a more substantial program to get used to reading and writing<br/>Rust code. So, in Chapter 2, we’ll build a guessing game program. If you would rather start<br/>by learning how common programming concepts work in Rust, see Chapter 3 and then<br/>return to Chapter 2.<br/>
https://doc.rust-lang.org/book/print.html<br/>
20/627<br/>
<hr/>
<a name=21></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#21"><b>Programming a Guessing Game</b></a><br/>
Let’s jump into Rust by working through a hands-on project together! This chapter<br/>introduces you to a few common Rust concepts by showing you how to use them in a real<br/>program. You’ll learn about&#160;&#160;let&#160;,&#160;&#160;match&#160;, methods, associated functions, external crates,<br/>and more! In the following chapters, we’ll explore these ideas in more detail. In this chapter,<br/>you’ll just practice the fundamentals.<br/>
We’ll implement a classic beginner programming problem: a guessing game. Here’s how it<br/>works: the program will generate a random integer between 1 and 100. It will then prompt<br/>the player to enter a guess. After a guess is entered, the program will indicate whether the<br/>guess is too low or too high. If the guess is correct, the game will print a congratulatory<br/>message and exit.<br/>
<a href="tests.html#21"><b>Setting Up a New Project</b></a><br/>
To set up a new project, go to the&#160;<i>projects</i>&#160;directory that you created in Chapter 1 and make<br/>a new project using Cargo, like so:<br/>
$&#160;cargo&#160;new&#160;guessing_game<br/>$&#160;cd&#160;guessing_game<br/>
The&#160;ﬁrst command,&#160;&#160;cargo&#160;new&#160;, takes the name of the project (&#160;guessing_game&#160;) as the&#160;ﬁrst<br/>argument. The second command changes to the new project’s directory.<br/>
Look at the generated&#160;<i>Cargo.toml</i>&#160;ﬁle:<br/>
Filename: Cargo.toml<br/>
[package]<br/>name&#160;=&#160;&#34;guessing_game&#34;<br/>version&#160;=&#160;&#34;0.1.0&#34;<br/>edition&#160;=&#160;&#34;2021&#34;<br/>
#&#160;See&#160;more&#160;keys&#160;and&#160;their&#160;definitions&#160;at&#160;https://doc.rust-<br/>lang.org/cargo/reference/manifest.html<br/>
[dependencies]<br/>
As you saw in Chapter 1,&#160;&#160;cargo&#160;new&#160;&#160;generates a “Hello, world!” program for you. Check out<br/>the&#160;<i>src/main.rs</i>&#160;ﬁle:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
21/627<br/>
<hr/>
<a name=22></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Hello,&#160;world!&#34;);<br/>}<br/>
Now let’s compile this “Hello, world!” program and run it in the same step using the&#160;&#160;cargo&#160;<br/>run&#160;&#160;command:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;1.50s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/guessing_game`<br/>Hello,&#160;world!<br/>
The&#160;&#160;run&#160;&#160;command comes in handy when you need to rapidly iterate on a project, as we’ll<br/>do in this game, quickly testing each iteration before moving on to the next one.<br/>
Reopen the&#160;<i>src/main.rs</i>&#160;ﬁle. You’ll be writing all the code in this&#160;ﬁle.<br/>
<a href="tests.html#22"><b>Processing a Guess</b></a><br/>
The&#160;ﬁrst part of the guessing game program will ask for user input, process that input, and<br/>check that the input is in the expected form. To start, we’ll allow the player to input a guess.<br/>Enter the code in Listing 2-1 into&#160;<i>src/main.rs</i>.<br/>
Filename: src/main.rs<br/>
use&#160;std::io;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Guess&#160;the&#160;number!&#34;);<br/>
&#160;&#160;&#160;&#160;println!(&#34;Please&#160;input&#160;your&#160;guess.&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;guess&#160;=&#160;String::new();<br/>
&#160;&#160;&#160;&#160;io::stdin()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.read_line(&amp;mut&#160;guess)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;Failed&#160;to&#160;read&#160;line&#34;);<br/>
&#160;&#160;&#160;&#160;println!(&#34;You&#160;guessed:&#160;{guess}&#34;);<br/>}<br/>
<b>Listing&#160;2-1:&#160;Code&#160;that&#160;gets&#160;a&#160;guess&#160;from&#160;the&#160;user&#160;and&#160;prints&#160;it</b><br/>
This code contains a lot of information, so let’s go over it line by line. To obtain user input<br/>and then print the result as output, we need to bring the&#160;&#160;io&#160;&#160;input/output library into scope.<br/>The&#160;&#160;io&#160;&#160;library comes from the standard library, known as&#160;&#160;std&#160;:<br/>
https://doc.rust-lang.org/book/print.html<br/>
22/627<br/>
<hr/>
<a name=23></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::io;<br/>
By default, Rust has a set of items deﬁned in the standard library that it brings into the<br/><a href="https://doc.rust-lang.org/std/prelude/index.html">scope of every program. This set is called the&#160;<i>prelude</i>, and you can see everything in it&#160;in the<br/>standard library documentation.</a><br/>
If a type you want to use isn’t in the prelude, you have to bring that type into scope explicitly<br/>with a&#160;&#160;use&#160;&#160;statement. Using the&#160;&#160;std::io&#160;&#160;library provides you with a number of useful<br/>features, including the ability to accept user input.<br/>
As you saw in Chapter 1, the&#160;&#160;main&#160;&#160;function is the entry point into the program:<br/>
fn&#160;main()&#160;{<br/>
The&#160;&#160;fn&#160;&#160;syntax declares a new function; the parentheses,&#160;&#160;()&#160;, indicate there are no<br/>parameters; and the curly bracket,&#160;&#160;{&#160;, starts the body of the function.<br/>
As you also learned in Chapter 1,&#160;&#160;println!&#160;&#160;is a macro that prints a string to the screen:<br/>
&#160;&#160;&#160;&#160;println!(&#34;Guess&#160;the&#160;number!&#34;);<br/>
&#160;&#160;&#160;&#160;println!(&#34;Please&#160;input&#160;your&#160;guess.&#34;);<br/>
This code is printing a prompt stating what the game is and requesting input from the user.<br/>
<a href="tests.html#23"><b>Storing&#160;Values&#160;with&#160;Variables</b></a><br/>
Next, we’ll create a&#160;<i>variable</i>&#160;to store the user input, like this:<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;guess&#160;=&#160;String::new();<br/>
Now the program is getting interesting! There’s a lot going on in this little line. We use the<br/>
let&#160;&#160;statement to create the variable. Here’s another example:<br/>
let&#160;apples&#160;=&#160;5;<br/>
This line creates a new variable named&#160;&#160;apples&#160;&#160;and binds it to the value 5. In Rust, variables<br/>are immutable by default, meaning once we give the variable a value, the value won’t<br/>change. We’ll be discussing this concept in detail in the&#160;<a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#variables-and-mutability">“Variables and Mutability”&#160;section in<br/></a>Chapter 3. To make a variable mutable, we add&#160;&#160;mut&#160;&#160;before the variable name:<br/>
let&#160;apples&#160;=&#160;5;&#160;//&#160;immutable<br/>let&#160;mut&#160;bananas&#160;=&#160;5;&#160;//&#160;mutable<br/>
https://doc.rust-lang.org/book/print.html<br/>
23/627<br/>
<hr/>
<a name=24></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Note: The&#160;&#160;//&#160;&#160;syntax starts a comment that continues until the end of the line. Rust<br/><a href="https://doc.rust-lang.org/book/ch03-04-comments.html">ignores everything in comments. We’ll discuss comments in more detail in&#160;Chapter 3.</a><br/>
Returning to the guessing game program, you now know that&#160;&#160;let&#160;mut&#160;guess&#160;&#160;will introduce<br/>a mutable variable named&#160;&#160;guess&#160;. The equal sign (&#160;=&#160;) tells Rust we want to bind something<br/>to the variable now. On the right of the equal sign is the value that&#160;&#160;guess&#160;&#160;is bound to, which<br/>is the result of calling&#160;&#160;String::new&#160;, a function that returns a new instance of a&#160;&#160;String&#160;.<br/>
<a href="https://doc.rust-lang.org/std/string/struct.String.html">String&#160;&#160;is a string type provided by the standard library that is a growable, UTF-8 encoded</a><br/>
bit of text.<br/>
The&#160;&#160;::&#160;&#160;syntax in the&#160;&#160;::new&#160;&#160;line indicates that&#160;&#160;new&#160;&#160;is an associated function of the&#160;&#160;String<br/>type. An&#160;<i>associated function</i>&#160;is a function that’s implemented on a type, in this case&#160;&#160;String&#160;.<br/>This&#160;&#160;new&#160;&#160;function creates a new, empty string. You’ll&#160;ﬁnd a&#160;&#160;new&#160;&#160;function on many types<br/>because it’s a common name for a function that makes a new value of some kind.<br/>
In full, the&#160;&#160;let&#160;mut&#160;guess&#160;=&#160;String::new();&#160;&#160;line has created a mutable variable that is<br/>currently bound to a new, empty instance of a&#160;&#160;String&#160;. Whew!<br/>
<a href="tests.html#24"><b>Receiving&#160;User&#160;Input</b></a><br/>
Recall that we included the input/output functionality from the standard library with&#160;&#160;use&#160;<br/>std::io;&#160;&#160;on the&#160;ﬁrst line of the program. Now we’ll call the&#160;&#160;stdin&#160;&#160;function from the&#160;&#160;io<br/>module, which will allow us to handle user input:<br/>
&#160;&#160;&#160;&#160;io::stdin()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.read_line(&amp;mut&#160;guess)<br/>
If we hadn’t imported the&#160;&#160;io&#160;&#160;library with&#160;&#160;use&#160;std::io;&#160;&#160;at the beginning of the program,<br/>we could still use the function by writing this function call as&#160;&#160;std::io::stdin&#160;. The&#160;&#160;stdin<br/>function returns an instance of&#160;&#160;<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html">std::io::Stdin&#160;, which is a type that represents a handle to<br/></a>the standard input for your terminal.<br/>
Next, the line&#160;&#160;.read_line(&amp;mut&#160;guess)&#160;<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line">&#160;calls the&#160;&#160;read_line&#160;&#160;method on the standard input<br/></a>handle to get input from the user. We’re also passing&#160;&#160;&amp;mut&#160;guess&#160;&#160;as the argument to<br/>
read_line&#160;&#160;to tell it what string to store the user input in. The full job of&#160;&#160;read_line&#160;&#160;is to<br/>
take whatever the user types into standard input and append that into a string (without<br/>overwriting its contents), so we therefore pass that string as an argument. The string<br/>argument needs to be mutable so the method can change the string’s content.<br/>
The&#160;&#160;&amp;&#160;&#160;indicates that this argument is a&#160;<i>reference</i>, which gives you a way to let multiple parts<br/>of your code access one piece of data without needing to copy that data into memory<br/>multiple times. References are a complex feature, and one of Rust’s major advantages is<br/>how safe and easy it is to use references. You don’t need to know a lot of those details to<br/>
https://doc.rust-lang.org/book/print.html<br/>
24/627<br/>
<hr/>
<a name=25></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
ﬁnish this program. For now, all you need to know is that, like variables, references are<br/>immutable by default. Hence, you need to write&#160;&#160;&amp;mut&#160;guess&#160;&#160;rather than&#160;&#160;&amp;guess&#160;&#160;to make it<br/>mutable. (Chapter 4 will explain references more thoroughly.)<br/>
<a href="tests.html#25"><b>Handling&#160;Potential&#160;Failure&#160;with&#160;</b>Result</a><br/>
We’re still working on this line of code. We’re now discussing a third line of text, but note<br/>that it’s still part of a single logical line of code. The next part is this method:<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;Failed&#160;to&#160;read&#160;line&#34;);<br/>
We could have written this code as:<br/>
io::stdin().read_line(&amp;mut&#160;guess).expect(&#34;Failed&#160;to&#160;read&#160;line&#34;);<br/>
However, one long line is diﬃcult to read, so it’s best to divide it. It’s often wise to introduce<br/>a newline and other whitespace to help break up long lines when you call a method with the<br/>
.method_name()&#160;&#160;syntax. Now let’s discuss what this line does.<br/>
As mentioned earlier,&#160;&#160;read_line&#160;&#160;puts whatever the user enters into the string we pass to it,<br/>but it also returns a&#160;&#160;Result&#160;<a href="https://doc.rust-lang.org/std/result/enum.Result.html">&#160;value.&#160;&#160;Result&#160;&#160;is an&#160;</a><a href="https://doc.rust-lang.org/book/ch06-00-enums.html"><i>enumeration</i></a>, often called an&#160;<i>enum</i>, which is<br/>a type that can be in one of multiple possible states. We call each possible state a&#160;<i>variant</i>.<br/>
<a href="https://doc.rust-lang.org/book/ch06-00-enums.html">Chapter 6&#160;will cover enums in more detail. The purpose of these&#160;&#160;</a>Result&#160;&#160;types is to encode<br/>error-handling information.<br/>
Result&#160;’s variants are&#160;&#160;Ok&#160;&#160;and&#160;&#160;Err&#160;. The&#160;&#160;Ok&#160;&#160;variant indicates the operation was successful,<br/>
and inside&#160;&#160;Ok&#160;&#160;is the successfully generated value. The&#160;&#160;Err&#160;&#160;variant means the operation<br/>failed, and&#160;&#160;Err&#160;&#160;contains information about how or why the operation failed.<br/>
Values of the&#160;&#160;Result&#160;&#160;type, like values of any type, have methods deﬁned on them. An<br/>instance of&#160;&#160;Result&#160;&#160;has an&#160;&#160;<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect">expect&#160;&#160;method&#160;that you can call. If this instance of&#160;&#160;</a>Result&#160;&#160;is an<br/>
Err&#160;&#160;value,&#160;&#160;expect&#160;&#160;will cause the program to crash and display the message that you<br/>
passed as an argument to&#160;&#160;expect&#160;. If the&#160;&#160;read_line&#160;&#160;method returns an&#160;&#160;Err&#160;, it would likely<br/>be the result of an error coming from the underlying operating system. If this instance of<br/>
Result&#160;&#160;is an&#160;&#160;Ok&#160;&#160;value,&#160;&#160;expect&#160;&#160;will take the return value that&#160;&#160;Ok&#160;&#160;is holding and return just<br/>
that value to you so you can use it. In this case, that value is the number of bytes in the<br/>user’s input.<br/>
If you don’t call&#160;&#160;expect&#160;, the program will compile, but you’ll get a warning:<br/>
https://doc.rust-lang.org/book/print.html<br/>
25/627<br/>
<hr/>
<a name=26></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>warning:&#160;unused&#160;`Result`&#160;that&#160;must&#160;be&#160;used<br/>&#160;&#160;--&gt;&#160;src/main.rs:10:5<br/>&#160;&#160;&#160;|<br/>10&#160;|&#160;&#160;&#160;&#160;&#160;io::stdin().read_line(&amp;mut&#160;guess);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br/>&#160;&#160;&#160;|<br/>&#160;&#160;&#160;=&#160;note:&#160;this&#160;`Result`&#160;may&#160;be&#160;an&#160;`Err`&#160;variant,&#160;which&#160;should&#160;be&#160;handled<br/>&#160;&#160;&#160;=&#160;note:&#160;`#[warn(unused_must_use)]`&#160;on&#160;by&#160;default<br/>
warning:&#160;`guessing_game`&#160;(bin&#160;&#34;guessing_game&#34;)&#160;generated&#160;1&#160;warning<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.59s<br/>
Rust warns that you haven’t used the&#160;&#160;Result&#160;&#160;value returned from&#160;&#160;read_line&#160;, indicating<br/>that the program hasn’t handled a possible error.<br/>
The right way to suppress the warning is to actually write error-handling code, but in our<br/>case we just want to crash this program when a problem occurs, so we can use&#160;&#160;expect&#160;.<br/>You’ll learn about recovering from errors in&#160;<a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">Chapter 9</a>.<br/>
<a href="tests.html#26"><b>Printing&#160;Values&#160;with&#160;</b>println!<b>&#160;Placeholders</b></a><br/>
Aside from the closing curly bracket, there’s only one more line to discuss in the code so far:<br/>
&#160;&#160;&#160;&#160;println!(&#34;You&#160;guessed:&#160;{guess}&#34;);<br/>
This line prints the string that now contains the user’s input. The&#160;&#160;{}&#160;&#160;set of curly brackets is<br/>a placeholder: think of&#160;&#160;{}&#160;&#160;as little crab pincers that hold a value in place. When printing the<br/>value of a variable, the variable name can go inside the curly brackets. When printing the<br/>result of evaluating an expression, place empty curly brackets in the format string, then<br/>follow the format string with a comma-separated list of expressions to print in each empty<br/>curly bracket placeholder in the same order. Printing a variable and the result of an<br/>expression in one call to&#160;&#160;println!&#160;&#160;would look like this:<br/>
let&#160;x&#160;=&#160;5;<br/>let&#160;y&#160;=&#160;10;<br/>
println!(&#34;x&#160;=&#160;{x}&#160;and&#160;y&#160;+&#160;2&#160;=&#160;{}&#34;,&#160;y&#160;+&#160;2);<br/>
This code would print&#160;&#160;x&#160;=&#160;5&#160;and&#160;y&#160;+&#160;2&#160;=&#160;12&#160;.<br/>
<a href="tests.html#26"><b>Testing&#160;the&#160;First&#160;Part</b></a><br/>
Let’s test the&#160;ﬁrst part of the guessing game. Run it using&#160;&#160;cargo&#160;run&#160;:<br/>
https://doc.rust-lang.org/book/print.html<br/>
26/627<br/>
<hr/>
<a name=27></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;6.44s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/guessing_game`<br/>Guess&#160;the&#160;number!<br/>Please&#160;input&#160;your&#160;guess.<br/>6<br/>You&#160;guessed:&#160;6<br/>
At this point, the&#160;ﬁrst part of the game is done: we’re getting input from the keyboard and<br/>then printing it.<br/>
<a href="tests.html#27"><b>Generating a Secret Number</b></a><br/>
Next, we need to generate a secret number that the user will try to guess. The secret<br/>number should be diﬀerent every time so the game is fun to play more than once. We’ll use<br/>a random number between 1 and 100 so the game isn’t too diﬃcult. Rust doesn’t yet include<br/>random number functionality in its standard library. However, the Rust team does provide a<br/>
<a href="https://crates.io/crates/rand">rand&#160;&#160;crate&#160;with said functionality.</a><br/>
<a href="tests.html#27"><b>Using&#160;a&#160;Crate&#160;to&#160;Get&#160;More&#160;Functionality</b></a><br/>
Remember that a crate is a collection of Rust source code&#160;ﬁles. The project we’ve been<br/>building is a&#160;<i>binary crate</i>, which is an executable. The&#160;&#160;rand&#160;&#160;crate is a&#160;<i>library crate</i>, which<br/>contains code that is intended to be used in other programs and can’t be executed on its<br/>own.<br/>
Cargo’s coordination of external crates is where Cargo really shines. Before we can write<br/>code that uses&#160;&#160;rand&#160;, we need to modify the&#160;<i>Cargo.toml</i>&#160;ﬁle to include the&#160;&#160;rand&#160;&#160;crate as a<br/>dependency. Open that&#160;ﬁle now and add the following line to the bottom, beneath the<br/>
[dependencies]&#160;&#160;section header that Cargo created for you. Be sure to specify&#160;&#160;rand&#160;&#160;exactly<br/>
as we have here, with this version number, or the code examples in this tutorial may not<br/>work:<br/>
Filename: Cargo.toml<br/>
[dependencies]<br/>rand&#160;=&#160;&#34;0.8.5&#34;<br/>
In the&#160;<i>Cargo.toml</i>&#160;ﬁle, everything that follows a header is part of that section that continues<br/>until another section starts. In&#160;&#160;[dependencies]&#160;&#160;you tell Cargo which external crates your<br/>project depends on and which versions of those crates you require. In this case, we specify<br/><a href="http://semver.org/">the&#160;&#160;rand&#160;&#160;crate with the semantic version speciﬁer&#160;&#160;0.8.5&#160;. Cargo understands&#160;Semantic<br/>Versioning&#160;(sometimes called&#160;<i>SemVer</i>), which is a standard for writing version numbers. The</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
27/627<br/>
<hr/>
<a name=28></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
speciﬁer&#160;&#160;0.8.5&#160;&#160;is actually shorthand for&#160;&#160;^0.8.5&#160;, which means any version that is at least<br/>0.8.5 but below 0.9.0.<br/>
Cargo considers these versions to have public APIs compatible with version 0.8.5, and this<br/>speciﬁcation ensures you’ll get the latest patch release that will still compile with the code in<br/>this chapter. Any version 0.9.0 or greater is not guaranteed to have the same API as what<br/>the following examples use.<br/>
Now, without changing any of the code, let’s build the project, as shown in Listing 2-2.<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;&#160;Updating&#160;crates.io&#160;index<br/>&#160;&#160;Downloaded&#160;rand&#160;v0.8.5<br/>&#160;&#160;Downloaded&#160;libc&#160;v0.2.127<br/>&#160;&#160;Downloaded&#160;getrandom&#160;v0.2.7<br/>&#160;&#160;Downloaded&#160;cfg-if&#160;v1.0.0<br/>&#160;&#160;Downloaded&#160;ppv-lite86&#160;v0.2.16<br/>&#160;&#160;Downloaded&#160;rand_chacha&#160;v0.3.1<br/>&#160;&#160;Downloaded&#160;rand_core&#160;v0.6.3<br/>&#160;&#160;&#160;Compiling&#160;libc&#160;v0.2.127<br/>&#160;&#160;&#160;Compiling&#160;getrandom&#160;v0.2.7<br/>&#160;&#160;&#160;Compiling&#160;cfg-if&#160;v1.0.0<br/>&#160;&#160;&#160;Compiling&#160;ppv-lite86&#160;v0.2.16<br/>&#160;&#160;&#160;Compiling&#160;rand_core&#160;v0.6.3<br/>&#160;&#160;&#160;Compiling&#160;rand_chacha&#160;v0.3.1<br/>&#160;&#160;&#160;Compiling&#160;rand&#160;v0.8.5<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;2.53s<br/>
<b>Listing&#160;2-2:&#160;The&#160;output&#160;from&#160;running&#160;&#160;</b>cargo&#160;build&#160;<b>&#160;after&#160;adding&#160;the&#160;rand&#160;crate&#160;as&#160;a&#160;dependency</b><br/>
You may see diﬀerent version numbers (but they will all be compatible with the code,<br/>thanks to SemVer!) and diﬀerent lines (depending on the operating system), and the lines<br/>may be in a diﬀerent order.<br/>
When we include an external dependency, Cargo fetches the latest versions of everything<br/>that dependency needs from the&#160;<i>registry</i><a href="https://crates.io/">, which is a copy of data from&#160;Crates.io</a>. Crates.io is<br/>where people in the Rust ecosystem post their open source Rust projects for others to use.<br/>
After updating the registry, Cargo checks the&#160;&#160;[dependencies]&#160;&#160;section and downloads any<br/>crates listed that aren’t already downloaded. In this case, although we only listed&#160;&#160;rand&#160;&#160;as a<br/>dependency, Cargo also grabbed other crates that&#160;&#160;rand&#160;&#160;depends on to work. After<br/>downloading the crates, Rust compiles them and then compiles the project with the<br/>dependencies available.<br/>
If you immediately run&#160;&#160;cargo&#160;build&#160;&#160;again without making any changes, you won’t get any<br/>output aside from the&#160;&#160;Finished&#160;&#160;line. Cargo knows it has already downloaded and compiled<br/>the dependencies, and you haven’t changed anything about them in your&#160;<i>Cargo.toml</i>&#160;ﬁle.<br/>Cargo also knows that you haven’t changed anything about your code, so it doesn’t<br/>recompile that either. With nothing to do, it simply exits.<br/>
https://doc.rust-lang.org/book/print.html<br/>
28/627<br/>
<hr/>
<a name=29></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
If you open the&#160;<i>src/main.rs</i>&#160;ﬁle, make a trivial change, and then save it and build again, you’ll<br/>only see two lines of output:<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;2.53&#160;secs<br/>
These lines show that Cargo only updates the build with your tiny change to the&#160;<i>src/main.rs<br/></i>ﬁle. Your dependencies haven’t changed, so Cargo knows it can reuse what it has already<br/>downloaded and compiled for those.<br/>
<a href="tests.html#29"><b>Ensuring Reproducible Builds with the&#160;<i>Cargo.lock</i></b><b>&#160;File</b></a><br/>
Cargo has a mechanism that ensures you can rebuild the same artifact every time you or<br/>anyone else builds your code: Cargo will use only the versions of the dependencies you<br/>speciﬁed until you indicate otherwise. For example, say that next week version 0.8.6 of the<br/>
rand&#160;&#160;crate comes out, and that version contains an important bug&#160;ﬁx, but it also contains a<br/>
regression that will break your code. To handle this, Rust creates the&#160;<i>Cargo.lock</i>&#160;ﬁle the&#160;ﬁrst<br/>time you run&#160;&#160;cargo&#160;build&#160;, so we now have this in the&#160;<i>guessing_game</i>&#160;directory.<br/>
When you build a project for the&#160;ﬁrst time, Cargo&#160;ﬁgures out all the versions of the<br/>dependencies that&#160;ﬁt the criteria and then writes them to the&#160;<i>Cargo.lock</i>&#160;ﬁle. When you build<br/>your project in the future, Cargo will see that the&#160;<i>Cargo.lock</i>&#160;ﬁle exists and will use the<br/>versions speciﬁed there rather than doing all the work of&#160;ﬁguring out versions again. This<br/>lets you have a reproducible build automatically. In other words, your project will remain at<br/>0.8.5 until you explicitly upgrade, thanks to the&#160;<i>Cargo.lock</i>&#160;ﬁle. Because the&#160;<i>Cargo.lock</i>&#160;ﬁle is<br/>important for reproducible builds, it’s often checked into source control with the rest of the<br/>code in your project.<br/>
<a href="tests.html#29"><b>Updating a Crate to Get a New Version</b></a><br/>
When you&#160;<i>do</i>&#160;want to update a crate, Cargo provides the command&#160;&#160;update&#160;, which will<br/>ignore the&#160;<i>Cargo.lock</i>&#160;ﬁle and&#160;ﬁgure out all the latest versions that&#160;ﬁt your speciﬁcations in<br/><i>Cargo.toml</i>. Cargo will then write those versions to the&#160;<i>Cargo.lock</i>&#160;ﬁle. Otherwise, by default,<br/>Cargo will only look for versions greater than 0.8.5 and less than 0.9.0. If the&#160;&#160;rand&#160;&#160;crate has<br/>released the two new versions 0.8.6 and 0.9.0, you would see the following if you ran&#160;&#160;cargo&#160;<br/>update&#160;:<br/>
$&#160;cargo&#160;update<br/>&#160;&#160;&#160;&#160;Updating&#160;crates.io&#160;index<br/>&#160;&#160;&#160;&#160;Updating&#160;rand&#160;v0.8.5&#160;-&gt;&#160;v0.8.6<br/>
Cargo ignores the 0.9.0 release. At this point, you would also notice a change in your<br/><i>Cargo.lock</i>&#160;ﬁle noting that the version of the&#160;&#160;rand&#160;&#160;crate you are now using is 0.8.6. To use<br/>
https://doc.rust-lang.org/book/print.html<br/>
29/627<br/>
<hr/>
<a name=30></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
rand&#160;&#160;version 0.9.0 or any version in the 0.9.<i>x</i>&#160;series, you’d have to update the&#160;<i>Cargo.toml</i>&#160;ﬁle<br/>
to look like this instead:<br/>
[dependencies]<br/>rand&#160;=&#160;&#34;0.9.0&#34;<br/>
The next time you run&#160;&#160;cargo&#160;build&#160;, Cargo will update the registry of crates available and<br/>reevaluate your&#160;&#160;rand&#160;&#160;requirements according to the new version you have speciﬁed.<br/>
There’s a lot more to say about&#160;<a href="http://doc.crates.io/">Cargo&#160;and&#160;</a><a href="http://doc.crates.io/crates-io.html">its ecosystem, which we’ll discuss in Chapter 14,<br/></a>but for now, that’s all you need to know. Cargo makes it very easy to reuse libraries, so<br/>Rustaceans are able to write smaller projects that are assembled from a number of<br/>packages.<br/>
<a href="tests.html#30"><b>Generating&#160;a&#160;Random&#160;Number</b></a><br/>
Let’s start using&#160;&#160;rand&#160;&#160;to generate a number to guess. The next step is to update&#160;<i>src/main.rs</i>,<br/>as shown in Listing 2-3.<br/>
Filename: src/main.rs<br/>
use&#160;std::io;<br/>use&#160;rand::Rng;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Guess&#160;the&#160;number!&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;secret_number&#160;=&#160;rand::thread_rng().gen_range(1..=100);<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;secret&#160;number&#160;is:&#160;{secret_number}&#34;);<br/>
&#160;&#160;&#160;&#160;println!(&#34;Please&#160;input&#160;your&#160;guess.&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;guess&#160;=&#160;String::new();<br/>
&#160;&#160;&#160;&#160;io::stdin()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.read_line(&amp;mut&#160;guess)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;Failed&#160;to&#160;read&#160;line&#34;);<br/>
&#160;&#160;&#160;&#160;println!(&#34;You&#160;guessed:&#160;{guess}&#34;);<br/>}<br/>
<b>Listing&#160;2-3:&#160;Adding&#160;code&#160;to&#160;generate&#160;a&#160;random&#160;number</b><br/>
First we add the line&#160;&#160;use&#160;rand::Rng;&#160;. The&#160;&#160;Rng&#160;&#160;trait deﬁnes methods that random number<br/>generators implement, and this trait must be in scope for us to use those methods. Chapter<br/>10 will cover traits in detail.<br/>
https://doc.rust-lang.org/book/print.html<br/>
30/627<br/>
<hr/>
<a name=31></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Next, we’re adding two lines in the middle. In the&#160;ﬁrst line, we call the&#160;&#160;rand::thread_rng<br/>function that gives us the particular random number generator we’re going to use: one that<br/>is local to the current thread of execution and is seeded by the operating system. Then we<br/>call the&#160;&#160;gen_range&#160;&#160;method on the random number generator. This method is deﬁned by<br/>the&#160;&#160;Rng&#160;&#160;trait that we brought into scope with the&#160;&#160;use&#160;rand::Rng;&#160;&#160;statement. The<br/>
gen_range&#160;&#160;method takes a range expression as an argument and generates a random<br/>
number in the range. The kind of range expression we’re using here takes the form<br/>
start..=end&#160;&#160;and is inclusive on the lower and upper bounds, so we need to specify<br/>1..=100&#160;&#160;to request a number between 1 and 100.<br/>
Note: You won’t just know which traits to use and which methods and functions to call<br/>from a crate, so each crate has documentation with instructions for using it. Another<br/>neat feature of Cargo is that running the&#160;&#160;cargo&#160;doc&#160;--open&#160;&#160;command will build<br/>documentation provided by all your dependencies locally and open it in your browser.<br/>If you’re interested in other functionality in the&#160;&#160;rand&#160;&#160;crate, for example, run&#160;&#160;cargo&#160;<br/>doc&#160;--open&#160;&#160;and click&#160;&#160;rand&#160;&#160;in the sidebar on the left.<br/>
The second new line prints the secret number. This is useful while we’re developing the<br/>program to be able to test it, but we’ll delete it from the&#160;ﬁnal version. It’s not much of a<br/>game if the program prints the answer as soon as it starts!<br/>
Try running the program a few times:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;2.53s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/guessing_game`<br/>Guess&#160;the&#160;number!<br/>The&#160;secret&#160;number&#160;is:&#160;7<br/>Please&#160;input&#160;your&#160;guess.<br/>4<br/>You&#160;guessed:&#160;4<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.02s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/guessing_game`<br/>Guess&#160;the&#160;number!<br/>The&#160;secret&#160;number&#160;is:&#160;83<br/>Please&#160;input&#160;your&#160;guess.<br/>5<br/>You&#160;guessed:&#160;5<br/>
You should get diﬀerent random numbers, and they should all be numbers between 1 and<br/>100. Great job!<br/>
https://doc.rust-lang.org/book/print.html<br/>
31/627<br/>
<hr/>
<a name=32></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#32"><b>Comparing the Guess to the Secret Number</b></a><br/>
Now that we have user input and a random number, we can compare them. That step is<br/>shown in Listing 2-4. Note that this code won’t compile just yet, as we will explain.<br/>
Filename: src/main.rs<br/>
use&#160;rand::Rng;<br/>use&#160;std::cmp::Ordering;<br/>use&#160;std::io;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;println!(&#34;You&#160;guessed:&#160;{guess}&#34;);<br/>
&#160;&#160;&#160;&#160;match&#160;guess.cmp(&amp;secret_number)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Less&#160;=&gt;&#160;println!(&#34;Too&#160;small!&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Greater&#160;=&gt;&#160;println!(&#34;Too&#160;big!&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Equal&#160;=&gt;&#160;println!(&#34;You&#160;win!&#34;),<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;2-4:&#160;Handling&#160;the&#160;possible&#160;return&#160;values&#160;of&#160;comparing&#160;two&#160;numbers</b><br/>
First we add another&#160;&#160;use&#160;&#160;statement, bringing a type called&#160;&#160;std::cmp::Ordering&#160;&#160;into scope<br/>from the standard library. The&#160;&#160;Ordering&#160;&#160;type is another enum and has the variants&#160;&#160;Less&#160;,<br/>
Greater&#160;, and&#160;&#160;Equal&#160;. These are the three outcomes that are possible when you compare<br/>
two values.<br/>
Then we add&#160;ﬁve new lines at the bottom that use the&#160;&#160;Ordering&#160;&#160;type. The&#160;&#160;cmp&#160;&#160;method<br/>compares two values and can be called on anything that can be compared. It takes a<br/>reference to whatever you want to compare with: here it’s comparing&#160;&#160;guess&#160;&#160;to<br/>
secret_number&#160;. Then it returns a variant of the&#160;&#160;Ordering&#160;&#160;enum we brought into scope<br/>
with the&#160;&#160;use&#160;&#160;statement. We use a&#160;&#160;<a href="https://doc.rust-lang.org/book/ch06-02-match.html">match&#160;</a>&#160;expression to decide what to do next based on<br/>which variant of&#160;&#160;Ordering&#160;&#160;was returned from the call to&#160;&#160;cmp&#160;&#160;with the values in&#160;&#160;guess&#160;&#160;and<br/>
secret_number&#160;.<br/>
A&#160;&#160;match&#160;&#160;expression is made up of&#160;<i>arms</i>. An arm consists of a&#160;<i>pattern</i>&#160;to match against, and<br/>the code that should be run if the value given to&#160;&#160;match&#160;&#160;ﬁts that arm’s pattern. Rust takes<br/>the value given to&#160;&#160;match&#160;&#160;and looks through each arm’s pattern in turn. Patterns and the<br/>
match&#160;&#160;construct are powerful Rust features: they let you express a variety of situations your<br/>
code might encounter and they make sure you handle them all. These features will be<br/>covered in detail in Chapter 6 and Chapter 18, respectively.<br/>
Let’s walk through an example with the&#160;&#160;match&#160;&#160;expression we use here. Say that the user<br/>has guessed 50 and the randomly generated secret number this time is 38.<br/>
https://doc.rust-lang.org/book/print.html<br/>
32/627<br/>
<hr/>
<a name=33></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
When the code compares 50 to 38, the&#160;&#160;cmp&#160;&#160;method will return&#160;&#160;Ordering::Greater<br/>because 50 is greater than 38. The&#160;&#160;match&#160;&#160;expression gets the&#160;&#160;Ordering::Greater&#160;&#160;value<br/>and starts checking each arm’s pattern. It looks at the&#160;ﬁrst arm’s pattern,&#160;&#160;Ordering::Less&#160;,<br/>and sees that the value&#160;&#160;Ordering::Greater&#160;&#160;does not match&#160;&#160;Ordering::Less&#160;, so it ignores<br/>the code in that arm and moves to the next arm. The next arm’s pattern is<br/>
Ordering::Greater&#160;, which&#160;<i>does</i>&#160;match&#160;&#160;Ordering::Greater&#160;! The associated code in that<br/>
arm will execute and print&#160;&#160;Too&#160;big!&#160;&#160;to the screen. The&#160;&#160;match&#160;&#160;expression ends after the<br/>ﬁrst successful match, so it won’t look at the last arm in this scenario.<br/>
However, the code in Listing 2-4 won’t compile yet. Let’s try it:<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;Compiling&#160;libc&#160;v0.2.86<br/>&#160;&#160;&#160;Compiling&#160;getrandom&#160;v0.2.2<br/>&#160;&#160;&#160;Compiling&#160;cfg-if&#160;v1.0.0<br/>&#160;&#160;&#160;Compiling&#160;ppv-lite86&#160;v0.2.10<br/>&#160;&#160;&#160;Compiling&#160;rand_core&#160;v0.6.2<br/>&#160;&#160;&#160;Compiling&#160;rand_chacha&#160;v0.3.0<br/>&#160;&#160;&#160;Compiling&#160;rand&#160;v0.8.5<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>error[E0308]:&#160;mismatched&#160;types<br/>&#160;&#160;--&gt;&#160;src/main.rs:22:21<br/>&#160;&#160;&#160;|<br/>22&#160;|&#160;&#160;&#160;&#160;&#160;match&#160;guess.cmp(&amp;secret_number)&#160;{<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;---&#160;^^^^^^^^^^^^^^&#160;expected&#160;struct&#160;`String`,&#160;found&#160;integer<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;arguments&#160;to&#160;this&#160;function&#160;are&#160;incorrect<br/>&#160;&#160;&#160;|<br/>&#160;&#160;&#160;=&#160;note:&#160;expected&#160;reference&#160;`&amp;String`<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;found&#160;reference&#160;`&amp;{integer}`<br/>note:&#160;associated&#160;function&#160;defined&#160;here<br/>&#160;&#160;--&gt;&#160;<br/>/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/cmp.rs:783:8<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0308`.<br/>error:&#160;could&#160;not&#160;compile&#160;`guessing_game`&#160;due&#160;to&#160;previous&#160;error<br/>
The core of the error states that there are&#160;<i>mismatched types</i>. Rust has a strong, static type<br/>system. However, it also has type inference. When we wrote&#160;&#160;let&#160;mut&#160;guess&#160;=&#160;<br/>String::new()&#160;, Rust was able to infer that&#160;&#160;guess&#160;&#160;should be a&#160;&#160;String&#160;&#160;and didn’t make us<br/>write the type. The&#160;&#160;secret_number&#160;, on the other hand, is a number type. A few of Rust’s<br/>number types can have a value between 1 and 100:&#160;&#160;i32&#160;, a 32-bit number;&#160;&#160;u32&#160;, an<br/>unsigned 32-bit number;&#160;&#160;i64&#160;, a 64-bit number; as well as others. Unless otherwise<br/>speciﬁed, Rust defaults to an&#160;&#160;i32&#160;, which is the type of&#160;&#160;secret_number&#160;&#160;unless you add type<br/>information elsewhere that would cause Rust to infer a diﬀerent numerical type. The reason<br/>for the error is that Rust cannot compare a string and a number type.<br/>
Ultimately, we want to convert the&#160;&#160;String&#160;&#160;the program reads as input into a real number<br/>type so we can compare it numerically to the secret number. We do so by adding this line to<br/>the&#160;&#160;main&#160;&#160;function body:<br/>
https://doc.rust-lang.org/book/print.html<br/>
33/627<br/>
<hr/>
<a name=34></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Filename: src/main.rs<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;guess&#160;=&#160;String::new();<br/>
&#160;&#160;&#160;&#160;io::stdin()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.read_line(&amp;mut&#160;guess)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;Failed&#160;to&#160;read&#160;line&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;guess:&#160;u32&#160;=&#160;guess.trim().parse().expect(&#34;Please&#160;type&#160;a&#160;number!&#34;);<br/>
&#160;&#160;&#160;&#160;println!(&#34;You&#160;guessed:&#160;{guess}&#34;);<br/>
&#160;&#160;&#160;&#160;match&#160;guess.cmp(&amp;secret_number)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Less&#160;=&gt;&#160;println!(&#34;Too&#160;small!&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Greater&#160;=&gt;&#160;println!(&#34;Too&#160;big!&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Equal&#160;=&gt;&#160;println!(&#34;You&#160;win!&#34;),<br/>&#160;&#160;&#160;&#160;}<br/>
The line is:<br/>
let&#160;guess:&#160;u32&#160;=&#160;guess.trim().parse().expect(&#34;Please&#160;type&#160;a&#160;number!&#34;);<br/>
We create a variable named&#160;&#160;guess&#160;. But wait, doesn’t the program already have a variable<br/>named&#160;&#160;guess&#160;? It does, but helpfully Rust allows us to shadow the previous value of&#160;&#160;guess<br/>with a new one.&#160;<i>Shadowing</i>&#160;lets us reuse the&#160;&#160;guess&#160;&#160;variable name rather than forcing us to<br/>create two unique variables, such as&#160;&#160;guess_str&#160;&#160;and&#160;&#160;guess&#160;, for example. We’ll cover this in<br/>more detail in&#160;<a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing">Chapter 3, but for now, know that this feature is often used when you want to<br/></a>convert a value from one type to another type.<br/>
We bind this new variable to the expression&#160;&#160;guess.trim().parse()&#160;. The&#160;&#160;guess&#160;&#160;in the<br/>expression refers to the original&#160;&#160;guess&#160;&#160;variable that contained the input as a string. The<br/>
trim&#160;&#160;method on a&#160;&#160;String&#160;&#160;instance will eliminate any whitespace at the beginning and<br/>
end, which we must do to be able to compare the string to the&#160;&#160;u32&#160;, which can only contain<br/>numerical data. The user must press&#160;enter&#160;to satisfy&#160;&#160;read_line&#160;&#160;and input their guess,<br/>which adds a newline character to the string. For example, if the user types&#160;5&#160;and presses<br/>enter,&#160;&#160;guess&#160;&#160;looks like this:&#160;&#160;5\n&#160;. The&#160;&#160;\n&#160;&#160;represents “newline.” (On Windows, pressing<br/>enter&#160;results in a carriage return and a newline,&#160;&#160;\r\n&#160;.) The&#160;&#160;trim&#160;&#160;method eliminates&#160;&#160;\n&#160;&#160;or<br/>
\r\n&#160;, resulting in just&#160;&#160;5&#160;.<br/>
<a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">The&#160;&#160;parse&#160;&#160;method on strings</a>&#160;converts a string to another type. Here, we use it to convert<br/>from a string to a number. We need to tell Rust the exact number type we want by using<br/>
let&#160;guess:&#160;u32&#160;. The colon (&#160;:&#160;) after&#160;&#160;guess&#160;&#160;tells Rust we’ll annotate the variable’s type.<br/>
Rust has a few built-in number types; the&#160;&#160;u32&#160;&#160;seen here is an unsigned, 32-bit integer. It’s a<br/>good default choice for a small positive number. You’ll learn about other number types in<br/><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types">Chapter 3.</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
34/627<br/>
<hr/>
<a name=35></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Additionally, the&#160;&#160;u32&#160;&#160;annotation in this example program and the comparison with<br/>
secret_number&#160;&#160;means Rust will infer that&#160;&#160;secret_number&#160;&#160;should be a&#160;&#160;u32&#160;&#160;as well. So now<br/>
the comparison will be between two values of the same type!<br/>
The&#160;&#160;parse&#160;&#160;method will only work on characters that can logically be converted into<br/>numbers and so can easily cause errors. If, for example, the string contained&#160;&#160;A👍%&#160;, there<br/>would be no way to convert that to a number. Because it might fail, the&#160;&#160;parse&#160;&#160;method<br/>returns a&#160;&#160;Result&#160;&#160;type, much as the&#160;&#160;read_line&#160;&#160;method does (discussed earlier in<br/><a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">“Handling Potential Failure with&#160;&#160;Result&#160;”). We’ll treat this&#160;&#160;</a>Result&#160;&#160;the same way by using the<br/>
expect&#160;&#160;method again. If&#160;&#160;parse&#160;&#160;returns an&#160;&#160;Err&#160;&#160;&#160;Result&#160;&#160;variant because it couldn’t create a<br/>
number from the string, the&#160;&#160;expect&#160;&#160;call will crash the game and print the message we give<br/>it. If&#160;&#160;parse&#160;&#160;can successfully convert the string to a number, it will return the&#160;&#160;Ok&#160;&#160;variant of<br/>
Result&#160;, and&#160;&#160;expect&#160;&#160;will return the number that we want from the&#160;&#160;Ok&#160;&#160;value.<br/>
Let’s run the program now:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.43s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/guessing_game`<br/>Guess&#160;the&#160;number!<br/>The&#160;secret&#160;number&#160;is:&#160;58<br/>Please&#160;input&#160;your&#160;guess.<br/>&#160;&#160;76<br/>You&#160;guessed:&#160;76<br/>Too&#160;big!<br/>
Nice! Even though spaces were added before the guess, the program still&#160;ﬁgured out that<br/>the user guessed 76. Run the program a few times to verify the diﬀerent behavior with<br/>diﬀerent kinds of input: guess the number correctly, guess a number that is too high, and<br/>guess a number that is too low.<br/>
We have most of the game working now, but the user can make only one guess. Let’s<br/>change that by adding a loop!<br/>
<a href="tests.html#35"><b>Allowing Multiple Guesses with Looping</b></a><br/>
The&#160;&#160;loop&#160;&#160;keyword creates an inﬁnite loop. We’ll add a loop to give users more chances at<br/>guessing the number:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
35/627<br/>
<hr/>
<a name=36></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;secret&#160;number&#160;is:&#160;{secret_number}&#34;);<br/>
&#160;&#160;&#160;&#160;loop&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Please&#160;input&#160;your&#160;guess.&#34;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;guess.cmp(&amp;secret_number)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Less&#160;=&gt;&#160;println!(&#34;Too&#160;small!&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Greater&#160;=&gt;&#160;println!(&#34;Too&#160;big!&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Equal&#160;=&gt;&#160;println!(&#34;You&#160;win!&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
As you can see, we’ve moved everything from the guess input prompt onward into a loop.<br/>Be sure to indent the lines inside the loop another four spaces each and run the program<br/>again. The program will now ask for another guess forever, which actually introduces a new<br/>problem. It doesn’t seem like the user can quit!<br/>
The user could always interrupt the program by using the keyboard shortcut&#160;ctrl-c. But<br/>there’s another way to escape this insatiable monster, as mentioned in the&#160;&#160;parse<br/>discussion in&#160;<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Comparing the Guess to the Secret Number”</a>: if the user enters a non-number<br/>answer, the program will crash. We can take advantage of that to allow the user to quit, as<br/>shown here:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;1.50s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/guessing_game`<br/>Guess&#160;the&#160;number!<br/>The&#160;secret&#160;number&#160;is:&#160;59<br/>Please&#160;input&#160;your&#160;guess.<br/>45<br/>You&#160;guessed:&#160;45<br/>Too&#160;small!<br/>Please&#160;input&#160;your&#160;guess.<br/>60<br/>You&#160;guessed:&#160;60<br/>Too&#160;big!<br/>Please&#160;input&#160;your&#160;guess.<br/>59<br/>You&#160;guessed:&#160;59<br/>You&#160;win!<br/>Please&#160;input&#160;your&#160;guess.<br/>quit<br/>thread&#160;'main'&#160;panicked&#160;at&#160;'Please&#160;type&#160;a&#160;number!:&#160;ParseIntError&#160;{&#160;kind:&#160;<br/>InvalidDigit&#160;}',&#160;src/main.rs:28:47<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
https://doc.rust-lang.org/book/print.html<br/>
36/627<br/>
<hr/>
<a name=37></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Typing&#160;&#160;quit&#160;&#160;will quit the game, but as you’ll notice, so will entering any other non-number<br/>input. This is suboptimal, to say the least; we want the game to also stop when the correct<br/>number is guessed.<br/>
<a href="tests.html#37"><b>Quitting&#160;After&#160;a&#160;Correct&#160;Guess</b></a><br/>
Let’s program the game to quit when the user wins by adding a&#160;&#160;break&#160;&#160;statement:<br/>
Filename: src/main.rs<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;guess.cmp(&amp;secret_number)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Less&#160;=&gt;&#160;println!(&#34;Too&#160;small!&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Greater&#160;=&gt;&#160;println!(&#34;Too&#160;big!&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Equal&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;You&#160;win!&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
Adding the&#160;&#160;break&#160;&#160;line after&#160;&#160;You&#160;win!&#160;&#160;makes the program exit the loop when the user<br/>guesses the secret number correctly. Exiting the loop also means exiting the program,<br/>because the loop is the last part of&#160;&#160;main&#160;.<br/>
<a href="tests.html#37"><b>Handling&#160;Invalid&#160;Input</b></a><br/>
To further reﬁne the game’s behavior, rather than crashing the program when the user<br/>inputs a non-number, let’s make the game ignore a non-number so the user can continue<br/>guessing. We can do that by altering the line where&#160;&#160;guess&#160;&#160;is converted from a&#160;&#160;String&#160;&#160;to a<br/>
u32&#160;, as shown in Listing 2-5.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
37/627<br/>
<hr/>
<a name=38></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;io::stdin()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.read_line(&amp;mut&#160;guess)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;Failed&#160;to&#160;read&#160;line&#34;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;guess:&#160;u32&#160;=&#160;match&#160;guess.trim().parse()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(num)&#160;=&gt;&#160;num,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(_)&#160;=&gt;&#160;continue,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;You&#160;guessed:&#160;{guess}&#34;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
<b>Listing&#160;2-5:&#160;Ignoring&#160;a&#160;non-number&#160;guess&#160;and&#160;asking&#160;for&#160;another&#160;guess&#160;instead&#160;of&#160;crashing&#160;the&#160;program</b><br/>
We switch from an&#160;&#160;expect&#160;&#160;call to a&#160;&#160;match&#160;&#160;expression to move from crashing on an error to<br/>handling the error. Remember that&#160;&#160;parse&#160;&#160;returns a&#160;&#160;Result&#160;&#160;type and&#160;&#160;Result&#160;&#160;is an enum<br/>that has the variants&#160;&#160;Ok&#160;&#160;and&#160;&#160;Err&#160;. We’re using a&#160;&#160;match&#160;&#160;expression here, as we did with the<br/>
Ordering&#160;&#160;result of the&#160;&#160;cmp&#160;&#160;method.<br/>
If&#160;&#160;parse&#160;&#160;is able to successfully turn the string into a number, it will return an&#160;&#160;Ok&#160;&#160;value that<br/>contains the resultant number. That&#160;&#160;Ok&#160;&#160;value will match the&#160;ﬁrst arm’s pattern, and the<br/>
match&#160;&#160;expression will just return the&#160;&#160;num&#160;&#160;value that&#160;&#160;parse&#160;&#160;produced and put inside the<br/>Ok&#160;&#160;value. That number will end up right where we want it in the new&#160;&#160;guess&#160;&#160;variable we’re<br/>
creating.<br/>
If&#160;&#160;parse&#160;&#160;is&#160;<i>not</i>&#160;able to turn the string into a number, it will return an&#160;&#160;Err&#160;&#160;value that<br/>contains more information about the error. The&#160;&#160;Err&#160;&#160;value does not match the&#160;&#160;Ok(num)<br/>pattern in the&#160;ﬁrst&#160;&#160;match&#160;&#160;arm, but it does match the&#160;&#160;Err(_)&#160;&#160;pattern in the second arm.<br/>The underscore,&#160;&#160;_&#160;, is a catchall value; in this example, we’re saying we want to match all<br/>
Err&#160;&#160;values, no matter what information they have inside them. So the program will execute<br/>
the second arm’s code,&#160;&#160;continue&#160;, which tells the program to go to the next iteration of the<br/>
loop&#160;&#160;and ask for another guess. So, eﬀectively, the program ignores all errors that&#160;&#160;parse<br/>
might encounter!<br/>
Now everything in the program should work as expected. Let’s try it:<br/>
https://doc.rust-lang.org/book/print.html<br/>
38/627<br/>
<hr/>
<a name=39></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;4.45s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/guessing_game`<br/>Guess&#160;the&#160;number!<br/>The&#160;secret&#160;number&#160;is:&#160;61<br/>Please&#160;input&#160;your&#160;guess.<br/>10<br/>You&#160;guessed:&#160;10<br/>Too&#160;small!<br/>Please&#160;input&#160;your&#160;guess.<br/>99<br/>You&#160;guessed:&#160;99<br/>Too&#160;big!<br/>Please&#160;input&#160;your&#160;guess.<br/>foo<br/>Please&#160;input&#160;your&#160;guess.<br/>61<br/>You&#160;guessed:&#160;61<br/>You&#160;win!<br/>
Awesome! With one tiny&#160;ﬁnal tweak, we will&#160;ﬁnish the guessing game. Recall that the<br/>program is still printing the secret number. That worked well for testing, but it ruins the<br/>game. Let’s delete the&#160;&#160;println!&#160;&#160;that outputs the secret number. Listing 2-6 shows the&#160;ﬁnal<br/>code.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
39/627<br/>
<hr/>
<a name=40></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;rand::Rng;<br/>use&#160;std::cmp::Ordering;<br/>use&#160;std::io;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Guess&#160;the&#160;number!&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;secret_number&#160;=&#160;rand::thread_rng().gen_range(1..=100);<br/>
&#160;&#160;&#160;&#160;loop&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Please&#160;input&#160;your&#160;guess.&#34;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;guess&#160;=&#160;String::new();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;io::stdin()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.read_line(&amp;mut&#160;guess)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;Failed&#160;to&#160;read&#160;line&#34;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;guess:&#160;u32&#160;=&#160;match&#160;guess.trim().parse()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(num)&#160;=&gt;&#160;num,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(_)&#160;=&gt;&#160;continue,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;You&#160;guessed:&#160;{guess}&#34;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;guess.cmp(&amp;secret_number)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Less&#160;=&gt;&#160;println!(&#34;Too&#160;small!&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Greater&#160;=&gt;&#160;println!(&#34;Too&#160;big!&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ordering::Equal&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;You&#160;win!&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;2-6:&#160;Complete&#160;guessing&#160;game&#160;code</b><br/>
At this point, you’ve successfully built the guessing game. Congratulations!<br/>
<a href="tests.html#40"><b>Summary</b></a><br/>
This project was a hands-on way to introduce you to many new Rust concepts:&#160;&#160;let&#160;,&#160;&#160;match&#160;,<br/>functions, the use of external crates, and more. In the next few chapters, you’ll learn about<br/>these concepts in more detail. Chapter 3 covers concepts that most programming<br/>languages have, such as variables, data types, and functions, and shows how to use them in<br/>Rust. Chapter 4 explores ownership, a feature that makes Rust diﬀerent from other<br/>languages. Chapter 5 discusses structs and method syntax, and Chapter 6 explains how<br/>enums work.<br/>
https://doc.rust-lang.org/book/print.html<br/>
40/627<br/>
<hr/>
<a name=41></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#41"><b>Common Programming Concepts</b></a><br/>
This chapter covers concepts that appear in almost every programming language and how<br/>they work in Rust. Many programming languages have much in common at their core. None<br/>of the concepts presented in this chapter are unique to Rust, but we’ll discuss them in the<br/>context of Rust and explain the conventions around using these concepts.<br/>
Speciﬁcally, you’ll learn about variables, basic types, functions, comments, and control&#160;ﬂow.<br/>These foundations will be in every Rust program, and learning them early will give you a<br/>strong core to start from.<br/>
<a href="tests.html#41"><b>Keywords</b></a><br/>
The Rust language has a set of&#160;<i>keywords</i>&#160;that are reserved for use by the language<br/>only, much as in other languages. Keep in mind that you cannot use these words as<br/>names of variables or functions. Most of the keywords have special meanings, and<br/>you’ll be using them to do various tasks in your Rust programs; a few have no current<br/>functionality associated with them but have been reserved for functionality that might<br/>be added to Rust in the future. You can&#160;ﬁnd a list of the keywords in&#160;<a href="https://doc.rust-lang.org/book/appendix-01-keywords.html">Appendix A</a>.<br/>
https://doc.rust-lang.org/book/print.html<br/>
41/627<br/>
<hr/>
<a name=42></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#42"><b>Variables and Mutability</b></a><br/>
<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#storing-values-with-variables">As mentioned in the&#160;“Storing Values with Variables”&#160;section, by default, variables are<br/></a>immutable. This is one of many nudges Rust gives you to write your code in a way that takes<br/>advantage of the safety and easy concurrency that Rust oﬀers. However, you still have the<br/>option to make your variables mutable. Let’s explore how and why Rust encourages you to<br/>favor immutability and why sometimes you might want to opt out.<br/>
When a variable is immutable, once a value is bound to a name, you can’t change that value.<br/>To illustrate this, generate a new project called&#160;<i>variables</i>&#160;in your&#160;<i>projects</i>&#160;directory by using<br/>
cargo&#160;new&#160;variables&#160;.<br/>
Then, in your new&#160;<i>variables</i>&#160;directory, open&#160;<i>src/main.rs</i>&#160;and replace its code with the<br/>following code, which won’t compile just yet:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;x&#160;is:&#160;{x}&#34;);<br/>&#160;&#160;&#160;&#160;x&#160;=&#160;6;<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;x&#160;is:&#160;{x}&#34;);<br/>}<br/>
Save and run the program using&#160;&#160;cargo&#160;run&#160;. You should receive an error message<br/>regarding an immutability error, as shown in this output:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;variables&#160;v0.1.0&#160;(file:///projects/variables)<br/>error[E0384]:&#160;cannot&#160;assign&#160;twice&#160;to&#160;immutable&#160;variable&#160;`x`<br/>&#160;--&gt;&#160;src/main.rs:4:5<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;first&#160;assignment&#160;to&#160;`x`<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;help:&#160;consider&#160;making&#160;this&#160;binding&#160;mutable:&#160;`mut&#160;x`<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;x&#160;is:&#160;{x}&#34;);<br/>4&#160;|&#160;&#160;&#160;&#160;&#160;x&#160;=&#160;6;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^&#160;cannot&#160;assign&#160;twice&#160;to&#160;immutable&#160;variable<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0384`.<br/>error:&#160;could&#160;not&#160;compile&#160;`variables`&#160;due&#160;to&#160;previous&#160;error<br/>
This example shows how the compiler helps you&#160;ﬁnd errors in your programs. Compiler<br/>errors can be frustrating, but really they only mean your program isn’t safely doing what<br/>
https://doc.rust-lang.org/book/print.html<br/>
42/627<br/>
<hr/>
<a name=43></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
you want it to do yet; they do&#160;<i>not</i>&#160;mean that you’re not a good programmer! Experienced<br/>Rustaceans still get compiler errors.<br/>
You received the error message&#160;&#160;cannot&#160;assign&#160;twice&#160;to&#160;immutable&#160;variable&#160;`x`<br/>because you tried to assign a second value to the immutable&#160;&#160;x&#160;&#160;variable.<br/>
It’s important that we get compile-time errors when we attempt to change a value that’s<br/>designated as immutable because this very situation can lead to bugs. If one part of our<br/>code operates on the assumption that a value will never change and another part of our<br/>code changes that value, it’s possible that the&#160;ﬁrst part of the code won’t do what it was<br/>designed to do. The cause of this kind of bug can be diﬃcult to track down after the fact,<br/>especially when the second piece of code changes the value only&#160;<i>sometimes</i>. The Rust<br/>compiler guarantees that when you state that a value won’t change, it really won’t change,<br/>so you don’t have to keep track of it yourself. Your code is thus easier to reason through.<br/>
But mutability can be very useful, and can make code more convenient to write. Although<br/>variables are immutable by default, you can make them mutable by adding&#160;&#160;mut&#160;&#160;in front of<br/><a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#storing-values-with-variables">the variable name as you did in&#160;Chapter 2</a>. Adding&#160;&#160;mut&#160;&#160;also conveys intent to future readers<br/>of the code by indicating that other parts of the code will be changing this variable’s value.<br/>
For example, let’s change&#160;<i>src/main.rs</i>&#160;to the following:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;x&#160;=&#160;5;<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;x&#160;is:&#160;{x}&#34;);<br/>&#160;&#160;&#160;&#160;x&#160;=&#160;6;<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;x&#160;is:&#160;{x}&#34;);<br/>}<br/>
When we run the program now, we get this:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;variables&#160;v0.1.0&#160;(file:///projects/variables)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.30s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/variables`<br/>The&#160;value&#160;of&#160;x&#160;is:&#160;5<br/>The&#160;value&#160;of&#160;x&#160;is:&#160;6<br/>
We’re allowed to change the value bound to&#160;&#160;x&#160;&#160;from&#160;&#160;5&#160;&#160;to&#160;&#160;6&#160;&#160;when&#160;&#160;mut&#160;&#160;is used. Ultimately,<br/>deciding whether to use mutability or not is up to you and depends on what you think is<br/>clearest in that particular situation.<br/>
https://doc.rust-lang.org/book/print.html<br/>
43/627<br/>
<hr/>
<a name=44></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#44"><b>Constants</b></a><br/>
Like immutable variables,&#160;<i>constants</i>&#160;are values that are bound to a name and are not<br/>allowed to change, but there are a few diﬀerences between constants and variables.<br/>
First, you aren’t allowed to use&#160;&#160;mut&#160;&#160;with constants. Constants aren’t just immutable by<br/>default—they’re always immutable. You declare constants using the&#160;&#160;const&#160;&#160;keyword instead<br/>of the&#160;&#160;let&#160;&#160;keyword, and the type of the value&#160;<i>must</i>&#160;be annotated. We’ll cover types and<br/><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#data-types">type annotations in the next section,&#160;“Data Types”, so don’t worry about the details right<br/></a>now. Just know that you must always annotate the type.<br/>
Constants can be declared in any scope, including the global scope, which makes them<br/>useful for values that many parts of code need to know about.<br/>
The last diﬀerence is that constants may be set only to a constant expression, not the result<br/>of a value that could only be computed at runtime.<br/>
Here’s an example of a constant declaration:<br/>
const&#160;THREE_HOURS_IN_SECONDS:&#160;u32&#160;=&#160;60&#160;*&#160;60&#160;*&#160;3;<br/>
The constant’s name is&#160;&#160;THREE_HOURS_IN_SECONDS&#160;&#160;and its value is set to the result of<br/>multiplying 60 (the number of seconds in a minute) by 60 (the number of minutes in an<br/>hour) by 3 (the number of hours we want to count in this program). Rust’s naming<br/>convention for constants is to use all uppercase with underscores between words. The<br/>compiler is able to evaluate a limited set of operations at compile time, which lets us choose<br/>to write out this value in a way that’s easier to understand and verify, rather than setting<br/><a href="https://doc.rust-lang.org/reference/const_eval.html">this constant to the value 10,800. See the&#160;Rust Reference’s section on constant evaluation<br/></a>for more information on what operations can be used when declaring constants.<br/>
Constants are valid for the entire time a program runs, within the scope in which they were<br/>declared. This property makes constants useful for values in your application domain that<br/>multiple parts of the program might need to know about, such as the maximum number of<br/>points any player of a game is allowed to earn, or the speed of light.<br/>
Naming hardcoded values used throughout your program as constants is useful in<br/>conveying the meaning of that value to future maintainers of the code. It also helps to have<br/>only one place in your code you would need to change if the hardcoded value needed to be<br/>updated in the future.<br/>
<a href="tests.html#44"><b>Shadowing</b></a><br/>
<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">As you saw in the guessing game tutorial in&#160;Chapter 2</a>, you can declare a new variable with<br/>the same name as a previous variable. Rustaceans say that the&#160;ﬁrst variable is&#160;<i>shadowed</i>&#160;by<br/>the second, which means that the second variable is what the compiler will see when you<br/>
https://doc.rust-lang.org/book/print.html<br/>
44/627<br/>
<hr/>
<a name=45></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use the name of the variable. In eﬀect, the second variable overshadows the&#160;ﬁrst, taking any<br/>uses of the variable name to itself until either it itself is shadowed or the scope ends. We<br/>can shadow a variable by using the same variable’s name and repeating the use of the&#160;&#160;let<br/>keyword as follows:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;<br/>
&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;x&#160;+&#160;1;<br/>
&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;x&#160;*&#160;2;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;x&#160;in&#160;the&#160;inner&#160;scope&#160;is:&#160;{x}&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;x&#160;is:&#160;{x}&#34;);<br/>}<br/>
This program&#160;ﬁrst binds&#160;&#160;x&#160;&#160;to a value of&#160;&#160;5&#160;. Then it creates a new variable&#160;&#160;x&#160;&#160;by repeating<br/>
let&#160;x&#160;=&#160;, taking the original value and adding&#160;&#160;1&#160;&#160;so the value of&#160;&#160;x&#160;&#160;is then&#160;&#160;6&#160;. Then, within<br/>
an inner scope created with the curly brackets, the third&#160;&#160;let&#160;&#160;statement also shadows&#160;&#160;x<br/>and creates a new variable, multiplying the previous value by&#160;&#160;2&#160;&#160;to give&#160;&#160;x&#160;&#160;a value of&#160;&#160;12&#160;.<br/>When that scope is over, the inner shadowing ends and&#160;&#160;x&#160;&#160;returns to being&#160;&#160;6&#160;. When we run<br/>this program, it will output the following:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;variables&#160;v0.1.0&#160;(file:///projects/variables)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.31s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/variables`<br/>The&#160;value&#160;of&#160;x&#160;in&#160;the&#160;inner&#160;scope&#160;is:&#160;12<br/>The&#160;value&#160;of&#160;x&#160;is:&#160;6<br/>
Shadowing is diﬀerent from marking a variable as&#160;&#160;mut&#160;&#160;because we’ll get a compile-time<br/>error if we accidentally try to reassign to this variable without using the&#160;&#160;let&#160;&#160;keyword. By<br/>using&#160;&#160;let&#160;, we can perform a few transformations on a value but have the variable be<br/>immutable after those transformations have been completed.<br/>
The other diﬀerence between&#160;&#160;mut&#160;&#160;and shadowing is that because we’re eﬀectively creating<br/>a new variable when we use the&#160;&#160;let&#160;&#160;keyword again, we can change the type of the value<br/>but reuse the same name. For example, say our program asks a user to show how many<br/>spaces they want between some text by inputting space characters, and then we want to<br/>store that input as a number:<br/>
&#160;&#160;&#160;&#160;let&#160;spaces&#160;=&#160;&#34;&#160;&#160;&#160;&#34;;<br/>&#160;&#160;&#160;&#160;let&#160;spaces&#160;=&#160;spaces.len();<br/>
https://doc.rust-lang.org/book/print.html<br/>
45/627<br/>
<hr/>
<a name=46></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The&#160;ﬁrst&#160;&#160;spaces&#160;&#160;variable is a string type and the second&#160;&#160;spaces&#160;&#160;variable is a number type.<br/>Shadowing thus spares us from having to come up with diﬀerent names, such as<br/>
spaces_str&#160;&#160;and&#160;&#160;spaces_num&#160;; instead, we can reuse the simpler&#160;&#160;spaces&#160;&#160;name. However, if<br/>
we try to use&#160;&#160;mut&#160;&#160;for this, as shown here, we’ll get a compile-time error:<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;spaces&#160;=&#160;&#34;&#160;&#160;&#160;&#34;;<br/>&#160;&#160;&#160;&#160;spaces&#160;=&#160;spaces.len();<br/>
The error says we’re not allowed to mutate a variable’s type:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;variables&#160;v0.1.0&#160;(file:///projects/variables)<br/>error[E0308]:&#160;mismatched&#160;types<br/>&#160;--&gt;&#160;src/main.rs:3:14<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;spaces&#160;=&#160;&#34;&#160;&#160;&#160;&#34;;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-----&#160;expected&#160;due&#160;to&#160;this&#160;value<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;spaces&#160;=&#160;spaces.len();<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^&#160;expected&#160;`&amp;str`,&#160;found&#160;`usize`<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0308`.<br/>error:&#160;could&#160;not&#160;compile&#160;`variables`&#160;due&#160;to&#160;previous&#160;error<br/>
Now that we’ve explored how variables work, let’s look at more data types they can have.<br/>
https://doc.rust-lang.org/book/print.html<br/>
46/627<br/>
<hr/>
<a name=47></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#47"><b>Data Types</b></a><br/>
Every value in Rust is of a certain&#160;<i>data type</i>, which tells Rust what kind of data is being<br/>speciﬁed so it knows how to work with that data. We’ll look at two data type subsets: scalar<br/>and compound.<br/>
Keep in mind that Rust is a&#160;<i>statically typed</i>&#160;language, which means that it must know the<br/>types of all variables at compile time. The compiler can usually infer what type we want to<br/>use based on the value and how we use it. In cases when many types are possible, such as<br/><a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">when we converted a&#160;&#160;String&#160;&#160;to a numeric type using&#160;&#160;parse&#160;&#160;in the&#160;“Comparing the Guess<br/>to the Secret Number”&#160;section in Chapter 2, we must add a type annotation, like this:</a><br/>
let&#160;guess:&#160;u32&#160;=&#160;&#34;42&#34;.parse().expect(&#34;Not&#160;a&#160;number!&#34;);<br/>
If we don’t add the&#160;&#160;:&#160;u32&#160;&#160;type annotation shown in the preceding code, Rust will display<br/>the following error, which means the compiler needs more information from us to know<br/>which type we want to use:<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;Compiling&#160;no_type_annotations&#160;v0.1.0&#160;(file:///projects/no_type_annotations)<br/>error[E0282]:&#160;type&#160;annotations&#160;needed<br/>&#160;--&gt;&#160;src/main.rs:2:9<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;guess&#160;=&#160;&#34;42&#34;.parse().expect(&#34;Not&#160;a&#160;number!&#34;);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^<br/>&#160;&#160;|<br/>help:&#160;consider&#160;giving&#160;`guess`&#160;an&#160;explicit&#160;type<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;guess:&#160;_&#160;=&#160;&#34;42&#34;.parse().expect(&#34;Not&#160;a&#160;number!&#34;);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+++<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0282`.<br/>error:&#160;could&#160;not&#160;compile&#160;`no_type_annotations`&#160;due&#160;to&#160;previous&#160;error<br/>
You’ll see diﬀerent type annotations for other data types.<br/>
<a href="tests.html#47"><b>Scalar&#160;Types</b></a><br/>
A&#160;<i>scalar</i>&#160;type represents a single value. Rust has four primary scalar types: integers,&#160;ﬂoating-<br/>point numbers, Booleans, and characters. You may recognize these from other<br/>programming languages. Let’s jump into how they work in Rust.<br/>
https://doc.rust-lang.org/book/print.html<br/>
47/627<br/>
<hr/>
<a name=48></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#48"><b>Integer Types</b></a><br/>
An&#160;<i>integer</i>&#160;is a number without a fractional component. We used one integer type in Chapter<br/>2, the&#160;&#160;u32&#160;&#160;type. This type declaration indicates that the value it’s associated with should be<br/>an unsigned integer (signed integer types start with&#160;&#160;i&#160;&#160;instead of&#160;&#160;u&#160;) that takes up 32 bits of<br/>space. Table 3-1 shows the built-in integer types in Rust. We can use any of these variants to<br/>declare the type of an integer value.<br/>
<b>Table&#160;3-1:&#160;Integer&#160;Types&#160;in&#160;Rust</b><br/>
<b>Length</b><br/>
<b>Signed</b><br/>
<b>Unsigned</b><br/>
8-bit<br/>
i8<br/>
u8<br/>
16-bit<br/>
i16<br/>
u16<br/>
32-bit<br/>
i32<br/>
u32<br/>
64-bit<br/>
i64<br/>
u64<br/>
128-bit<br/>
i128<br/>
u128<br/>
arch<br/>
isize<br/>
usize<br/>
Each variant can be either signed or unsigned and has an explicit size.&#160;<i>Signed</i>&#160;and&#160;<i>unsigned<br/></i>refer to whether it’s possible for the number to be negative—in other words, whether the<br/>number needs to have a sign with it (signed) or whether it will only ever be positive and can<br/>therefore be represented without a sign (unsigned). It’s like writing numbers on paper:<br/>when the sign matters, a number is shown with a plus sign or a minus sign; however, when<br/>it’s safe to assume the number is positive, it’s shown with no sign. Signed numbers are<br/>stored using&#160;<a href="https://en.wikipedia.org/wiki/Two%27s_complement">two’s complement&#160;representation.</a><br/>
Each signed variant can store numbers from -(2n&#160;-&#160;1) to 2n&#160;-&#160;1&#160;- 1 inclusive, where&#160;<i>n</i>&#160;is the<br/>number of bits that variant uses. So an&#160;&#160;i8&#160;&#160;can store numbers from -(27) to 27&#160;- 1, which<br/>equals -128 to 127. Unsigned variants can store numbers from 0 to 2n&#160;- 1, so a&#160;&#160;u8&#160;&#160;can store<br/>numbers from 0 to 28&#160;- 1, which equals 0 to 255.<br/>
Additionally, the&#160;&#160;isize&#160;&#160;and&#160;&#160;usize&#160;&#160;types depend on the architecture of the computer your<br/>program is running on, which is denoted in the table as “arch”: 64 bits if you’re on a 64-bit<br/>architecture and 32 bits if you’re on a 32-bit architecture.<br/>
You can write integer literals in any of the forms shown in Table 3-2. Note that number<br/>literals that can be multiple numeric types allow a type suﬃx, such as&#160;&#160;57u8&#160;, to designate<br/>the type. Number literals can also use&#160;&#160;_&#160;&#160;as a visual separator to make the number easier to<br/>read, such as&#160;&#160;1_000&#160;, which will have the same value as if you had speciﬁed&#160;&#160;1000&#160;.<br/>
<b>Table&#160;3-2:&#160;Integer&#160;Literals&#160;in&#160;Rust</b><br/>
<b>Number literals</b><br/>
<b>Example</b><br/>
Decimal<br/>
98_222<br/>
https://doc.rust-lang.org/book/print.html<br/>
48/627<br/>
<hr/>
<a name=49></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Number literals</b><br/>
<b>Example</b><br/>
Hex<br/>
0xff<br/>
Octal<br/>
0o77<br/>
Binary<br/>
0b1111_0000<br/>
Byte (&#160;u8&#160;&#160;only)<br/>
b'A'<br/>
So how do you know which type of integer to use? If you’re unsure, Rust’s defaults are<br/>generally good places to start: integer types default to&#160;&#160;i32&#160;. The primary situation in which<br/>you’d use&#160;&#160;isize&#160;&#160;or&#160;&#160;usize&#160;&#160;is when indexing some sort of collection.<br/>
<a href="tests.html#49"><b>Integer&#160;Overﬂow</b></a><br/>
Let’s say you have a variable of type&#160;&#160;u8&#160;&#160;that can hold values between 0 and 255. If you<br/>try to change the variable to a value outside that range, such as 256,&#160;<i>integer overﬂow<br/></i>will occur, which can result in one of two behaviors. When you’re compiling in debug<br/>mode, Rust includes checks for integer overﬂow that cause your program to&#160;<i>panic</i>&#160;at<br/>runtime if this behavior occurs. Rust uses the term&#160;<i>panicking</i>&#160;when a program exits<br/><a href="https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html">with an error; we’ll discuss panics in more depth in the&#160;“Unrecoverable Errors with</a><br/>
<a href="https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html">panic!&#160;”&#160;section in Chapter 9.</a><br/>
When you’re compiling in release mode with the&#160;&#160;--release&#160;&#160;ﬂag, Rust does&#160;<i>not</i>&#160;include<br/>checks for integer overﬂow that cause panics. Instead, if overﬂow occurs, Rust<br/>performs&#160;<i>two’s complement wrapping</i>. In short, values greater than the maximum value<br/>the type can hold “wrap around” to the minimum of the values the type can hold. In<br/>the case of a&#160;&#160;u8&#160;, the value 256 becomes 0, the value 257 becomes 1, and so on. The<br/>program won’t panic, but the variable will have a value that probably isn’t what you<br/>were expecting it to have. Relying on integer overﬂow’s wrapping behavior is<br/>considered an error.<br/>
To explicitly handle the possibility of overﬂow, you can use these families of methods<br/>provided by the standard library for primitive numeric types:<br/>
Wrap in all modes with the&#160;&#160;wrapping_*&#160;&#160;methods, such as&#160;&#160;wrapping_add&#160;.<br/>Return the&#160;&#160;None&#160;&#160;value if there is overﬂow with the&#160;&#160;checked_*&#160;&#160;methods.<br/>Return the value and a boolean indicating whether there was overﬂow with the<br/>
overflowing_*&#160;&#160;methods.<br/>
Saturate at the value’s minimum or maximum values with the&#160;&#160;saturating_*<br/>methods.<br/>
https://doc.rust-lang.org/book/print.html<br/>
49/627<br/>
<hr/>
<a name=50></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#50"><b>Floating-Point Types</b></a><br/>
Rust also has two primitive types for&#160;<i>ﬂoating-point numbers</i>, which are numbers with decimal<br/>points. Rust’s&#160;ﬂoating-point types are&#160;&#160;f32&#160;&#160;and&#160;&#160;f64&#160;, which are 32 bits and 64 bits in size,<br/>respectively. The default type is&#160;&#160;f64&#160;&#160;because on modern CPUs, it’s roughly the same speed<br/>as&#160;&#160;f32&#160;&#160;but is capable of more precision. All&#160;ﬂoating-point types are signed.<br/>
Here’s an example that shows&#160;ﬂoating-point numbers in action:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;2.0;&#160;//&#160;f64<br/>
&#160;&#160;&#160;&#160;let&#160;y:&#160;f32&#160;=&#160;3.0;&#160;//&#160;f32<br/>}<br/>
Floating-point numbers are represented according to the IEEE-754 standard. The&#160;&#160;f32&#160;&#160;type<br/>is a single-precision&#160;ﬂoat, and&#160;&#160;f64&#160;&#160;has double precision.<br/>
<a href="tests.html#50"><b>Numeric Operations</b></a><br/>
Rust supports the basic mathematical operations you’d expect for all the number types:<br/>addition, subtraction, multiplication, division, and remainder. Integer division truncates<br/>toward zero to the nearest integer. The following code shows how you’d use each numeric<br/>operation in a&#160;&#160;let&#160;&#160;statement:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;addition<br/>&#160;&#160;&#160;&#160;let&#160;sum&#160;=&#160;5&#160;+&#160;10;<br/>
&#160;&#160;&#160;&#160;//&#160;subtraction<br/>&#160;&#160;&#160;&#160;let&#160;difference&#160;=&#160;95.5&#160;-&#160;4.3;<br/>
&#160;&#160;&#160;&#160;//&#160;multiplication<br/>&#160;&#160;&#160;&#160;let&#160;product&#160;=&#160;4&#160;*&#160;30;<br/>
&#160;&#160;&#160;&#160;//&#160;division<br/>&#160;&#160;&#160;&#160;let&#160;quotient&#160;=&#160;56.7&#160;/&#160;32.2;<br/>&#160;&#160;&#160;&#160;let&#160;truncated&#160;=&#160;-5&#160;/&#160;3;&#160;//&#160;Results&#160;in&#160;-1<br/>
&#160;&#160;&#160;&#160;//&#160;remainder<br/>&#160;&#160;&#160;&#160;let&#160;remainder&#160;=&#160;43&#160;%&#160;5;<br/>}<br/>
Each expression in these statements uses a mathematical operator and evaluates to a<br/><a href="https://doc.rust-lang.org/book/appendix-02-operators.html">single value, which is then bound to a variable.&#160;Appendix B</a>&#160;contains a list of all operators<br/>that Rust provides.<br/>
https://doc.rust-lang.org/book/print.html<br/>
50/627<br/>
<hr/>
<a name=51></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#51"><b>The Boolean Type</b></a><br/>
As in most other programming languages, a Boolean type in Rust has two possible values:<br/>
true&#160;&#160;and&#160;&#160;false&#160;. Booleans are one byte in size. The Boolean type in Rust is speciﬁed using<br/>bool&#160;. For example:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;t&#160;=&#160;true;<br/>
&#160;&#160;&#160;&#160;let&#160;f:&#160;bool&#160;=&#160;false;&#160;//&#160;with&#160;explicit&#160;type&#160;annotation<br/>}<br/>
The main way to use Boolean values is through conditionals, such as an&#160;&#160;if&#160;&#160;expression.<br/>We’ll cover how&#160;&#160;if&#160;<a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html#control-flow">&#160;expressions work in Rust in the&#160;“Control Flow”&#160;section.</a><br/>
<a href="tests.html#51"><b>The Character Type</b></a><br/>
Rust’s&#160;&#160;char&#160;&#160;type is the language’s most primitive alphabetic type. Here are some examples<br/>of declaring&#160;&#160;char&#160;&#160;values:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;c&#160;=&#160;'z';<br/>&#160;&#160;&#160;&#160;let&#160;z:&#160;char&#160;=&#160;'ℤ';&#160;//&#160;with&#160;explicit&#160;type&#160;annotation<br/>&#160;&#160;&#160;&#160;let&#160;heart_eyed_cat&#160;=&#160;'😻';<br/>}<br/>
Note that we specify&#160;&#160;char&#160;&#160;literals with single quotes, as opposed to string literals, which<br/>use double quotes. Rust’s&#160;&#160;char&#160;&#160;type is four bytes in size and represents a Unicode Scalar<br/>Value, which means it can represent a lot more than just ASCII. Accented letters; Chinese,<br/>Japanese, and Korean characters; emoji; and zero-width spaces are all valid&#160;&#160;char&#160;&#160;values in<br/>Rust. Unicode Scalar Values range from&#160;&#160;U+0000&#160;&#160;to&#160;&#160;U+D7FF&#160;&#160;and&#160;&#160;U+E000&#160;&#160;to&#160;&#160;U+10FFFF<br/>inclusive. However, a “character” isn’t really a concept in Unicode, so your human intuition<br/>for what a “character” is may not match up with what a&#160;&#160;char&#160;&#160;is in Rust. We’ll discuss this<br/>topic in detail in&#160;<a href="https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“Storing UTF-8 Encoded Text with Strings”&#160;in Chapter 8.</a><br/>
<a href="tests.html#51"><b>Compound&#160;Types</b></a><br/>
<i>Compound types</i>&#160;can group multiple values into one type. Rust has two primitive compound<br/>types: tuples and arrays.<br/>
https://doc.rust-lang.org/book/print.html<br/>
51/627<br/>
<hr/>
<a name=52></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#52"><b>The Tuple Type</b></a><br/>
A&#160;<i>tuple</i>&#160;is a general way of grouping together a number of values with a variety of types into<br/>one compound type. Tuples have a&#160;ﬁxed length: once declared, they cannot grow or shrink<br/>in size.<br/>
We create a tuple by writing a comma-separated list of values inside parentheses. Each<br/>position in the tuple has a type, and the types of the diﬀerent values in the tuple don’t have<br/>to be the same. We’ve added optional type annotations in this example:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;tup:&#160;(i32,&#160;f64,&#160;u8)&#160;=&#160;(500,&#160;6.4,&#160;1);<br/>}<br/>
The variable&#160;&#160;tup&#160;&#160;binds to the entire tuple because a tuple is considered a single compound<br/>element. To get the individual values out of a tuple, we can use pattern matching to<br/>destructure a tuple value, like this:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;tup&#160;=&#160;(500,&#160;6.4,&#160;1);<br/>
&#160;&#160;&#160;&#160;let&#160;(x,&#160;y,&#160;z)&#160;=&#160;tup;<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;y&#160;is:&#160;{y}&#34;);<br/>}<br/>
This program&#160;ﬁrst creates a tuple and binds it to the variable&#160;&#160;tup&#160;. It then uses a pattern<br/>with&#160;&#160;let&#160;&#160;to take&#160;&#160;tup&#160;&#160;and turn it into three separate variables,&#160;&#160;x&#160;,&#160;&#160;y&#160;, and&#160;&#160;z&#160;. This is called<br/><i>destructuring</i>&#160;because it breaks the single tuple into three parts. Finally, the program prints<br/>the value of&#160;&#160;y&#160;, which is&#160;&#160;6.4&#160;.<br/>
We can also access a tuple element directly by using a period (&#160;.&#160;) followed by the index of<br/>the value we want to access. For example:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x:&#160;(i32,&#160;f64,&#160;u8)&#160;=&#160;(500,&#160;6.4,&#160;1);<br/>
&#160;&#160;&#160;&#160;let&#160;five_hundred&#160;=&#160;x.0;<br/>
&#160;&#160;&#160;&#160;let&#160;six_point_four&#160;=&#160;x.1;<br/>
&#160;&#160;&#160;&#160;let&#160;one&#160;=&#160;x.2;<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
52/627<br/>
<hr/>
<a name=53></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
This program creates the tuple&#160;&#160;x&#160;&#160;and then accesses each element of the tuple using their<br/>respective indices. As with most programming languages, the&#160;ﬁrst index in a tuple is 0.<br/>
The tuple without any values has a special name,&#160;<i>unit</i>. This value and its corresponding type<br/>are both written&#160;&#160;()&#160;&#160;and represent an empty value or an empty return type. Expressions<br/>implicitly return the unit value if they don’t return any other value.<br/>
<a href="tests.html#53"><b>The Array Type</b></a><br/>
Another way to have a collection of multiple values is with an&#160;<i>array</i>. Unlike a tuple, every<br/>element of an array must have the same type. Unlike arrays in some other languages, arrays<br/>in Rust have a&#160;ﬁxed length.<br/>
We write the values in an array as a comma-separated list inside square brackets:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;a&#160;=&#160;[1,&#160;2,&#160;3,&#160;4,&#160;5];<br/>}<br/>
Arrays are useful when you want your data allocated on the stack rather than the heap (we<br/><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap">will discuss the stack and the heap more in&#160;Chapter 4</a>) or when you want to ensure you<br/>always have a&#160;ﬁxed number of elements. An array isn’t as&#160;ﬂexible as the vector type, though.<br/>A&#160;<i>vector</i>&#160;is a similar collection type provided by the standard library that&#160;<i>is</i>&#160;allowed to grow<br/>or shrink in size. If you’re unsure whether to use an array or a vector, chances are you<br/><a href="https://doc.rust-lang.org/book/ch08-01-vectors.html">should use a vector.&#160;Chapter 8&#160;discusses vectors in more detail.</a><br/>
However, arrays are more useful when you know the number of elements will not need to<br/>change. For example, if you were using the names of the month in a program, you would<br/>probably use an array rather than a vector because you know it will always contain 12<br/>elements:<br/>
let&#160;months&#160;=&#160;[&#34;January&#34;,&#160;&#34;February&#34;,&#160;&#34;March&#34;,&#160;&#34;April&#34;,&#160;&#34;May&#34;,&#160;&#34;June&#34;,&#160;&#34;July&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;August&#34;,&#160;&#34;September&#34;,&#160;&#34;October&#34;,&#160;&#34;November&#34;,&#160;&#34;December&#34;];<br/>
You write an array’s type using square brackets with the type of each element, a semicolon,<br/>and then the number of elements in the array, like so:<br/>
let&#160;a:&#160;[i32;&#160;5]&#160;=&#160;[1,&#160;2,&#160;3,&#160;4,&#160;5];<br/>
Here,&#160;&#160;i32&#160;&#160;is the type of each element. After the semicolon, the number&#160;&#160;5&#160;&#160;indicates the<br/>array contains&#160;ﬁve elements.<br/>
You can also initialize an array to contain the same value for each element by specifying the<br/>initial value, followed by a semicolon, and then the length of the array in square brackets, as<br/>
https://doc.rust-lang.org/book/print.html<br/>
53/627<br/>
<hr/>
<a name=54></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
shown here:<br/>
let&#160;a&#160;=&#160;[3;&#160;5];<br/>
The array named&#160;&#160;a&#160;&#160;will contain&#160;&#160;5&#160;&#160;elements that will all be set to the value&#160;&#160;3&#160;&#160;initially. This<br/>is the same as writing&#160;&#160;let&#160;a&#160;=&#160;[3,&#160;3,&#160;3,&#160;3,&#160;3];&#160;&#160;but in a more concise way.<br/>
<a href="tests.html#54"><b>Accessing&#160;Array&#160;Elements</b></a><br/>
An array is a single chunk of memory of a known,&#160;ﬁxed size that can be allocated on the<br/>stack. You can access elements of an array using indexing, like this:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;a&#160;=&#160;[1,&#160;2,&#160;3,&#160;4,&#160;5];<br/>
&#160;&#160;&#160;&#160;let&#160;first&#160;=&#160;a[0];<br/>&#160;&#160;&#160;&#160;let&#160;second&#160;=&#160;a[1];<br/>}<br/>
In this example, the variable named&#160;&#160;first&#160;&#160;will get the value&#160;&#160;1&#160;&#160;because that is the value at<br/>index&#160;&#160;[0]&#160;&#160;in the array. The variable named&#160;&#160;second&#160;&#160;will get the value&#160;&#160;2&#160;&#160;from index&#160;&#160;[1]&#160;&#160;in<br/>the array.<br/>
<a href="tests.html#54"><b>Invalid&#160;Array&#160;Element&#160;Access</b></a><br/>
Let’s see what happens if you try to access an element of an array that is past the end of the<br/>array. Say you run this code, similar to the guessing game in Chapter 2, to get an array index<br/>from the user:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
54/627<br/>
<hr/>
<a name=55></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::io;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;a&#160;=&#160;[1,&#160;2,&#160;3,&#160;4,&#160;5];<br/>
&#160;&#160;&#160;&#160;println!(&#34;Please&#160;enter&#160;an&#160;array&#160;index.&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;index&#160;=&#160;String::new();<br/>
&#160;&#160;&#160;&#160;io::stdin()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.read_line(&amp;mut&#160;index)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;Failed&#160;to&#160;read&#160;line&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;index:&#160;usize&#160;=&#160;index<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.trim()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.parse()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;Index&#160;entered&#160;was&#160;not&#160;a&#160;number&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;element&#160;=&#160;a[index];<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;the&#160;element&#160;at&#160;index&#160;{index}&#160;is:&#160;{element}&#34;);<br/>}<br/>
This code compiles successfully. If you run this code using&#160;&#160;cargo&#160;run&#160;&#160;and enter&#160;&#160;0&#160;,&#160;&#160;1&#160;,&#160;&#160;2&#160;,<br/>
3&#160;, or&#160;&#160;4&#160;, the program will print out the corresponding value at that index in the array. If you<br/>
instead enter a number past the end of the array, such as&#160;&#160;10&#160;, you’ll see output like this:<br/>
thread&#160;'main'&#160;panicked&#160;at&#160;'index&#160;out&#160;of&#160;bounds:&#160;the&#160;len&#160;is&#160;5&#160;but&#160;the&#160;index&#160;is&#160;<br/>10',&#160;src/main.rs:19:19<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
The program resulted in a&#160;<i>runtime</i>&#160;error at the point of using an invalid value in the indexing<br/>operation. The program exited with an error message and didn’t execute the&#160;ﬁnal&#160;&#160;println!<br/>statement. When you attempt to access an element using indexing, Rust will check that the<br/>index you’ve speciﬁed is less than the array length. If the index is greater than or equal to<br/>the length, Rust will panic. This check has to happen at runtime, especially in this case,<br/>because the compiler can’t possibly know what value a user will enter when they run the<br/>code later.<br/>
This is an example of Rust’s memory safety principles in action. In many low-level languages,<br/>this kind of check is not done, and when you provide an incorrect index, invalid memory can<br/>be accessed. Rust protects you against this kind of error by immediately exiting instead of<br/>allowing the memory access and continuing. Chapter 9 discusses more of Rust’s error<br/>handling and how you can write readable, safe code that neither panics nor allows invalid<br/>memory access.<br/>
https://doc.rust-lang.org/book/print.html<br/>
55/627<br/>
<hr/>
<a name=56></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#56"><b>Functions</b></a><br/>
Functions are prevalent in Rust code. You’ve already seen one of the most important<br/>functions in the language: the&#160;&#160;main&#160;&#160;function, which is the entry point of many programs.<br/>You’ve also seen the&#160;&#160;fn&#160;&#160;keyword, which allows you to declare new functions.<br/>
Rust code uses&#160;<i>snake case</i>&#160;as the conventional style for function and variable names, in<br/>which all letters are lowercase and underscores separate words. Here’s a program that<br/>contains an example function deﬁnition:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Hello,&#160;world!&#34;);<br/>
&#160;&#160;&#160;&#160;another_function();<br/>}<br/>
fn&#160;another_function()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Another&#160;function.&#34;);<br/>}<br/>
We deﬁne a function in Rust by entering&#160;&#160;fn&#160;&#160;followed by a function name and a set of<br/>parentheses. The curly brackets tell the compiler where the function body begins and ends.<br/>
We can call any function we’ve deﬁned by entering its name followed by a set of<br/>parentheses. Because&#160;&#160;another_function&#160;&#160;is deﬁned in the program, it can be called from<br/>inside the&#160;&#160;main&#160;&#160;function. Note that we deﬁned&#160;&#160;another_function&#160;&#160;<i>after</i>&#160;the&#160;&#160;main&#160;&#160;function<br/>in the source code; we could have deﬁned it before as well. Rust doesn’t care where you<br/>deﬁne your functions, only that they’re deﬁned somewhere in a scope that can be seen by<br/>the caller.<br/>
Let’s start a new binary project named&#160;<i>functions</i>&#160;to explore functions further. Place the<br/>
another_function&#160;&#160;example in&#160;<i>src/main.rs</i>&#160;and run it. You should see the following output:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;functions&#160;v0.1.0&#160;(file:///projects/functions)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.28s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/functions`<br/>Hello,&#160;world!<br/>Another&#160;function.<br/>
The lines execute in the order in which they appear in the&#160;&#160;main&#160;&#160;function. First the “Hello,<br/>world!” message prints, and then&#160;&#160;another_function&#160;&#160;is called and its message is printed.<br/>
https://doc.rust-lang.org/book/print.html<br/>
56/627<br/>
<hr/>
<a name=57></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#57"><b>Parameters</b></a><br/>
We can deﬁne functions to have&#160;<i>parameters</i>, which are special variables that are part of a<br/>function’s signature. When a function has parameters, you can provide it with concrete<br/>values for those parameters. Technically, the concrete values are called&#160;<i>arguments</i>, but in<br/>casual conversation, people tend to use the words&#160;<i>parameter</i>&#160;and&#160;<i>argument</i>&#160;interchangeably<br/>for either the variables in a function’s deﬁnition or the concrete values passed in when you<br/>call a function.<br/>
In this version of&#160;&#160;another_function&#160;&#160;we add a parameter:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;another_function(5);<br/>}<br/>
fn&#160;another_function(x:&#160;i32)&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;x&#160;is:&#160;{x}&#34;);<br/>}<br/>
Try running this program; you should get the following output:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;functions&#160;v0.1.0&#160;(file:///projects/functions)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;1.21s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/functions`<br/>The&#160;value&#160;of&#160;x&#160;is:&#160;5<br/>
The declaration of&#160;&#160;another_function&#160;&#160;has one parameter named&#160;&#160;x&#160;. The type of&#160;&#160;x&#160;&#160;is<br/>speciﬁed as&#160;&#160;i32&#160;. When we pass&#160;&#160;5&#160;&#160;in to&#160;&#160;another_function&#160;, the&#160;&#160;println!&#160;&#160;macro puts&#160;&#160;5<br/>where the pair of curly brackets containing&#160;&#160;x&#160;&#160;was in the format string.<br/>
In function signatures, you&#160;<i>must</i>&#160;declare the type of each parameter. This is a deliberate<br/>decision in Rust’s design: requiring type annotations in function deﬁnitions means the<br/>compiler almost never needs you to use them elsewhere in the code to&#160;ﬁgure out what type<br/>you mean. The compiler is also able to give more helpful error messages if it knows what<br/>types the function expects.<br/>
When deﬁning multiple parameters, separate the parameter declarations with commas, like<br/>this:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
57/627<br/>
<hr/>
<a name=58></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;print_labeled_measurement(5,&#160;'h');<br/>}<br/>
fn&#160;print_labeled_measurement(value:&#160;i32,&#160;unit_label:&#160;char)&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;measurement&#160;is:&#160;{value}{unit_label}&#34;);<br/>}<br/>
This example creates a function named&#160;&#160;print_labeled_measurement&#160;&#160;with two parameters.<br/>The&#160;ﬁrst parameter is named&#160;&#160;value&#160;&#160;and is an&#160;&#160;i32&#160;. The second is named&#160;&#160;unit_label&#160;&#160;and<br/>is type&#160;&#160;char&#160;. The function then prints text containing both the&#160;&#160;value&#160;&#160;and the&#160;&#160;unit_label&#160;.<br/>
Let’s try running this code. Replace the program currently in your&#160;<i>functions</i>&#160;project’s<br/><i>src/main.rs</i>&#160;ﬁle with the preceding example and run it using&#160;&#160;cargo&#160;run&#160;:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;functions&#160;v0.1.0&#160;(file:///projects/functions)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.31s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/functions`<br/>The&#160;measurement&#160;is:&#160;5h<br/>
Because we called the function with&#160;&#160;5&#160;&#160;as the value for&#160;&#160;value&#160;&#160;and&#160;&#160;'h'&#160;&#160;as the value for<br/>
unit_label&#160;, the program output contains those values.<br/>
<a href="tests.html#58"><b>Statements&#160;and&#160;Expressions</b></a><br/>
Function bodies are made up of a series of statements optionally ending in an expression.<br/>So far, the functions we’ve covered haven’t included an ending expression, but you have<br/>seen an expression as part of a statement. Because Rust is an expression-based language,<br/>this is an important distinction to understand. Other languages don’t have the same<br/>distinctions, so let’s look at what statements and expressions are and how their diﬀerences<br/>aﬀect the bodies of functions.<br/>
<b>Statements</b>&#160;are instructions that perform some action and do not return a value.<br/><b>Expressions</b>&#160;evaluate to a resultant value. Let’s look at some examples.<br/>
We’ve actually already used statements and expressions. Creating a variable and assigning a<br/>value to it with the&#160;&#160;let&#160;&#160;keyword is a statement. In Listing 3-1,&#160;&#160;let&#160;y&#160;=&#160;6;&#160;&#160;is a statement.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;6;<br/>}<br/>
<b>Listing&#160;3-1:&#160;A&#160;&#160;</b>main&#160;<b>&#160;function&#160;declaration&#160;containing&#160;one&#160;statement</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
58/627<br/>
<hr/>
<a name=59></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Function deﬁnitions are also statements; the entire preceding example is a statement in<br/>itself.<br/>
Statements do not return values. Therefore, you can’t assign a&#160;&#160;let&#160;&#160;statement to another<br/>variable, as the following code tries to do; you’ll get an error:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;(let&#160;y&#160;=&#160;6);<br/>}<br/>
When you run this program, the error you’ll get looks like this:<br/>
https://doc.rust-lang.org/book/print.html<br/>
59/627<br/>
<hr/>
<a name=60></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;functions&#160;v0.1.0&#160;(file:///projects/functions)<br/>error:&#160;expected&#160;expression,&#160;found&#160;`let`&#160;statement<br/>&#160;--&gt;&#160;src/main.rs:2:14<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;(let&#160;y&#160;=&#160;6);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^<br/>
error:&#160;expected&#160;expression,&#160;found&#160;statement&#160;(`let`)<br/>&#160;--&gt;&#160;src/main.rs:2:14<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;(let&#160;y&#160;=&#160;6);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;variable&#160;declaration&#160;using&#160;`let`&#160;is&#160;a&#160;statement<br/>
error[E0658]:&#160;`let`&#160;expressions&#160;in&#160;this&#160;position&#160;are&#160;unstable<br/>&#160;--&gt;&#160;src/main.rs:2:14<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;(let&#160;y&#160;=&#160;6);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;see&#160;issue&#160;#53667&#160;&lt;https://github.com/rust-lang/rust/issues/53667&gt;&#160;for&#160;<br/>more&#160;information<br/>
warning:&#160;unnecessary&#160;parentheses&#160;around&#160;assigned&#160;value<br/>&#160;--&gt;&#160;src/main.rs:2:13<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;(let&#160;y&#160;=&#160;6);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;`#[warn(unused_parens)]`&#160;on&#160;by&#160;default<br/>help:&#160;remove&#160;these&#160;parentheses<br/>&#160;&#160;|<br/>2&#160;-&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;(let&#160;y&#160;=&#160;6);<br/>2&#160;+&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;let&#160;y&#160;=&#160;6;<br/>&#160;&#160;|<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0658`.<br/>warning:&#160;`functions`&#160;(bin&#160;&#34;functions&#34;)&#160;generated&#160;1&#160;warning<br/>error:&#160;could&#160;not&#160;compile&#160;`functions`&#160;due&#160;to&#160;3&#160;previous&#160;errors;&#160;1&#160;warning&#160;<br/>emitted<br/>
The&#160;&#160;let&#160;y&#160;=&#160;6&#160;&#160;statement does not return a value, so there isn’t anything for&#160;&#160;x&#160;&#160;to bind to.<br/>This is diﬀerent from what happens in other languages, such as C and Ruby, where the<br/>assignment returns the value of the assignment. In those languages, you can write&#160;&#160;x&#160;=&#160;y&#160;=&#160;<br/>6&#160;&#160;and have both&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;&#160;have the value&#160;&#160;6&#160;; that is not the case in Rust.<br/>
Expressions evaluate to a value and make up most of the rest of the code that you’ll write in<br/>Rust. Consider a math operation, such as&#160;&#160;5&#160;+&#160;6&#160;, which is an expression that evaluates to<br/>the value&#160;&#160;11&#160;. Expressions can be part of statements: in Listing 3-1, the&#160;&#160;6&#160;&#160;in the statement<br/>
let&#160;y&#160;=&#160;6;&#160;&#160;is an expression that evaluates to the value&#160;&#160;6&#160;. Calling a function is an<br/>
expression. Calling a macro is an expression. A new scope block created with curly brackets<br/>is an expression, for example:<br/>
https://doc.rust-lang.org/book/print.html<br/>
60/627<br/>
<hr/>
<a name=61></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;3;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x&#160;+&#160;1<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;y&#160;is:&#160;{y}&#34;);<br/>}<br/>
This expression:<br/>
{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;3;<br/>&#160;&#160;&#160;&#160;x&#160;+&#160;1<br/>}<br/>
is a block that, in this case, evaluates to&#160;&#160;4&#160;. That value gets bound to&#160;&#160;y&#160;&#160;as part of the&#160;&#160;let<br/>statement. Note that the&#160;&#160;x&#160;+&#160;1&#160;&#160;line doesn’t have a semicolon at the end, which is unlike<br/>most of the lines you’ve seen so far. Expressions do not include ending semicolons. If you<br/>add a semicolon to the end of an expression, you turn it into a statement, and it will then<br/>not return a value. Keep this in mind as you explore function return values and expressions<br/>next.<br/>
<a href="tests.html#61"><b>Functions&#160;with&#160;Return&#160;Values</b></a><br/>
Functions can return values to the code that calls them. We don’t name return values, but<br/>we must declare their type after an arrow (&#160;-&gt;&#160;). In Rust, the return value of the function is<br/>synonymous with the value of the&#160;ﬁnal expression in the block of the body of a function.<br/>You can return early from a function by using the&#160;&#160;return&#160;&#160;keyword and specifying a value,<br/>but most functions return the last expression implicitly. Here’s an example of a function that<br/>returns a value:<br/>
Filename: src/main.rs<br/>
fn&#160;five()&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;5<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;five();<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;x&#160;is:&#160;{x}&#34;);<br/>}<br/>
There are no function calls, macros, or even&#160;&#160;let&#160;&#160;statements in the&#160;&#160;five&#160;&#160;function—just the<br/>number&#160;&#160;5&#160;&#160;by itself. That’s a perfectly valid function in Rust. Note that the function’s return<br/>
https://doc.rust-lang.org/book/print.html<br/>
61/627<br/>
<hr/>
<a name=62></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
type is speciﬁed too, as&#160;&#160;-&gt;&#160;i32&#160;. Try running this code; the output should look like this:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;functions&#160;v0.1.0&#160;(file:///projects/functions)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.30s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/functions`<br/>The&#160;value&#160;of&#160;x&#160;is:&#160;5<br/>
The&#160;&#160;5&#160;&#160;in&#160;&#160;five&#160;&#160;is the function’s return value, which is why the return type is&#160;&#160;i32&#160;. Let’s<br/>examine this in more detail. There are two important bits:&#160;ﬁrst, the line&#160;&#160;let&#160;x&#160;=&#160;five();<br/>shows that we’re using the return value of a function to initialize a variable. Because the<br/>function&#160;&#160;five&#160;&#160;returns a&#160;&#160;5&#160;, that line is the same as the following:<br/>
let&#160;x&#160;=&#160;5;<br/>
Second, the&#160;&#160;five&#160;&#160;function has no parameters and deﬁnes the type of the return value, but<br/>the body of the function is a lonely&#160;&#160;5&#160;&#160;with no semicolon because it’s an expression whose<br/>value we want to return.<br/>
Let’s look at another example:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;plus_one(5);<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;x&#160;is:&#160;{x}&#34;);<br/>}<br/>
fn&#160;plus_one(x:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;x&#160;+&#160;1<br/>}<br/>
Running this code will print&#160;&#160;The&#160;value&#160;of&#160;x&#160;is:&#160;6&#160;. But if we place a semicolon at the end<br/>of the line containing&#160;&#160;x&#160;+&#160;1&#160;, changing it from an expression to a statement, we’ll get an<br/>error:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;plus_one(5);<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;x&#160;is:&#160;{x}&#34;);<br/>}<br/>
fn&#160;plus_one(x:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;x&#160;+&#160;1;<br/>}<br/>
Compiling this code produces an error, as follows:<br/>
https://doc.rust-lang.org/book/print.html<br/>
62/627<br/>
<hr/>
<a name=63></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;functions&#160;v0.1.0&#160;(file:///projects/functions)<br/>error[E0308]:&#160;mismatched&#160;types<br/>&#160;--&gt;&#160;src/main.rs:7:24<br/>&#160;&#160;|<br/>7&#160;|&#160;fn&#160;plus_one(x:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;--------&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^&#160;expected&#160;`i32`,&#160;found&#160;`()`<br/>&#160;&#160;|&#160;&#160;&#160;&#160;|<br/>&#160;&#160;|&#160;&#160;&#160;&#160;implicitly&#160;returns&#160;`()`&#160;as&#160;its&#160;body&#160;has&#160;no&#160;tail&#160;or&#160;`return`&#160;expression<br/>8&#160;|&#160;&#160;&#160;&#160;&#160;x&#160;+&#160;1;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&#160;help:&#160;remove&#160;this&#160;semicolon&#160;to&#160;return&#160;this&#160;value<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0308`.<br/>error:&#160;could&#160;not&#160;compile&#160;`functions`&#160;due&#160;to&#160;previous&#160;error<br/>
The main error message,&#160;&#160;mismatched&#160;types&#160;, reveals the core issue with this code. The<br/>deﬁnition of the function&#160;&#160;plus_one&#160;&#160;says that it will return an&#160;&#160;i32&#160;, but statements don’t<br/>evaluate to a value, which is expressed by&#160;&#160;()&#160;, the unit type. Therefore, nothing is returned,<br/>which contradicts the function deﬁnition and results in an error. In this output, Rust<br/>provides a message to possibly help rectify this issue: it suggests removing the semicolon,<br/>which would&#160;ﬁx the error.<br/>
https://doc.rust-lang.org/book/print.html<br/>
63/627<br/>
<hr/>
<a name=64></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#64"><b>Comments</b></a><br/>
All programmers strive to make their code easy to understand, but sometimes extra<br/>explanation is warranted. In these cases, programmers leave&#160;<i>comments</i>&#160;in their source code<br/>that the compiler will ignore but people reading the source code may&#160;ﬁnd useful.<br/>
Here’s a simple comment:<br/>
//&#160;hello,&#160;world<br/>
In Rust, the idiomatic comment style starts a comment with two slashes, and the comment<br/>continues until the end of the line. For comments that extend beyond a single line, you’ll<br/>need to include&#160;&#160;//&#160;&#160;on each line, like this:<br/>
//&#160;So&#160;we’re&#160;doing&#160;something&#160;complicated&#160;here,&#160;long&#160;enough&#160;that&#160;we&#160;need<br/>//&#160;multiple&#160;lines&#160;of&#160;comments&#160;to&#160;do&#160;it!&#160;Whew!&#160;Hopefully,&#160;this&#160;comment&#160;will<br/>//&#160;explain&#160;what’s&#160;going&#160;on.<br/>
Comments can also be placed at the end of lines containing code:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;lucky_number&#160;=&#160;7;&#160;//&#160;I’m&#160;feeling&#160;lucky&#160;today<br/>}<br/>
But you’ll more often see them used in this format, with the comment on a separate line<br/>above the code it’s annotating:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;I’m&#160;feeling&#160;lucky&#160;today<br/>&#160;&#160;&#160;&#160;let&#160;lucky_number&#160;=&#160;7;<br/>}<br/>
Rust also has another kind of comment, documentation comments, which we’ll discuss in<br/>the&#160;<a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html">“Publishing a Crate to Crates.io”&#160;section of Chapter 14.</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
64/627<br/>
<hr/>
<a name=65></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#65"><b>Control Flow</b></a><br/>
The ability to run some code depending on whether a condition is&#160;&#160;true&#160;&#160;and to run some<br/>code repeatedly while a condition is&#160;&#160;true&#160;&#160;are basic building blocks in most programming<br/>languages. The most common constructs that let you control the&#160;ﬂow of execution of Rust<br/>code are&#160;&#160;if&#160;&#160;expressions and loops.<br/>
<a href="tests.html#65">if<b>&#160;Expressions</b></a><br/>
An&#160;&#160;if&#160;&#160;expression allows you to branch your code depending on conditions. You provide a<br/>condition and then state, “If this condition is met, run this block of code. If the condition is<br/>not met, do not run this block of code.”<br/>
Create a new project called&#160;<i>branches</i>&#160;in your&#160;<i>projects</i>&#160;directory to explore the&#160;&#160;if&#160;&#160;expression.<br/>In the&#160;<i>src/main.rs</i>&#160;ﬁle, input the following:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;number&#160;=&#160;3;<br/>
&#160;&#160;&#160;&#160;if&#160;number&#160;&lt;&#160;5&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;condition&#160;was&#160;true&#34;);<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;condition&#160;was&#160;false&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
All&#160;&#160;if&#160;&#160;expressions start with the keyword&#160;&#160;if&#160;, followed by a condition. In this case, the<br/>condition checks whether or not the variable&#160;&#160;number&#160;&#160;has a value less than 5. We place the<br/>block of code to execute if the condition is&#160;&#160;true&#160;&#160;immediately after the condition inside<br/>curly brackets. Blocks of code associated with the conditions in&#160;&#160;if&#160;&#160;expressions are<br/>sometimes called&#160;<i>arms</i>, just like the arms in&#160;&#160;match&#160;&#160;expressions that we discussed in the<br/><a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Comparing the Guess to the Secret Number”&#160;section of Chapter 2.</a><br/>
Optionally, we can also include an&#160;&#160;else&#160;&#160;expression, which we chose to do here, to give the<br/>program an alternative block of code to execute should the condition evaluate to&#160;&#160;false&#160;. If<br/>you don’t provide an&#160;&#160;else&#160;&#160;expression and the condition is&#160;&#160;false&#160;, the program will just skip<br/>the&#160;&#160;if&#160;&#160;block and move on to the next bit of code.<br/>
Try running this code; you should see the following output:<br/>
https://doc.rust-lang.org/book/print.html<br/>
65/627<br/>
<hr/>
<a name=66></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;branches&#160;v0.1.0&#160;(file:///projects/branches)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.31s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/branches`<br/>condition&#160;was&#160;true<br/>
Let’s try changing the value of&#160;&#160;number&#160;&#160;to a value that makes the condition&#160;&#160;false&#160;&#160;to see<br/>what happens:<br/>
&#160;&#160;&#160;&#160;let&#160;number&#160;=&#160;7;<br/>
Run the program again, and look at the output:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;branches&#160;v0.1.0&#160;(file:///projects/branches)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.31s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/branches`<br/>condition&#160;was&#160;false<br/>
It’s also worth noting that the condition in this code&#160;<i>must</i>&#160;be a&#160;&#160;bool&#160;. If the condition isn’t a<br/>
bool&#160;, we’ll get an error. For example, try running the following code:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;number&#160;=&#160;3;<br/>
&#160;&#160;&#160;&#160;if&#160;number&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;number&#160;was&#160;three&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
The&#160;&#160;if&#160;&#160;condition evaluates to a value of&#160;&#160;3&#160;&#160;this time, and Rust throws an error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;branches&#160;v0.1.0&#160;(file:///projects/branches)<br/>error[E0308]:&#160;mismatched&#160;types<br/>&#160;--&gt;&#160;src/main.rs:4:8<br/>&#160;&#160;|<br/>4&#160;|&#160;&#160;&#160;&#160;&#160;if&#160;number&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^&#160;expected&#160;`bool`,&#160;found&#160;integer<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0308`.<br/>error:&#160;could&#160;not&#160;compile&#160;`branches`&#160;due&#160;to&#160;previous&#160;error<br/>
The error indicates that Rust expected a&#160;&#160;bool&#160;&#160;but got an integer. Unlike languages such as<br/>Ruby and JavaScript, Rust will not automatically try to convert non-Boolean types to a<br/>Boolean. You must be explicit and always provide&#160;&#160;if&#160;&#160;with a Boolean as its condition. If we<br/>
https://doc.rust-lang.org/book/print.html<br/>
66/627<br/>
<hr/>
<a name=67></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
want the&#160;&#160;if&#160;&#160;code block to run only when a number is not equal to&#160;&#160;0&#160;, for example, we can<br/>change the&#160;&#160;if&#160;&#160;expression to the following:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;number&#160;=&#160;3;<br/>
&#160;&#160;&#160;&#160;if&#160;number&#160;!=&#160;0&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;number&#160;was&#160;something&#160;other&#160;than&#160;zero&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
Running this code will print&#160;&#160;number&#160;was&#160;something&#160;other&#160;than&#160;zero&#160;.<br/>
<a href="tests.html#67"><b>Handling Multiple Conditions with&#160;</b>else&#160;if</a><br/>
You can use multiple conditions by combining&#160;&#160;if&#160;&#160;and&#160;&#160;else&#160;&#160;in an&#160;&#160;else&#160;if&#160;&#160;expression. For<br/>example:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;number&#160;=&#160;6;<br/>
&#160;&#160;&#160;&#160;if&#160;number&#160;%&#160;4&#160;==&#160;0&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;number&#160;is&#160;divisible&#160;by&#160;4&#34;);<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;if&#160;number&#160;%&#160;3&#160;==&#160;0&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;number&#160;is&#160;divisible&#160;by&#160;3&#34;);<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;if&#160;number&#160;%&#160;2&#160;==&#160;0&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;number&#160;is&#160;divisible&#160;by&#160;2&#34;);<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;number&#160;is&#160;not&#160;divisible&#160;by&#160;4,&#160;3,&#160;or&#160;2&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
This program has four possible paths it can take. After running it, you should see the<br/>following output:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;branches&#160;v0.1.0&#160;(file:///projects/branches)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.31s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/branches`<br/>number&#160;is&#160;divisible&#160;by&#160;3<br/>
When this program executes, it checks each&#160;&#160;if&#160;&#160;expression in turn and executes the&#160;ﬁrst<br/>body for which the condition evaluates to&#160;&#160;true&#160;. Note that even though 6 is divisible by 2,<br/>we don’t see the output&#160;&#160;number&#160;is&#160;divisible&#160;by&#160;2&#160;, nor do we see the&#160;&#160;number&#160;is&#160;not&#160;<br/>
https://doc.rust-lang.org/book/print.html<br/>
67/627<br/>
<hr/>
<a name=68></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
divisible&#160;by&#160;4,&#160;3,&#160;or&#160;2&#160;&#160;text from the&#160;&#160;else&#160;&#160;block. That’s because Rust only executes the<br/>block for the&#160;ﬁrst&#160;&#160;true&#160;&#160;condition, and once it&#160;ﬁnds one, it doesn’t even check the rest.<br/>
Using too many&#160;&#160;else&#160;if&#160;&#160;expressions can clutter your code, so if you have more than one,<br/>you might want to refactor your code. Chapter 6 describes a powerful Rust branching<br/>construct called&#160;&#160;match&#160;&#160;for these cases.<br/>
<a href="tests.html#68"><b>Using&#160;</b>if<b>&#160;in a&#160;</b>let<b>&#160;Statement</b></a><br/>
Because&#160;&#160;if&#160;&#160;is an expression, we can use it on the right side of a&#160;&#160;let&#160;&#160;statement to assign<br/>the outcome to a variable, as in Listing 3-2.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;condition&#160;=&#160;true;<br/>&#160;&#160;&#160;&#160;let&#160;number&#160;=&#160;if&#160;condition&#160;{&#160;5&#160;}&#160;else&#160;{&#160;6&#160;};<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;number&#160;is:&#160;{number}&#34;);<br/>}<br/>
<b>Listing&#160;3-2:&#160;Assigning&#160;the&#160;result&#160;of&#160;an&#160;&#160;</b>if&#160;<b>&#160;expression&#160;to&#160;a&#160;variable</b><br/>
The&#160;&#160;number&#160;&#160;variable will be bound to a value based on the outcome of the&#160;&#160;if&#160;&#160;expression.<br/>Run this code to see what happens:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;branches&#160;v0.1.0&#160;(file:///projects/branches)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.30s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/branches`<br/>The&#160;value&#160;of&#160;number&#160;is:&#160;5<br/>
Remember that blocks of code evaluate to the last expression in them, and numbers by<br/>themselves are also expressions. In this case, the value of the whole&#160;&#160;if&#160;&#160;expression<br/>depends on which block of code executes. This means the values that have the potential to<br/>be results from each arm of the&#160;&#160;if&#160;&#160;must be the same type; in Listing 3-2, the results of<br/>both the&#160;&#160;if&#160;&#160;arm and the&#160;&#160;else&#160;&#160;arm were&#160;&#160;i32&#160;&#160;integers. If the types are mismatched, as in<br/>the following example, we’ll get an error:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
68/627<br/>
<hr/>
<a name=69></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;condition&#160;=&#160;true;<br/>
&#160;&#160;&#160;&#160;let&#160;number&#160;=&#160;if&#160;condition&#160;{&#160;5&#160;}&#160;else&#160;{&#160;&#34;six&#34;&#160;};<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;value&#160;of&#160;number&#160;is:&#160;{number}&#34;);<br/>}<br/>
When we try to compile this code, we’ll get an error. The&#160;&#160;if&#160;&#160;and&#160;&#160;else&#160;&#160;arms have value<br/>types that are incompatible, and Rust indicates exactly where to&#160;ﬁnd the problem in the<br/>program:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;branches&#160;v0.1.0&#160;(file:///projects/branches)<br/>error[E0308]:&#160;`if`&#160;and&#160;`else`&#160;have&#160;incompatible&#160;types<br/>&#160;--&gt;&#160;src/main.rs:4:44<br/>&#160;&#160;|<br/>4&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;number&#160;=&#160;if&#160;condition&#160;{&#160;5&#160;}&#160;else&#160;{&#160;&#34;six&#34;&#160;};<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^&#160;expected&#160;integer,&#160;found&#160;<br/>`&amp;str`<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;expected&#160;because&#160;of&#160;this<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0308`.<br/>error:&#160;could&#160;not&#160;compile&#160;`branches`&#160;due&#160;to&#160;previous&#160;error<br/>
The expression in the&#160;&#160;if&#160;&#160;block evaluates to an integer, and the expression in the&#160;&#160;else<br/>block evaluates to a string. This won’t work because variables must have a single type, and<br/>Rust needs to know at compile time what type the&#160;&#160;number&#160;&#160;variable is, deﬁnitively. Knowing<br/>the type of&#160;&#160;number&#160;&#160;lets the compiler verify the type is valid everywhere we use&#160;&#160;number&#160;.<br/>Rust wouldn’t be able to do that if the type of&#160;&#160;number&#160;&#160;was only determined at runtime; the<br/>compiler would be more complex and would make fewer guarantees about the code if it<br/>had to keep track of multiple hypothetical types for any variable.<br/>
<a href="tests.html#69"><b>Repetition&#160;with&#160;Loops</b></a><br/>
It’s often useful to execute a block of code more than once. For this task, Rust provides<br/>several&#160;<i>loops</i>, which will run through the code inside the loop body to the end and then start<br/>immediately back at the beginning. To experiment with loops, let’s make a new project<br/>called&#160;<i>loops</i>.<br/>
Rust has three kinds of loops:&#160;&#160;loop&#160;,&#160;&#160;while&#160;, and&#160;&#160;for&#160;. Let’s try each one.<br/>
<a href="tests.html#69"><b>Repeating Code with&#160;</b>loop</a><br/>
The&#160;&#160;loop&#160;&#160;keyword tells Rust to execute a block of code over and over again forever or until<br/>you explicitly tell it to stop.<br/>
https://doc.rust-lang.org/book/print.html<br/>
69/627<br/>
<hr/>
<a name=70></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
As an example, change the&#160;<i>src/main.rs</i>&#160;ﬁle in your&#160;<i>loops</i>&#160;directory to look like this:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;loop&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;again!&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
When we run this program, we’ll see&#160;&#160;again!&#160;&#160;printed over and over continuously until we<br/>stop the program manually. Most terminals support the keyboard shortcut&#160;ctrl-c&#160;to<br/>interrupt a program that is stuck in a continual loop. Give it a try:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;loops&#160;v0.1.0&#160;(file:///projects/loops)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.29s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/loops`<br/>again!<br/>again!<br/>again!<br/>again!<br/>^Cagain!<br/>
The symbol&#160;&#160;^C&#160;&#160;represents where you pressed&#160;ctrl-c. You may or may not see the word<br/>
again!&#160;&#160;printed after the&#160;&#160;^C&#160;, depending on where the code was in the loop when it<br/>
received the interrupt signal.<br/>
Fortunately, Rust also provides a way to break out of a loop using code. You can place the<br/>
break&#160;&#160;keyword within the loop to tell the program when to stop executing the loop. Recall<br/>
<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">that we did this in the guessing game in the&#160;“Quitting After a Correct Guess”&#160;section of<br/></a>Chapter 2 to exit the program when the user won the game by guessing the correct<br/>number.<br/>
We also used&#160;&#160;continue&#160;&#160;in the guessing game, which in a loop tells the program to skip over<br/>any remaining code in this iteration of the loop and go to the next iteration.<br/>
<a href="tests.html#70"><b>Returning Values from Loops</b></a><br/>
One of the uses of a&#160;&#160;loop&#160;&#160;is to retry an operation you know might fail, such as checking<br/>whether a thread has completed its job. You might also need to pass the result of that<br/>operation out of the loop to the rest of your code. To do this, you can add the value you<br/>want returned after the&#160;&#160;break&#160;&#160;expression you use to stop the loop; that value will be<br/>returned out of the loop so you can use it, as shown here:<br/>
https://doc.rust-lang.org/book/print.html<br/>
70/627<br/>
<hr/>
<a name=71></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;counter&#160;=&#160;0;<br/>
&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;loop&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;counter&#160;+=&#160;1;<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;counter&#160;==&#160;10&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break&#160;counter&#160;*&#160;2;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;result&#160;is&#160;{result}&#34;);<br/>}<br/>
Before the loop, we declare a variable named&#160;&#160;counter&#160;&#160;and initialize it to&#160;&#160;0&#160;. Then we<br/>declare a variable named&#160;&#160;result&#160;&#160;to hold the value returned from the loop. On every<br/>iteration of the loop, we add&#160;&#160;1&#160;&#160;to the&#160;&#160;counter&#160;&#160;variable, and then check whether the<br/>
counter&#160;&#160;is equal to&#160;&#160;10&#160;. When it is, we use the&#160;&#160;break&#160;&#160;keyword with the value&#160;&#160;counter&#160;*&#160;<br/>
2&#160;. After the loop, we use a semicolon to end the statement that assigns the value to<br/>
result&#160;. Finally, we print the value in&#160;&#160;result&#160;, which in this case is&#160;&#160;20&#160;.<br/>
<a href="tests.html#71"><b>Loop Labels to Disambiguate Between Multiple Loops</b></a><br/>
If you have loops within loops,&#160;&#160;break&#160;&#160;and&#160;&#160;continue&#160;&#160;apply to the innermost loop at that<br/>point. You can optionally specify a&#160;<i>loop label</i>&#160;on a loop that you can then use with&#160;&#160;break&#160;&#160;or<br/>
continue&#160;&#160;to specify that those keywords apply to the labeled loop instead of the innermost<br/>
loop. Loop labels must begin with a single quote. Here’s an example with two nested loops:<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;count&#160;=&#160;0;<br/>&#160;&#160;&#160;&#160;'counting_up:&#160;loop&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;count&#160;=&#160;{count}&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;remaining&#160;=&#160;10;<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;loop&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;remaining&#160;=&#160;{remaining}&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;remaining&#160;==&#160;9&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;count&#160;==&#160;2&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break&#160;'counting_up;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;remaining&#160;-=&#160;1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count&#160;+=&#160;1;<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;println!(&#34;End&#160;count&#160;=&#160;{count}&#34;);<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
71/627<br/>
<hr/>
<a name=72></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The outer loop has the label&#160;&#160;'counting_up&#160;, and it will count up from 0 to 2. The inner loop<br/>without a label counts down from 10 to 9. The&#160;ﬁrst&#160;&#160;break&#160;&#160;that doesn’t specify a label will<br/>exit the inner loop only. The&#160;&#160;break&#160;'counting_up;&#160;&#160;statement will exit the outer loop. This<br/>code prints:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;loops&#160;v0.1.0&#160;(file:///projects/loops)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.58s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/loops`<br/>count&#160;=&#160;0<br/>remaining&#160;=&#160;10<br/>remaining&#160;=&#160;9<br/>count&#160;=&#160;1<br/>remaining&#160;=&#160;10<br/>remaining&#160;=&#160;9<br/>count&#160;=&#160;2<br/>remaining&#160;=&#160;10<br/>End&#160;count&#160;=&#160;2<br/>
<a href="tests.html#72"><b>Conditional Loops with&#160;</b>while</a><br/>
A program will often need to evaluate a condition within a loop. While the condition is<br/>
true&#160;, the loop runs. When the condition ceases to be&#160;&#160;true&#160;, the program calls&#160;&#160;break&#160;,<br/>
stopping the loop. It’s possible to implement behavior like this using a combination of&#160;&#160;loop&#160;,<br/>
if&#160;,&#160;&#160;else&#160;, and&#160;&#160;break&#160;; you could try that now in a program, if you’d like. However, this<br/>
pattern is so common that Rust has a built-in language construct for it, called a&#160;&#160;while&#160;&#160;loop.<br/>In Listing 3-3, we use&#160;&#160;while&#160;&#160;to loop the program three times, counting down each time, and<br/>then, after the loop, print a message and exit.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;number&#160;=&#160;3;<br/>
&#160;&#160;&#160;&#160;while&#160;number&#160;!=&#160;0&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;{number}!&#34;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;number&#160;-=&#160;1;<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;LIFTOFF!!!&#34;);<br/>}<br/>
<b>Listing&#160;3-3:&#160;Using&#160;a&#160;&#160;</b>while&#160;<b>&#160;loop&#160;to&#160;run&#160;code&#160;while&#160;a&#160;condition&#160;holds&#160;true</b><br/>
This construct eliminates a lot of nesting that would be necessary if you used&#160;&#160;loop&#160;,&#160;&#160;if&#160;,<br/>
else&#160;, and&#160;&#160;break&#160;, and it’s clearer. While a condition evaluates to&#160;&#160;true&#160;, the code runs;<br/>
otherwise, it exits the loop.<br/>
https://doc.rust-lang.org/book/print.html<br/>
72/627<br/>
<hr/>
<a name=73></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#73"><b>Looping Through a Collection with&#160;</b>for</a><br/>
You can choose to use the&#160;&#160;while&#160;&#160;construct to loop over the elements of a collection, such<br/>as an array. For example, the loop in Listing 3-4 prints each element in the array&#160;&#160;a&#160;.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;a&#160;=&#160;[10,&#160;20,&#160;30,&#160;40,&#160;50];<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;index&#160;=&#160;0;<br/>
&#160;&#160;&#160;&#160;while&#160;index&#160;&lt;&#160;5&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;the&#160;value&#160;is:&#160;{}&#34;,&#160;a[index]);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;index&#160;+=&#160;1;<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;3-4:&#160;Looping&#160;through&#160;each&#160;element&#160;of&#160;a&#160;collection&#160;using&#160;a&#160;&#160;</b>while&#160;<b>&#160;loop</b><br/>
Here, the code counts up through the elements in the array. It starts at index&#160;&#160;0&#160;, and then<br/>loops until it reaches the&#160;ﬁnal index in the array (that is, when&#160;&#160;index&#160;&lt;&#160;5&#160;&#160;is no longer<br/>
true&#160;). Running this code will print every element in the array:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;loops&#160;v0.1.0&#160;(file:///projects/loops)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.32s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/loops`<br/>the&#160;value&#160;is:&#160;10<br/>the&#160;value&#160;is:&#160;20<br/>the&#160;value&#160;is:&#160;30<br/>the&#160;value&#160;is:&#160;40<br/>the&#160;value&#160;is:&#160;50<br/>
All&#160;ﬁve array values appear in the terminal, as expected. Even though&#160;&#160;index&#160;&#160;will reach a<br/>value of&#160;&#160;5&#160;&#160;at some point, the loop stops executing before trying to fetch a sixth value from<br/>the array.<br/>
However, this approach is error prone; we could cause the program to panic if the index<br/>value or test condition is incorrect. For example, if you changed the deﬁnition of the&#160;&#160;a&#160;&#160;array<br/>to have four elements but forgot to update the condition to&#160;&#160;while&#160;index&#160;&lt;&#160;4&#160;, the code<br/>would panic. It’s also slow, because the compiler adds runtime code to perform the<br/>conditional check of whether the index is within the bounds of the array on every iteration<br/>through the loop.<br/>
As a more concise alternative, you can use a&#160;&#160;for&#160;&#160;loop and execute some code for each item<br/>in a collection. A&#160;&#160;for&#160;&#160;loop looks like the code in Listing 3-5.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
73/627<br/>
<hr/>
<a name=74></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;a&#160;=&#160;[10,&#160;20,&#160;30,&#160;40,&#160;50];<br/>
&#160;&#160;&#160;&#160;for&#160;element&#160;in&#160;a&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;the&#160;value&#160;is:&#160;{element}&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;3-5:&#160;Looping&#160;through&#160;each&#160;element&#160;of&#160;a&#160;collection&#160;using&#160;a&#160;&#160;</b>for&#160;<b>&#160;loop</b><br/>
When we run this code, we’ll see the same output as in Listing 3-4. More importantly, we’ve<br/>now increased the safety of the code and eliminated the chance of bugs that might result<br/>from going beyond the end of the array or not going far enough and missing some items.<br/>
Using the&#160;&#160;for&#160;&#160;loop, you wouldn’t need to remember to change any other code if you<br/>changed the number of values in the array, as you would with the method used in Listing 3-<br/>4.<br/>
The safety and conciseness of&#160;&#160;for&#160;&#160;loops make them the most commonly used loop<br/>construct in Rust. Even in situations in which you want to run some code a certain number<br/>of times, as in the countdown example that used a&#160;&#160;while&#160;&#160;loop in Listing 3-3, most<br/>Rustaceans would use a&#160;&#160;for&#160;&#160;loop. The way to do that would be to use a&#160;&#160;Range&#160;, provided<br/>by the standard library, which generates all numbers in sequence starting from one number<br/>and ending before another number.<br/>
Here’s what the countdown would look like using a&#160;&#160;for&#160;&#160;loop and another method we’ve not<br/>yet talked about,&#160;&#160;rev&#160;, to reverse the range:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;for&#160;number&#160;in&#160;(1..4).rev()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;{number}!&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;println!(&#34;LIFTOFF!!!&#34;);<br/>}<br/>
This code is a bit nicer, isn’t it?<br/>
<a href="tests.html#74"><b>Summary</b></a><br/>
You made it! This was a sizable chapter: you learned about variables, scalar and compound<br/>data types, functions, comments,&#160;&#160;if&#160;&#160;expressions, and loops! To practice with the concepts<br/>discussed in this chapter, try building programs to do the following:<br/>
Convert temperatures between Fahrenheit and Celsius.<br/>
https://doc.rust-lang.org/book/print.html<br/>
74/627<br/>
<hr/>
<a name=75></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Generate the&#160;<i>n</i>th Fibonacci number.<br/>Print the lyrics to the Christmas carol “The Twelve Days of Christmas,” taking<br/>advantage of the repetition in the song.<br/>
When you’re ready to move on, we’ll talk about a concept in Rust that&#160;<i>doesn’t</i>&#160;commonly<br/>exist in other programming languages: ownership.<br/>
https://doc.rust-lang.org/book/print.html<br/>
75/627<br/>
<hr/>
<a name=76></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#76"><b>Understanding Ownership</b></a><br/>
Ownership is Rust’s most unique feature and has deep implications for the rest of the<br/>language. It enables Rust to make memory safety guarantees without needing a garbage<br/>collector, so it’s important to understand how ownership works. In this chapter, we’ll talk<br/>about ownership as well as several related features: borrowing, slices, and how Rust lays<br/>data out in memory.<br/>
https://doc.rust-lang.org/book/print.html<br/>
76/627<br/>
<hr/>
<a name=77></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#77"><b>What Is Ownership?</b></a><br/>
<i>Ownership</i>&#160;is a set of rules that govern how a Rust program manages memory. All programs<br/>have to manage the way they use a computer’s memory while running. Some languages<br/>have garbage collection that regularly looks for no-longer-used memory as the program<br/>runs; in other languages, the programmer must explicitly allocate and free the memory.<br/>Rust uses a third approach: memory is managed through a system of ownership with a set<br/>of rules that the compiler checks. If any of the rules are violated, the program won’t compile.<br/>None of the features of ownership will slow down your program while it’s running.<br/>
Because ownership is a new concept for many programmers, it does take some time to get<br/>used to. The good news is that the more experienced you become with Rust and the rules of<br/>the ownership system, the easier you’ll&#160;ﬁnd it to naturally develop code that is safe and<br/>eﬃcient. Keep at it!<br/>
When you understand ownership, you’ll have a solid foundation for understanding the<br/>features that make Rust unique. In this chapter, you’ll learn ownership by working through<br/>some examples that focus on a very common data structure: strings.<br/>
<a href="tests.html#77"><b>The&#160;Stack&#160;and&#160;the&#160;Heap</b></a><br/>
Many programming languages don’t require you to think about the stack and the heap<br/>very often. But in a systems programming language like Rust, whether a value is on the<br/>stack or the heap aﬀects how the language behaves and why you have to make certain<br/>decisions. Parts of ownership will be described in relation to the stack and the heap<br/>later in this chapter, so here is a brief explanation in preparation.<br/>
Both the stack and the heap are parts of memory available to your code to use at<br/>runtime, but they are structured in diﬀerent ways. The stack stores values in the order<br/>it gets them and removes the values in the opposite order. This is referred to as&#160;<i>last in,<br/>ﬁrst out</i>. Think of a stack of plates: when you add more plates, you put them on top of<br/>the pile, and when you need a plate, you take one oﬀ&#160;the top. Adding or removing<br/>plates from the middle or bottom wouldn’t work as well! Adding data is called&#160;<i>pushing<br/>onto the stack</i>, and removing data is called&#160;<i>popping oﬀ&#160;the stack</i>. All data stored on the<br/>stack must have a known,&#160;ﬁxed size. Data with an unknown size at compile time or a<br/>size that might change must be stored on the heap instead.<br/>
The heap is less organized: when you put data on the heap, you request a certain<br/>amount of space. The memory allocator&#160;ﬁnds an empty spot in the heap that is big<br/>enough, marks it as being in use, and returns a&#160;<i>pointer</i>, which is the address of that<br/>location. This process is called&#160;<i>allocating on the heap</i>&#160;and is sometimes abbreviated as<br/>
https://doc.rust-lang.org/book/print.html<br/>
77/627<br/>
<hr/>
<a name=78></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
just&#160;<i>allocating</i>&#160;(pushing values onto the stack is not considered allocating). Because the<br/>pointer to the heap is a known,&#160;ﬁxed size, you can store the pointer on the stack, but<br/>when you want the actual data, you must follow the pointer. Think of being seated at a<br/>restaurant. When you enter, you state the number of people in your group, and the<br/>host&#160;ﬁnds an empty table that&#160;ﬁts everyone and leads you there. If someone in your<br/>group comes late, they can ask where you’ve been seated to&#160;ﬁnd you.<br/>
Pushing to the stack is faster than allocating on the heap because the allocator never<br/>has to search for a place to store new data; that location is always at the top of the<br/>stack. Comparatively, allocating space on the heap requires more work because the<br/>allocator must&#160;ﬁrst&#160;ﬁnd a big enough space to hold the data and then perform<br/>bookkeeping to prepare for the next allocation.<br/>
Accessing data in the heap is slower than accessing data on the stack because you<br/>have to follow a pointer to get there. Contemporary processors are faster if they jump<br/>around less in memory. Continuing the analogy, consider a server at a restaurant<br/>taking orders from many tables. It’s most eﬃcient to get all the orders at one table<br/>before moving on to the next table. Taking an order from table A, then an order from<br/>table B, then one from A again, and then one from B again would be a much slower<br/>process. By the same token, a processor can do its job better if it works on data that’s<br/>close to other data (as it is on the stack) rather than farther away (as it can be on the<br/>heap).<br/>
When your code calls a function, the values passed into the function (including,<br/>potentially, pointers to data on the heap) and the function’s local variables get pushed<br/>onto the stack. When the function is over, those values get popped oﬀ&#160;the stack.<br/>
Keeping track of what parts of code are using what data on the heap, minimizing the<br/>amount of duplicate data on the heap, and cleaning up unused data on the heap so<br/>you don’t run out of space are all problems that ownership addresses. Once you<br/>understand ownership, you won’t need to think about the stack and the heap very<br/>often, but knowing that the main purpose of ownership is to manage heap data can<br/>help explain why it works the way it does.<br/>
<a href="tests.html#78"><b>Ownership&#160;Rules</b></a><br/>
First, let’s take a look at the ownership rules. Keep these rules in mind as we work through<br/>the examples that illustrate them:<br/>
Each value in Rust has an&#160;<i>owner</i>.<br/>There can only be one owner at a time.<br/>When the owner goes out of scope, the value will be dropped.<br/>
https://doc.rust-lang.org/book/print.html<br/>
78/627<br/>
<hr/>
<a name=79></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#79"><b>Variable&#160;Scope</b></a><br/>
Now that we’re past basic Rust syntax, we won’t include all the&#160;&#160;fn&#160;main()&#160;{&#160;&#160;code in<br/>examples, so if you’re following along, make sure to put the following examples inside a<br/>
main&#160;&#160;function manually. As a result, our examples will be a bit more concise, letting us<br/>
focus on the actual details rather than boilerplate code.<br/>
As a&#160;ﬁrst example of ownership, we’ll look at the&#160;<i>scope</i>&#160;of some variables. A scope is the<br/>range within a program for which an item is valid. Take the following variable:<br/>
let&#160;s&#160;=&#160;&#34;hello&#34;;<br/>
The variable&#160;&#160;s&#160;&#160;refers to a string literal, where the value of the string is hardcoded into the<br/>text of our program. The variable is valid from the point at which it’s declared until the end<br/>of the current&#160;<i>scope</i>. Listing 4-1 shows a program with comments annotating where the<br/>variable&#160;&#160;s&#160;&#160;would be valid.<br/>
&#160;&#160;&#160;&#160;{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;s&#160;is&#160;not&#160;valid&#160;here,&#160;it’s&#160;not&#160;yet&#160;declared<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;&#34;hello&#34;;&#160;&#160;&#160;//&#160;s&#160;is&#160;valid&#160;from&#160;this&#160;point&#160;forward<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;do&#160;stuff&#160;with&#160;s<br/>&#160;&#160;&#160;&#160;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;this&#160;scope&#160;is&#160;now&#160;over,&#160;and&#160;s&#160;is&#160;no&#160;longer&#160;valid<br/>
<b>Listing&#160;4-1:&#160;A&#160;variable&#160;and&#160;the&#160;scope&#160;in&#160;which&#160;it&#160;is&#160;valid</b><br/>
In other words, there are two important points in time here:<br/>
When&#160;&#160;s&#160;&#160;comes&#160;<i>into</i>&#160;scope, it is valid.<br/>It remains valid until it goes&#160;<i>out of</i>&#160;scope.<br/>
At this point, the relationship between scopes and when variables are valid is similar to that<br/>in other programming languages. Now we’ll build on top of this understanding by<br/>introducing the&#160;&#160;String&#160;&#160;type.<br/>
<a href="tests.html#79"><b>The&#160;</b>String<b>&#160;Type</b></a><br/>
To illustrate the rules of ownership, we need a data type that is more complex than those<br/><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#data-types">we covered in the&#160;“Data Types”&#160;section of Chapter 3. The types covered previously are of a<br/></a>known size, can be stored on the stack and popped oﬀ&#160;the stack when their scope is over,<br/>and can be quickly and trivially copied to make a new, independent instance if another part<br/>of code needs to use the same value in a diﬀerent scope. But we want to look at data that is<br/>stored on the heap and explore how Rust knows when to clean up that data, and the<br/>
String&#160;&#160;type is a great example.<br/>
We’ll concentrate on the parts of&#160;&#160;String&#160;&#160;that relate to ownership. These aspects also apply<br/>to other complex data types, whether they are provided by the standard library or created<br/>
https://doc.rust-lang.org/book/print.html<br/>
79/627<br/>
<hr/>
<a name=80></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
by you. We’ll discuss&#160;&#160;String&#160;&#160;in more depth in&#160;<a href="https://doc.rust-lang.org/book/ch08-02-strings.html">Chapter 8.</a><br/>
We’ve already seen string literals, where a string value is hardcoded into our program.<br/>String literals are convenient, but they aren’t suitable for every situation in which we may<br/>want to use text. One reason is that they’re immutable. Another is that not every string<br/>value can be known when we write our code: for example, what if we want to take user<br/>input and store it? For these situations, Rust has a second string type,&#160;&#160;String&#160;. This type<br/>manages data allocated on the heap and as such is able to store an amount of text that is<br/>unknown to us at compile time. You can create a&#160;&#160;String&#160;&#160;from a string literal using the<br/>
from&#160;&#160;function, like so:<br/>
let&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
The double colon&#160;&#160;::&#160;&#160;operator allows us to namespace this particular&#160;&#160;from&#160;&#160;function under<br/>the&#160;&#160;String&#160;&#160;type rather than using some sort of name like&#160;&#160;string_from&#160;. We’ll discuss this<br/><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#method-syntax">syntax more in the&#160;“Method Syntax”&#160;section of Chapter 5, and when we talk about<br/></a><a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">namespacing with modules in&#160;“Paths for Referring to an Item in the Module Tree”&#160;in Chapter<br/></a>7.<br/>
This kind of string&#160;<i>can</i>&#160;be mutated:<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
&#160;&#160;&#160;&#160;s.push_str(&#34;,&#160;world!&#34;);&#160;//&#160;push_str()&#160;appends&#160;a&#160;literal&#160;to&#160;a&#160;String<br/>
&#160;&#160;&#160;&#160;println!(&#34;{}&#34;,&#160;s);&#160;//&#160;This&#160;will&#160;print&#160;`hello,&#160;world!`<br/>
So, what’s the diﬀerence here? Why can&#160;&#160;String&#160;&#160;be mutated but literals cannot? The<br/>diﬀerence is in how these two types deal with memory.<br/>
<a href="tests.html#80"><b>Memory&#160;and&#160;Allocation</b></a><br/>
In the case of a string literal, we know the contents at compile time, so the text is hardcoded<br/>directly into the&#160;ﬁnal executable. This is why string literals are fast and eﬃcient. But these<br/>properties only come from the string literal’s immutability. Unfortunately, we can’t put a<br/>blob of memory into the binary for each piece of text whose size is unknown at compile<br/>time and whose size might change while running the program.<br/>
With the&#160;&#160;String&#160;&#160;type, in order to support a mutable, growable piece of text, we need to<br/>allocate an amount of memory on the heap, unknown at compile time, to hold the contents.<br/>This means:<br/>
The memory must be requested from the memory allocator at runtime.<br/>We need a way of returning this memory to the allocator when we’re done with our<br/>
String&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
80/627<br/>
<hr/>
<a name=81></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
That&#160;ﬁrst part is done by us: when we call&#160;&#160;String::from&#160;, its implementation requests the<br/>memory it needs. This is pretty much universal in programming languages.<br/>
However, the second part is diﬀerent. In languages with a&#160;<i>garbage collector (GC)</i>, the GC<br/>keeps track of and cleans up memory that isn’t being used anymore, and we don’t need to<br/>think about it. In most languages without a GC, it’s our responsibility to identify when<br/>memory is no longer being used and to call code to explicitly free it, just as we did to<br/>request it. Doing this correctly has historically been a diﬃcult programming problem. If we<br/>forget, we’ll waste memory. If we do it too early, we’ll have an invalid variable. If we do it<br/>twice, that’s a bug too. We need to pair exactly one&#160;&#160;allocate&#160;&#160;with exactly one&#160;&#160;free&#160;.<br/>
Rust takes a diﬀerent path: the memory is automatically returned once the variable that<br/>owns it goes out of scope. Here’s a version of our scope example from Listing 4-1 using a<br/>
String&#160;&#160;instead of a string literal:<br/>
&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;String::from(&#34;hello&#34;);&#160;//&#160;s&#160;is&#160;valid&#160;from&#160;this&#160;point&#160;forward<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;do&#160;stuff&#160;with&#160;s<br/>&#160;&#160;&#160;&#160;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;this&#160;scope&#160;is&#160;now&#160;over,&#160;and&#160;s&#160;is&#160;no<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;longer&#160;valid<br/>
There is a natural point at which we can return the memory our&#160;&#160;String&#160;&#160;needs to the<br/>allocator: when&#160;&#160;s&#160;&#160;goes out of scope. When a variable goes out of scope, Rust calls a special<br/>function for us. This function is called&#160;&#160;<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop">drop&#160;, and it’s where the author of&#160;&#160;</a>String&#160;&#160;can put<br/>the code to return the memory. Rust calls&#160;&#160;drop&#160;&#160;automatically at the closing curly bracket.<br/>
Note: In C++, this pattern of deallocating resources at the end of an item’s lifetime is<br/>sometimes called&#160;<i>Resource Acquisition Is Initialization (RAII)</i>. The&#160;&#160;drop&#160;&#160;function in Rust<br/>will be familiar to you if you’ve used RAII patterns.<br/>
This pattern has a profound impact on the way Rust code is written. It may seem simple<br/>right now, but the behavior of code can be unexpected in more complicated situations<br/>when we want to have multiple variables use the data we’ve allocated on the heap. Let’s<br/>explore some of those situations now.<br/>
<a href="tests.html#81"><b>Variables and Data Interacting with Move</b></a><br/>
Multiple variables can interact with the same data in diﬀerent ways in Rust. Let’s look at an<br/>example using an integer in Listing 4-2.<br/>
&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;<br/>&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;x;<br/>
<b>Listing&#160;4-2:&#160;Assigning&#160;the&#160;integer&#160;value&#160;of&#160;variable&#160;&#160;</b>x&#160;<b>&#160;to&#160;&#160;</b>y<br/>
https://doc.rust-lang.org/book/print.html<br/>
81/627<br/>
<hr/>
<a name=82></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We can probably guess what this is doing: “bind the value&#160;&#160;5&#160;&#160;to&#160;&#160;x&#160;; then make a copy of the<br/>value in&#160;&#160;x&#160;&#160;and bind it to&#160;&#160;y&#160;.” We now have two variables,&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;, and both equal&#160;&#160;5&#160;. This<br/>is indeed what is happening, because integers are simple values with a known,&#160;ﬁxed size,<br/>and these two&#160;&#160;5&#160;&#160;values are pushed onto the stack.<br/>
Now let’s look at the&#160;&#160;String&#160;&#160;version:<br/>
&#160;&#160;&#160;&#160;let&#160;s1&#160;=&#160;String::from(&#34;hello&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;s2&#160;=&#160;s1;<br/>
This looks very similar, so we might assume that the way it works would be the same: that<br/>is, the second line would make a copy of the value in&#160;&#160;s1&#160;&#160;and bind it to&#160;&#160;s2&#160;. But this isn’t<br/>quite what happens.<br/>
Take a look at Figure 4-1 to see what is happening to&#160;&#160;String&#160;&#160;under the covers. A&#160;&#160;String&#160;&#160;is<br/>made up of three parts, shown on the left: a pointer to the memory that holds the contents<br/>of the string, a length, and a capacity. This group of data is stored on the stack. On the right<br/>is the memory on the heap that holds the contents.<br/>
s1<br/>
name&#160;value<br/>
index&#160;value<br/>
ptr<br/>
0<br/>
h<br/>
len<br/>
5<br/>
1<br/>
e<br/>
capacity<br/>
5<br/>
2<br/>
l<br/>
3<br/>
l<br/>
4<br/>
o<br/>
<b>Figure&#160;4-1:&#160;Representation&#160;in&#160;memory&#160;of&#160;a&#160;&#160;</b>String&#160;<b>&#160;holding&#160;the&#160;value&#160;&#160;</b>&#34;hello&#34;&#160;<b>&#160;bound&#160;to&#160;&#160;</b>s1<br/>
The length is how much memory, in bytes, the contents of the&#160;&#160;String&#160;&#160;are currently using.<br/>The capacity is the total amount of memory, in bytes, that the&#160;&#160;String&#160;&#160;has received from the<br/>allocator. The diﬀerence between length and capacity matters, but not in this context, so for<br/>now, it’s&#160;ﬁne to ignore the capacity.<br/>
When we assign&#160;&#160;s1&#160;&#160;to&#160;&#160;s2&#160;, the&#160;&#160;String&#160;&#160;data is copied, meaning we copy the pointer, the<br/>length, and the capacity that are on the stack. We do not copy the data on the heap that the<br/>pointer refers to. In other words, the data representation in memory looks like Figure 4-2.<br/>
https://doc.rust-lang.org/book/print.html<br/>
82/627<br/>
<hr/>
<a name=83></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
s1<br/>
name&#160;value<br/>
ptr<br/>
len<br/>
5<br/>
capacity<br/>
5<br/>
index&#160;value<br/>
0<br/>
h<br/>
s2<br/>
1<br/>
e<br/>
name&#160;value<br/>
2<br/>
l<br/>
ptr<br/>
3<br/>
l<br/>
len<br/>
5<br/>
4<br/>
o<br/>
capacity<br/>
5<br/>
<b>Figure&#160;4-2:&#160;Representation&#160;in&#160;memory&#160;of&#160;the&#160;variable&#160;&#160;</b>s2&#160;<b>&#160;that&#160;has&#160;a&#160;copy&#160;of&#160;the&#160;pointer,&#160;length,&#160;and&#160;capacity&#160;of</b><br/>
s1<br/>
The representation does&#160;<i>not</i>&#160;look like Figure 4-3, which is what memory would look like if<br/>Rust instead copied the heap data as well. If Rust did this, the operation&#160;&#160;s2&#160;=&#160;s1&#160;&#160;could be<br/>very expensive in terms of runtime performance if the data on the heap were large.<br/>
s1<br/>
name&#160;value<br/>
index&#160;value<br/>
ptr<br/>
0<br/>
h<br/>
len<br/>
5<br/>
1<br/>
e<br/>
capacity<br/>
5<br/>
2<br/>
l<br/>
3<br/>
l<br/>
4<br/>
o<br/>
s2<br/>
name&#160;value<br/>
index&#160;value<br/>
ptr<br/>
0<br/>
h<br/>
len<br/>
5<br/>
1<br/>
e<br/>
capacity<br/>
5<br/>
2<br/>
l<br/>
3<br/>
l<br/>
4<br/>
o<br/>
<b>Figure&#160;4-3:&#160;Another&#160;possibility&#160;for&#160;what&#160;&#160;</b>s2&#160;=&#160;s1&#160;<b>&#160;might&#160;do&#160;if&#160;Rust&#160;copied&#160;the&#160;heap&#160;data&#160;as&#160;well</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
83/627<br/>
<hr/>
<a name=84></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Earlier, we said that when a variable goes out of scope, Rust automatically calls the&#160;&#160;drop<br/>function and cleans up the heap memory for that variable. But Figure 4-2 shows both data<br/>pointers pointing to the same location. This is a problem: when&#160;&#160;s2&#160;&#160;and&#160;&#160;s1&#160;&#160;go out of scope,<br/>they will both try to free the same memory. This is known as a&#160;<i>double free</i>&#160;error and is one<br/>of the memory safety bugs we mentioned previously. Freeing memory twice can lead to<br/>memory corruption, which can potentially lead to security vulnerabilities.<br/>
To ensure memory safety, after the line&#160;&#160;let&#160;s2&#160;=&#160;s1;&#160;, Rust considers&#160;&#160;s1&#160;&#160;as no longer<br/>valid. Therefore, Rust doesn’t need to free anything when&#160;&#160;s1&#160;&#160;goes out of scope. Check out<br/>what happens when you try to use&#160;&#160;s1&#160;&#160;after&#160;&#160;s2&#160;&#160;is created; it won’t work:<br/>
&#160;&#160;&#160;&#160;let&#160;s1&#160;=&#160;String::from(&#34;hello&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;s2&#160;=&#160;s1;<br/>
&#160;&#160;&#160;&#160;println!(&#34;{},&#160;world!&#34;,&#160;s1);<br/>
You’ll get an error like this because Rust prevents you from using the invalidated reference:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;ownership&#160;v0.1.0&#160;(file:///projects/ownership)<br/>error[E0382]:&#160;borrow&#160;of&#160;moved&#160;value:&#160;`s1`<br/>&#160;--&gt;&#160;src/main.rs:5:28<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;s1&#160;=&#160;String::from(&#34;hello&#34;);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&#160;move&#160;occurs&#160;because&#160;`s1`&#160;has&#160;type&#160;`String`,&#160;which&#160;does&#160;not&#160;<br/>implement&#160;the&#160;`Copy`&#160;trait<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;s2&#160;=&#160;s1;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&#160;value&#160;moved&#160;here<br/>4&#160;|<br/>5&#160;|&#160;&#160;&#160;&#160;&#160;println!(&#34;{},&#160;world!&#34;,&#160;s1);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^&#160;value&#160;borrowed&#160;here&#160;after&#160;move<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;this&#160;error&#160;originates&#160;in&#160;the&#160;macro&#160;`$crate::format_args_nl`&#160;which&#160;<br/>comes&#160;from&#160;the&#160;expansion&#160;of&#160;the&#160;macro&#160;`println`&#160;(in&#160;Nightly&#160;builds,&#160;run&#160;with&#160;-Z&#160;<br/>macro-backtrace&#160;for&#160;more&#160;info)<br/>help:&#160;consider&#160;cloning&#160;the&#160;value&#160;if&#160;the&#160;performance&#160;cost&#160;is&#160;acceptable<br/>&#160;&#160;|<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;s2&#160;=&#160;s1.clone();<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++++++++<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0382`.<br/>error:&#160;could&#160;not&#160;compile&#160;`ownership`&#160;due&#160;to&#160;previous&#160;error<br/>
If you’ve heard the terms&#160;<i>shallow copy</i>&#160;and&#160;<i>deep copy</i>&#160;while working with other languages,<br/>the concept of copying the pointer, length, and capacity without copying the data probably<br/>sounds like making a shallow copy. But because Rust also invalidates the&#160;ﬁrst variable,<br/>instead of being called a shallow copy, it’s known as a&#160;<i>move</i>. In this example, we would say<br/>that&#160;&#160;s1&#160;&#160;was&#160;<i>moved</i>&#160;into&#160;&#160;s2&#160;. So, what actually happens is shown in Figure 4-4.<br/>
https://doc.rust-lang.org/book/print.html<br/>
84/627<br/>
<hr/>
<a name=85></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
s1<br/>
name&#160;value<br/>
ptr<br/>
len<br/>
5<br/>
capacity<br/>
5<br/>
index&#160;value<br/>
0<br/>
h<br/>
s2<br/>
1<br/>
e<br/>
name&#160;value<br/>
2<br/>
l<br/>
ptr<br/>
3<br/>
l<br/>
len<br/>
5<br/>
4<br/>
o<br/>
capacity<br/>
5<br/>
<b>Figure&#160;4-4:&#160;Representation&#160;in&#160;memory&#160;after&#160;&#160;</b>s1&#160;<b>&#160;has&#160;been&#160;invalidated</b><br/>
That solves our problem! With only&#160;&#160;s2&#160;&#160;valid, when it goes out of scope it alone will free the<br/>memory, and we’re done.<br/>
In addition, there’s a design choice that’s implied by this: Rust will never automatically create<br/>“deep” copies of your data. Therefore, any&#160;<i>automatic</i>&#160;copying can be assumed to be<br/>inexpensive in terms of runtime performance.<br/>
<a href="tests.html#85"><b>Variables and Data Interacting with Clone</b></a><br/>
If we&#160;<i>do</i>&#160;want to deeply copy the heap data of the&#160;&#160;String&#160;, not just the stack data, we can<br/>use a common method called&#160;&#160;clone&#160;. We’ll discuss method syntax in Chapter 5, but because<br/>methods are a common feature in many programming languages, you’ve probably seen<br/>them before.<br/>
Here’s an example of the&#160;&#160;clone&#160;&#160;method in action:<br/>
&#160;&#160;&#160;&#160;let&#160;s1&#160;=&#160;String::from(&#34;hello&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;s2&#160;=&#160;s1.clone();<br/>
&#160;&#160;&#160;&#160;println!(&#34;s1&#160;=&#160;{},&#160;s2&#160;=&#160;{}&#34;,&#160;s1,&#160;s2);<br/>
This works just&#160;ﬁne and explicitly produces the behavior shown in Figure 4-3, where the<br/>heap data&#160;<i>does</i>&#160;get copied.<br/>
When you see a call to&#160;&#160;clone&#160;, you know that some arbitrary code is being executed and<br/>that code may be expensive. It’s a visual indicator that something diﬀerent is going on.<br/>
https://doc.rust-lang.org/book/print.html<br/>
85/627<br/>
<hr/>
<a name=86></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#86"><b>Stack-Only Data: Copy</b></a><br/>
There’s another wrinkle we haven’t talked about yet. This code using integers—part of which<br/>was shown in Listing 4-2—works and is valid:<br/>
&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;<br/>&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;x;<br/>
&#160;&#160;&#160;&#160;println!(&#34;x&#160;=&#160;{},&#160;y&#160;=&#160;{}&#34;,&#160;x,&#160;y);<br/>
But this code seems to contradict what we just learned: we don’t have a call to&#160;&#160;clone&#160;, but<br/>
x&#160;&#160;is still valid and wasn’t moved into&#160;&#160;y&#160;.<br/>
The reason is that types such as integers that have a known size at compile time are stored<br/>entirely on the stack, so copies of the actual values are quick to make. That means there’s<br/>no reason we would want to prevent&#160;&#160;x&#160;&#160;from being valid after we create the variable&#160;&#160;y&#160;. In<br/>other words, there’s no diﬀerence between deep and shallow copying here, so calling<br/>
clone&#160;&#160;wouldn’t do anything diﬀerent from the usual shallow copying, and we can leave it<br/>
out.<br/>
Rust has a special annotation called the&#160;&#160;Copy&#160;&#160;trait that we can place on types that are<br/>stored on the stack, as integers are (we’ll talk more about traits in&#160;<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Chapter 10</a>). If a type<br/>implements the&#160;&#160;Copy&#160;&#160;trait, variables that use it do not move, but rather are trivially copied,<br/>making them still valid after assignment to another variable.<br/>
Rust won’t let us annotate a type with&#160;&#160;Copy&#160;&#160;if the type, or any of its parts, has implemented<br/>the&#160;&#160;Drop&#160;&#160;trait. If the type needs something special to happen when the value goes out of<br/>scope and we add the&#160;&#160;Copy&#160;&#160;annotation to that type, we’ll get a compile-time error. To learn<br/><a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">about how to add the&#160;&#160;Copy&#160;&#160;annotation to your type to implement the trait, see&#160;“Derivable<br/>Traits”&#160;in Appendix C.</a><br/>
So, what types implement the&#160;&#160;Copy&#160;&#160;trait? You can check the documentation for the given<br/>type to be sure, but as a general rule, any group of simple scalar values can implement<br/>
Copy&#160;, and nothing that requires allocation or is some form of resource can implement<br/>Copy&#160;. Here are some of the types that implement&#160;&#160;Copy&#160;:<br/>
All the integer types, such as&#160;&#160;u32&#160;.<br/>The Boolean type,&#160;&#160;bool&#160;, with values&#160;&#160;true&#160;&#160;and&#160;&#160;false&#160;.<br/>All the&#160;ﬂoating-point types, such as&#160;&#160;f64&#160;.<br/>The character type,&#160;&#160;char&#160;.<br/>Tuples, if they only contain types that also implement&#160;&#160;Copy&#160;. For example,&#160;&#160;(i32,&#160;i32)<br/>implements&#160;&#160;Copy&#160;, but&#160;&#160;(i32,&#160;String)&#160;&#160;does not.<br/>
https://doc.rust-lang.org/book/print.html<br/>
86/627<br/>
<hr/>
<a name=87></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#87"><b>Ownership&#160;and&#160;Functions</b></a><br/>
The mechanics of passing a value to a function are similar to those when assigning a value<br/>to a variable. Passing a variable to a function will move or copy, just as assignment does.<br/>Listing 4-3 has an example with some annotations showing where variables go into and out<br/>of scope.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;String::from(&#34;hello&#34;);&#160;&#160;//&#160;s&#160;comes&#160;into&#160;scope<br/>
&#160;&#160;&#160;&#160;takes_ownership(s);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;s's&#160;value&#160;moves&#160;into&#160;the&#160;function...<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;...&#160;and&#160;so&#160;is&#160;no&#160;longer&#160;valid&#160;here<br/>
&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;x&#160;comes&#160;into&#160;scope<br/>
&#160;&#160;&#160;&#160;makes_copy(x);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;x&#160;would&#160;move&#160;into&#160;the&#160;function,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;but&#160;i32&#160;is&#160;Copy,&#160;so&#160;it's&#160;okay&#160;to&#160;still<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;use&#160;x&#160;afterward<br/>
}&#160;//&#160;Here,&#160;x&#160;goes&#160;out&#160;of&#160;scope,&#160;then&#160;s.&#160;But&#160;because&#160;s's&#160;value&#160;was&#160;moved,&#160;<br/>nothing<br/>&#160;&#160;//&#160;special&#160;happens.<br/>
fn&#160;takes_ownership(some_string:&#160;String)&#160;{&#160;//&#160;some_string&#160;comes&#160;into&#160;scope<br/>&#160;&#160;&#160;&#160;println!(&#34;{}&#34;,&#160;some_string);<br/>}&#160;//&#160;Here,&#160;some_string&#160;goes&#160;out&#160;of&#160;scope&#160;and&#160;`drop`&#160;is&#160;called.&#160;The&#160;backing<br/>&#160;&#160;//&#160;memory&#160;is&#160;freed.<br/>
fn&#160;makes_copy(some_integer:&#160;i32)&#160;{&#160;//&#160;some_integer&#160;comes&#160;into&#160;scope<br/>&#160;&#160;&#160;&#160;println!(&#34;{}&#34;,&#160;some_integer);<br/>}&#160;//&#160;Here,&#160;some_integer&#160;goes&#160;out&#160;of&#160;scope.&#160;Nothing&#160;special&#160;happens.<br/>
<b>Listing&#160;4-3:&#160;Functions&#160;with&#160;ownership&#160;and&#160;scope&#160;annotated</b><br/>
If we tried to use&#160;&#160;s&#160;&#160;after the call to&#160;&#160;takes_ownership&#160;, Rust would throw a compile-time<br/>error. These static checks protect us from mistakes. Try adding code to&#160;&#160;main&#160;&#160;that uses&#160;&#160;s<br/>and&#160;&#160;x&#160;&#160;to see where you can use them and where the ownership rules prevent you from<br/>doing so.<br/>
<a href="tests.html#87"><b>Return&#160;Values&#160;and&#160;Scope</b></a><br/>
Returning values can also transfer ownership. Listing 4-4 shows an example of a function<br/>that returns some value, with similar annotations as those in Listing 4-3.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
87/627<br/>
<hr/>
<a name=88></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;s1&#160;=&#160;gives_ownership();&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;gives_ownership&#160;moves&#160;its&#160;return<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;value&#160;into&#160;s1<br/>
&#160;&#160;&#160;&#160;let&#160;s2&#160;=&#160;String::from(&#34;hello&#34;);&#160;&#160;&#160;&#160;&#160;//&#160;s2&#160;comes&#160;into&#160;scope<br/>
&#160;&#160;&#160;&#160;let&#160;s3&#160;=&#160;takes_and_gives_back(s2);&#160;&#160;//&#160;s2&#160;is&#160;moved&#160;into<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;takes_and_gives_back,&#160;which&#160;also<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;moves&#160;its&#160;return&#160;value&#160;into&#160;s3<br/>}&#160;//&#160;Here,&#160;s3&#160;goes&#160;out&#160;of&#160;scope&#160;and&#160;is&#160;dropped.&#160;s2&#160;was&#160;moved,&#160;so&#160;nothing<br/>&#160;&#160;//&#160;happens.&#160;s1&#160;goes&#160;out&#160;of&#160;scope&#160;and&#160;is&#160;dropped.<br/>
fn&#160;gives_ownership()&#160;-&gt;&#160;String&#160;{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;gives_ownership&#160;will&#160;move&#160;its<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;return&#160;value&#160;into&#160;the&#160;function<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;that&#160;calls&#160;it<br/>
&#160;&#160;&#160;&#160;let&#160;some_string&#160;=&#160;String::from(&#34;yours&#34;);&#160;//&#160;some_string&#160;comes&#160;into&#160;scope<br/>
&#160;&#160;&#160;&#160;some_string&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;some_string&#160;is&#160;returned&#160;and<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;moves&#160;out&#160;to&#160;the&#160;calling<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;function<br/>}<br/>
//&#160;This&#160;function&#160;takes&#160;a&#160;String&#160;and&#160;returns&#160;one<br/>fn&#160;takes_and_gives_back(a_string:&#160;String)&#160;-&gt;&#160;String&#160;{&#160;//&#160;a_string&#160;comes&#160;into<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;scope<br/>
&#160;&#160;&#160;&#160;a_string&#160;&#160;//&#160;a_string&#160;is&#160;returned&#160;and&#160;moves&#160;out&#160;to&#160;the&#160;calling&#160;function<br/>}<br/>
<b>Listing&#160;4-4:&#160;Transferring&#160;ownership&#160;of&#160;return&#160;values</b><br/>
The ownership of a variable follows the same pattern every time: assigning a value to<br/>another variable moves it. When a variable that includes data on the heap goes out of<br/>scope, the value will be cleaned up by&#160;&#160;drop&#160;&#160;unless ownership of the data has been moved<br/>to another variable.<br/>
While this works, taking ownership and then returning ownership with every function is a bit<br/>tedious. What if we want to let a function use a value but not take ownership? It’s quite<br/>annoying that anything we pass in also needs to be passed back if we want to use it again, in<br/>addition to any data resulting from the body of the function that we might want to return as<br/>well.<br/>
Rust does let us return multiple values using a tuple, as shown in Listing 4-5.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
88/627<br/>
<hr/>
<a name=89></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;s1&#160;=&#160;String::from(&#34;hello&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;(s2,&#160;len)&#160;=&#160;calculate_length(s1);<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;length&#160;of&#160;'{}'&#160;is&#160;{}.&#34;,&#160;s2,&#160;len);<br/>}<br/>
fn&#160;calculate_length(s:&#160;String)&#160;-&gt;&#160;(String,&#160;usize)&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;length&#160;=&#160;s.len();&#160;//&#160;len()&#160;returns&#160;the&#160;length&#160;of&#160;a&#160;String<br/>
&#160;&#160;&#160;&#160;(s,&#160;length)<br/>}<br/>
<b>Listing&#160;4-5:&#160;Returning&#160;ownership&#160;of&#160;parameters</b><br/>
But this is too much ceremony and a lot of work for a concept that should be common.<br/>Luckily for us, Rust has a feature for using a value without transferring ownership, called<br/><i>references</i>.<br/>
https://doc.rust-lang.org/book/print.html<br/>
89/627<br/>
<hr/>
<a name=90></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#90"><b>References and Borrowing</b></a><br/>
The issue with the tuple code in Listing 4-5 is that we have to return the&#160;&#160;String&#160;&#160;to the<br/>calling function so we can still use the&#160;&#160;String&#160;&#160;after the call to&#160;&#160;calculate_length&#160;, because<br/>the&#160;&#160;String&#160;&#160;was moved into&#160;&#160;calculate_length&#160;. Instead, we can provide a reference to the<br/>
String&#160;&#160;value. A&#160;<i>reference</i>&#160;is like a pointer in that it’s an address we can follow to access the<br/>
data stored at that address; that data is owned by some other variable. Unlike a pointer, a<br/>reference is guaranteed to point to a valid value of a particular type for the life of that<br/>reference.<br/>
Here is how you would deﬁne and use a&#160;&#160;calculate_length&#160;&#160;function that has a reference to<br/>an object as a parameter instead of taking ownership of the value:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;s1&#160;=&#160;String::from(&#34;hello&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;len&#160;=&#160;calculate_length(&amp;s1);<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;length&#160;of&#160;'{}'&#160;is&#160;{}.&#34;,&#160;s1,&#160;len);<br/>}<br/>
fn&#160;calculate_length(s:&#160;&amp;String)&#160;-&gt;&#160;usize&#160;{<br/>&#160;&#160;&#160;&#160;s.len()<br/>}<br/>
First, notice that all the tuple code in the variable declaration and the function return value<br/>is gone. Second, note that we pass&#160;&#160;&amp;s1&#160;&#160;into&#160;&#160;calculate_length&#160;&#160;and, in its deﬁnition, we<br/>take&#160;&#160;&amp;String&#160;&#160;rather than&#160;&#160;String&#160;. These ampersands represent&#160;<i>references</i>, and they allow<br/>you to refer to some value without taking ownership of it. Figure 4-5 depicts this concept.<br/>
https://doc.rust-lang.org/book/print.html<br/>
90/627<br/>
<hr/>
<a name=91></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
s<br/>
s1<br/>
name&#160;value<br/>
name&#160;value<br/>
index&#160;value<br/>
ptr<br/>
ptr<br/>
0<br/>
h<br/>
len<br/>
5<br/>
1<br/>
e<br/>
capacity<br/>
5<br/>
2<br/>
l<br/>
3<br/>
l<br/>
4<br/>
o<br/>
<b>Figure&#160;4-5:&#160;A&#160;diagram&#160;of&#160;&#160;</b>&amp;String&#160;s&#160;<b>&#160;pointing&#160;at&#160;&#160;</b>String&#160;s1<br/>
Note: The opposite of referencing by using&#160;&#160;&amp;&#160;&#160;is&#160;<i>dereferencing</i>, which is accomplished<br/>with the dereference operator,&#160;&#160;*&#160;. We’ll see some uses of the dereference operator in<br/>Chapter 8 and discuss details of dereferencing in Chapter 15.<br/>
Let’s take a closer look at the function call here:<br/>
&#160;&#160;&#160;&#160;let&#160;s1&#160;=&#160;String::from(&#34;hello&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;len&#160;=&#160;calculate_length(&amp;s1);<br/>
The&#160;&#160;&amp;s1&#160;&#160;syntax lets us create a reference that&#160;<i>refers</i>&#160;to the value of&#160;&#160;s1&#160;&#160;but does not own it.<br/>Because it does not own it, the value it points to will not be dropped when the reference<br/>stops being used.<br/>
Likewise, the signature of the function uses&#160;&#160;&amp;&#160;&#160;to indicate that the type of the parameter&#160;&#160;s<br/>is a reference. Let’s add some explanatory annotations:<br/>
fn&#160;calculate_length(s:&#160;&amp;String)&#160;-&gt;&#160;usize&#160;{&#160;//&#160;s&#160;is&#160;a&#160;reference&#160;to&#160;a&#160;String<br/>&#160;&#160;&#160;&#160;s.len()<br/>}&#160;//&#160;Here,&#160;s&#160;goes&#160;out&#160;of&#160;scope.&#160;But&#160;because&#160;it&#160;does&#160;not&#160;have&#160;ownership&#160;of&#160;what<br/>&#160;&#160;//&#160;it&#160;refers&#160;to,&#160;it&#160;is&#160;not&#160;dropped.<br/>
The scope in which the variable&#160;&#160;s&#160;&#160;is valid is the same as any function parameter’s scope,<br/>but the value pointed to by the reference is not dropped when&#160;&#160;s&#160;&#160;stops being used, because<br/>
s&#160;&#160;doesn’t have ownership. When functions have references as parameters instead of the<br/>
actual values, we won’t need to return the values in order to give back ownership, because<br/>we never had ownership.<br/>
https://doc.rust-lang.org/book/print.html<br/>
91/627<br/>
<hr/>
<a name=92></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We call the action of creating a reference&#160;<i>borrowing</i>. As in real life, if a person owns<br/>something, you can borrow it from them. When you’re done, you have to give it back. You<br/>don’t own it.<br/>
So, what happens if we try to modify something we’re borrowing? Try the code in Listing 4-6.<br/>Spoiler alert: it doesn’t work!<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
&#160;&#160;&#160;&#160;change(&amp;s);<br/>}<br/>
fn&#160;change(some_string:&#160;&amp;String)&#160;{<br/>&#160;&#160;&#160;&#160;some_string.push_str(&#34;,&#160;world&#34;);<br/>}<br/>
<b>Listing&#160;4-6:&#160;Attempting&#160;to&#160;modify&#160;a&#160;borrowed&#160;value</b><br/>
Here’s the error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;ownership&#160;v0.1.0&#160;(file:///projects/ownership)<br/>error[E0596]:&#160;cannot&#160;borrow&#160;`*some_string`&#160;as&#160;mutable,&#160;as&#160;it&#160;is&#160;behind&#160;a&#160;`&amp;`&#160;<br/>reference<br/>&#160;--&gt;&#160;src/main.rs:8:5<br/>&#160;&#160;|<br/>7&#160;|&#160;fn&#160;change(some_string:&#160;&amp;String)&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-------&#160;help:&#160;consider&#160;changing&#160;this&#160;to&#160;be&#160;a&#160;mutable&#160;<br/>reference:&#160;`&amp;mut&#160;String`<br/>8&#160;|&#160;&#160;&#160;&#160;&#160;some_string.push_str(&#34;,&#160;world&#34;);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#160;`some_string`&#160;is&#160;a&#160;`&amp;`&#160;reference,&#160;so&#160;<br/>the&#160;data&#160;it&#160;refers&#160;to&#160;cannot&#160;be&#160;borrowed&#160;as&#160;mutable<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0596`.<br/>error:&#160;could&#160;not&#160;compile&#160;`ownership`&#160;due&#160;to&#160;previous&#160;error<br/>
Just as variables are immutable by default, so are references. We’re not allowed to modify<br/>something we have a reference to.<br/>
<a href="tests.html#92"><b>Mutable&#160;References</b></a><br/>
We can&#160;ﬁx the code from Listing 4-6 to allow us to modify a borrowed value with just a few<br/>small tweaks that use, instead, a&#160;<i>mutable reference</i>:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
92/627<br/>
<hr/>
<a name=93></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
&#160;&#160;&#160;&#160;change(&amp;mut&#160;s);<br/>}<br/>
fn&#160;change(some_string:&#160;&amp;mut&#160;String)&#160;{<br/>&#160;&#160;&#160;&#160;some_string.push_str(&#34;,&#160;world&#34;);<br/>}<br/>
First we change&#160;&#160;s&#160;&#160;to be&#160;&#160;mut&#160;. Then we create a mutable reference with&#160;&#160;&amp;mut&#160;s&#160;&#160;where we<br/>call the&#160;&#160;change&#160;&#160;function, and update the function signature to accept a mutable reference<br/>with&#160;&#160;some_string:&#160;&amp;mut&#160;String&#160;. This makes it very clear that the&#160;&#160;change&#160;&#160;function will<br/>mutate the value it borrows.<br/>
Mutable references have one big restriction: if you have a mutable reference to a value, you<br/>can have no other references to that value. This code that attempts to create two mutable<br/>references to&#160;&#160;s&#160;&#160;will fail:<br/>
Filename: src/main.rs<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;r1&#160;=&#160;&amp;mut&#160;s;<br/>&#160;&#160;&#160;&#160;let&#160;r2&#160;=&#160;&amp;mut&#160;s;<br/>
&#160;&#160;&#160;&#160;println!(&#34;{},&#160;{}&#34;,&#160;r1,&#160;r2);<br/>
Here’s the error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;ownership&#160;v0.1.0&#160;(file:///projects/ownership)<br/>error[E0499]:&#160;cannot&#160;borrow&#160;`s`&#160;as&#160;mutable&#160;more&#160;than&#160;once&#160;at&#160;a&#160;time<br/>&#160;--&gt;&#160;src/main.rs:5:14<br/>&#160;&#160;|<br/>4&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;r1&#160;=&#160;&amp;mut&#160;s;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;------&#160;first&#160;mutable&#160;borrow&#160;occurs&#160;here<br/>5&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;r2&#160;=&#160;&amp;mut&#160;s;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^&#160;second&#160;mutable&#160;borrow&#160;occurs&#160;here<br/>6&#160;|<br/>7&#160;|&#160;&#160;&#160;&#160;&#160;println!(&#34;{},&#160;{}&#34;,&#160;r1,&#160;r2);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&#160;first&#160;borrow&#160;later&#160;used&#160;here<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0499`.<br/>error:&#160;could&#160;not&#160;compile&#160;`ownership`&#160;due&#160;to&#160;previous&#160;error<br/>
This error says that this code is invalid because we cannot borrow&#160;&#160;s&#160;&#160;as mutable more than<br/>once at a time. The&#160;ﬁrst mutable borrow is in&#160;&#160;r1&#160;&#160;and must last until it’s used in the<br/>
println!&#160;, but between the creation of that mutable reference and its usage, we tried to<br/>
create another mutable reference in&#160;&#160;r2&#160;&#160;that borrows the same data as&#160;&#160;r1&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
93/627<br/>
<hr/>
<a name=94></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The restriction preventing multiple mutable references to the same data at the same time<br/>allows for mutation but in a very controlled fashion. It’s something that new Rustaceans<br/>struggle with because most languages let you mutate whenever you’d like. The beneﬁt of<br/>having this restriction is that Rust can prevent data races at compile time. A&#160;<i>data race</i>&#160;is<br/>similar to a race condition and happens when these three behaviors occur:<br/>
Two or more pointers access the same data at the same time.<br/>At least one of the pointers is being used to write to the data.<br/>There’s no mechanism being used to synchronize access to the data.<br/>
Data races cause undeﬁned behavior and can be diﬃcult to diagnose and&#160;ﬁx when you’re<br/>trying to track them down at runtime; Rust prevents this problem by refusing to compile<br/>code with data races!<br/>
As always, we can use curly brackets to create a new scope, allowing for multiple mutable<br/>references, just not&#160;<i>simultaneous</i>&#160;ones:<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;r1&#160;=&#160;&amp;mut&#160;s;<br/>&#160;&#160;&#160;&#160;}&#160;//&#160;r1&#160;goes&#160;out&#160;of&#160;scope&#160;here,&#160;so&#160;we&#160;can&#160;make&#160;a&#160;new&#160;reference&#160;with&#160;no&#160;<br/>problems.<br/>
&#160;&#160;&#160;&#160;let&#160;r2&#160;=&#160;&amp;mut&#160;s;<br/>
Rust enforces a similar rule for combining mutable and immutable references. This code<br/>results in an error:<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;r1&#160;=&#160;&amp;s;&#160;//&#160;no&#160;problem<br/>&#160;&#160;&#160;&#160;let&#160;r2&#160;=&#160;&amp;s;&#160;//&#160;no&#160;problem<br/>&#160;&#160;&#160;&#160;let&#160;r3&#160;=&#160;&amp;mut&#160;s;&#160;//&#160;BIG&#160;PROBLEM<br/>
&#160;&#160;&#160;&#160;println!(&#34;{},&#160;{},&#160;and&#160;{}&#34;,&#160;r1,&#160;r2,&#160;r3);<br/>
Here’s the error:<br/>
https://doc.rust-lang.org/book/print.html<br/>
94/627<br/>
<hr/>
<a name=95></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;ownership&#160;v0.1.0&#160;(file:///projects/ownership)<br/>error[E0502]:&#160;cannot&#160;borrow&#160;`s`&#160;as&#160;mutable&#160;because&#160;it&#160;is&#160;also&#160;borrowed&#160;as&#160;<br/>immutable<br/>&#160;--&gt;&#160;src/main.rs:6:14<br/>&#160;&#160;|<br/>4&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;r1&#160;=&#160;&amp;s;&#160;//&#160;no&#160;problem<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&#160;immutable&#160;borrow&#160;occurs&#160;here<br/>5&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;r2&#160;=&#160;&amp;s;&#160;//&#160;no&#160;problem<br/>6&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;r3&#160;=&#160;&amp;mut&#160;s;&#160;//&#160;BIG&#160;PROBLEM<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^&#160;mutable&#160;borrow&#160;occurs&#160;here<br/>7&#160;|<br/>8&#160;|&#160;&#160;&#160;&#160;&#160;println!(&#34;{},&#160;{},&#160;and&#160;{}&#34;,&#160;r1,&#160;r2,&#160;r3);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&#160;immutable&#160;borrow&#160;later&#160;used&#160;here<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0502`.<br/>error:&#160;could&#160;not&#160;compile&#160;`ownership`&#160;due&#160;to&#160;previous&#160;error<br/>
Whew! We&#160;<i>also</i>&#160;cannot have a mutable reference while we have an immutable one to the<br/>same value.<br/>
Users of an immutable reference don’t expect the value to suddenly change out from under<br/>them! However, multiple immutable references are allowed because no one who is just<br/>reading the data has the ability to aﬀect anyone else’s reading of the data.<br/>
Note that a reference’s scope starts from where it is introduced and continues through the<br/>last time that reference is used. For instance, this code will compile because the last usage<br/>of the immutable references, the&#160;&#160;println!&#160;, occurs before the mutable reference is<br/>introduced:<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;r1&#160;=&#160;&amp;s;&#160;//&#160;no&#160;problem<br/>&#160;&#160;&#160;&#160;let&#160;r2&#160;=&#160;&amp;s;&#160;//&#160;no&#160;problem<br/>&#160;&#160;&#160;&#160;println!(&#34;{}&#160;and&#160;{}&#34;,&#160;r1,&#160;r2);<br/>&#160;&#160;&#160;&#160;//&#160;variables&#160;r1&#160;and&#160;r2&#160;will&#160;not&#160;be&#160;used&#160;after&#160;this&#160;point<br/>
&#160;&#160;&#160;&#160;let&#160;r3&#160;=&#160;&amp;mut&#160;s;&#160;//&#160;no&#160;problem<br/>&#160;&#160;&#160;&#160;println!(&#34;{}&#34;,&#160;r3);<br/>
The scopes of the immutable references&#160;&#160;r1&#160;&#160;and&#160;&#160;r2&#160;&#160;end after the&#160;&#160;println!&#160;&#160;where they<br/>are last used, which is before the mutable reference&#160;&#160;r3&#160;&#160;is created. These scopes don’t<br/>overlap, so this code is allowed: the compiler can tell that the reference is no longer being<br/>used at a point before the end of the scope.<br/>
Even though borrowing errors may be frustrating at times, remember that it’s the Rust<br/>compiler pointing out a potential bug early (at compile time rather than at runtime) and<br/>showing you exactly where the problem is. Then you don’t have to track down why your<br/>data isn’t what you thought it was.<br/>
https://doc.rust-lang.org/book/print.html<br/>
95/627<br/>
<hr/>
<a name=96></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#96"><b>Dangling&#160;References</b></a><br/>
In languages with pointers, it’s easy to erroneously create a&#160;<i>dangling pointer</i>—a pointer that<br/>references a location in memory that may have been given to someone else—by freeing<br/>some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler<br/>guarantees that references will never be dangling references: if you have a reference to<br/>some data, the compiler will ensure that the data will not go out of scope before the<br/>reference to the data does.<br/>
Let’s try to create a dangling reference to see how Rust prevents them with a compile-time<br/>error:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;reference_to_nothing&#160;=&#160;dangle();<br/>}<br/>
fn&#160;dangle()&#160;-&gt;&#160;&amp;String&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
&#160;&#160;&#160;&#160;&amp;s<br/>}<br/>
Here’s the error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;ownership&#160;v0.1.0&#160;(file:///projects/ownership)<br/>error[E0106]:&#160;missing&#160;lifetime&#160;specifier<br/>&#160;--&gt;&#160;src/main.rs:5:16<br/>&#160;&#160;|<br/>5&#160;|&#160;fn&#160;dangle()&#160;-&gt;&#160;&amp;String&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^&#160;expected&#160;named&#160;lifetime&#160;parameter<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;help:&#160;this&#160;function's&#160;return&#160;type&#160;contains&#160;a&#160;borrowed&#160;value,&#160;but&#160;there&#160;is&#160;<br/>no&#160;value&#160;for&#160;it&#160;to&#160;be&#160;borrowed&#160;from<br/>help:&#160;consider&#160;using&#160;the&#160;`'static`&#160;lifetime<br/>&#160;&#160;|<br/>5&#160;|&#160;fn&#160;dangle()&#160;-&gt;&#160;&amp;'static&#160;String&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+++++++<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0106`.<br/>error:&#160;could&#160;not&#160;compile&#160;`ownership`&#160;due&#160;to&#160;previous&#160;error<br/>
This error message refers to a feature we haven’t covered yet: lifetimes. We’ll discuss<br/>lifetimes in detail in Chapter 10. But, if you disregard the parts about lifetimes, the message<br/>does contain the key to why this code is a problem:<br/>
this&#160;function's&#160;return&#160;type&#160;contains&#160;a&#160;borrowed&#160;value,&#160;but&#160;there&#160;is&#160;no&#160;value<br/>for&#160;it&#160;to&#160;be&#160;borrowed&#160;from<br/>
https://doc.rust-lang.org/book/print.html<br/>
96/627<br/>
<hr/>
<a name=97></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Let’s take a closer look at exactly what’s happening at each stage of our&#160;&#160;dangle&#160;&#160;code:<br/>
Filename: src/main.rs<br/>
fn&#160;dangle()&#160;-&gt;&#160;&amp;String&#160;{&#160;//&#160;dangle&#160;returns&#160;a&#160;reference&#160;to&#160;a&#160;String<br/>
&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;String::from(&#34;hello&#34;);&#160;//&#160;s&#160;is&#160;a&#160;new&#160;String<br/>
&#160;&#160;&#160;&#160;&amp;s&#160;//&#160;we&#160;return&#160;a&#160;reference&#160;to&#160;the&#160;String,&#160;s<br/>}&#160;//&#160;Here,&#160;s&#160;goes&#160;out&#160;of&#160;scope,&#160;and&#160;is&#160;dropped.&#160;Its&#160;memory&#160;goes&#160;away.<br/>&#160;&#160;//&#160;Danger!<br/>
Because&#160;&#160;s&#160;&#160;is created inside&#160;&#160;dangle&#160;, when the code of&#160;&#160;dangle&#160;&#160;is&#160;ﬁnished,&#160;&#160;s&#160;&#160;will be<br/>deallocated. But we tried to return a reference to it. That means this reference would be<br/>pointing to an invalid&#160;&#160;String&#160;. That’s no good! Rust won’t let us do this.<br/>
The solution here is to return the&#160;&#160;String&#160;&#160;directly:<br/>
fn&#160;no_dangle()&#160;-&gt;&#160;String&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
&#160;&#160;&#160;&#160;s<br/>}<br/>
This works without any problems. Ownership is moved out, and nothing is deallocated.<br/>
<a href="tests.html#97"><b>The&#160;Rules&#160;of&#160;References</b></a><br/>
Let’s recap what we’ve discussed about references:<br/>
At any given time, you can have&#160;<i>either</i>&#160;one mutable reference&#160;<i>or</i>&#160;any number of<br/>immutable references.<br/>References must always be valid.<br/>
Next, we’ll look at a diﬀerent kind of reference: slices.<br/>
https://doc.rust-lang.org/book/print.html<br/>
97/627<br/>
<hr/>
<a name=98></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#98"><b>The Slice Type</b></a><br/>
<i>Slices</i>&#160;let you reference a contiguous sequence of elements in a collection rather than the<br/>whole collection. A slice is a kind of reference, so it does not have ownership.<br/>
Here’s a small programming problem: write a function that takes a string of words<br/>separated by spaces and returns the&#160;ﬁrst word it&#160;ﬁnds in that string. If the function doesn’t<br/>ﬁnd a space in the string, the whole string must be one word, so the entire string should be<br/>returned.<br/>
Let’s work through how we’d write the signature of this function without using slices, to<br/>understand the problem that slices will solve:<br/>
fn&#160;first_word(s:&#160;&amp;String)&#160;-&gt;&#160;?<br/>
The&#160;&#160;first_word&#160;&#160;function has a&#160;&#160;&amp;String&#160;&#160;as a parameter. We don’t want ownership, so this<br/>is&#160;ﬁne. But what should we return? We don’t really have a way to talk about&#160;<i>part</i>&#160;of a string.<br/>However, we could return the index of the end of the word, indicated by a space. Let’s try<br/>that, as shown in Listing 4-7.<br/>
Filename: src/main.rs<br/>
fn&#160;first_word(s:&#160;&amp;String)&#160;-&gt;&#160;usize&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;bytes&#160;=&#160;s.as_bytes();<br/>
&#160;&#160;&#160;&#160;for&#160;(i,&#160;&amp;item)&#160;in&#160;bytes.iter().enumerate()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;item&#160;==&#160;b'&#160;'&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;i;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;s.len()<br/>}<br/>
<b>Listing&#160;4-7:&#160;The&#160;&#160;</b>first_word&#160;<b>&#160;function&#160;that&#160;returns&#160;a&#160;byte&#160;index&#160;value&#160;into&#160;the&#160;&#160;</b>String&#160;<b>&#160;parameter</b><br/>
Because we need to go through the&#160;&#160;String&#160;&#160;element by element and check whether a value<br/>is a space, we’ll convert our&#160;&#160;String&#160;&#160;to an array of bytes using the&#160;&#160;as_bytes&#160;&#160;method.<br/>
&#160;&#160;&#160;&#160;let&#160;bytes&#160;=&#160;s.as_bytes();<br/>
Next, we create an iterator over the array of bytes using the&#160;&#160;iter&#160;&#160;method:<br/>
&#160;&#160;&#160;&#160;for&#160;(i,&#160;&amp;item)&#160;in&#160;bytes.iter().enumerate()&#160;{<br/>
https://doc.rust-lang.org/book/print.html<br/>
98/627<br/>
<hr/>
<a name=99></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We’ll discuss iterators in more detail in&#160;<a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">Chapter 13</a>. For now, know that&#160;&#160;iter&#160;&#160;is a method<br/>that returns each element in a collection and that&#160;&#160;enumerate&#160;&#160;wraps the result of&#160;&#160;iter&#160;&#160;and<br/>returns each element as part of a tuple instead. The&#160;ﬁrst element of the tuple returned from<br/>
enumerate&#160;&#160;is the index, and the second element is a reference to the element. This is a bit<br/>
more convenient than calculating the index ourselves.<br/>
Because the&#160;&#160;enumerate&#160;&#160;method returns a tuple, we can use patterns to destructure that<br/><a href="https://doc.rust-lang.org/book/ch06-02-match.html#patterns-that-bind-to-values">tuple. We’ll be discussing patterns more in&#160;Chapter 6. In the&#160;&#160;</a>for&#160;&#160;loop, we specify a pattern<br/>that has&#160;&#160;i&#160;&#160;for the index in the tuple and&#160;&#160;&amp;item&#160;&#160;for the single byte in the tuple. Because we<br/>get a reference to the element from&#160;&#160;.iter().enumerate()&#160;, we use&#160;&#160;&amp;&#160;&#160;in the pattern.<br/>
Inside the&#160;&#160;for&#160;&#160;loop, we search for the byte that represents the space by using the byte<br/>literal syntax. If we&#160;ﬁnd a space, we return the position. Otherwise, we return the length of<br/>the string by using&#160;&#160;s.len()&#160;.<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;item&#160;==&#160;b'&#160;'&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;i;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;s.len()<br/>
We now have a way to&#160;ﬁnd out the index of the end of the&#160;ﬁrst word in the string, but<br/>there’s a problem. We’re returning a&#160;&#160;usize&#160;&#160;on its own, but it’s only a meaningful number in<br/>the context of the&#160;&#160;&amp;String&#160;. In other words, because it’s a separate value from the&#160;&#160;String&#160;,<br/>there’s no guarantee that it will still be valid in the future. Consider the program in Listing 4-<br/>8 that uses the&#160;&#160;first_word&#160;&#160;function from Listing 4-7.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;s&#160;=&#160;String::from(&#34;hello&#160;world&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;word&#160;=&#160;first_word(&amp;s);&#160;//&#160;word&#160;will&#160;get&#160;the&#160;value&#160;5<br/>
&#160;&#160;&#160;&#160;s.clear();&#160;//&#160;this&#160;empties&#160;the&#160;String,&#160;making&#160;it&#160;equal&#160;to&#160;&#34;&#34;<br/>
&#160;&#160;&#160;&#160;//&#160;word&#160;still&#160;has&#160;the&#160;value&#160;5&#160;here,&#160;but&#160;there's&#160;no&#160;more&#160;string&#160;that<br/>&#160;&#160;&#160;&#160;//&#160;we&#160;could&#160;meaningfully&#160;use&#160;the&#160;value&#160;5&#160;with.&#160;word&#160;is&#160;now&#160;totally&#160;invalid!<br/>}<br/>
<b>Listing&#160;4-8:&#160;Storing&#160;the&#160;result&#160;from&#160;calling&#160;the&#160;&#160;</b>first_word&#160;<b>&#160;function&#160;and&#160;then&#160;changing&#160;the&#160;&#160;</b>String&#160;<b>&#160;contents</b><br/>
This program compiles without any errors and would also do so if we used&#160;&#160;word&#160;&#160;after<br/>calling&#160;&#160;s.clear()&#160;. Because&#160;&#160;word&#160;&#160;isn’t connected to the state of&#160;&#160;s&#160;&#160;at all,&#160;&#160;word&#160;&#160;still contains<br/>the value&#160;&#160;5&#160;. We could use that value&#160;&#160;5&#160;&#160;with the variable&#160;&#160;s&#160;&#160;to try to extract the&#160;ﬁrst word<br/>out, but this would be a bug because the contents of&#160;&#160;s&#160;&#160;have changed since we saved&#160;&#160;5&#160;&#160;in<br/>
word&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
99/627<br/>
<hr/>
<a name=100></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Having to worry about the index in&#160;&#160;word&#160;&#160;getting out of sync with the data in&#160;&#160;s&#160;&#160;is tedious<br/>and error prone! Managing these indices is even more brittle if we write a&#160;&#160;second_word<br/>function. Its signature would have to look like this:<br/>
fn&#160;second_word(s:&#160;&amp;String)&#160;-&gt;&#160;(usize,&#160;usize)&#160;{<br/>
Now we’re tracking a starting&#160;<i>and</i>&#160;an ending index, and we have even more values that were<br/>calculated from data in a particular state but aren’t tied to that state at all. We have three<br/>unrelated variables&#160;ﬂoating around that need to be kept in sync.<br/>
Luckily, Rust has a solution to this problem: string slices.<br/>
<a href="tests.html#100"><b>String&#160;Slices</b></a><br/>
A&#160;<i>string slice</i>&#160;is a reference to part of a&#160;&#160;String&#160;, and it looks like this:<br/>
&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;String::from(&#34;hello&#160;world&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;&amp;s[0..5];<br/>&#160;&#160;&#160;&#160;let&#160;world&#160;=&#160;&amp;s[6..11];<br/>
Rather than a reference to the entire&#160;&#160;String&#160;,&#160;&#160;hello&#160;&#160;is a reference to a portion of the<br/>
String&#160;, speciﬁed in the extra&#160;&#160;[0..5]&#160;&#160;bit. We create slices using a range within brackets by<br/>
specifying&#160;&#160;[starting_index..ending_index]&#160;, where&#160;&#160;starting_index&#160;&#160;is the&#160;ﬁrst position in<br/>the slice and&#160;&#160;ending_index&#160;&#160;is one more than the last position in the slice. Internally, the<br/>slice data structure stores the starting position and the length of the slice, which<br/>corresponds to&#160;&#160;ending_index&#160;&#160;minus&#160;&#160;starting_index&#160;. So, in the case of&#160;&#160;let&#160;world&#160;=&#160;<br/>&amp;s[6..11];&#160;,&#160;&#160;world&#160;&#160;would be a slice that contains a pointer to the byte at index 6 of&#160;&#160;s&#160;&#160;with<br/>a length value of&#160;&#160;5&#160;.<br/>
Figure 4-6 shows this in a diagram.<br/>
https://doc.rust-lang.org/book/print.html<br/>
100/627<br/>
<hr/>
<a name=101></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
s<br/>
name&#160;value<br/>
index&#160;value<br/>
ptr<br/>
0<br/>
h<br/>
len<br/>
11<br/>
1<br/>
e<br/>
capacity&#160;11<br/>
2<br/>
l<br/>
3<br/>
l<br/>
world<br/>
4<br/>
o<br/>
name&#160;value<br/>
5<br/>
ptr<br/>
6<br/>
w<br/>
len<br/>
5<br/>
7<br/>
o<br/>
8<br/>
r<br/>
9<br/>
l<br/>
10<br/>
d<br/>
<b>Figure&#160;4-6:&#160;String&#160;slice&#160;referring&#160;to&#160;part&#160;of&#160;a&#160;&#160;</b>String<br/>
With Rust’s&#160;&#160;..&#160;&#160;range syntax, if you want to start at index 0, you can drop the value before<br/>the two periods. In other words, these are equal:<br/>
let&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
let&#160;slice&#160;=&#160;&amp;s[0..2];<br/>let&#160;slice&#160;=&#160;&amp;s[..2];<br/>
By the same token, if your slice includes the last byte of the&#160;&#160;String&#160;, you can drop the<br/>trailing number. That means these are equal:<br/>
let&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
let&#160;len&#160;=&#160;s.len();<br/>
let&#160;slice&#160;=&#160;&amp;s[3..len];<br/>let&#160;slice&#160;=&#160;&amp;s[3..];<br/>
You can also drop both values to take a slice of the entire string. So these are equal:<br/>
https://doc.rust-lang.org/book/print.html<br/>
101/627<br/>
<hr/>
<a name=102></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
let&#160;s&#160;=&#160;String::from(&#34;hello&#34;);<br/>
let&#160;len&#160;=&#160;s.len();<br/>
let&#160;slice&#160;=&#160;&amp;s[0..len];<br/>let&#160;slice&#160;=&#160;&amp;s[..];<br/>
Note: String slice range indices must occur at valid UTF-8 character boundaries. If you<br/>attempt to create a string slice in the middle of a multibyte character, your program<br/>will exit with an error. For the purposes of introducing string slices, we are assuming<br/>ASCII only in this section; a more thorough discussion of UTF-8 handling is in the<br/><a href="https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“Storing UTF-8 Encoded Text with Strings”&#160;section of Chapter 8.</a><br/>
With all this information in mind, let’s rewrite&#160;&#160;first_word&#160;&#160;to return a slice. The type that<br/>signiﬁes “string slice” is written as&#160;&#160;&amp;str&#160;:<br/>
Filename: src/main.rs<br/>
fn&#160;first_word(s:&#160;&amp;String)&#160;-&gt;&#160;&amp;str&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;bytes&#160;=&#160;s.as_bytes();<br/>
&#160;&#160;&#160;&#160;for&#160;(i,&#160;&amp;item)&#160;in&#160;bytes.iter().enumerate()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;item&#160;==&#160;b'&#160;'&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;&amp;s[0..i];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&amp;s[..]<br/>}<br/>
We get the index for the end of the word the same way we did in Listing 4-7, by looking for<br/>the&#160;ﬁrst occurrence of a space. When we&#160;ﬁnd a space, we return a string slice using the start<br/>of the string and the index of the space as the starting and ending indices.<br/>
Now when we call&#160;&#160;first_word&#160;, we get back a single value that is tied to the underlying data.<br/>The value is made up of a reference to the starting point of the slice and the number of<br/>elements in the slice.<br/>
Returning a slice would also work for a&#160;&#160;second_word&#160;&#160;function:<br/>
fn&#160;second_word(s:&#160;&amp;String)&#160;-&gt;&#160;&amp;str&#160;{<br/>
We now have a straightforward API that’s much harder to mess up because the compiler will<br/>ensure the references into the&#160;&#160;String&#160;&#160;remain valid. Remember the bug in the program in<br/>Listing 4-8, when we got the index to the end of the&#160;ﬁrst word but then cleared the string so<br/>our index was invalid? That code was logically incorrect but didn’t show any immediate<br/>errors. The problems would show up later if we kept trying to use the&#160;ﬁrst word index with<br/>
https://doc.rust-lang.org/book/print.html<br/>
102/627<br/>
<hr/>
<a name=103></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
an emptied string. Slices make this bug impossible and let us know we have a problem with<br/>our code much sooner. Using the slice version of&#160;&#160;first_word&#160;&#160;will throw a compile-time<br/>error:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;s&#160;=&#160;String::from(&#34;hello&#160;world&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;word&#160;=&#160;first_word(&amp;s);<br/>
&#160;&#160;&#160;&#160;s.clear();&#160;//&#160;error!<br/>
&#160;&#160;&#160;&#160;println!(&#34;the&#160;first&#160;word&#160;is:&#160;{}&#34;,&#160;word);<br/>}<br/>
Here’s the compiler error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;ownership&#160;v0.1.0&#160;(file:///projects/ownership)<br/>error[E0502]:&#160;cannot&#160;borrow&#160;`s`&#160;as&#160;mutable&#160;because&#160;it&#160;is&#160;also&#160;borrowed&#160;as&#160;<br/>immutable<br/>&#160;&#160;--&gt;&#160;src/main.rs:18:5<br/>&#160;&#160;&#160;|<br/>16&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;word&#160;=&#160;first_word(&amp;s);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&#160;immutable&#160;borrow&#160;occurs&#160;here<br/>17&#160;|<br/>18&#160;|&#160;&#160;&#160;&#160;&#160;s.clear();&#160;//&#160;error!<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^&#160;mutable&#160;borrow&#160;occurs&#160;here<br/>19&#160;|<br/>20&#160;|&#160;&#160;&#160;&#160;&#160;println!(&#34;the&#160;first&#160;word&#160;is:&#160;{}&#34;,&#160;word);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;----&#160;immutable&#160;borrow&#160;later&#160;used&#160;<br/>here<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0502`.<br/>error:&#160;could&#160;not&#160;compile&#160;`ownership`&#160;due&#160;to&#160;previous&#160;error<br/>
Recall from the borrowing rules that if we have an immutable reference to something, we<br/>cannot also take a mutable reference. Because&#160;&#160;clear&#160;&#160;needs to truncate the&#160;&#160;String&#160;, it<br/>needs to get a mutable reference. The&#160;&#160;println!&#160;&#160;after the call to&#160;&#160;clear&#160;&#160;uses the reference<br/>in&#160;&#160;word&#160;, so the immutable reference must still be active at that point. Rust disallows the<br/>mutable reference in&#160;&#160;clear&#160;&#160;and the immutable reference in&#160;&#160;word&#160;&#160;from existing at the<br/>same time, and compilation fails. Not only has Rust made our API easier to use, but it has<br/>also eliminated an entire class of errors at compile time!<br/>
<a href="tests.html#103"><b>String Literals as Slices</b></a><br/>
Recall that we talked about string literals being stored inside the binary. Now that we know<br/>about slices, we can properly understand string literals:<br/>
https://doc.rust-lang.org/book/print.html<br/>
103/627<br/>
<hr/>
<a name=104></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
let&#160;s&#160;=&#160;&#34;Hello,&#160;world!&#34;;<br/>
The type of&#160;&#160;s&#160;&#160;here is&#160;&#160;&amp;str&#160;: it’s a slice pointing to that speciﬁc point of the binary. This is<br/>also why string literals are immutable;&#160;&#160;&amp;str&#160;&#160;is an immutable reference.<br/>
<a href="tests.html#104"><b>String Slices as Parameters</b></a><br/>
Knowing that you can take slices of literals and&#160;&#160;String&#160;&#160;values leads us to one more<br/>improvement on&#160;&#160;first_word&#160;, and that’s its signature:<br/>
fn&#160;first_word(s:&#160;&amp;String)&#160;-&gt;&#160;&amp;str&#160;{<br/>
A more experienced Rustacean would write the signature shown in Listing 4-9 instead<br/>because it allows us to use the same function on both&#160;&#160;&amp;String&#160;&#160;values and&#160;&#160;&amp;str&#160;&#160;values.<br/>
fn&#160;first_word(s:&#160;&amp;str)&#160;-&gt;&#160;&amp;str&#160;{<br/>
<b>Listing&#160;4-9:&#160;Improving&#160;the&#160;&#160;</b>first_word&#160;<b>&#160;function&#160;by&#160;using&#160;a&#160;string&#160;slice&#160;for&#160;the&#160;type&#160;of&#160;the&#160;&#160;</b>s&#160;<b>&#160;parameter</b><br/>
If we have a string slice, we can pass that directly. If we have a&#160;&#160;String&#160;, we can pass a slice<br/>of the&#160;&#160;String&#160;&#160;or a reference to the&#160;&#160;String&#160;. This&#160;ﬂexibility takes advantage of&#160;<i>deref<br/>coercions</i>, a feature we will cover in&#160;<a href="https://doc.rust-lang.org/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods">“Implicit Deref Coercions with Functions and Methods”<br/></a>section of Chapter 15.<br/>
Deﬁning a function to take a string slice instead of a reference to a&#160;&#160;String&#160;&#160;makes our API<br/>more general and useful without losing any functionality:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
104/627<br/>
<hr/>
<a name=105></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;my_string&#160;=&#160;String::from(&#34;hello&#160;world&#34;);<br/>
&#160;&#160;&#160;&#160;//&#160;`first_word`&#160;works&#160;on&#160;slices&#160;of&#160;`String`s,&#160;whether&#160;partial&#160;or&#160;whole<br/>&#160;&#160;&#160;&#160;let&#160;word&#160;=&#160;first_word(&amp;my_string[0..6]);<br/>&#160;&#160;&#160;&#160;let&#160;word&#160;=&#160;first_word(&amp;my_string[..]);<br/>&#160;&#160;&#160;&#160;//&#160;`first_word`&#160;also&#160;works&#160;on&#160;references&#160;to&#160;`String`s,&#160;which&#160;are&#160;equivalent<br/>&#160;&#160;&#160;&#160;//&#160;to&#160;whole&#160;slices&#160;of&#160;`String`s<br/>&#160;&#160;&#160;&#160;let&#160;word&#160;=&#160;first_word(&amp;my_string);<br/>
&#160;&#160;&#160;&#160;let&#160;my_string_literal&#160;=&#160;&#34;hello&#160;world&#34;;<br/>
&#160;&#160;&#160;&#160;//&#160;`first_word`&#160;works&#160;on&#160;slices&#160;of&#160;string&#160;literals,&#160;whether&#160;partial&#160;or&#160;<br/>whole<br/>&#160;&#160;&#160;&#160;let&#160;word&#160;=&#160;first_word(&amp;my_string_literal[0..6]);<br/>&#160;&#160;&#160;&#160;let&#160;word&#160;=&#160;first_word(&amp;my_string_literal[..]);<br/>
&#160;&#160;&#160;&#160;//&#160;Because&#160;string&#160;literals&#160;*are*&#160;string&#160;slices&#160;already,<br/>&#160;&#160;&#160;&#160;//&#160;this&#160;works&#160;too,&#160;without&#160;the&#160;slice&#160;syntax!<br/>&#160;&#160;&#160;&#160;let&#160;word&#160;=&#160;first_word(my_string_literal);<br/>}<br/>
<a href="tests.html#105"><b>Other&#160;Slices</b></a><br/>
String slices, as you might imagine, are speciﬁc to strings. But there’s a more general slice<br/>type too. Consider this array:<br/>
let&#160;a&#160;=&#160;[1,&#160;2,&#160;3,&#160;4,&#160;5];<br/>
Just as we might want to refer to part of a string, we might want to refer to part of an array.<br/>We’d do so like this:<br/>
let&#160;a&#160;=&#160;[1,&#160;2,&#160;3,&#160;4,&#160;5];<br/>
let&#160;slice&#160;=&#160;&amp;a[1..3];<br/>
assert_eq!(slice,&#160;&amp;[2,&#160;3]);<br/>
This slice has the type&#160;&#160;&amp;[i32]&#160;. It works the same way as string slices do, by storing a<br/>reference to the&#160;ﬁrst element and a length. You’ll use this kind of slice for all sorts of other<br/>collections. We’ll discuss these collections in detail when we talk about vectors in Chapter 8.<br/>
<a href="tests.html#105"><b>Summary</b></a><br/>
The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs<br/>at compile time. The Rust language gives you control over your memory usage in the same<br/>
https://doc.rust-lang.org/book/print.html<br/>
105/627<br/>
<hr/>
<a name=106></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
way as other systems programming languages, but having the owner of data automatically<br/>clean up that data when the owner goes out of scope means you don’t have to write and<br/>debug extra code to get this control.<br/>
Ownership aﬀects how lots of other parts of Rust work, so we’ll talk about these concepts<br/>further throughout the rest of the book. Let’s move on to Chapter 5 and look at grouping<br/>pieces of data together in a&#160;&#160;struct&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
106/627<br/>
<hr/>
<a name=107></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#107"><b>Using Structs to Structure Related Data</b></a><br/>
A&#160;<i>struct</i>, or&#160;<i>structure</i>, is a custom data type that lets you package together and name<br/>multiple related values that make up a meaningful group. If you’re familiar with an object-<br/>oriented language, a&#160;<i>struct</i>&#160;is like an object’s data attributes. In this chapter, we’ll compare<br/>and contrast tuples with structs to build on what you already know and demonstrate when<br/>structs are a better way to group data.<br/>
We’ll demonstrate how to deﬁne and instantiate structs. We’ll discuss how to deﬁne<br/>associated functions, especially the kind of associated functions called&#160;<i>methods</i>, to specify<br/>behavior associated with a struct type. Structs and enums (discussed in Chapter 6) are the<br/>building blocks for creating new types in your program’s domain to take full advantage of<br/>Rust’s compile-time type checking.<br/>
https://doc.rust-lang.org/book/print.html<br/>
107/627<br/>
<hr/>
<a name=108></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#108"><b>Deﬁning and Instantiating Structs</b></a><br/>
<a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type">Structs are similar to tuples, discussed in&#160;“The Tuple Type”&#160;section, in that both hold<br/></a>multiple related values. Like tuples, the pieces of a struct can be diﬀerent types. Unlike with<br/>tuples, in a struct you’ll name each piece of data so it’s clear what the values mean. Adding<br/>these names means that structs are more&#160;ﬂexible than tuples: you don’t have to rely on the<br/>order of the data to specify or access the values of an instance.<br/>
To deﬁne a struct, we enter the keyword&#160;&#160;struct&#160;&#160;and name the entire struct. A struct’s<br/>name should describe the signiﬁcance of the pieces of data being grouped together. Then,<br/>inside curly brackets, we deﬁne the names and types of the pieces of data, which we call<br/><i>ﬁelds</i>. For example, Listing 5-1 shows a struct that stores information about a user account.<br/>
Filename: src/main.rs<br/>
struct&#160;User&#160;{<br/>&#160;&#160;&#160;&#160;active:&#160;bool,<br/>&#160;&#160;&#160;&#160;username:&#160;String,<br/>&#160;&#160;&#160;&#160;email:&#160;String,<br/>&#160;&#160;&#160;&#160;sign_in_count:&#160;u64,<br/>}<br/>
<b>Listing&#160;5-1:&#160;A&#160;&#160;</b>User&#160;<b>&#160;struct&#160;deﬁnition</b><br/>
To use a struct after we’ve deﬁned it, we create an&#160;<i>instance</i>&#160;of that struct by specifying<br/>concrete values for each of the&#160;ﬁelds. We create an instance by stating the name of the<br/>struct and then add curly brackets containing&#160;<i>key: value</i>&#160;pairs, where the keys are the names<br/>of the&#160;ﬁelds and the values are the data we want to store in those&#160;ﬁelds. We don’t have to<br/>specify the&#160;ﬁelds in the same order in which we declared them in the struct. In other words,<br/>the struct deﬁnition is like a general template for the type, and instances&#160;ﬁll in that template<br/>with particular data to create values of the type. For example, we can declare a particular<br/>user as shown in Listing 5-2.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;user1&#160;=&#160;User&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;active:&#160;true,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;username:&#160;String::from(&#34;someusername123&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;email:&#160;String::from(&#34;someone@example.com&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sign_in_count:&#160;1,<br/>&#160;&#160;&#160;&#160;};<br/>}<br/>
<b>Listing&#160;5-2:&#160;Creating&#160;an&#160;instance&#160;of&#160;the&#160;&#160;</b>User&#160;<b>&#160;struct</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
108/627<br/>
<hr/>
<a name=109></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
To get a speciﬁc value from a struct, we use dot notation. For example, to access this user’s<br/>email address, we use&#160;&#160;user1.email&#160;. If the instance is mutable, we can change a value by<br/>using the dot notation and assigning into a particular&#160;ﬁeld. Listing 5-3 shows how to change<br/>the value in the&#160;&#160;email&#160;&#160;ﬁeld of a mutable&#160;&#160;User&#160;&#160;instance.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;user1&#160;=&#160;User&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;active:&#160;true,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;username:&#160;String::from(&#34;someusername123&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;email:&#160;String::from(&#34;someone@example.com&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sign_in_count:&#160;1,<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;user1.email&#160;=&#160;String::from(&#34;anotheremail@example.com&#34;);<br/>}<br/>
<b>Listing&#160;5-3:&#160;Changing&#160;the&#160;value&#160;in&#160;the&#160;&#160;</b>email&#160;<b>&#160;ﬁeld&#160;of&#160;a&#160;&#160;</b>User&#160;<b>&#160;instance</b><br/>
Note that the entire instance must be mutable; Rust doesn’t allow us to mark only certain<br/>ﬁelds as mutable. As with any expression, we can construct a new instance of the struct as<br/>the last expression in the function body to implicitly return that new instance.<br/>
Listing 5-4 shows a&#160;&#160;build_user&#160;&#160;function that returns a&#160;&#160;User&#160;&#160;instance with the given email<br/>and username. The&#160;&#160;active&#160;&#160;ﬁeld gets the value of&#160;&#160;true&#160;, and the&#160;&#160;sign_in_count&#160;&#160;gets a<br/>value of&#160;&#160;1&#160;.<br/>
Filename: src/main.rs<br/>
fn&#160;build_user(email:&#160;String,&#160;username:&#160;String)&#160;-&gt;&#160;User&#160;{<br/>&#160;&#160;&#160;&#160;User&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;active:&#160;true,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;username:&#160;username,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;email:&#160;email,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sign_in_count:&#160;1,<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;5-4:&#160;A&#160;&#160;</b>build_user&#160;<b>&#160;function&#160;that&#160;takes&#160;an&#160;email&#160;and&#160;username&#160;and&#160;returns&#160;a&#160;&#160;</b>User&#160;<b>&#160;instance</b><br/>
It makes sense to name the function parameters with the same name as the struct&#160;ﬁelds,<br/>but having to repeat the&#160;&#160;email&#160;&#160;and&#160;&#160;username&#160;&#160;ﬁeld names and variables is a bit tedious. If<br/>the struct had more&#160;ﬁelds, repeating each name would get even more annoying. Luckily,<br/>there’s a convenient shorthand!<br/>
https://doc.rust-lang.org/book/print.html<br/>
109/627<br/>
<hr/>
<a name=110></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#110"><b>Using&#160;the&#160;Field&#160;Init&#160;Shorthand</b></a><br/>
Because the parameter names and the struct&#160;ﬁeld names are exactly the same in Listing 5-<br/>4, we can use the&#160;<i>ﬁeld init shorthand</i>&#160;syntax to rewrite&#160;&#160;build_user&#160;&#160;so it behaves exactly the<br/>same but doesn’t have the repetition of&#160;&#160;username&#160;&#160;and&#160;&#160;email&#160;, as shown in Listing 5-5.<br/>
Filename: src/main.rs<br/>
fn&#160;build_user(email:&#160;String,&#160;username:&#160;String)&#160;-&gt;&#160;User&#160;{<br/>&#160;&#160;&#160;&#160;User&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;active:&#160;true,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;username,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;email,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sign_in_count:&#160;1,<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;5-5:&#160;A&#160;&#160;</b>build_user&#160;<b>&#160;function&#160;that&#160;uses&#160;ﬁeld&#160;init&#160;shorthand&#160;because&#160;the&#160;&#160;</b>username&#160;<b>&#160;and&#160;&#160;</b>email&#160;<b>&#160;parameters</b><br/>
<b>have&#160;the&#160;same&#160;name&#160;as&#160;struct&#160;ﬁelds</b><br/>
Here, we’re creating a new instance of the&#160;&#160;User&#160;&#160;struct, which has a&#160;ﬁeld named&#160;&#160;email&#160;. We<br/>want to set the&#160;&#160;email&#160;&#160;ﬁeld’s value to the value in the&#160;&#160;email&#160;&#160;parameter of the&#160;&#160;build_user<br/>function. Because the&#160;&#160;email&#160;&#160;ﬁeld and the&#160;&#160;email&#160;&#160;parameter have the same name, we only<br/>need to write&#160;&#160;email&#160;&#160;rather than&#160;&#160;email:&#160;email&#160;.<br/>
<a href="tests.html#110"><b>Creating&#160;Instances&#160;from&#160;Other&#160;Instances&#160;with&#160;Struct&#160;Update&#160;Syntax</b></a><br/>
It’s often useful to create a new instance of a struct that includes most of the values from<br/>another instance, but changes some. You can do this using&#160;<i>struct update syntax</i>.<br/>
First, in Listing 5-6 we show how to create a new&#160;&#160;User&#160;&#160;instance in&#160;&#160;user2&#160;&#160;regularly, without<br/>the update syntax. We set a new value for&#160;&#160;email&#160;&#160;but otherwise use the same values from<br/>
user1&#160;&#160;that we created in Listing 5-2.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;let&#160;user2&#160;=&#160;User&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;active:&#160;user1.active,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;username:&#160;user1.username,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;email:&#160;String::from(&#34;another@example.com&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sign_in_count:&#160;user1.sign_in_count,<br/>&#160;&#160;&#160;&#160;};<br/>}<br/>
<b>Listing&#160;5-6:&#160;Creating&#160;a&#160;new&#160;&#160;</b>User&#160;<b>&#160;instance&#160;using&#160;one&#160;of&#160;the&#160;values&#160;from&#160;&#160;</b>user1<br/>
https://doc.rust-lang.org/book/print.html<br/>
110/627<br/>
<hr/>
<a name=111></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Using struct update syntax, we can achieve the same eﬀect with less code, as shown in<br/>Listing 5-7. The syntax&#160;&#160;..&#160;&#160;speciﬁes that the remaining&#160;ﬁelds not explicitly set should have<br/>the same value as the&#160;ﬁelds in the given instance.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;let&#160;user2&#160;=&#160;User&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;email:&#160;String::from(&#34;another@example.com&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;..user1<br/>&#160;&#160;&#160;&#160;};<br/>}<br/>
<b>Listing&#160;5-7:&#160;Using&#160;struct&#160;update&#160;syntax&#160;to&#160;set&#160;a&#160;new&#160;&#160;</b>email&#160;<b>&#160;value&#160;for&#160;a&#160;&#160;</b>User&#160;<b>&#160;instance&#160;but&#160;to&#160;use&#160;the&#160;rest&#160;of&#160;the<br/>values&#160;from&#160;&#160;</b>user1<br/>
The code in Listing 5-7 also creates an instance in&#160;&#160;user2&#160;&#160;that has a diﬀerent value for<br/>
email&#160;&#160;but has the same values for the&#160;&#160;username&#160;,&#160;&#160;active&#160;, and&#160;&#160;sign_in_count&#160;&#160;ﬁelds from<br/>user1&#160;. The&#160;&#160;..user1&#160;&#160;must come last to specify that any remaining&#160;ﬁelds should get their<br/>
values from the corresponding&#160;ﬁelds in&#160;&#160;user1&#160;, but we can choose to specify values for as<br/>many&#160;ﬁelds as we want in any order, regardless of the order of the&#160;ﬁelds in the struct’s<br/>deﬁnition.<br/>
Note that the struct update syntax uses&#160;&#160;=&#160;&#160;like an assignment; this is because it moves the<br/>data, just as we saw in the&#160;<a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variables-and-data-interacting-with-move">“Variables and Data Interacting with Move”</a>&#160;section. In this<br/>example, we can no longer use&#160;&#160;user1&#160;&#160;as a whole after creating&#160;&#160;user2&#160;&#160;because the&#160;&#160;String<br/>in the&#160;&#160;username&#160;&#160;ﬁeld of&#160;&#160;user1&#160;&#160;was moved into&#160;&#160;user2&#160;. If we had given&#160;&#160;user2&#160;&#160;new&#160;&#160;String<br/>values for both&#160;&#160;email&#160;&#160;and&#160;&#160;username&#160;, and thus only used the&#160;&#160;active&#160;&#160;and&#160;&#160;sign_in_count<br/>values from&#160;&#160;user1&#160;, then&#160;&#160;user1&#160;&#160;would still be valid after creating&#160;&#160;user2&#160;. Both&#160;&#160;active&#160;&#160;and<br/>
sign_in_count&#160;&#160;are types that implement the&#160;&#160;Copy&#160;&#160;trait, so the behavior we discussed in<br/>
the&#160;<a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#stack-only-data-copy">“Stack-Only Data: Copy”&#160;section would apply.</a><br/>
<a href="tests.html#111"><b>Using&#160;Tuple&#160;Structs&#160;Without&#160;Named&#160;Fields&#160;to&#160;Create&#160;Diﬀerent&#160;Types</b></a><br/>
Rust also supports structs that look similar to tuples, called&#160;<i>tuple structs</i>. Tuple structs have<br/>the added meaning the struct name provides but don’t have names associated with their<br/>ﬁelds; rather, they just have the types of the&#160;ﬁelds. Tuple structs are useful when you want<br/>to give the whole tuple a name and make the tuple a diﬀerent type from other tuples, and<br/>when naming each&#160;ﬁeld as in a regular struct would be verbose or redundant.<br/>
To deﬁne a tuple struct, start with the&#160;&#160;struct&#160;&#160;keyword and the struct name followed by the<br/>types in the tuple. For example, here we deﬁne and use two tuple structs named&#160;&#160;Color&#160;&#160;and<br/>
Point&#160;:<br/>
https://doc.rust-lang.org/book/print.html<br/>
111/627<br/>
<hr/>
<a name=112></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Filename: src/main.rs<br/>
struct&#160;Color(i32,&#160;i32,&#160;i32);<br/>struct&#160;Point(i32,&#160;i32,&#160;i32);<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;black&#160;=&#160;Color(0,&#160;0,&#160;0);<br/>&#160;&#160;&#160;&#160;let&#160;origin&#160;=&#160;Point(0,&#160;0,&#160;0);<br/>}<br/>
Note that the&#160;&#160;black&#160;&#160;and&#160;&#160;origin&#160;&#160;values are diﬀerent types because they’re instances of<br/>diﬀerent tuple structs. Each struct you deﬁne is its own type, even though the&#160;ﬁelds within<br/>the struct might have the same types. For example, a function that takes a parameter of<br/>type&#160;&#160;Color&#160;&#160;cannot take a&#160;&#160;Point&#160;&#160;as an argument, even though both types are made up of<br/>three&#160;&#160;i32&#160;&#160;values. Otherwise, tuple struct instances are similar to tuples in that you can<br/>destructure them into their individual pieces, and you can use a&#160;&#160;.&#160;&#160;followed by the index to<br/>access an individual value.<br/>
<a href="tests.html#112"><b>Unit-Like&#160;Structs&#160;Without&#160;Any&#160;Fields</b></a><br/>
You can also deﬁne structs that don’t have any&#160;ﬁelds! These are called&#160;<i>unit-like structs<br/></i>because they behave similarly to&#160;&#160;()&#160;, the unit type that we mentioned in&#160;<a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type">“The Tuple Type”<br/></a>section. Unit-like structs can be useful when you need to implement a trait on some type<br/>but don’t have any data that you want to store in the type itself. We’ll discuss traits in<br/>Chapter 10. Here’s an example of declaring and instantiating a unit struct named<br/>
AlwaysEqual&#160;:<br/>
Filename: src/main.rs<br/>
struct&#160;AlwaysEqual;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;subject&#160;=&#160;AlwaysEqual;<br/>}<br/>
To deﬁne&#160;&#160;AlwaysEqual&#160;, we use the&#160;&#160;struct&#160;&#160;keyword, the name we want, and then a<br/>semicolon. No need for curly brackets or parentheses! Then we can get an instance of<br/>
AlwaysEqual&#160;&#160;in the&#160;&#160;subject&#160;&#160;variable in a similar way: using the name we deﬁned, without<br/>
any curly brackets or parentheses. Imagine that later we’ll implement behavior for this type<br/>such that every instance of&#160;&#160;AlwaysEqual&#160;&#160;is always equal to every instance of any other type,<br/>perhaps to have a known result for testing purposes. We wouldn’t need any data to<br/>implement that behavior! You’ll see in Chapter 10 how to deﬁne traits and implement them<br/>on any type, including unit-like structs.<br/>
https://doc.rust-lang.org/book/print.html<br/>
112/627<br/>
<hr/>
<a name=113></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#113"><b>Ownership&#160;of&#160;Struct&#160;Data</b></a><br/>
In the&#160;&#160;User&#160;&#160;struct deﬁnition in Listing 5-1, we used the owned&#160;&#160;String&#160;&#160;type rather<br/>than the&#160;&#160;&amp;str&#160;&#160;string slice type. This is a deliberate choice because we want each<br/>instance of this struct to own all of its data and for that data to be valid for as long as<br/>the entire struct is valid.<br/>
It’s also possible for structs to store references to data owned by something else, but<br/>to do so requires the use of&#160;<i>lifetimes</i>, a Rust feature that we’ll discuss in Chapter 10.<br/>Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is.<br/>Let’s say you try to store a reference in a struct without specifying lifetimes, like the<br/>following; this won’t work:<br/>
Filename: src/main.rs<br/>
struct&#160;User&#160;{<br/>&#160;&#160;&#160;&#160;active:&#160;bool,<br/>&#160;&#160;&#160;&#160;username:&#160;&amp;str,<br/>&#160;&#160;&#160;&#160;email:&#160;&amp;str,<br/>&#160;&#160;&#160;&#160;sign_in_count:&#160;u64,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;user1&#160;=&#160;User&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;active:&#160;true,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;username:&#160;&#34;someusername123&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;email:&#160;&#34;someone@example.com&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sign_in_count:&#160;1,<br/>&#160;&#160;&#160;&#160;};<br/>}<br/>
The compiler will complain that it needs lifetime speciﬁers:<br/>
https://doc.rust-lang.org/book/print.html<br/>
113/627<br/>
<hr/>
<a name=114></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;structs&#160;v0.1.0&#160;(file:///projects/structs)<br/>error[E0106]:&#160;missing&#160;lifetime&#160;specifier<br/>&#160;--&gt;&#160;src/main.rs:3:15<br/>&#160;&#160;|<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;username:&#160;&amp;str,<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^&#160;expected&#160;named&#160;lifetime&#160;parameter<br/>&#160;&#160;|<br/>help:&#160;consider&#160;introducing&#160;a&#160;named&#160;lifetime&#160;parameter<br/>&#160;&#160;|<br/>1&#160;~&#160;struct&#160;User&lt;'a&gt;&#160;{<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;active:&#160;bool,<br/>3&#160;~&#160;&#160;&#160;&#160;&#160;username:&#160;&amp;'a&#160;str,<br/>&#160;&#160;|<br/>
error[E0106]:&#160;missing&#160;lifetime&#160;specifier<br/>&#160;--&gt;&#160;src/main.rs:4:12<br/>&#160;&#160;|<br/>4&#160;|&#160;&#160;&#160;&#160;&#160;email:&#160;&amp;str,<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^&#160;expected&#160;named&#160;lifetime&#160;parameter<br/>&#160;&#160;|<br/>help:&#160;consider&#160;introducing&#160;a&#160;named&#160;lifetime&#160;parameter<br/>&#160;&#160;|<br/>1&#160;~&#160;struct&#160;User&lt;'a&gt;&#160;{<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;active:&#160;bool,<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;username:&#160;&amp;str,<br/>4&#160;~&#160;&#160;&#160;&#160;&#160;email:&#160;&amp;'a&#160;str,<br/>&#160;&#160;|<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0106`.<br/>error:&#160;could&#160;not&#160;compile&#160;`structs`&#160;due&#160;to&#160;2&#160;previous&#160;errors<br/>
In Chapter 10, we’ll discuss how to&#160;ﬁx these errors so you can store references in<br/>structs, but for now, we’ll&#160;ﬁx errors like these using owned types like&#160;&#160;String&#160;&#160;instead<br/>of references like&#160;&#160;&amp;str&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
114/627<br/>
<hr/>
<a name=115></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#115"><b>An Example Program Using Structs</b></a><br/>
To understand when we might want to use structs, let’s write a program that calculates the<br/>area of a rectangle. We’ll start by using single variables, and then refactor the program until<br/>we’re using structs instead.<br/>
Let’s make a new binary project with Cargo called&#160;<i>rectangles</i>&#160;that will take the width and<br/>height of a rectangle speciﬁed in pixels and calculate the area of the rectangle. Listing 5-8<br/>shows a short program with one way of doing exactly that in our project’s&#160;<i>src/main.rs</i>.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;width1&#160;=&#160;30;<br/>&#160;&#160;&#160;&#160;let&#160;height1&#160;=&#160;50;<br/>
&#160;&#160;&#160;&#160;println!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;The&#160;area&#160;of&#160;the&#160;rectangle&#160;is&#160;{}&#160;square&#160;pixels.&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;area(width1,&#160;height1)<br/>&#160;&#160;&#160;&#160;);<br/>}<br/>
fn&#160;area(width:&#160;u32,&#160;height:&#160;u32)&#160;-&gt;&#160;u32&#160;{<br/>&#160;&#160;&#160;&#160;width&#160;*&#160;height<br/>}<br/>
<b>Listing&#160;5-8:&#160;Calculating&#160;the&#160;area&#160;of&#160;a&#160;rectangle&#160;speciﬁed&#160;by&#160;separate&#160;width&#160;and&#160;height&#160;variables</b><br/>
Now, run this program using&#160;&#160;cargo&#160;run&#160;:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;rectangles&#160;v0.1.0&#160;(file:///projects/rectangles)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.42s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/rectangles`<br/>The&#160;area&#160;of&#160;the&#160;rectangle&#160;is&#160;1500&#160;square&#160;pixels.<br/>
This code succeeds in&#160;ﬁguring out the area of the rectangle by calling the&#160;&#160;area&#160;&#160;function<br/>with each dimension, but we can do more to make this code clear and readable.<br/>
The issue with this code is evident in the signature of&#160;&#160;area&#160;:<br/>
fn&#160;area(width:&#160;u32,&#160;height:&#160;u32)&#160;-&gt;&#160;u32&#160;{<br/>
The&#160;&#160;area&#160;&#160;function is supposed to calculate the area of one rectangle, but the function we<br/>wrote has two parameters, and it’s not clear anywhere in our program that the parameters<br/>are related. It would be more readable and more manageable to group width and height<br/>
https://doc.rust-lang.org/book/print.html<br/>
115/627<br/>
<hr/>
<a name=116></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
together. We’ve already discussed one way we might do that in&#160;<a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type">“The Tuple Type”</a>&#160;section of<br/>Chapter 3: by using tuples.<br/>
<a href="tests.html#116"><b>Refactoring&#160;with&#160;Tuples</b></a><br/>
Listing 5-9 shows another version of our program that uses tuples.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;rect1&#160;=&#160;(30,&#160;50);<br/>
&#160;&#160;&#160;&#160;println!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;The&#160;area&#160;of&#160;the&#160;rectangle&#160;is&#160;{}&#160;square&#160;pixels.&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;area(rect1)<br/>&#160;&#160;&#160;&#160;);<br/>}<br/>
fn&#160;area(dimensions:&#160;(u32,&#160;u32))&#160;-&gt;&#160;u32&#160;{<br/>&#160;&#160;&#160;&#160;dimensions.0&#160;*&#160;dimensions.1<br/>}<br/>
<b>Listing&#160;5-9:&#160;Specifying&#160;the&#160;width&#160;and&#160;height&#160;of&#160;the&#160;rectangle&#160;with&#160;a&#160;tuple</b><br/>
In one way, this program is better. Tuples let us add a bit of structure, and we’re now<br/>passing just one argument. But in another way, this version is less clear: tuples don’t name<br/>their elements, so we have to index into the parts of the tuple, making our calculation less<br/>obvious.<br/>
Mixing up the width and height wouldn’t matter for the area calculation, but if we want to<br/>draw the rectangle on the screen, it would matter! We would have to keep in mind that<br/>
width&#160;&#160;is the tuple index&#160;&#160;0&#160;&#160;and&#160;&#160;height&#160;&#160;is the tuple index&#160;&#160;1&#160;. This would be even harder for<br/>
someone else to&#160;ﬁgure out and keep in mind if they were to use our code. Because we<br/>haven’t conveyed the meaning of our data in our code, it’s now easier to introduce errors.<br/>
<a href="tests.html#116"><b>Refactoring&#160;with&#160;Structs:&#160;Adding&#160;More&#160;Meaning</b></a><br/>
We use structs to add meaning by labeling the data. We can transform the tuple we’re using<br/>into a struct with a name for the whole as well as names for the parts, as shown in Listing 5-<br/>10.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
116/627<br/>
<hr/>
<a name=117></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
struct&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;width:&#160;u32,<br/>&#160;&#160;&#160;&#160;height:&#160;u32,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;rect1&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;30,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;50,<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;println!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;The&#160;area&#160;of&#160;the&#160;rectangle&#160;is&#160;{}&#160;square&#160;pixels.&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;area(&amp;rect1)<br/>&#160;&#160;&#160;&#160;);<br/>}<br/>
fn&#160;area(rectangle:&#160;&amp;Rectangle)&#160;-&gt;&#160;u32&#160;{<br/>&#160;&#160;&#160;&#160;rectangle.width&#160;*&#160;rectangle.height<br/>}<br/>
<b>Listing&#160;5-10:&#160;Deﬁning&#160;a&#160;&#160;</b>Rectangle&#160;<b>&#160;struct</b><br/>
Here we’ve deﬁned a struct and named it&#160;&#160;Rectangle&#160;. Inside the curly brackets, we deﬁned<br/>the&#160;ﬁelds as&#160;&#160;width&#160;&#160;and&#160;&#160;height&#160;, both of which have type&#160;&#160;u32&#160;. Then, in&#160;&#160;main&#160;, we created a<br/>particular instance of&#160;&#160;Rectangle&#160;&#160;that has a width of&#160;&#160;30&#160;&#160;and a height of&#160;&#160;50&#160;.<br/>
Our&#160;&#160;area&#160;&#160;function is now deﬁned with one parameter, which we’ve named&#160;&#160;rectangle&#160;,<br/>whose type is an immutable borrow of a struct&#160;&#160;Rectangle&#160;&#160;instance. As mentioned in<br/>Chapter 4, we want to borrow the struct rather than take ownership of it. This way,&#160;&#160;main<br/>retains its ownership and can continue using&#160;&#160;rect1&#160;, which is the reason we use the&#160;&#160;&amp;&#160;&#160;in<br/>the function signature and where we call the function.<br/>
The&#160;&#160;area&#160;&#160;function accesses the&#160;&#160;width&#160;&#160;and&#160;&#160;height&#160;&#160;ﬁelds of the&#160;&#160;Rectangle&#160;&#160;instance (note<br/>that accessing&#160;ﬁelds of a borrowed struct instance does not move the&#160;ﬁeld values, which is<br/>why you often see borrows of structs). Our function signature for&#160;&#160;area&#160;&#160;now says exactly<br/>what we mean: calculate the area of&#160;&#160;Rectangle&#160;, using its&#160;&#160;width&#160;&#160;and&#160;&#160;height&#160;&#160;ﬁelds. This<br/>conveys that the width and height are related to each other, and it gives descriptive names<br/>to the values rather than using the tuple index values of&#160;&#160;0&#160;&#160;and&#160;&#160;1&#160;. This is a win for clarity.<br/>
<a href="tests.html#117"><b>Adding&#160;Useful&#160;Functionality&#160;with&#160;Derived&#160;Traits</b></a><br/>
It’d be useful to be able to print an instance of&#160;&#160;Rectangle&#160;&#160;while we’re debugging our<br/>program and see the values for all its&#160;ﬁelds. Listing 5-11 tries using the&#160;&#160;<a href="https://doc.rust-lang.org/std/macro.println.html">println!&#160;&#160;macro&#160;as<br/></a>we have used in previous chapters. This won’t work, however.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
117/627<br/>
<hr/>
<a name=118></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
struct&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;width:&#160;u32,<br/>&#160;&#160;&#160;&#160;height:&#160;u32,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;rect1&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;30,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;50,<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;println!(&#34;rect1&#160;is&#160;{}&#34;,&#160;rect1);<br/>}<br/>
<b>Listing&#160;5-11:&#160;Attempting&#160;to&#160;print&#160;a&#160;&#160;</b>Rectangle&#160;<b>&#160;instance</b><br/>
When we compile this code, we get an error with this core message:<br/>
error[E0277]:&#160;`Rectangle`&#160;doesn't&#160;implement&#160;`std::fmt::Display`<br/>
The&#160;&#160;println!&#160;&#160;macro can do many kinds of formatting, and by default, the curly brackets<br/>tell&#160;&#160;println!&#160;&#160;to use formatting known as&#160;&#160;Display&#160;: output intended for direct end user<br/>consumption. The primitive types we’ve seen so far implement&#160;&#160;Display&#160;&#160;by default because<br/>there’s only one way you’d want to show a&#160;&#160;1&#160;&#160;or any other primitive type to a user. But with<br/>structs, the way&#160;&#160;println!&#160;&#160;should format the output is less clear because there are more<br/>display possibilities: Do you want commas or not? Do you want to print the curly brackets?<br/>Should all the&#160;ﬁelds be shown? Due to this ambiguity, Rust doesn’t try to guess what we<br/>want, and structs don’t have a provided implementation of&#160;&#160;Display&#160;&#160;to use with&#160;&#160;println!<br/>and the&#160;&#160;{}&#160;&#160;placeholder.<br/>
If we continue reading the errors, we’ll&#160;ﬁnd this helpful note:<br/>
&#160;&#160;&#160;=&#160;help:&#160;the&#160;trait&#160;`std::fmt::Display`&#160;is&#160;not&#160;implemented&#160;for&#160;`Rectangle`<br/>&#160;&#160;&#160;=&#160;note:&#160;in&#160;format&#160;strings&#160;you&#160;may&#160;be&#160;able&#160;to&#160;use&#160;`{:?}`&#160;(or&#160;{:#?}&#160;for&#160;<br/>pretty-print)&#160;instead<br/>
Let’s try it! The&#160;&#160;println!&#160;&#160;macro call will now look like&#160;&#160;println!(&#34;rect1&#160;is&#160;{:?}&#34;,&#160;<br/>rect1);&#160;. Putting the speciﬁer&#160;&#160;:?&#160;&#160;inside the curly brackets tells&#160;&#160;println!&#160;&#160;we want to use<br/>an output format called&#160;&#160;Debug&#160;. The&#160;&#160;Debug&#160;&#160;trait enables us to print our struct in a way that<br/>is useful for developers so we can see its value while we’re debugging our code.<br/>
Compile the code with this change. Drat! We still get an error:<br/>
error[E0277]:&#160;`Rectangle`&#160;doesn't&#160;implement&#160;`Debug`<br/>
But again, the compiler gives us a helpful note:<br/>
https://doc.rust-lang.org/book/print.html<br/>
118/627<br/>
<hr/>
<a name=119></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;=&#160;help:&#160;the&#160;trait&#160;`Debug`&#160;is&#160;not&#160;implemented&#160;for&#160;`Rectangle`<br/>&#160;&#160;&#160;=&#160;note:&#160;add&#160;`#[derive(Debug)]`&#160;to&#160;`Rectangle`&#160;or&#160;manually&#160;`impl&#160;Debug&#160;for&#160;<br/>Rectangle`<br/>
Rust&#160;<i>does</i>&#160;include functionality to print out debugging information, but we have to explicitly<br/>opt in to make that functionality available for our struct. To do that, we add the outer<br/>attribute&#160;&#160;#[derive(Debug)]&#160;&#160;just before the struct deﬁnition, as shown in Listing 5-12.<br/>
Filename: src/main.rs<br/>
#[derive(Debug)]<br/>struct&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;width:&#160;u32,<br/>&#160;&#160;&#160;&#160;height:&#160;u32,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;rect1&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;30,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;50,<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;println!(&#34;rect1&#160;is&#160;{:?}&#34;,&#160;rect1);<br/>}<br/>
<b>Listing&#160;5-12:&#160;Adding&#160;the&#160;attribute&#160;to&#160;derive&#160;the&#160;&#160;</b>Debug&#160;<b>&#160;trait&#160;and&#160;printing&#160;the&#160;&#160;</b>Rectangle&#160;<b>&#160;instance&#160;using&#160;debug<br/>formatting</b><br/>
Now when we run the program, we won’t get any errors, and we’ll see the following output:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;rectangles&#160;v0.1.0&#160;(file:///projects/rectangles)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.48s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/rectangles`<br/>rect1&#160;is&#160;Rectangle&#160;{&#160;width:&#160;30,&#160;height:&#160;50&#160;}<br/>
Nice! It’s not the prettiest output, but it shows the values of all the&#160;ﬁelds for this instance,<br/>which would deﬁnitely help during debugging. When we have larger structs, it’s useful to<br/>have output that’s a bit easier to read; in those cases, we can use&#160;&#160;{:#?}&#160;&#160;instead of&#160;&#160;{:?}&#160;&#160;in<br/>the&#160;&#160;println!&#160;&#160;string. In this example, using the&#160;&#160;{:#?}&#160;&#160;style will output the following:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;rectangles&#160;v0.1.0&#160;(file:///projects/rectangles)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.48s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/rectangles`<br/>rect1&#160;is&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;width:&#160;30,<br/>&#160;&#160;&#160;&#160;height:&#160;50,<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
119/627<br/>
<hr/>
<a name=120></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Another way to print out a value using the&#160;&#160;Debug&#160;&#160;format is to use the&#160;&#160;<a href="https://doc.rust-lang.org/std/macro.dbg.html">dbg!&#160;&#160;macro, which<br/></a>takes ownership of an expression (as opposed to&#160;&#160;println!&#160;, which takes a reference), prints<br/>the&#160;ﬁle and line number of where that&#160;&#160;dbg!&#160;&#160;macro call occurs in your code along with the<br/>resultant value of that expression, and returns ownership of the value.<br/>
Note: Calling the&#160;&#160;dbg!&#160;&#160;macro prints to the standard error console stream (&#160;stderr&#160;), as<br/>opposed to&#160;&#160;println!&#160;, which prints to the standard output console stream (&#160;stdout&#160;).<br/><a href="https://doc.rust-lang.org/book/ch12-06-writing-to-stderr-instead-of-stdout.html">We’ll talk more about&#160;&#160;stderr&#160;&#160;and&#160;&#160;stdout&#160;&#160;in the&#160;“Writing Error Messages to Standard<br/>Error Instead of Standard Output” section in Chapter 12.</a><br/>
Here’s an example where we’re interested in the value that gets assigned to the&#160;&#160;width&#160;&#160;ﬁeld,<br/>as well as the value of the whole struct in&#160;&#160;rect1&#160;:<br/>
#[derive(Debug)]<br/>struct&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;width:&#160;u32,<br/>&#160;&#160;&#160;&#160;height:&#160;u32,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;scale&#160;=&#160;2;<br/>&#160;&#160;&#160;&#160;let&#160;rect1&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;dbg!(30&#160;*&#160;scale),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;50,<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;dbg!(&amp;rect1);<br/>}<br/>
We can put&#160;&#160;dbg!&#160;&#160;around the expression&#160;&#160;30&#160;*&#160;scale&#160;&#160;and, because&#160;&#160;dbg!&#160;&#160;returns<br/>ownership of the expression’s value, the&#160;&#160;width&#160;&#160;ﬁeld will get the same value as if we didn’t<br/>have the&#160;&#160;dbg!&#160;&#160;call there. We don’t want&#160;&#160;dbg!&#160;&#160;to take ownership of&#160;&#160;rect1&#160;, so we use a<br/>reference to&#160;&#160;rect1&#160;&#160;in the next call. Here’s what the output of this example looks like:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;rectangles&#160;v0.1.0&#160;(file:///projects/rectangles)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.61s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/rectangles`<br/>[src/main.rs:10]&#160;30&#160;*&#160;scale&#160;=&#160;60<br/>[src/main.rs:14]&#160;&amp;rect1&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;width:&#160;60,<br/>&#160;&#160;&#160;&#160;height:&#160;50,<br/>}<br/>
We can see the&#160;ﬁrst bit of output came from&#160;<i>src/main.rs</i>&#160;line 10 where we’re debugging the<br/>expression&#160;&#160;30&#160;*&#160;scale&#160;, and its resultant value is&#160;&#160;60&#160;&#160;(the&#160;&#160;Debug&#160;&#160;formatting implemented<br/>for integers is to print only their value). The&#160;&#160;dbg!&#160;&#160;call on line 14 of&#160;<i>src/main.rs</i>&#160;outputs the<br/>value of&#160;&#160;&amp;rect1&#160;, which is the&#160;&#160;Rectangle&#160;&#160;struct. This output uses the pretty&#160;&#160;Debug<br/>
https://doc.rust-lang.org/book/print.html<br/>
120/627<br/>
<hr/>
<a name=121></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
formatting of the&#160;&#160;Rectangle&#160;&#160;type. The&#160;&#160;dbg!&#160;&#160;macro can be really helpful when you’re trying<br/>to&#160;ﬁgure out what your code is doing!<br/>
In addition to the&#160;&#160;Debug&#160;&#160;trait, Rust has provided a number of traits for us to use with the<br/>
derive&#160;&#160;attribute that can add useful behavior to our custom types. Those traits and their<br/>
<a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">behaviors are listed in&#160;Appendix C</a>. We’ll cover how to implement these traits with custom<br/>behavior as well as how to create your own traits in Chapter 10. There are also many<br/><a href="https://doc.rust-lang.org/reference/attributes.html">attributes other than&#160;&#160;derive&#160;; for more information, see&#160;the “Attributes” section of the Rust<br/>Reference.</a><br/>
Our&#160;&#160;area&#160;&#160;function is very speciﬁc: it only computes the area of rectangles. It would be<br/>helpful to tie this behavior more closely to our&#160;&#160;Rectangle&#160;&#160;struct because it won’t work with<br/>any other type. Let’s look at how we can continue to refactor this code by turning the&#160;&#160;area<br/>function into an&#160;&#160;area&#160;&#160;<i>method</i>&#160;deﬁned on our&#160;&#160;Rectangle&#160;&#160;type.<br/>
https://doc.rust-lang.org/book/print.html<br/>
121/627<br/>
<hr/>
<a name=122></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#122"><b>Method Syntax</b></a><br/>
<i>Methods</i>&#160;are similar to functions: we declare them with the&#160;&#160;fn&#160;&#160;keyword and a name, they<br/>can have parameters and a return value, and they contain some code that’s run when the<br/>method is called from somewhere else. Unlike functions, methods are deﬁned within the<br/><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">context of a struct (or an enum or a trait object, which we cover in&#160;</a><a href="https://doc.rust-lang.org/book/ch06-00-enums.html">Chapter 6&#160;and&#160;</a><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">Chapter<br/>17, respectively), and their&#160;ﬁrst parameter is always&#160;&#160;self&#160;, which represents the instance of<br/></a>the struct the method is being called on.<br/>
<a href="tests.html#122"><b>Deﬁning&#160;Methods</b></a><br/>
Let’s change the&#160;&#160;area&#160;&#160;function that has a&#160;&#160;Rectangle&#160;&#160;instance as a parameter and instead<br/>make an&#160;&#160;area&#160;&#160;method deﬁned on the&#160;&#160;Rectangle&#160;&#160;struct, as shown in Listing 5-13.<br/>
Filename: src/main.rs<br/>
#[derive(Debug)]<br/>struct&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;width:&#160;u32,<br/>&#160;&#160;&#160;&#160;height:&#160;u32,<br/>}<br/>
impl&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;area(&amp;self)&#160;-&gt;&#160;u32&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.width&#160;*&#160;self.height<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;rect1&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;30,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;50,<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;println!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;The&#160;area&#160;of&#160;the&#160;rectangle&#160;is&#160;{}&#160;square&#160;pixels.&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rect1.area()<br/>&#160;&#160;&#160;&#160;);<br/>}<br/>
<b>Listing&#160;5-13:&#160;Deﬁning&#160;an&#160;&#160;</b>area&#160;<b>&#160;method&#160;on&#160;the&#160;&#160;</b>Rectangle&#160;<b>&#160;struct</b><br/>
To deﬁne the function within the context of&#160;&#160;Rectangle&#160;, we start an&#160;&#160;impl&#160;&#160;(implementation)<br/>block for&#160;&#160;Rectangle&#160;. Everything within this&#160;&#160;impl&#160;&#160;block will be associated with the<br/>
Rectangle&#160;&#160;type. Then we move the&#160;&#160;area&#160;&#160;function within the&#160;&#160;impl&#160;&#160;curly brackets and<br/>
change the&#160;ﬁrst (and in this case, only) parameter to be&#160;&#160;self&#160;&#160;in the signature and<br/>
https://doc.rust-lang.org/book/print.html<br/>
122/627<br/>
<hr/>
<a name=123></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
everywhere within the body. In&#160;&#160;main&#160;, where we called the&#160;&#160;area&#160;&#160;function and passed<br/>
rect1&#160;&#160;as an argument, we can instead use&#160;<i>method syntax</i>&#160;to call the&#160;&#160;area&#160;&#160;method on our<br/>Rectangle&#160;&#160;instance. The method syntax goes after an instance: we add a dot followed by<br/>
the method name, parentheses, and any arguments.<br/>
In the signature for&#160;&#160;area&#160;, we use&#160;&#160;&amp;self&#160;&#160;instead of&#160;&#160;rectangle:&#160;&amp;Rectangle&#160;. The&#160;&#160;&amp;self&#160;&#160;is<br/>actually short for&#160;&#160;self:&#160;&amp;Self&#160;. Within an&#160;&#160;impl&#160;&#160;block, the type&#160;&#160;Self&#160;&#160;is an alias for the type<br/>that the&#160;&#160;impl&#160;&#160;block is for. Methods must have a parameter named&#160;&#160;self&#160;&#160;of type&#160;&#160;Self&#160;&#160;for<br/>their&#160;ﬁrst parameter, so Rust lets you abbreviate this with only the name&#160;&#160;self&#160;&#160;in the&#160;ﬁrst<br/>parameter spot. Note that we still need to use the&#160;&#160;&amp;&#160;&#160;in front of the&#160;&#160;self&#160;&#160;shorthand to<br/>indicate that this method borrows the&#160;&#160;Self&#160;&#160;instance, just as we did in&#160;&#160;rectangle:&#160;<br/>&amp;Rectangle&#160;. Methods can take ownership of&#160;&#160;self&#160;, borrow&#160;&#160;self&#160;&#160;immutably, as we’ve done<br/>here, or borrow&#160;&#160;self&#160;&#160;mutably, just as they can any other parameter.<br/>
We chose&#160;&#160;&amp;self&#160;&#160;here for the same reason we used&#160;&#160;&amp;Rectangle&#160;&#160;in the function version: we<br/>don’t want to take ownership, and we just want to read the data in the struct, not write to it.<br/>If we wanted to change the instance that we’ve called the method on as part of what the<br/>method does, we’d use&#160;&#160;&amp;mut&#160;self&#160;&#160;as the&#160;ﬁrst parameter. Having a method that takes<br/>ownership of the instance by using just&#160;&#160;self&#160;&#160;as the&#160;ﬁrst parameter is rare; this technique is<br/>usually used when the method transforms&#160;&#160;self&#160;&#160;into something else and you want to<br/>prevent the caller from using the original instance after the transformation.<br/>
The main reason for using methods instead of functions, in addition to providing method<br/>syntax and not having to repeat the type of&#160;&#160;self&#160;&#160;in every method’s signature, is for<br/>organization. We’ve put all the things we can do with an instance of a type in one&#160;&#160;impl<br/>block rather than making future users of our code search for capabilities of&#160;&#160;Rectangle&#160;&#160;in<br/>various places in the library we provide.<br/>
Note that we can choose to give a method the same name as one of the struct’s&#160;ﬁelds. For<br/>example, we can deﬁne a method on&#160;&#160;Rectangle&#160;&#160;that is also named&#160;&#160;width&#160;:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
123/627<br/>
<hr/>
<a name=124></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
impl&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;width(&amp;self)&#160;-&gt;&#160;bool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.width&#160;&gt;&#160;0<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;rect1&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;30,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;50,<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;if&#160;rect1.width()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;The&#160;rectangle&#160;has&#160;a&#160;nonzero&#160;width;&#160;it&#160;is&#160;{}&#34;,&#160;rect1.width);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
Here, we’re choosing to make the&#160;&#160;width&#160;&#160;method return&#160;&#160;true&#160;&#160;if the value in the instance’s<br/>
width&#160;&#160;ﬁeld is greater than&#160;&#160;0&#160;&#160;and&#160;&#160;false&#160;&#160;if the value is&#160;&#160;0&#160;: we can use a&#160;ﬁeld within a<br/>
method of the same name for any purpose. In&#160;&#160;main&#160;, when we follow&#160;&#160;rect1.width&#160;&#160;with<br/>parentheses, Rust knows we mean the method&#160;&#160;width&#160;. When we don’t use parentheses,<br/>Rust knows we mean the&#160;ﬁeld&#160;&#160;width&#160;.<br/>
Often, but not always, when we give a method the same name as a&#160;ﬁeld we want it to only<br/>return the value in the&#160;ﬁeld and do nothing else. Methods like this are called&#160;<i>getters</i>, and<br/>Rust does not implement them automatically for struct&#160;ﬁelds as some other languages do.<br/>Getters are useful because you can make the&#160;ﬁeld private but the method public, and thus<br/>enable read-only access to that&#160;ﬁeld as part of the type’s public API. We will discuss what<br/>public and private are and how to designate a&#160;ﬁeld or method as public or private in<br/><a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">Chapter 7.</a><br/>
<a href="tests.html#124"><b>Where’s&#160;the&#160;</b>-&gt;<b>&#160;Operator?</b></a><br/>
In C and C++, two diﬀerent operators are used for calling methods: you use&#160;&#160;.&#160;&#160;if you’re<br/>calling a method on the object directly and&#160;&#160;-&gt;&#160;&#160;if you’re calling the method on a<br/>pointer to the object and need to dereference the pointer&#160;ﬁrst. In other words, if<br/>
object&#160;&#160;is a pointer,&#160;&#160;object-&gt;something()&#160;&#160;is similar to&#160;&#160;(*object).something()&#160;.<br/>
Rust doesn’t have an equivalent to the&#160;&#160;-&gt;&#160;&#160;operator; instead, Rust has a feature called<br/><i>automatic referencing and dereferencing</i>. Calling methods is one of the few places in<br/>Rust that has this behavior.<br/>
Here’s how it works: when you call a method with&#160;&#160;object.something()&#160;, Rust<br/>automatically adds in&#160;&#160;&amp;&#160;,&#160;&#160;&amp;mut&#160;, or&#160;&#160;*&#160;&#160;so&#160;&#160;object&#160;&#160;matches the signature of the method.<br/>In other words, the following are the same:<br/>
https://doc.rust-lang.org/book/print.html<br/>
124/627<br/>
<hr/>
<a name=125></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
p1.distance(&amp;p2);<br/>(&amp;p1).distance(&amp;p2);<br/>
The&#160;ﬁrst one looks much cleaner. This automatic referencing behavior works because<br/>methods have a clear receiver—the type of&#160;&#160;self&#160;. Given the receiver and name of a<br/>method, Rust can&#160;ﬁgure out deﬁnitively whether the method is reading (&#160;&amp;self&#160;),<br/>mutating (&#160;&amp;mut&#160;self&#160;), or consuming (&#160;self&#160;). The fact that Rust makes borrowing<br/>implicit for method receivers is a big part of making ownership ergonomic in practice.<br/>
<a href="tests.html#125"><b>Methods&#160;with&#160;More&#160;Parameters</b></a><br/>
Let’s practice using methods by implementing a second method on the&#160;&#160;Rectangle&#160;&#160;struct.<br/>This time we want an instance of&#160;&#160;Rectangle&#160;&#160;to take another instance of&#160;&#160;Rectangle&#160;&#160;and<br/>return&#160;&#160;true&#160;&#160;if the second&#160;&#160;Rectangle&#160;&#160;can&#160;ﬁt completely within&#160;&#160;self&#160;&#160;(the&#160;ﬁrst&#160;&#160;Rectangle&#160;);<br/>otherwise, it should return&#160;&#160;false&#160;. That is, once we’ve deﬁned the&#160;&#160;can_hold&#160;&#160;method, we<br/>want to be able to write the program shown in Listing 5-14.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;rect1&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;30,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;50,<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;let&#160;rect2&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;10,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;40,<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;let&#160;rect3&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;60,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;45,<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;println!(&#34;Can&#160;rect1&#160;hold&#160;rect2?&#160;{}&#34;,&#160;rect1.can_hold(&amp;rect2));<br/>&#160;&#160;&#160;&#160;println!(&#34;Can&#160;rect1&#160;hold&#160;rect3?&#160;{}&#34;,&#160;rect1.can_hold(&amp;rect3));<br/>}<br/>
<b>Listing&#160;5-14:&#160;Using&#160;the&#160;as-yet-unwritten&#160;&#160;</b>can_hold&#160;<b>&#160;method</b><br/>
The expected output would look like the following because both dimensions of&#160;&#160;rect2&#160;&#160;are<br/>smaller than the dimensions of&#160;&#160;rect1&#160;, but&#160;&#160;rect3&#160;&#160;is wider than&#160;&#160;rect1&#160;:<br/>
Can&#160;rect1&#160;hold&#160;rect2?&#160;true<br/>Can&#160;rect1&#160;hold&#160;rect3?&#160;false<br/>
We know we want to deﬁne a method, so it will be within the&#160;&#160;impl&#160;Rectangle&#160;&#160;block. The<br/>method name will be&#160;&#160;can_hold&#160;, and it will take an immutable borrow of another<br/>
https://doc.rust-lang.org/book/print.html<br/>
125/627<br/>
<hr/>
<a name=126></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Rectangle&#160;&#160;as a parameter. We can tell what the type of the parameter will be by looking at<br/>
the code that calls the method:&#160;&#160;rect1.can_hold(&amp;rect2)&#160;&#160;passes in&#160;&#160;&amp;rect2&#160;, which is an<br/>immutable borrow to&#160;&#160;rect2&#160;, an instance of&#160;&#160;Rectangle&#160;. This makes sense because we only<br/>need to read&#160;&#160;rect2&#160;&#160;(rather than write, which would mean we’d need a mutable borrow),<br/>and we want&#160;&#160;main&#160;&#160;to retain ownership of&#160;&#160;rect2&#160;&#160;so we can use it again after calling the<br/>
can_hold&#160;&#160;method. The return value of&#160;&#160;can_hold&#160;&#160;will be a Boolean, and the<br/>
implementation will check whether the width and height of&#160;&#160;self&#160;&#160;are greater than the width<br/>and height of the other&#160;&#160;Rectangle&#160;, respectively. Let’s add the new&#160;&#160;can_hold&#160;&#160;method to the<br/>
impl&#160;&#160;block from Listing 5-13, shown in Listing 5-15.<br/>
Filename: src/main.rs<br/>
impl&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;area(&amp;self)&#160;-&gt;&#160;u32&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.width&#160;*&#160;self.height<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;fn&#160;can_hold(&amp;self,&#160;other:&#160;&amp;Rectangle)&#160;-&gt;&#160;bool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.width&#160;&gt;&#160;other.width&#160;&amp;&amp;&#160;self.height&#160;&gt;&#160;other.height<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;5-15:&#160;Implementing&#160;the&#160;&#160;</b>can_hold&#160;<b>&#160;method&#160;on&#160;&#160;</b>Rectangle&#160;<b>&#160;that&#160;takes&#160;another&#160;&#160;</b>Rectangle&#160;<b>&#160;instance&#160;as&#160;a<br/>parameter</b><br/>
When we run this code with the&#160;&#160;main&#160;&#160;function in Listing 5-14, we’ll get our desired output.<br/>Methods can take multiple parameters that we add to the signature after the&#160;&#160;self<br/>parameter, and those parameters work just like parameters in functions.<br/>
<a href="tests.html#126"><b>Associated&#160;Functions</b></a><br/>
All functions deﬁned within an&#160;&#160;impl&#160;&#160;block are called&#160;<i>associated functions</i>&#160;because they’re<br/>associated with the type named after the&#160;&#160;impl&#160;. We can deﬁne associated functions that<br/>don’t have&#160;&#160;self&#160;&#160;as their&#160;ﬁrst parameter (and thus are not methods) because they don’t<br/>need an instance of the type to work with. We’ve already used one function like this: the<br/>
String::from&#160;&#160;function that’s deﬁned on the&#160;&#160;String&#160;&#160;type.<br/>
Associated functions that aren’t methods are often used for constructors that will return a<br/>new instance of the struct. These are often called&#160;&#160;new&#160;, but&#160;&#160;new&#160;&#160;isn’t a special name and<br/>isn’t built into the language. For example, we could choose to provide an associated function<br/>named&#160;&#160;square&#160;&#160;that would have one dimension parameter and use that as both width and<br/>height, thus making it easier to create a square&#160;&#160;Rectangle&#160;&#160;rather than having to specify the<br/>same value twice:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
126/627<br/>
<hr/>
<a name=127></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
impl&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;square(size:&#160;u32)&#160;-&gt;&#160;Self&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Self&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;size,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;size,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
The&#160;&#160;Self&#160;&#160;keywords in the return type and in the body of the function are aliases for the<br/>type that appears after the&#160;&#160;impl&#160;&#160;keyword, which in this case is&#160;&#160;Rectangle&#160;.<br/>
To call this associated function, we use the&#160;&#160;::&#160;&#160;syntax with the struct name;&#160;&#160;let&#160;sq&#160;=&#160;<br/>Rectangle::square(3);&#160;&#160;is an example. This function is namespaced by the struct: the&#160;&#160;::<br/>syntax is used for both associated functions and namespaces created by modules. We’ll<br/>discuss modules in&#160;<a href="https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html">Chapter 7</a>.<br/>
<a href="tests.html#127"><b>Multiple&#160;</b>impl<b>&#160;Blocks</b></a><br/>
Each struct is allowed to have multiple&#160;&#160;impl&#160;&#160;blocks. For example, Listing 5-15 is equivalent<br/>to the code shown in Listing 5-16, which has each method in its own&#160;&#160;impl&#160;&#160;block.<br/>
impl&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;area(&amp;self)&#160;-&gt;&#160;u32&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.width&#160;*&#160;self.height<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
impl&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;can_hold(&amp;self,&#160;other:&#160;&amp;Rectangle)&#160;-&gt;&#160;bool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.width&#160;&gt;&#160;other.width&#160;&amp;&amp;&#160;self.height&#160;&gt;&#160;other.height<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;5-16:&#160;Rewriting&#160;Listing&#160;5-15&#160;using&#160;multiple&#160;&#160;</b>impl&#160;<b>&#160;blocks</b><br/>
There’s no reason to separate these methods into multiple&#160;&#160;impl&#160;&#160;blocks here, but this is<br/>valid syntax. We’ll see a case in which multiple&#160;&#160;impl&#160;&#160;blocks are useful in Chapter 10, where<br/>we discuss generic types and traits.<br/>
<a href="tests.html#127"><b>Summary</b></a><br/>
Structs let you create custom types that are meaningful for your domain. By using structs,<br/>you can keep associated pieces of data connected to each other and name each piece to<br/>make your code clear. In&#160;&#160;impl&#160;&#160;blocks, you can deﬁne functions that are associated with<br/>
https://doc.rust-lang.org/book/print.html<br/>
127/627<br/>
<hr/>
<a name=128></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
your type, and methods are a kind of associated function that let you specify the behavior<br/>that instances of your structs have.<br/>
But structs aren’t the only way you can create custom types: let’s turn to Rust’s enum<br/>feature to add another tool to your toolbox.<br/>
https://doc.rust-lang.org/book/print.html<br/>
128/627<br/>
<hr/>
<a name=129></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#129"><b>Enums and Pattern Matching</b></a><br/>
In this chapter, we’ll look at&#160;<i>enumerations</i>, also referred to as&#160;<i>enums</i>. Enums allow you to<br/>deﬁne a type by enumerating its possible&#160;<i>variants</i>. First we’ll deﬁne and use an enum to<br/>show how an enum can encode meaning along with data. Next, we’ll explore a particularly<br/>useful enum, called&#160;&#160;Option&#160;, which expresses that a value can be either something or<br/>nothing. Then we’ll look at how pattern matching in the&#160;&#160;match&#160;&#160;expression makes it easy to<br/>run diﬀerent code for diﬀerent values of an enum. Finally, we’ll cover how the&#160;&#160;if&#160;let<br/>construct is another convenient and concise idiom available to handle enums in your code.<br/>
https://doc.rust-lang.org/book/print.html<br/>
129/627<br/>
<hr/>
<a name=130></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#130"><b>Deﬁning an Enum</b></a><br/>
Where structs give you a way of grouping together related&#160;ﬁelds and data, like a&#160;&#160;Rectangle<br/>with its&#160;&#160;width&#160;&#160;and&#160;&#160;height&#160;, enums give you a way of saying a value is one of a possible set<br/>of values. For example, we may want to say that&#160;&#160;Rectangle&#160;&#160;is one of a set of possible<br/>shapes that also includes&#160;&#160;Circle&#160;&#160;and&#160;&#160;Triangle&#160;. To do this, Rust allows us to encode these<br/>possibilities as an enum.<br/>
Let’s look at a situation we might want to express in code and see why enums are useful<br/>and more appropriate than structs in this case. Say we need to work with IP addresses.<br/>Currently, two major standards are used for IP addresses: version four and version six.<br/>Because these are the only possibilities for an IP address that our program will come across,<br/>we can&#160;<i>enumerate</i>&#160;all possible variants, which is where enumeration gets its name.<br/>
Any IP address can be either a version four or a version six address, but not both at the<br/>same time. That property of IP addresses makes the enum data structure appropriate<br/>because an enum value can only be one of its variants. Both version four and version six<br/>addresses are still fundamentally IP addresses, so they should be treated as the same type<br/>when the code is handling situations that apply to any kind of IP address.<br/>
We can express this concept in code by deﬁning an&#160;&#160;IpAddrKind&#160;&#160;enumeration and listing the<br/>possible kinds an IP address can be,&#160;&#160;V4&#160;&#160;and&#160;&#160;V6&#160;. These are the variants of the enum:<br/>
enum&#160;IpAddrKind&#160;{<br/>&#160;&#160;&#160;&#160;V4,<br/>&#160;&#160;&#160;&#160;V6,<br/>}<br/>
IpAddrKind&#160;&#160;is now a custom data type that we can use elsewhere in our code.<br/>
<a href="tests.html#130"><b>Enum&#160;Values</b></a><br/>
We can create instances of each of the two variants of&#160;&#160;IpAddrKind&#160;&#160;like this:<br/>
&#160;&#160;&#160;&#160;let&#160;four&#160;=&#160;IpAddrKind::V4;<br/>&#160;&#160;&#160;&#160;let&#160;six&#160;=&#160;IpAddrKind::V6;<br/>
Note that the variants of the enum are namespaced under its identiﬁer, and we use a<br/>double colon to separate the two. This is useful because now both values&#160;&#160;IpAddrKind::V4<br/>and&#160;&#160;IpAddrKind::V6&#160;&#160;are of the same type:&#160;&#160;IpAddrKind&#160;. We can then, for instance, deﬁne a<br/>function that takes any&#160;&#160;IpAddrKind&#160;:<br/>
https://doc.rust-lang.org/book/print.html<br/>
130/627<br/>
<hr/>
<a name=131></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;route(ip_kind:&#160;IpAddrKind)&#160;{}<br/>
And we can call this function with either variant:<br/>
&#160;&#160;&#160;&#160;route(IpAddrKind::V4);<br/>&#160;&#160;&#160;&#160;route(IpAddrKind::V6);<br/>
Using enums has even more advantages. Thinking more about our IP address type, at the<br/>moment we don’t have a way to store the actual IP address&#160;<i>data</i>; we only know what&#160;<i>kind</i>&#160;it<br/>is. Given that you just learned about structs in Chapter 5, you might be tempted to tackle<br/>this problem with structs as shown in Listing 6-1.<br/>
&#160;&#160;&#160;&#160;enum&#160;IpAddrKind&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;V4,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;V6,<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;struct&#160;IpAddr&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;kind:&#160;IpAddrKind,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;address:&#160;String,<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;let&#160;home&#160;=&#160;IpAddr&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;kind:&#160;IpAddrKind::V4,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;address:&#160;String::from(&#34;127.0.0.1&#34;),<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;let&#160;loopback&#160;=&#160;IpAddr&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;kind:&#160;IpAddrKind::V6,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;address:&#160;String::from(&#34;::1&#34;),<br/>&#160;&#160;&#160;&#160;};<br/>
<b>Listing&#160;6-1:&#160;Storing&#160;the&#160;data&#160;and&#160;&#160;</b>IpAddrKind&#160;<b>&#160;variant&#160;of&#160;an&#160;IP&#160;address&#160;using&#160;a&#160;&#160;</b>struct<br/>
Here, we’ve deﬁned a struct&#160;&#160;IpAddr&#160;&#160;that has two&#160;ﬁelds: a&#160;&#160;kind&#160;&#160;ﬁeld that is of type<br/>
IpAddrKind&#160;&#160;(the enum we deﬁned previously) and an&#160;&#160;address&#160;&#160;ﬁeld of type&#160;&#160;String&#160;. We<br/>
have two instances of this struct. The&#160;ﬁrst is&#160;&#160;home&#160;, and it has the value&#160;&#160;IpAddrKind::V4&#160;&#160;as<br/>its&#160;&#160;kind&#160;&#160;with associated address data of&#160;&#160;127.0.0.1&#160;. The second instance is&#160;&#160;loopback&#160;. It<br/>has the other variant of&#160;&#160;IpAddrKind&#160;&#160;as its&#160;&#160;kind&#160;&#160;value,&#160;&#160;V6&#160;, and has address&#160;&#160;::1<br/>associated with it. We’ve used a struct to bundle the&#160;&#160;kind&#160;&#160;and&#160;&#160;address&#160;&#160;values together, so<br/>now the variant is associated with the value.<br/>
However, representing the same concept using just an enum is more concise: rather than<br/>an enum inside a struct, we can put data directly into each enum variant. This new deﬁnition<br/>of the&#160;&#160;IpAddr&#160;&#160;enum says that both&#160;&#160;V4&#160;&#160;and&#160;&#160;V6&#160;&#160;variants will have associated&#160;&#160;String<br/>values:<br/>
https://doc.rust-lang.org/book/print.html<br/>
131/627<br/>
<hr/>
<a name=132></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;enum&#160;IpAddr&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;V4(String),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;V6(String),<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;let&#160;home&#160;=&#160;IpAddr::V4(String::from(&#34;127.0.0.1&#34;));<br/>
&#160;&#160;&#160;&#160;let&#160;loopback&#160;=&#160;IpAddr::V6(String::from(&#34;::1&#34;));<br/>
We attach data to each variant of the enum directly, so there is no need for an extra struct.<br/>Here, it’s also easier to see another detail of how enums work: the name of each enum<br/>variant that we deﬁne also becomes a function that constructs an instance of the enum.<br/>That is,&#160;&#160;IpAddr::V4()&#160;&#160;is a function call that takes a&#160;&#160;String&#160;&#160;argument and returns an<br/>instance of the&#160;&#160;IpAddr&#160;&#160;type. We automatically get this constructor function deﬁned as a<br/>result of deﬁning the enum.<br/>
There’s another advantage to using an enum rather than a struct: each variant can have<br/>diﬀerent types and amounts of associated data. Version four IP addresses will always have<br/>four numeric components that will have values between 0 and 255. If we wanted to store<br/>
V4&#160;&#160;addresses as four&#160;&#160;u8&#160;&#160;values but still express&#160;&#160;V6&#160;&#160;addresses as one&#160;&#160;String&#160;&#160;value, we<br/>
wouldn’t be able to with a struct. Enums handle this case with ease:<br/>
&#160;&#160;&#160;&#160;enum&#160;IpAddr&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;V4(u8,&#160;u8,&#160;u8,&#160;u8),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;V6(String),<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;let&#160;home&#160;=&#160;IpAddr::V4(127,&#160;0,&#160;0,&#160;1);<br/>
&#160;&#160;&#160;&#160;let&#160;loopback&#160;=&#160;IpAddr::V6(String::from(&#34;::1&#34;));<br/>
We’ve shown several diﬀerent ways to deﬁne data structures to store version four and<br/>version six IP addresses. However, as it turns out, wanting to store IP addresses and encode<br/>which kind they are is so common that&#160;<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">the standard library has a deﬁnition we can use!</a>&#160;Let’s<br/>look at how the standard library deﬁnes&#160;&#160;IpAddr&#160;: it has the exact enum and variants that<br/>we’ve deﬁned and used, but it embeds the address data inside the variants in the form of<br/>two diﬀerent structs, which are deﬁned diﬀerently for each variant:<br/>
struct&#160;Ipv4Addr&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
struct&#160;Ipv6Addr&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
enum&#160;IpAddr&#160;{<br/>&#160;&#160;&#160;&#160;V4(Ipv4Addr),<br/>&#160;&#160;&#160;&#160;V6(Ipv6Addr),<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
132/627<br/>
<hr/>
<a name=133></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
This code illustrates that you can put any kind of data inside an enum variant: strings,<br/>numeric types, or structs, for example. You can even include another enum! Also, standard<br/>library types are often not much more complicated than what you might come up with.<br/>
Note that even though the standard library contains a deﬁnition for&#160;&#160;IpAddr&#160;, we can still<br/>create and use our own deﬁnition without conﬂict because we haven’t brought the standard<br/>library’s deﬁnition into our scope. We’ll talk more about bringing types into scope in Chapter<br/>7.<br/>
Let’s look at another example of an enum in Listing 6-2: this one has a wide variety of types<br/>embedded in its variants.<br/>
enum&#160;Message&#160;{<br/>&#160;&#160;&#160;&#160;Quit,<br/>&#160;&#160;&#160;&#160;Move&#160;{&#160;x:&#160;i32,&#160;y:&#160;i32&#160;},<br/>&#160;&#160;&#160;&#160;Write(String),<br/>&#160;&#160;&#160;&#160;ChangeColor(i32,&#160;i32,&#160;i32),<br/>}<br/>
<b>Listing&#160;6-2:&#160;A&#160;&#160;</b>Message&#160;<b>&#160;enum&#160;whose&#160;variants&#160;each&#160;store&#160;diﬀerent&#160;amounts&#160;and&#160;types&#160;of&#160;values</b><br/>
This enum has four variants with diﬀerent types:<br/>
Quit&#160;&#160;has no data associated with it at all.<br/>Move&#160;&#160;has named&#160;ﬁelds, like a struct does.<br/>Write&#160;&#160;includes a single&#160;&#160;String&#160;.<br/>ChangeColor&#160;&#160;includes three&#160;&#160;i32&#160;&#160;values.<br/>
Deﬁning an enum with variants such as the ones in Listing 6-2 is similar to deﬁning diﬀerent<br/>kinds of struct deﬁnitions, except the enum doesn’t use the&#160;&#160;struct&#160;&#160;keyword and all the<br/>variants are grouped together under the&#160;&#160;Message&#160;&#160;type. The following structs could hold the<br/>same data that the preceding enum variants hold:<br/>
struct&#160;QuitMessage;&#160;//&#160;unit&#160;struct<br/>struct&#160;MoveMessage&#160;{<br/>&#160;&#160;&#160;&#160;x:&#160;i32,<br/>&#160;&#160;&#160;&#160;y:&#160;i32,<br/>}<br/>struct&#160;WriteMessage(String);&#160;//&#160;tuple&#160;struct<br/>struct&#160;ChangeColorMessage(i32,&#160;i32,&#160;i32);&#160;//&#160;tuple&#160;struct<br/>
But if we used the diﬀerent structs, each of which has its own type, we couldn’t as easily<br/>deﬁne a function to take any of these kinds of messages as we could with the&#160;&#160;Message<br/>enum deﬁned in Listing 6-2, which is a single type.<br/>
There is one more similarity between enums and structs: just as we’re able to deﬁne<br/>methods on structs using&#160;&#160;impl&#160;, we’re also able to deﬁne methods on enums. Here’s a<br/>method named&#160;&#160;call&#160;&#160;that we could deﬁne on our&#160;&#160;Message&#160;&#160;enum:<br/>
https://doc.rust-lang.org/book/print.html<br/>
133/627<br/>
<hr/>
<a name=134></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;impl&#160;Message&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;call(&amp;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;method&#160;body&#160;would&#160;be&#160;defined&#160;here<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;let&#160;m&#160;=&#160;Message::Write(String::from(&#34;hello&#34;));<br/>&#160;&#160;&#160;&#160;m.call();<br/>
The body of the method would use&#160;&#160;self&#160;&#160;to get the value that we called the method on. In<br/>this example, we’ve created a variable&#160;&#160;m&#160;&#160;that has the value<br/>
Message::Write(String::from(&#34;hello&#34;))&#160;, and that is what&#160;&#160;self&#160;&#160;will be in the body of the<br/>call&#160;&#160;method when&#160;&#160;m.call()&#160;&#160;runs.<br/>
Let’s look at another enum in the standard library that is very common and useful:&#160;&#160;Option&#160;.<br/>
<a href="tests.html#134"><b>The&#160;</b>Option<b>&#160;Enum&#160;and&#160;Its&#160;Advantages&#160;Over&#160;Null&#160;Values</b></a><br/>
This section explores a case study of&#160;&#160;Option&#160;, which is another enum deﬁned by the<br/>standard library. The&#160;&#160;Option&#160;&#160;type encodes the very common scenario in which a value<br/>could be something or it could be nothing.<br/>
For example, if you request the&#160;ﬁrst item in a non-empty list, you would get a value. If you<br/>request the&#160;ﬁrst item in an empty list, you would get nothing. Expressing this concept in<br/>terms of the type system means the compiler can check whether you’ve handled all the<br/>cases you should be handling; this functionality can prevent bugs that are extremely<br/>common in other programming languages.<br/>
Programming language design is often thought of in terms of which features you include,<br/>but the features you exclude are important too. Rust doesn’t have the null feature that<br/>many other languages have.&#160;<i>Null</i>&#160;is a value that means there is no value there. In languages<br/>with null, variables can always be in one of two states: null or not-null.<br/>
In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony Hoare, the<br/>inventor of null, has this to say:<br/>
I call it my billion-dollar mistake. At that time, I was designing the&#160;ﬁrst comprehensive<br/>type system for references in an object-oriented language. My goal was to ensure that<br/>all use of references should be absolutely safe, with checking performed automatically<br/>by the compiler. But I couldn’t resist the temptation to put in a null reference, simply<br/>because it was so easy to implement. This has led to innumerable errors,<br/>vulnerabilities, and system crashes, which have probably caused a billion dollars of<br/>pain and damage in the last forty years.<br/>
https://doc.rust-lang.org/book/print.html<br/>
134/627<br/>
<hr/>
<a name=135></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The problem with null values is that if you try to use a null value as a not-null value, you’ll<br/>get an error of some kind. Because this null or not-null property is pervasive, it’s extremely<br/>easy to make this kind of error.<br/>
However, the concept that null is trying to express is still a useful one: a null is a value that is<br/>currently invalid or absent for some reason.<br/>
The problem isn’t really with the concept but with the particular implementation. As such,<br/>Rust does not have nulls, but it does have an enum that can encode the concept of a value<br/>being present or absent. This enum is&#160;&#160;Option&lt;T&gt;&#160;<a href="https://doc.rust-lang.org/std/option/enum.Option.html">, and it is&#160;deﬁned by the standard library<br/></a>as follows:<br/>
enum&#160;Option&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;None,<br/>&#160;&#160;&#160;&#160;Some(T),<br/>}<br/>
The&#160;&#160;Option&lt;T&gt;&#160;&#160;enum is so useful that it’s even included in the prelude; you don’t need to<br/>bring it into scope explicitly. Its variants are also included in the prelude: you can use&#160;&#160;Some<br/>and&#160;&#160;None&#160;&#160;directly without the&#160;&#160;Option::&#160;&#160;preﬁx. The&#160;&#160;Option&lt;T&gt;&#160;&#160;enum is still just a regular<br/>enum, and&#160;&#160;Some(T)&#160;&#160;and&#160;&#160;None&#160;&#160;are still variants of type&#160;&#160;Option&lt;T&gt;&#160;.<br/>
The&#160;&#160;&lt;T&gt;&#160;&#160;syntax is a feature of Rust we haven’t talked about yet. It’s a generic type<br/>parameter, and we’ll cover generics in more detail in Chapter 10. For now, all you need to<br/>know is that&#160;&#160;&lt;T&gt;&#160;&#160;means that the&#160;&#160;Some&#160;&#160;variant of the&#160;&#160;Option&#160;&#160;enum can hold one piece of<br/>data of any type, and that each concrete type that gets used in place of&#160;&#160;T&#160;&#160;makes the overall<br/>
Option&lt;T&gt;&#160;&#160;type a diﬀerent type. Here are some examples of using&#160;&#160;Option&#160;&#160;values to hold<br/>
number types and string types:<br/>
&#160;&#160;&#160;&#160;let&#160;some_number&#160;=&#160;Some(5);<br/>&#160;&#160;&#160;&#160;let&#160;some_char&#160;=&#160;Some('e');<br/>
&#160;&#160;&#160;&#160;let&#160;absent_number:&#160;Option&lt;i32&gt;&#160;=&#160;None;<br/>
The type of&#160;&#160;some_number&#160;&#160;is&#160;&#160;Option&lt;i32&gt;&#160;. The type of&#160;&#160;some_char&#160;&#160;is&#160;&#160;Option&lt;char&gt;&#160;, which is<br/>a diﬀerent type. Rust can infer these types because we’ve speciﬁed a value inside the&#160;&#160;Some<br/>variant. For&#160;&#160;absent_number&#160;, Rust requires us to annotate the overall&#160;&#160;Option&#160;&#160;type: the<br/>compiler can’t infer the type that the corresponding&#160;&#160;Some&#160;&#160;variant will hold by looking only<br/>at a&#160;&#160;None&#160;&#160;value. Here, we tell Rust that we mean for&#160;&#160;absent_number&#160;&#160;to be of type<br/>
Option&lt;i32&gt;&#160;.<br/>
When we have a&#160;&#160;Some&#160;&#160;value, we know that a value is present and the value is held within<br/>the&#160;&#160;Some&#160;. When we have a&#160;&#160;None&#160;&#160;value, in some sense it means the same thing as null: we<br/>don’t have a valid value. So why is having&#160;&#160;Option&lt;T&gt;&#160;&#160;any better than having null?<br/>
In short, because&#160;&#160;Option&lt;T&gt;&#160;&#160;and&#160;&#160;T&#160;&#160;(where&#160;&#160;T&#160;&#160;can be any type) are diﬀerent types, the<br/>compiler won’t let us use an&#160;&#160;Option&lt;T&gt;&#160;&#160;value as if it were deﬁnitely a valid value. For<br/>
https://doc.rust-lang.org/book/print.html<br/>
135/627<br/>
<hr/>
<a name=136></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
example, this code won’t compile, because it’s trying to add an&#160;&#160;i8&#160;&#160;to an&#160;&#160;Option&lt;i8&gt;&#160;:<br/>
&#160;&#160;&#160;&#160;let&#160;x:&#160;i8&#160;=&#160;5;<br/>&#160;&#160;&#160;&#160;let&#160;y:&#160;Option&lt;i8&gt;&#160;=&#160;Some(5);<br/>
&#160;&#160;&#160;&#160;let&#160;sum&#160;=&#160;x&#160;+&#160;y;<br/>
If we run this code, we get an error message like this one:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;enums&#160;v0.1.0&#160;(file:///projects/enums)<br/>error[E0277]:&#160;cannot&#160;add&#160;`Option&lt;i8&gt;`&#160;to&#160;`i8`<br/>&#160;--&gt;&#160;src/main.rs:5:17<br/>&#160;&#160;|<br/>5&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;sum&#160;=&#160;x&#160;+&#160;y;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^&#160;no&#160;implementation&#160;for&#160;`i8&#160;+&#160;Option&lt;i8&gt;`<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;help:&#160;the&#160;trait&#160;`Add&lt;Option&lt;i8&gt;&gt;`&#160;is&#160;not&#160;implemented&#160;for&#160;`i8`<br/>&#160;&#160;=&#160;help:&#160;the&#160;following&#160;other&#160;types&#160;implement&#160;trait&#160;`Add&lt;Rhs&gt;`:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&amp;'a&#160;i8&#160;as&#160;Add&lt;i8&gt;&gt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;&amp;i8&#160;as&#160;Add&lt;&amp;i8&gt;&gt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;i8&#160;as&#160;Add&lt;&amp;i8&gt;&gt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;i8&#160;as&#160;Add&gt;<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0277`.<br/>error:&#160;could&#160;not&#160;compile&#160;`enums`&#160;due&#160;to&#160;previous&#160;error<br/>
Intense! In eﬀect, this error message means that Rust doesn’t understand how to add an<br/>
i8&#160;&#160;and an&#160;&#160;Option&lt;i8&gt;&#160;, because they’re diﬀerent types. When we have a value of a type<br/>
like&#160;&#160;i8&#160;&#160;in Rust, the compiler will ensure that we always have a valid value. We can proceed<br/>conﬁdently without having to check for null before using that value. Only when we have an<br/>
Option&lt;i8&gt;&#160;&#160;(or whatever type of value we’re working with) do we have to worry about<br/>
possibly not having a value, and the compiler will make sure we handle that case before<br/>using the value.<br/>
In other words, you have to convert an&#160;&#160;Option&lt;T&gt;&#160;&#160;to a&#160;&#160;T&#160;&#160;before you can perform&#160;&#160;T<br/>operations with it. Generally, this helps catch one of the most common issues with null:<br/>assuming that something isn’t null when it actually is.<br/>
Eliminating the risk of incorrectly assuming a not-null value helps you to be more conﬁdent<br/>in your code. In order to have a value that can possibly be null, you must explicitly opt in by<br/>making the type of that value&#160;&#160;Option&lt;T&gt;&#160;. Then, when you use that value, you are required<br/>to explicitly handle the case when the value is null. Everywhere that a value has a type that<br/>isn’t an&#160;&#160;Option&lt;T&gt;&#160;, you&#160;<i>can</i>&#160;safely assume that the value isn’t null. This was a deliberate<br/>design decision for Rust to limit null’s pervasiveness and increase the safety of Rust code.<br/>
So how do you get the&#160;&#160;T&#160;&#160;value out of a&#160;&#160;Some&#160;&#160;variant when you have a value of type<br/>
Option&lt;T&gt;&#160;&#160;so that you can use that value? The&#160;&#160;Option&lt;T&gt;&#160;&#160;enum has a large number of<br/>
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">methods that are useful in a variety of situations; you can check them out in&#160;its</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
136/627<br/>
<hr/>
<a name=137></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">documentation. Becoming familiar with the methods on&#160;&#160;Option&lt;T&gt;&#160;&#160;will be extremely useful<br/></a>in your journey with Rust.<br/>
In general, in order to use an&#160;&#160;Option&lt;T&gt;&#160;&#160;value, you want to have code that will handle each<br/>variant. You want some code that will run only when you have a&#160;&#160;Some(T)&#160;&#160;value, and this<br/>code is allowed to use the inner&#160;&#160;T&#160;. You want some other code to run only if you have a<br/>
None&#160;&#160;value, and that code doesn’t have a&#160;&#160;T&#160;&#160;value available. The&#160;&#160;match&#160;&#160;expression is a<br/>
control&#160;ﬂow construct that does just this when used with enums: it will run diﬀerent code<br/>depending on which variant of the enum it has, and that code can use the data inside the<br/>matching value.<br/>
https://doc.rust-lang.org/book/print.html<br/>
137/627<br/>
<hr/>
<a name=138></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#138"><b>The&#160;</b>match<b>&#160;Control Flow Construct</b></a><br/>
Rust has an extremely powerful control&#160;ﬂow construct called&#160;&#160;match&#160;&#160;that allows you to<br/>compare a value against a series of patterns and then execute code based on which pattern<br/>matches. Patterns can be made up of literal values, variable names, wildcards, and many<br/>other things;&#160;<a href="https://doc.rust-lang.org/book/ch18-00-patterns.html">Chapter 18</a>&#160;covers all the diﬀerent kinds of patterns and what they do. The<br/>power of&#160;&#160;match&#160;&#160;comes from the expressiveness of the patterns and the fact that the<br/>compiler conﬁrms that all possible cases are handled.<br/>
Think of a&#160;&#160;match&#160;&#160;expression as being like a coin-sorting machine: coins slide down a track<br/>with variously sized holes along it, and each coin falls through the&#160;ﬁrst hole it encounters<br/>that it&#160;ﬁts into. In the same way, values go through each pattern in a&#160;&#160;match&#160;, and at the&#160;ﬁrst<br/>pattern the value “ﬁts,” the value falls into the associated code block to be used during<br/>execution.<br/>
Speaking of coins, let’s use them as an example using&#160;&#160;match&#160;! We can write a function that<br/>takes an unknown US coin and, in a similar way as the counting machine, determines which<br/>coin it is and returns its value in cents, as shown in Listing 6-3.<br/>
enum&#160;Coin&#160;{<br/>&#160;&#160;&#160;&#160;Penny,<br/>&#160;&#160;&#160;&#160;Nickel,<br/>&#160;&#160;&#160;&#160;Dime,<br/>&#160;&#160;&#160;&#160;Quarter,<br/>}<br/>
fn&#160;value_in_cents(coin:&#160;Coin)&#160;-&gt;&#160;u8&#160;{<br/>&#160;&#160;&#160;&#160;match&#160;coin&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Penny&#160;=&gt;&#160;1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Nickel&#160;=&gt;&#160;5,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Dime&#160;=&gt;&#160;10,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Quarter&#160;=&gt;&#160;25,<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;6-3:&#160;An&#160;enum&#160;and&#160;a&#160;&#160;</b>match&#160;<b>&#160;expression&#160;that&#160;has&#160;the&#160;variants&#160;of&#160;the&#160;enum&#160;as&#160;its&#160;patterns</b><br/>
Let’s break down the&#160;&#160;match&#160;&#160;in the&#160;&#160;value_in_cents&#160;&#160;function. First we list the&#160;&#160;match<br/>keyword followed by an expression, which in this case is the value&#160;&#160;coin&#160;. This seems very<br/>similar to a conditional expression used with&#160;&#160;if&#160;, but there’s a big diﬀerence: with&#160;&#160;if&#160;, the<br/>condition needs to evaluate to a Boolean value, but here it can be any type. The type of<br/>
coin&#160;&#160;in this example is the&#160;&#160;Coin&#160;&#160;enum that we deﬁned on the&#160;ﬁrst line.<br/>
Next are the&#160;&#160;match&#160;&#160;arms. An arm has two parts: a pattern and some code. The&#160;ﬁrst arm<br/>here has a pattern that is the value&#160;&#160;Coin::Penny&#160;&#160;and then the&#160;&#160;=&gt;&#160;&#160;operator that separates<br/>
https://doc.rust-lang.org/book/print.html<br/>
138/627<br/>
<hr/>
<a name=139></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
the pattern and the code to run. The code in this case is just the value&#160;&#160;1&#160;. Each arm is<br/>separated from the next with a comma.<br/>
When the&#160;&#160;match&#160;&#160;expression executes, it compares the resultant value against the pattern<br/>of each arm, in order. If a pattern matches the value, the code associated with that pattern<br/>is executed. If that pattern doesn’t match the value, execution continues to the next arm,<br/>much as in a coin-sorting machine. We can have as many arms as we need: in Listing 6-3,<br/>our&#160;&#160;match&#160;&#160;has four arms.<br/>
The code associated with each arm is an expression, and the resultant value of the<br/>expression in the matching arm is the value that gets returned for the entire&#160;&#160;match<br/>expression.<br/>
We don’t typically use curly brackets if the match arm code is short, as it is in Listing 6-3<br/>where each arm just returns a value. If you want to run multiple lines of code in a match<br/>arm, you must use curly brackets, and the comma following the arm is then optional. For<br/>example, the following code prints “Lucky penny!” every time the method is called with a<br/>
Coin::Penny&#160;, but still returns the last value of the block,&#160;&#160;1&#160;:<br/>
fn&#160;value_in_cents(coin:&#160;Coin)&#160;-&gt;&#160;u8&#160;{<br/>&#160;&#160;&#160;&#160;match&#160;coin&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Penny&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Lucky&#160;penny!&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Nickel&#160;=&gt;&#160;5,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Dime&#160;=&gt;&#160;10,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Quarter&#160;=&gt;&#160;25,<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<a href="tests.html#139"><b>Patterns&#160;That&#160;Bind&#160;to&#160;Values</b></a><br/>
Another useful feature of match arms is that they can bind to the parts of the values that<br/>match the pattern. This is how we can extract values out of enum variants.<br/>
As an example, let’s change one of our enum variants to hold data inside it. From 1999<br/>through 2008, the United States minted quarters with diﬀerent designs for each of the 50<br/>states on one side. No other coins got state designs, so only quarters have this extra value.<br/>We can add this information to our&#160;&#160;enum&#160;&#160;by changing the&#160;&#160;Quarter&#160;&#160;variant to include a<br/>
UsState&#160;&#160;value stored inside it, which we’ve done in Listing 6-4.<br/>
https://doc.rust-lang.org/book/print.html<br/>
139/627<br/>
<hr/>
<a name=140></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
#[derive(Debug)]&#160;//&#160;so&#160;we&#160;can&#160;inspect&#160;the&#160;state&#160;in&#160;a&#160;minute<br/>enum&#160;UsState&#160;{<br/>&#160;&#160;&#160;&#160;Alabama,<br/>&#160;&#160;&#160;&#160;Alaska,<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
enum&#160;Coin&#160;{<br/>&#160;&#160;&#160;&#160;Penny,<br/>&#160;&#160;&#160;&#160;Nickel,<br/>&#160;&#160;&#160;&#160;Dime,<br/>&#160;&#160;&#160;&#160;Quarter(UsState),<br/>}<br/>
<b>Listing&#160;6-4:&#160;A&#160;&#160;</b>Coin&#160;<b>&#160;enum&#160;in&#160;which&#160;the&#160;&#160;</b>Quarter&#160;<b>&#160;variant&#160;also&#160;holds&#160;a&#160;&#160;</b>UsState&#160;<b>&#160;value</b><br/>
Let’s imagine that a friend is trying to collect all 50 state quarters. While we sort our loose<br/>change by coin type, we’ll also call out the name of the state associated with each quarter so<br/>that if it’s one our friend doesn’t have, they can add it to their collection.<br/>
In the match expression for this code, we add a variable called&#160;&#160;state&#160;&#160;to the pattern that<br/>matches values of the variant&#160;&#160;Coin::Quarter&#160;. When a&#160;&#160;Coin::Quarter&#160;&#160;matches, the&#160;&#160;state<br/>variable will bind to the value of that quarter’s state. Then we can use&#160;&#160;state&#160;&#160;in the code for<br/>that arm, like so:<br/>
fn&#160;value_in_cents(coin:&#160;Coin)&#160;-&gt;&#160;u8&#160;{<br/>&#160;&#160;&#160;&#160;match&#160;coin&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Penny&#160;=&gt;&#160;1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Nickel&#160;=&gt;&#160;5,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Dime&#160;=&gt;&#160;10,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Quarter(state)&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;State&#160;quarter&#160;from&#160;{:?}!&#34;,&#160;state);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;25<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
If we were to call&#160;&#160;value_in_cents(Coin::Quarter(UsState::Alaska))&#160;,&#160;&#160;coin&#160;&#160;would be<br/>
Coin::Quarter(UsState::Alaska)&#160;. When we compare that value with each of the match<br/>
arms, none of them match until we reach&#160;&#160;Coin::Quarter(state)&#160;. At that point, the binding<br/>for&#160;&#160;state&#160;&#160;will be the value&#160;&#160;UsState::Alaska&#160;. We can then use that binding in the<br/>
println!&#160;&#160;expression, thus getting the inner state value out of the&#160;&#160;Coin&#160;&#160;enum variant for<br/>Quarter&#160;.<br/>
<a href="tests.html#140"><b>Matching&#160;with&#160;</b>Option&lt;T&gt;</a><br/>
In the previous section, we wanted to get the inner&#160;&#160;T&#160;&#160;value out of the&#160;&#160;Some&#160;&#160;case when<br/>using&#160;&#160;Option&lt;T&gt;&#160;; we can also handle&#160;&#160;Option&lt;T&gt;&#160;&#160;using&#160;&#160;match&#160;, as we did with the&#160;&#160;Coin<br/>
https://doc.rust-lang.org/book/print.html<br/>
140/627<br/>
<hr/>
<a name=141></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
enum! Instead of comparing coins, we’ll compare the variants of&#160;&#160;Option&lt;T&gt;&#160;, but the way<br/>the&#160;&#160;match&#160;&#160;expression works remains the same.<br/>
Let’s say we want to write a function that takes an&#160;&#160;Option&lt;i32&gt;&#160;&#160;and, if there’s a value<br/>inside, adds 1 to that value. If there isn’t a value inside, the function should return the&#160;&#160;None<br/>value and not attempt to perform any operations.<br/>
This function is very easy to write, thanks to&#160;&#160;match&#160;, and will look like Listing 6-5.<br/>
&#160;&#160;&#160;&#160;fn&#160;plus_one(x:&#160;Option&lt;i32&gt;)&#160;-&gt;&#160;Option&lt;i32&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;x&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;None&#160;=&gt;&#160;None,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(i)&#160;=&gt;&#160;Some(i&#160;+&#160;1),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;let&#160;five&#160;=&#160;Some(5);<br/>&#160;&#160;&#160;&#160;let&#160;six&#160;=&#160;plus_one(five);<br/>&#160;&#160;&#160;&#160;let&#160;none&#160;=&#160;plus_one(None);<br/>
<b>Listing&#160;6-5:&#160;A&#160;function&#160;that&#160;uses&#160;a&#160;&#160;</b>match&#160;<b>&#160;expression&#160;on&#160;an&#160;&#160;</b>Option&lt;i32&gt;<br/>
Let’s examine the&#160;ﬁrst execution of&#160;&#160;plus_one&#160;&#160;in more detail. When we call<br/>
plus_one(five)&#160;, the variable&#160;&#160;x&#160;&#160;in the body of&#160;&#160;plus_one&#160;&#160;will have the value&#160;&#160;Some(5)&#160;. We<br/>
then compare that against each match arm:<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;None&#160;=&gt;&#160;None,<br/>
The&#160;&#160;Some(5)&#160;&#160;value doesn’t match the pattern&#160;&#160;None&#160;, so we continue to the next arm:<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(i)&#160;=&gt;&#160;Some(i&#160;+&#160;1),<br/>
Does&#160;&#160;Some(5)&#160;&#160;match&#160;&#160;Some(i)&#160;? It does! We have the same variant. The&#160;&#160;i&#160;&#160;binds to the<br/>value contained in&#160;&#160;Some&#160;, so&#160;&#160;i&#160;&#160;takes the value&#160;&#160;5&#160;. The code in the match arm is then<br/>executed, so we add 1 to the value of&#160;&#160;i&#160;&#160;and create a new&#160;&#160;Some&#160;&#160;value with our total&#160;&#160;6<br/>inside.<br/>
Now let’s consider the second call of&#160;&#160;plus_one&#160;&#160;in Listing 6-5, where&#160;&#160;x&#160;&#160;is&#160;&#160;None&#160;. We enter<br/>the&#160;&#160;match&#160;&#160;and compare to the&#160;ﬁrst arm:<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;None&#160;=&gt;&#160;None,<br/>
It matches! There’s no value to add to, so the program stops and returns the&#160;&#160;None&#160;&#160;value on<br/>the right side of&#160;&#160;=&gt;&#160;. Because the&#160;ﬁrst arm matched, no other arms are compared.<br/>
Combining&#160;&#160;match&#160;&#160;and enums is useful in many situations. You’ll see this pattern a lot in<br/>Rust code:&#160;&#160;match&#160;&#160;against an enum, bind a variable to the data inside, and then execute<br/>
https://doc.rust-lang.org/book/print.html<br/>
141/627<br/>
<hr/>
<a name=142></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
code based on it. It’s a bit tricky at&#160;ﬁrst, but once you get used to it, you’ll wish you had it in<br/>all languages. It’s consistently a user favorite.<br/>
<a href="tests.html#142"><b>Matches&#160;Are&#160;Exhaustive</b></a><br/>
There’s one other aspect of&#160;&#160;match&#160;&#160;we need to discuss: the arms’ patterns must cover all<br/>possibilities. Consider this version of our&#160;&#160;plus_one&#160;&#160;function, which has a bug and won’t<br/>compile:<br/>
&#160;&#160;&#160;&#160;fn&#160;plus_one(x:&#160;Option&lt;i32&gt;)&#160;-&gt;&#160;Option&lt;i32&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;x&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(i)&#160;=&gt;&#160;Some(i&#160;+&#160;1),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
We didn’t handle the&#160;&#160;None&#160;&#160;case, so this code will cause a bug. Luckily, it’s a bug Rust knows<br/>how to catch. If we try to compile this code, we’ll get this error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;enums&#160;v0.1.0&#160;(file:///projects/enums)<br/>error[E0004]:&#160;non-exhaustive&#160;patterns:&#160;`None`&#160;not&#160;covered<br/>&#160;--&gt;&#160;src/main.rs:3:15<br/>&#160;&#160;|<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;x&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^&#160;pattern&#160;`None`&#160;not&#160;covered<br/>&#160;&#160;|<br/>note:&#160;`Option&lt;i32&gt;`&#160;defined&#160;here<br/>&#160;--&gt;&#160;<br/>/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:518:<br/>1<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;<br/>/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:522:<br/>5:&#160;not&#160;covered<br/>&#160;&#160;=&#160;note:&#160;the&#160;matched&#160;value&#160;is&#160;of&#160;type&#160;`Option&lt;i32&gt;`<br/>help:&#160;ensure&#160;that&#160;all&#160;possible&#160;cases&#160;are&#160;being&#160;handled&#160;by&#160;adding&#160;a&#160;match&#160;arm&#160;<br/>with&#160;a&#160;wildcard&#160;pattern&#160;or&#160;an&#160;explicit&#160;pattern&#160;as&#160;shown<br/>&#160;&#160;|<br/>4&#160;~&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(i)&#160;=&gt;&#160;Some(i&#160;+&#160;1),<br/>5&#160;~&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;None&#160;=&gt;&#160;todo!(),<br/>&#160;&#160;|<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0004`.<br/>error:&#160;could&#160;not&#160;compile&#160;`enums`&#160;due&#160;to&#160;previous&#160;error<br/>
Rust knows that we didn’t cover every possible case, and even knows which pattern we<br/>forgot! Matches in Rust are&#160;<i>exhaustive</i>: we must exhaust every last possibility in order for the<br/>code to be valid. Especially in the case of&#160;&#160;Option&lt;T&gt;&#160;, when Rust prevents us from forgetting<br/>to explicitly handle the&#160;&#160;None&#160;&#160;case, it protects us from assuming that we have a value when<br/>we might have null, thus making the billion-dollar mistake discussed earlier impossible.<br/>
https://doc.rust-lang.org/book/print.html<br/>
142/627<br/>
<hr/>
<a name=143></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#143"><b>Catch-all&#160;Patterns&#160;and&#160;the&#160;</b>_<b>&#160;Placeholder</b></a><br/>
Using enums, we can also take special actions for a few particular values, but for all other<br/>values take one default action. Imagine we’re implementing a game where, if you roll a 3 on<br/>a dice roll, your player doesn’t move, but instead gets a new fancy hat. If you roll a 7, your<br/>player loses a fancy hat. For all other values, your player moves that number of spaces on<br/>the game board. Here’s a&#160;&#160;match&#160;&#160;that implements that logic, with the result of the dice roll<br/>hardcoded rather than a random value, and all other logic represented by functions without<br/>bodies because actually implementing them is out of scope for this example:<br/>
&#160;&#160;&#160;&#160;let&#160;dice_roll&#160;=&#160;9;<br/>&#160;&#160;&#160;&#160;match&#160;dice_roll&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3&#160;=&gt;&#160;add_fancy_hat(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7&#160;=&gt;&#160;remove_fancy_hat(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;other&#160;=&gt;&#160;move_player(other),<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;fn&#160;add_fancy_hat()&#160;{}<br/>&#160;&#160;&#160;&#160;fn&#160;remove_fancy_hat()&#160;{}<br/>&#160;&#160;&#160;&#160;fn&#160;move_player(num_spaces:&#160;u8)&#160;{}<br/>
For the&#160;ﬁrst two arms, the patterns are the literal values&#160;&#160;3&#160;&#160;and&#160;&#160;7&#160;. For the last arm that<br/>covers every other possible value, the pattern is the variable we’ve chosen to name&#160;&#160;other&#160;.<br/>The code that runs for the&#160;&#160;other&#160;&#160;arm uses the variable by passing it to the&#160;&#160;move_player<br/>function.<br/>
This code compiles, even though we haven’t listed all the possible values a&#160;&#160;u8&#160;&#160;can have,<br/>because the last pattern will match all values not speciﬁcally listed. This catch-all pattern<br/>meets the requirement that&#160;&#160;match&#160;&#160;must be exhaustive. Note that we have to put the catch-<br/>all arm last because the patterns are evaluated in order. If we put the catch-all arm earlier,<br/>the other arms would never run, so Rust will warn us if we add arms after a catch-all!<br/>
Rust also has a pattern we can use when we want a catch-all but don’t want to&#160;<i>use</i>&#160;the value<br/>in the catch-all pattern:&#160;&#160;_&#160;&#160;is a special pattern that matches any value and does not bind to<br/>that value. This tells Rust we aren’t going to use the value, so Rust won’t warn us about an<br/>unused variable.<br/>
Let’s change the rules of the game: now, if you roll anything other than a 3 or a 7, you must<br/>roll again. We no longer need to use the catch-all value, so we can change our code to use<br/>
_&#160;&#160;instead of the variable named&#160;&#160;other&#160;:<br/>
https://doc.rust-lang.org/book/print.html<br/>
143/627<br/>
<hr/>
<a name=144></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;let&#160;dice_roll&#160;=&#160;9;<br/>&#160;&#160;&#160;&#160;match&#160;dice_roll&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3&#160;=&gt;&#160;add_fancy_hat(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7&#160;=&gt;&#160;remove_fancy_hat(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;reroll(),<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;fn&#160;add_fancy_hat()&#160;{}<br/>&#160;&#160;&#160;&#160;fn&#160;remove_fancy_hat()&#160;{}<br/>&#160;&#160;&#160;&#160;fn&#160;reroll()&#160;{}<br/>
This example also meets the exhaustiveness requirement because we’re explicitly ignoring<br/>all other values in the last arm; we haven’t forgotten anything.<br/>
Finally, we’ll change the rules of the game one more time so that nothing else happens on<br/>your turn if you roll anything other than a 3 or a 7. We can express that by using the unit<br/><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type">value (the empty tuple type we mentioned in&#160;“The Tuple Type”&#160;section) as the code that goes<br/></a>with the&#160;&#160;_&#160;&#160;arm:<br/>
&#160;&#160;&#160;&#160;let&#160;dice_roll&#160;=&#160;9;<br/>&#160;&#160;&#160;&#160;match&#160;dice_roll&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3&#160;=&gt;&#160;add_fancy_hat(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;7&#160;=&gt;&#160;remove_fancy_hat(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;(),<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;fn&#160;add_fancy_hat()&#160;{}<br/>&#160;&#160;&#160;&#160;fn&#160;remove_fancy_hat()&#160;{}<br/>
Here, we’re telling Rust explicitly that we aren’t going to use any other value that doesn’t<br/>match a pattern in an earlier arm, and we don’t want to run any code in this case.<br/>
There’s more about patterns and matching that we’ll cover in&#160;<a href="https://doc.rust-lang.org/book/ch18-00-patterns.html">Chapter 18</a>. For now, we’re<br/>going to move on to the&#160;&#160;if&#160;let&#160;&#160;syntax, which can be useful in situations where the&#160;&#160;match<br/>expression is a bit wordy.<br/>
https://doc.rust-lang.org/book/print.html<br/>
144/627<br/>
<hr/>
<a name=145></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#145"><b>Concise Control Flow with&#160;</b>if&#160;let</a><br/>
The&#160;&#160;if&#160;let&#160;&#160;syntax lets you combine&#160;&#160;if&#160;&#160;and&#160;&#160;let&#160;&#160;into a less verbose way to handle values<br/>that match one pattern while ignoring the rest. Consider the program in Listing 6-6 that<br/>matches on an&#160;&#160;Option&lt;u8&gt;&#160;&#160;value in the&#160;&#160;config_max&#160;&#160;variable but only wants to execute<br/>code if the value is the&#160;&#160;Some&#160;&#160;variant.<br/>
&#160;&#160;&#160;&#160;let&#160;config_max&#160;=&#160;Some(3u8);<br/>&#160;&#160;&#160;&#160;match&#160;config_max&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(max)&#160;=&gt;&#160;println!(&#34;The&#160;maximum&#160;is&#160;configured&#160;to&#160;be&#160;{}&#34;,&#160;max),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;(),<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;6-6:&#160;A&#160;&#160;</b>match&#160;<b>&#160;that&#160;only&#160;cares&#160;about&#160;executing&#160;code&#160;when&#160;the&#160;value&#160;is&#160;&#160;</b>Some<br/>
If the value is&#160;&#160;Some&#160;, we print out the value in the&#160;&#160;Some&#160;&#160;variant by binding the value to the<br/>variable&#160;&#160;max&#160;&#160;in the pattern. We don’t want to do anything with the&#160;&#160;None&#160;&#160;value. To satisfy<br/>the&#160;&#160;match&#160;&#160;expression, we have to add&#160;&#160;_&#160;=&gt;&#160;()&#160;&#160;after processing just one variant, which is<br/>annoying boilerplate code to add.<br/>
Instead, we could write this in a shorter way using&#160;&#160;if&#160;let&#160;. The following code behaves the<br/>same as the&#160;&#160;match&#160;&#160;in Listing 6-6:<br/>
&#160;&#160;&#160;&#160;let&#160;config_max&#160;=&#160;Some(3u8);<br/>&#160;&#160;&#160;&#160;if&#160;let&#160;Some(max)&#160;=&#160;config_max&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;The&#160;maximum&#160;is&#160;configured&#160;to&#160;be&#160;{}&#34;,&#160;max);<br/>&#160;&#160;&#160;&#160;}<br/>
The syntax&#160;&#160;if&#160;let&#160;&#160;takes a pattern and an expression separated by an equal sign. It works<br/>the same way as a&#160;&#160;match&#160;, where the expression is given to the&#160;&#160;match&#160;&#160;and the pattern is its<br/>ﬁrst arm. In this case, the pattern is&#160;&#160;Some(max)&#160;, and the&#160;&#160;max&#160;&#160;binds to the value inside the<br/>
Some&#160;. We can then use&#160;&#160;max&#160;&#160;in the body of the&#160;&#160;if&#160;let&#160;&#160;block in the same way we used&#160;&#160;max<br/>
in the corresponding&#160;&#160;match&#160;&#160;arm. The code in the&#160;&#160;if&#160;let&#160;&#160;block isn’t run if the value doesn’t<br/>match the pattern.<br/>
Using&#160;&#160;if&#160;let&#160;&#160;means less typing, less indentation, and less boilerplate code. However, you<br/>lose the exhaustive checking that&#160;&#160;match&#160;&#160;enforces. Choosing between&#160;&#160;match&#160;&#160;and&#160;&#160;if&#160;let<br/>depends on what you’re doing in your particular situation and whether gaining conciseness<br/>is an appropriate trade-oﬀ&#160;for losing exhaustive checking.<br/>
In other words, you can think of&#160;&#160;if&#160;let&#160;&#160;as syntax sugar for a&#160;&#160;match&#160;&#160;that runs code when<br/>the value matches one pattern and then ignores all other values.<br/>
https://doc.rust-lang.org/book/print.html<br/>
145/627<br/>
<hr/>
<a name=146></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We can include an&#160;&#160;else&#160;&#160;with an&#160;&#160;if&#160;let&#160;. The block of code that goes with the&#160;&#160;else&#160;&#160;is the<br/>same as the block of code that would go with the&#160;&#160;_&#160;&#160;case in the&#160;&#160;match&#160;&#160;expression that is<br/>equivalent to the&#160;&#160;if&#160;let&#160;&#160;and&#160;&#160;else&#160;. Recall the&#160;&#160;Coin&#160;&#160;enum deﬁnition in Listing 6-4, where<br/>the&#160;&#160;Quarter&#160;&#160;variant also held a&#160;&#160;UsState&#160;&#160;value. If we wanted to count all non-quarter coins<br/>we see while also announcing the state of the quarters, we could do that with a&#160;&#160;match<br/>expression, like this:<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;count&#160;=&#160;0;<br/>&#160;&#160;&#160;&#160;match&#160;coin&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Coin::Quarter(state)&#160;=&gt;&#160;println!(&#34;State&#160;quarter&#160;from&#160;{:?}!&#34;,&#160;state),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;count&#160;+=&#160;1,<br/>&#160;&#160;&#160;&#160;}<br/>
Or we could use an&#160;&#160;if&#160;let&#160;&#160;and&#160;&#160;else&#160;&#160;expression, like this:<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;count&#160;=&#160;0;<br/>&#160;&#160;&#160;&#160;if&#160;let&#160;Coin::Quarter(state)&#160;=&#160;coin&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;State&#160;quarter&#160;from&#160;{:?}!&#34;,&#160;state);<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count&#160;+=&#160;1;<br/>&#160;&#160;&#160;&#160;}<br/>
If you have a situation in which your program has logic that is too verbose to express using<br/>a&#160;&#160;match&#160;, remember that&#160;&#160;if&#160;let&#160;&#160;is in your Rust toolbox as well.<br/>
<a href="tests.html#146"><b>Summary</b></a><br/>
We’ve now covered how to use enums to create custom types that can be one of a set of<br/>enumerated values. We’ve shown how the standard library’s&#160;&#160;Option&lt;T&gt;&#160;&#160;type helps you use<br/>the type system to prevent errors. When enum values have data inside them, you can use<br/>
match&#160;&#160;or&#160;&#160;if&#160;let&#160;&#160;to extract and use those values, depending on how many cases you need<br/>
to handle.<br/>
Your Rust programs can now express concepts in your domain using structs and enums.<br/>Creating custom types to use in your API ensures type safety: the compiler will make certain<br/>your functions only get values of the type each function expects.<br/>
In order to provide a well-organized API to your users that is straightforward to use and only<br/>exposes exactly what your users will need, let’s now turn to Rust’s modules.<br/>
https://doc.rust-lang.org/book/print.html<br/>
146/627<br/>
<hr/>
<a name=147></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#147"><b>Managing Growing Projects with Packages,<br/>Crates, and Modules</b></a><br/>
As you write large programs, organizing your code will become increasingly important. By<br/>grouping related functionality and separating code with distinct features, you’ll clarify where<br/>to&#160;ﬁnd code that implements a particular feature and where to go to change how a feature<br/>works.<br/>
The programs we’ve written so far have been in one module in one&#160;ﬁle. As a project grows,<br/>you should organize code by splitting it into multiple modules and then multiple&#160;ﬁles. A<br/>package can contain multiple binary crates and optionally one library crate. As a package<br/>grows, you can extract parts into separate crates that become external dependencies. This<br/>chapter covers all these techniques. For very large projects comprising a set of interrelated<br/><a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">packages that evolve together, Cargo provides&#160;<i>workspaces</i>, which we’ll cover in the&#160;“Cargo<br/>Workspaces”&#160;section in Chapter 14.</a><br/>
We’ll also discuss encapsulating implementation details, which lets you reuse code at a<br/>higher level: once you’ve implemented an operation, other code can call your code via its<br/>public interface without having to know how the implementation works. The way you write<br/>code deﬁnes which parts are public for other code to use and which parts are private<br/>implementation details that you reserve the right to change. This is another way to limit the<br/>amount of detail you have to keep in your head.<br/>
A related concept is scope: the nested context in which code is written has a set of names<br/>that are deﬁned as “in scope.” When reading, writing, and compiling code, programmers<br/>and compilers need to know whether a particular name at a particular spot refers to a<br/>variable, function, struct, enum, module, constant, or other item and what that item means.<br/>You can create scopes and change which names are in or out of scope. You can’t have two<br/>items with the same name in the same scope; tools are available to resolve name conﬂicts.<br/>
Rust has a number of features that allow you to manage your code’s organization, including<br/>which details are exposed, which details are private, and what names are in each scope in<br/>your programs. These features, sometimes collectively referred to as the&#160;<i>module system</i>,<br/>include:<br/>
<b>Packages:</b>&#160;A Cargo feature that lets you build, test, and share crates<br/><b>Crates:</b>&#160;A tree of modules that produces a library or executable<br/><b>Modules</b>&#160;and&#160;<b>use:</b>&#160;Let you control the organization, scope, and privacy of paths<br/><b>Paths:</b>&#160;A way of naming an item, such as a struct, function, or module<br/>
In this chapter, we’ll cover all these features, discuss how they interact, and explain how to<br/>use them to manage scope. By the end, you should have a solid understanding of the<br/>module system and be able to work with scopes like a pro!<br/>
https://doc.rust-lang.org/book/print.html<br/>
147/627<br/>
<hr/>
<a name=148></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#148"><b>Packages and Crates</b></a><br/>
The&#160;ﬁrst parts of the module system we’ll cover are packages and crates.<br/>
A&#160;<i>crate</i>&#160;is the smallest amount of code that the Rust compiler considers at a time. Even if<br/>you run&#160;&#160;rustc&#160;&#160;rather than&#160;&#160;cargo&#160;&#160;and pass a single source code&#160;ﬁle (as we did all the way<br/>back in the “Writing and Running a Rust Program” section of Chapter 1), the compiler<br/>considers that&#160;ﬁle to be a crate. Crates can contain modules, and the modules may be<br/>deﬁned in other&#160;ﬁles that get compiled with the crate, as we’ll see in the coming sections.<br/>
A crate can come in one of two forms: a binary crate or a library crate.&#160;<i>Binary crates</i>&#160;are<br/>programs you can compile to an executable that you can run, such as a command-line<br/>program or a server. Each must have a function called&#160;&#160;main&#160;&#160;that deﬁnes what happens<br/>when the executable runs. All the crates we’ve created so far have been binary crates.<br/>
<i>Library crates</i>&#160;don’t have a&#160;&#160;main&#160;&#160;function, and they don’t compile to an executable. Instead,<br/>they deﬁne functionality intended to be shared with multiple projects. For example, the<br/>
rand&#160;&#160;crate we used in&#160;<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#generating-a-random-number">Chapter 2</a>&#160;provides functionality that generates random numbers.<br/>
Most of the time when Rustaceans say “crate”, they mean library crate, and they use “crate”<br/>interchangeably with the general programming concept of a “library&#34;.<br/>
The&#160;<i>crate root</i>&#160;is a source&#160;ﬁle that the Rust compiler starts from and makes up the root<br/><a href="https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html">module of your crate (we’ll explain modules in depth in the&#160;“Deﬁning Modules to Control<br/>Scope and Privacy”&#160;section).</a><br/>
A&#160;<i>package</i>&#160;is a bundle of one or more crates that provides a set of functionality. A package<br/>contains a&#160;<i>Cargo.toml</i>&#160;ﬁle that describes how to build those crates. Cargo is actually a<br/>package that contains the binary crate for the command-line tool you’ve been using to build<br/>your code. The Cargo package also contains a library crate that the binary crate depends on.<br/>Other projects can depend on the Cargo library crate to use the same logic the Cargo<br/>command-line tool uses.<br/>
A package can contain as many binary crates as you like, but at most only one library crate.<br/>A package must contain at least one crate, whether that’s a library or binary crate.<br/>
Let’s walk through what happens when we create a package. First, we enter the command<br/>
cargo&#160;new&#160;:<br/>
https://doc.rust-lang.org/book/print.html<br/>
148/627<br/>
<hr/>
<a name=149></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;new&#160;my-project<br/>&#160;&#160;&#160;&#160;&#160;Created&#160;binary&#160;(application)&#160;`my-project`&#160;package<br/>$&#160;ls&#160;my-project<br/>Cargo.toml<br/>src<br/>$&#160;ls&#160;my-project/src<br/>main.rs<br/>
After we run&#160;&#160;cargo&#160;new&#160;, we use&#160;&#160;ls&#160;&#160;to see what Cargo creates. In the project directory,<br/>there’s a&#160;<i>Cargo.toml</i>&#160;ﬁle, giving us a package. There’s also a&#160;<i>src</i>&#160;directory that contains<br/><i>main.rs</i>. Open&#160;<i>Cargo.toml</i>&#160;in your text editor, and note there’s no mention of&#160;<i>src/main.rs</i>.<br/>Cargo follows a convention that&#160;<i>src/main.rs</i>&#160;is the crate root of a binary crate with the same<br/>name as the package. Likewise, Cargo knows that if the package directory contains&#160;<i>src/lib.rs</i>,<br/>the package contains a library crate with the same name as the package, and&#160;<i>src/lib.rs</i>&#160;is its<br/>crate root. Cargo passes the crate root&#160;ﬁles to&#160;&#160;rustc&#160;&#160;to build the library or binary.<br/>
Here, we have a package that only contains&#160;<i>src/main.rs</i>, meaning it only contains a binary<br/>crate named&#160;&#160;my-project&#160;. If a package contains&#160;<i>src/main.rs</i>&#160;and&#160;<i>src/lib.rs</i>, it has two crates: a<br/>binary and a library, both with the same name as the package. A package can have multiple<br/>binary crates by placing&#160;ﬁles in the&#160;<i>src/bin</i>&#160;directory: each&#160;ﬁle will be a separate binary crate.<br/>
https://doc.rust-lang.org/book/print.html<br/>
149/627<br/>
<hr/>
<a name=150></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#150"><b>Deﬁning Modules to Control Scope and Privacy</b></a><br/>
In this section, we’ll talk about modules and other parts of the module system, namely&#160;<i>paths<br/></i>that allow you to name items; the&#160;&#160;use&#160;&#160;keyword that brings a path into scope; and the&#160;&#160;pub<br/>keyword to make items public. We’ll also discuss the&#160;&#160;as&#160;&#160;keyword, external packages, and<br/>the glob operator.<br/>
First, we’re going to start with a list of rules for easy reference when you’re organizing your<br/>code in the future. Then we’ll explain each of the rules in detail.<br/>
<a href="tests.html#150"><b>Modules&#160;Cheat&#160;Sheet</b></a><br/>
Here we provide a quick reference on how modules, paths, the&#160;&#160;use&#160;&#160;keyword, and the&#160;&#160;pub<br/>keyword work in the compiler, and how most developers organize their code. We’ll be going<br/>through examples of each of these rules throughout this chapter, but this is a great place to<br/>refer to as a reminder of how modules work.<br/>
<b>Start from the crate root</b>: When compiling a crate, the compiler&#160;ﬁrst looks in the<br/>crate root&#160;ﬁle (usually&#160;<i>src/lib.rs</i>&#160;for a library crate or&#160;<i>src/main.rs</i>&#160;for a binary crate) for<br/>code to compile.<br/><b>Declaring modules</b>: In the crate root&#160;ﬁle, you can declare new modules; say, you<br/>declare a “garden” module with&#160;&#160;mod&#160;garden;&#160;. The compiler will look for the module’s<br/>code in these places:<br/>
Inline, within curly brackets that replace the semicolon following&#160;&#160;mod&#160;garden<br/>In the&#160;ﬁle&#160;<i>src/garden.rs<br/></i>In the&#160;ﬁle&#160;<i>src/garden/mod.rs</i><br/>
<b>Declaring submodules</b>: In any&#160;ﬁle other than the crate root, you can declare<br/>submodules. For example, you might declare&#160;&#160;mod&#160;vegetables;&#160;&#160;in&#160;<i>src/garden.rs</i>. The<br/>compiler will look for the submodule’s code within the directory named for the parent<br/>module in these places:<br/>
Inline, directly following&#160;&#160;mod&#160;vegetables&#160;, within curly brackets instead of the<br/>semicolon<br/>In the&#160;ﬁle&#160;<i>src/garden/vegetables.rs<br/></i>In the&#160;ﬁle&#160;<i>src/garden/vegetables/mod.rs</i><br/>
<b>Paths to code in modules</b>: Once a module is part of your crate, you can refer to code<br/>in that module from anywhere else in that same crate, as long as the privacy rules<br/>allow, using the path to the code. For example, an&#160;&#160;Asparagus&#160;&#160;type in the garden<br/>vegetables module would be found at&#160;&#160;crate::garden::vegetables::Asparagus&#160;.<br/><b>Private vs public</b>: Code within a module is private from its parent modules by default.<br/>To make a module public, declare it with&#160;&#160;pub&#160;mod&#160;&#160;instead of&#160;&#160;mod&#160;. To make items<br/>within a public module public as well, use&#160;&#160;pub&#160;&#160;before their declarations.<br/>
https://doc.rust-lang.org/book/print.html<br/>
150/627<br/>
<hr/>
<a name=151></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>The&#160;&#160;</b>use&#160;<b>&#160;keyword</b>: Within a scope, the&#160;&#160;use&#160;&#160;keyword creates shortcuts to items to<br/>reduce repetition of long paths. In any scope that can refer to<br/>
crate::garden::vegetables::Asparagus&#160;, you can create a shortcut with&#160;&#160;use&#160;<br/>
crate::garden::vegetables::Asparagus;&#160;&#160;and from then on you only need to write<br/>
Asparagus&#160;&#160;to make use of that type in the scope.<br/>
Here we create a binary crate named&#160;&#160;backyard&#160;&#160;that illustrates these rules. The crate’s<br/>directory, also named&#160;&#160;backyard&#160;, contains these&#160;ﬁles and directories:<br/>
backyard<br/>├──&#160;Cargo.lock<br/>├──&#160;Cargo.toml<br/>└──&#160;src<br/>&#160;&#160;&#160;&#160;├──&#160;garden<br/>&#160;&#160;&#160;&#160;│  &#160;└──&#160;vegetables.rs<br/>&#160;&#160;&#160;&#160;├──&#160;garden.rs<br/>&#160;&#160;&#160;&#160;└──&#160;main.rs<br/>
The crate root&#160;ﬁle in this case is&#160;<i>src/main.rs</i>, and it contains:<br/>
Filename: src/main.rs<br/>
use&#160;crate::garden::vegetables::Asparagus;<br/>
pub&#160;mod&#160;garden;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;plant&#160;=&#160;Asparagus&#160;{};<br/>&#160;&#160;&#160;&#160;println!(&#34;I'm&#160;growing&#160;{:?}!&#34;,&#160;plant);<br/>}<br/>
The&#160;&#160;pub&#160;mod&#160;garden;&#160;&#160;line tells the compiler to include the code it&#160;ﬁnds in&#160;<i>src/garden.rs</i>,<br/>which is:<br/>
Filename: src/garden.rs<br/>
pub&#160;mod&#160;vegetables;<br/>
Here,&#160;&#160;pub&#160;mod&#160;vegetables;&#160;&#160;means the code in&#160;<i>src/garden/vegetables.rs</i>&#160;is included too. That<br/>code is:<br/>
#[derive(Debug)]<br/>pub&#160;struct&#160;Asparagus&#160;{}<br/>
Now let’s get into the details of these rules and demonstrate them in action!<br/>
https://doc.rust-lang.org/book/print.html<br/>
151/627<br/>
<hr/>
<a name=152></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#152"><b>Grouping&#160;Related&#160;Code&#160;in&#160;Modules</b></a><br/>
<i>Modules</i>&#160;let us organize code within a crate for readability and easy reuse. Modules also<br/>allow us to control the&#160;<i>privacy</i>&#160;of items, because code within a module is private by default.<br/>Private items are internal implementation details not available for outside use. We can<br/>choose to make modules and the items within them public, which exposes them to allow<br/>external code to use and depend on them.<br/>
As an example, let’s write a library crate that provides the functionality of a restaurant. We’ll<br/>deﬁne the signatures of functions but leave their bodies empty to concentrate on the<br/>organization of the code, rather than the implementation of a restaurant.<br/>
In the restaurant industry, some parts of a restaurant are referred to as&#160;<i>front of house</i>&#160;and<br/>others as&#160;<i>back of house</i>. Front of house is where customers are; this encompasses where<br/>the hosts seat customers, servers take orders and payment, and bartenders make drinks.<br/>Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and<br/>managers do administrative work.<br/>
To structure our crate in this way, we can organize its functions into nested modules. Create<br/>a new library named&#160;&#160;restaurant&#160;&#160;by running&#160;&#160;cargo&#160;new&#160;restaurant&#160;--lib&#160;; then enter the<br/>code in Listing 7-1 into&#160;<i>src/lib.rs</i>&#160;to deﬁne some modules and function signatures. Here’s the<br/>front of house section:<br/>
Filename: src/lib.rs<br/>
mod&#160;front_of_house&#160;{<br/>&#160;&#160;&#160;&#160;mod&#160;hosting&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;add_to_waitlist()&#160;{}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;seat_at_table()&#160;{}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;mod&#160;serving&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;take_order()&#160;{}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;serve_order()&#160;{}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;take_payment()&#160;{}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;7-1:&#160;A&#160;&#160;</b>front_of_house&#160;<b>&#160;module&#160;containing&#160;other&#160;modules&#160;that&#160;then&#160;contain&#160;functions</b><br/>
We deﬁne a module with the&#160;&#160;mod&#160;&#160;keyword followed by the name of the module (in this<br/>case,&#160;&#160;front_of_house&#160;). The body of the module then goes inside curly brackets. Inside<br/>modules, we can place other modules, as in this case with the modules&#160;&#160;hosting&#160;&#160;and<br/>
serving&#160;. Modules can also hold deﬁnitions for other items, such as structs, enums,<br/>
constants, traits, and—as in Listing 7-1—functions.<br/>
https://doc.rust-lang.org/book/print.html<br/>
152/627<br/>
<hr/>
<a name=153></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
By using modules, we can group related deﬁnitions together and name why they’re related.<br/>Programmers using this code can navigate the code based on the groups rather than having<br/>to read through all the deﬁnitions, making it easier to&#160;ﬁnd the deﬁnitions relevant to them.<br/>Programmers adding new functionality to this code would know where to place the code to<br/>keep the program organized.<br/>
Earlier, we mentioned that&#160;<i>src/main.rs</i>&#160;and&#160;<i>src/lib.rs</i>&#160;are called crate roots. The reason for<br/>their name is that the contents of either of these two&#160;ﬁles form a module named&#160;&#160;crate&#160;&#160;at<br/>the root of the crate’s module structure, known as the&#160;<i>module tree</i>.<br/>
Listing 7-2 shows the module tree for the structure in Listing 7-1.<br/>
crate<br/>&#160;└──&#160;front_of_house<br/>&#160;&#160;&#160;&#160;&#160;├──&#160;hosting<br/>&#160;&#160;&#160;&#160;&#160;│&#160;&#160;&#160;├──&#160;add_to_waitlist<br/>&#160;&#160;&#160;&#160;&#160;│&#160;&#160;&#160;└──&#160;seat_at_table<br/>&#160;&#160;&#160;&#160;&#160;└──&#160;serving<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;├──&#160;take_order<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;├──&#160;serve_order<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──&#160;take_payment<br/>
<b>Listing&#160;7-2:&#160;The&#160;module&#160;tree&#160;for&#160;the&#160;code&#160;in&#160;Listing&#160;7-1</b><br/>
This tree shows how some of the modules nest inside one another; for example,&#160;&#160;hosting<br/>nests inside&#160;&#160;front_of_house&#160;. The tree also shows that some modules are&#160;<i>siblings</i>&#160;to each<br/>other, meaning they’re deﬁned in the same module;&#160;&#160;hosting&#160;&#160;and&#160;&#160;serving&#160;&#160;are siblings<br/>deﬁned within&#160;&#160;front_of_house&#160;. If module A is contained inside module B, we say that<br/>module A is the&#160;<i>child</i>&#160;of module B and that module B is the&#160;<i>parent</i>&#160;of module A. Notice that<br/>the entire module tree is rooted under the implicit module named&#160;&#160;crate&#160;.<br/>
The module tree might remind you of the&#160;ﬁlesystem’s directory tree on your computer; this<br/>is a very apt comparison! Just like directories in a&#160;ﬁlesystem, you use modules to organize<br/>your code. And just like&#160;ﬁles in a directory, we need a way to&#160;ﬁnd our modules.<br/>
https://doc.rust-lang.org/book/print.html<br/>
153/627<br/>
<hr/>
<a name=154></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#154"><b>Paths for Referring to an Item in the Module Tree</b></a><br/>
To show Rust where to&#160;ﬁnd an item in a module tree, we use a path in the same way we use<br/>a path when navigating a&#160;ﬁlesystem. To call a function, we need to know its path.<br/>
A path can take two forms:<br/>
An&#160;<i>absolute path</i>&#160;is the full path starting from a crate root; for code from an external<br/>crate, the absolute path begins with the crate name, and for code from the current<br/>crate, it starts with the literal&#160;&#160;crate&#160;.<br/>A&#160;<i>relative path</i>&#160;starts from the current module and uses&#160;&#160;self&#160;,&#160;&#160;super&#160;, or an identiﬁer<br/>in the current module.<br/>
Both absolute and relative paths are followed by one or more identiﬁers separated by<br/>double colons (&#160;::&#160;).<br/>
Returning to Listing 7-1, say we want to call the&#160;&#160;add_to_waitlist&#160;&#160;function. This is the same<br/>as asking: what’s the path of the&#160;&#160;add_to_waitlist&#160;&#160;function? Listing 7-3 contains Listing 7-1<br/>with some of the modules and functions removed.<br/>
We’ll show two ways to call the&#160;&#160;add_to_waitlist&#160;&#160;function from a new function<br/>
eat_at_restaurant&#160;&#160;deﬁned in the crate root. These paths are correct, but there’s another<br/>
problem remaining that will prevent this example from compiling as-is. We’ll explain why in<br/>a bit.<br/>
The&#160;&#160;eat_at_restaurant&#160;&#160;function is part of our library crate’s public API, so we mark it with<br/>the&#160;&#160;pub&#160;&#160;keyword. In the&#160;<a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">“Exposing Paths with the&#160;&#160;pub&#160;&#160;Keyword”&#160;section, we’ll go into more<br/></a>detail about&#160;&#160;pub&#160;.<br/>
Filename: src/lib.rs<br/>
mod&#160;front_of_house&#160;{<br/>&#160;&#160;&#160;&#160;mod&#160;hosting&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;add_to_waitlist()&#160;{}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
pub&#160;fn&#160;eat_at_restaurant()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;Absolute&#160;path<br/>&#160;&#160;&#160;&#160;crate::front_of_house::hosting::add_to_waitlist();<br/>
&#160;&#160;&#160;&#160;//&#160;Relative&#160;path<br/>&#160;&#160;&#160;&#160;front_of_house::hosting::add_to_waitlist();<br/>}<br/>
<b>Listing&#160;7-3:&#160;Calling&#160;the&#160;&#160;</b>add_to_waitlist&#160;<b>&#160;function&#160;using&#160;absolute&#160;and&#160;relative&#160;paths</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
154/627<br/>
<hr/>
<a name=155></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The&#160;ﬁrst time we call the&#160;&#160;add_to_waitlist&#160;&#160;function in&#160;&#160;eat_at_restaurant&#160;, we use an<br/>absolute path. The&#160;&#160;add_to_waitlist&#160;&#160;function is deﬁned in the same crate as<br/>
eat_at_restaurant&#160;, which means we can use the&#160;&#160;crate&#160;&#160;keyword to start an absolute<br/>
path. We then include each of the successive modules until we make our way to<br/>
add_to_waitlist&#160;. You can imagine a&#160;ﬁlesystem with the same structure: we’d specify the<br/>
path&#160;&#160;/front_of_house/hosting/add_to_waitlist&#160;&#160;to run the&#160;&#160;add_to_waitlist&#160;&#160;program;<br/>using the&#160;&#160;crate&#160;&#160;name to start from the crate root is like using&#160;&#160;/&#160;&#160;to start from the<br/>ﬁlesystem root in your shell.<br/>
The second time we call&#160;&#160;add_to_waitlist&#160;&#160;in&#160;&#160;eat_at_restaurant&#160;, we use a relative path.<br/>The path starts with&#160;&#160;front_of_house&#160;, the name of the module deﬁned at the same level of<br/>the module tree as&#160;&#160;eat_at_restaurant&#160;. Here the&#160;ﬁlesystem equivalent would be using the<br/>path&#160;&#160;front_of_house/hosting/add_to_waitlist&#160;. Starting with a module name means that<br/>the path is relative.<br/>
Choosing whether to use a relative or absolute path is a decision you’ll make based on your<br/>project, and depends on whether you’re more likely to move item deﬁnition code separately<br/>from or together with the code that uses the item. For example, if we move the<br/>
front_of_house&#160;&#160;module and the&#160;&#160;eat_at_restaurant&#160;&#160;function into a module named<br/>customer_experience&#160;, we’d need to update the absolute path to&#160;&#160;add_to_waitlist&#160;, but the<br/>
relative path would still be valid. However, if we moved the&#160;&#160;eat_at_restaurant&#160;&#160;function<br/>separately into a module named&#160;&#160;dining&#160;, the absolute path to the&#160;&#160;add_to_waitlist&#160;&#160;call<br/>would stay the same, but the relative path would need to be updated. Our preference in<br/>general is to specify absolute paths because it’s more likely we’ll want to move code<br/>deﬁnitions and item calls independently of each other.<br/>
Let’s try to compile Listing 7-3 and&#160;ﬁnd out why it won’t compile yet! The error we get is<br/>shown in Listing 7-4.<br/>
https://doc.rust-lang.org/book/print.html<br/>
155/627<br/>
<hr/>
<a name=156></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;Compiling&#160;restaurant&#160;v0.1.0&#160;(file:///projects/restaurant)<br/>error[E0603]:&#160;module&#160;`hosting`&#160;is&#160;private<br/>&#160;--&gt;&#160;src/lib.rs:9:28<br/>&#160;&#160;|<br/>9&#160;|&#160;&#160;&#160;&#160;&#160;crate::front_of_house::hosting::add_to_waitlist();<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^&#160;private&#160;module<br/>&#160;&#160;|<br/>note:&#160;the&#160;module&#160;`hosting`&#160;is&#160;defined&#160;here<br/>&#160;--&gt;&#160;src/lib.rs:2:5<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;mod&#160;hosting&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^<br/>
error[E0603]:&#160;module&#160;`hosting`&#160;is&#160;private<br/>&#160;&#160;--&gt;&#160;src/lib.rs:12:21<br/>&#160;&#160;&#160;|<br/>12&#160;|&#160;&#160;&#160;&#160;&#160;front_of_house::hosting::add_to_waitlist();<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^&#160;private&#160;module<br/>&#160;&#160;&#160;|<br/>note:&#160;the&#160;module&#160;`hosting`&#160;is&#160;defined&#160;here<br/>&#160;&#160;--&gt;&#160;src/lib.rs:2:5<br/>&#160;&#160;&#160;|<br/>2&#160;&#160;|&#160;&#160;&#160;&#160;&#160;mod&#160;hosting&#160;{<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0603`.<br/>error:&#160;could&#160;not&#160;compile&#160;`restaurant`&#160;due&#160;to&#160;2&#160;previous&#160;errors<br/>
<b>Listing&#160;7-4:&#160;Compiler&#160;errors&#160;from&#160;building&#160;the&#160;code&#160;in&#160;Listing&#160;7-3</b><br/>
The error messages say that module&#160;&#160;hosting&#160;&#160;is private. In other words, we have the<br/>correct paths for the&#160;&#160;hosting&#160;&#160;module and the&#160;&#160;add_to_waitlist&#160;&#160;function, but Rust won’t<br/>let us use them because it doesn’t have access to the private sections. In Rust, all items<br/>(functions, methods, structs, enums, modules, and constants) are private to parent modules<br/>by default. If you want to make an item like a function or struct private, you put it in a<br/>module.<br/>
Items in a parent module can’t use the private items inside child modules, but items in child<br/>modules can use the items in their ancestor modules. This is because child modules wrap<br/>and hide their implementation details, but the child modules can see the context in which<br/>they’re deﬁned. To continue with our metaphor, think of the privacy rules as being like the<br/>back oﬃce of a restaurant: what goes on in there is private to restaurant customers, but<br/>oﬃce managers can see and do everything in the restaurant they operate.<br/>
Rust chose to have the module system function this way so that hiding inner<br/>implementation details is the default. That way, you know which parts of the inner code you<br/>can change without breaking outer code. However, Rust does give you the option to expose<br/>inner parts of child modules’ code to outer ancestor modules by using the&#160;&#160;pub&#160;&#160;keyword to<br/>make an item public.<br/>
https://doc.rust-lang.org/book/print.html<br/>
156/627<br/>
<hr/>
<a name=157></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#157"><b>Exposing&#160;Paths&#160;with&#160;the&#160;</b>pub<b>&#160;Keyword</b></a><br/>
Let’s return to the error in Listing 7-4 that told us the&#160;&#160;hosting&#160;&#160;module is private. We want<br/>the&#160;&#160;eat_at_restaurant&#160;&#160;function in the parent module to have access to the<br/>
add_to_waitlist&#160;&#160;function in the child module, so we mark the&#160;&#160;hosting&#160;&#160;module with the<br/>pub&#160;&#160;keyword, as shown in Listing 7-5.<br/>
Filename: src/lib.rs<br/>
mod&#160;front_of_house&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;mod&#160;hosting&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;add_to_waitlist()&#160;{}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
pub&#160;fn&#160;eat_at_restaurant()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;Absolute&#160;path<br/>&#160;&#160;&#160;&#160;crate::front_of_house::hosting::add_to_waitlist();<br/>
&#160;&#160;&#160;&#160;//&#160;Relative&#160;path<br/>&#160;&#160;&#160;&#160;front_of_house::hosting::add_to_waitlist();<br/>}<br/>
<b>Listing&#160;7-5:&#160;Declaring&#160;the&#160;&#160;</b>hosting&#160;<b>&#160;module&#160;as&#160;&#160;</b>pub&#160;<b>&#160;to&#160;use&#160;it&#160;from&#160;&#160;</b>eat_at_restaurant<br/>
Unfortunately, the code in Listing 7-5 still results in an error, as shown in Listing 7-6.<br/>
https://doc.rust-lang.org/book/print.html<br/>
157/627<br/>
<hr/>
<a name=158></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;Compiling&#160;restaurant&#160;v0.1.0&#160;(file:///projects/restaurant)<br/>error[E0603]:&#160;function&#160;`add_to_waitlist`&#160;is&#160;private<br/>&#160;--&gt;&#160;src/lib.rs:9:37<br/>&#160;&#160;|<br/>9&#160;|&#160;&#160;&#160;&#160;&#160;crate::front_of_house::hosting::add_to_waitlist();<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^&#160;private&#160;function<br/>&#160;&#160;|<br/>note:&#160;the&#160;function&#160;`add_to_waitlist`&#160;is&#160;defined&#160;here<br/>&#160;--&gt;&#160;src/lib.rs:3:9<br/>&#160;&#160;|<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;add_to_waitlist()&#160;{}<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^^^^^<br/>
error[E0603]:&#160;function&#160;`add_to_waitlist`&#160;is&#160;private<br/>&#160;&#160;--&gt;&#160;src/lib.rs:12:30<br/>&#160;&#160;&#160;|<br/>12&#160;|&#160;&#160;&#160;&#160;&#160;front_of_house::hosting::add_to_waitlist();<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^&#160;private&#160;function<br/>&#160;&#160;&#160;|<br/>note:&#160;the&#160;function&#160;`add_to_waitlist`&#160;is&#160;defined&#160;here<br/>&#160;&#160;--&gt;&#160;src/lib.rs:3:9<br/>&#160;&#160;&#160;|<br/>3&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;add_to_waitlist()&#160;{}<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^^^^^<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0603`.<br/>error:&#160;could&#160;not&#160;compile&#160;`restaurant`&#160;due&#160;to&#160;2&#160;previous&#160;errors<br/>
<b>Listing&#160;7-6:&#160;Compiler&#160;errors&#160;from&#160;building&#160;the&#160;code&#160;in&#160;Listing&#160;7-5</b><br/>
What happened? Adding the&#160;&#160;pub&#160;&#160;keyword in front of&#160;&#160;mod&#160;hosting&#160;&#160;makes the module<br/>public. With this change, if we can access&#160;&#160;front_of_house&#160;, we can access&#160;&#160;hosting&#160;. But the<br/><i>contents</i>&#160;of&#160;&#160;hosting&#160;&#160;are still private; making the module public doesn’t make its contents<br/>public. The&#160;&#160;pub&#160;&#160;keyword on a module only lets code in its ancestor modules refer to it, not<br/>access its inner code. Because modules are containers, there’s not much we can do by only<br/>making the module public; we need to go further and choose to make one or more of the<br/>items within the module public as well.<br/>
The errors in Listing 7-6 say that the&#160;&#160;add_to_waitlist&#160;&#160;function is private. The privacy rules<br/>apply to structs, enums, functions, and methods as well as modules.<br/>
Let’s also make the&#160;&#160;add_to_waitlist&#160;&#160;function public by adding the&#160;&#160;pub&#160;&#160;keyword before its<br/>deﬁnition, as in Listing 7-7.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
158/627<br/>
<hr/>
<a name=159></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
mod&#160;front_of_house&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;mod&#160;hosting&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pub&#160;fn&#160;add_to_waitlist()&#160;{}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
pub&#160;fn&#160;eat_at_restaurant()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;Absolute&#160;path<br/>&#160;&#160;&#160;&#160;crate::front_of_house::hosting::add_to_waitlist();<br/>
&#160;&#160;&#160;&#160;//&#160;Relative&#160;path<br/>&#160;&#160;&#160;&#160;front_of_house::hosting::add_to_waitlist();<br/>}<br/>
<b>Listing&#160;7-7:&#160;Adding&#160;the&#160;&#160;</b>pub&#160;<b>&#160;keyword&#160;to&#160;&#160;</b>mod&#160;hosting&#160;<b>&#160;and&#160;&#160;</b>fn&#160;add_to_waitlist&#160;<b>&#160;lets&#160;us&#160;call&#160;the&#160;function&#160;from</b><br/>
eat_at_restaurant<br/>
Now the code will compile! To see why adding the&#160;&#160;pub&#160;&#160;keyword lets us use these paths in<br/>
add_to_waitlist&#160;&#160;with respect to the privacy rules, let’s look at the absolute and the relative<br/>
paths.<br/>
In the absolute path, we start with&#160;&#160;crate&#160;, the root of our crate’s module tree. The<br/>
front_of_house&#160;&#160;module is deﬁned in the crate root. While&#160;&#160;front_of_house&#160;&#160;isn’t public,<br/>
because the&#160;&#160;eat_at_restaurant&#160;&#160;function is deﬁned in the same module as<br/>
front_of_house&#160;&#160;(that is,&#160;&#160;eat_at_restaurant&#160;&#160;and&#160;&#160;front_of_house&#160;&#160;are siblings), we can<br/>
refer to&#160;&#160;front_of_house&#160;&#160;from&#160;&#160;eat_at_restaurant&#160;. Next is the&#160;&#160;hosting&#160;&#160;module marked<br/>with&#160;&#160;pub&#160;. We can access the parent module of&#160;&#160;hosting&#160;, so we can access&#160;&#160;hosting&#160;. Finally,<br/>the&#160;&#160;add_to_waitlist&#160;&#160;function is marked with&#160;&#160;pub&#160;&#160;and we can access its parent module, so<br/>this function call works!<br/>
In the relative path, the logic is the same as the absolute path except for the&#160;ﬁrst step:<br/>rather than starting from the crate root, the path starts from&#160;&#160;front_of_house&#160;. The<br/>
front_of_house&#160;&#160;module is deﬁned within the same module as&#160;&#160;eat_at_restaurant&#160;, so the<br/>
relative path starting from the module in which&#160;&#160;eat_at_restaurant&#160;&#160;is deﬁned works. Then,<br/>because&#160;&#160;hosting&#160;&#160;and&#160;&#160;add_to_waitlist&#160;&#160;are marked with&#160;&#160;pub&#160;, the rest of the path works,<br/>and this function call is valid!<br/>
If you plan on sharing your library crate so other projects can use your code, your public API<br/>is your contract with users of your crate that determines how they can interact with your<br/>code. There are many considerations around managing changes to your public API to make<br/>it easier for people to depend on your crate. These considerations are out of the scope of<br/>this book; if you’re interested in this topic, see&#160;<a href="https://rust-lang.github.io/api-guidelines/">The Rust API Guidelines.</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
159/627<br/>
<hr/>
<a name=160></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#160"><b>Best Practices for Packages with a Binary and a Library</b></a><br/>
We mentioned a package can contain both a&#160;<i>src/main.rs</i>&#160;binary crate root as well as a<br/><i>src/lib.rs</i>&#160;library crate root, and both crates will have the package name by default.<br/>Typically, packages with this pattern of containing both a library and a binary crate will<br/>have just enough code in the binary crate to start an executable that calls code with<br/>the library crate. This lets other projects beneﬁt from the most functionality that the<br/>package provides, because the library crate’s code can be shared.<br/>
The module tree should be deﬁned in&#160;<i>src/lib.rs</i>. Then, any public items can be used in<br/>the binary crate by starting paths with the name of the package. The binary crate<br/>becomes a user of the library crate just like a completely external crate would use the<br/>library crate: it can only use the public API. This helps you design a good API; not only<br/>are you the author, you’re also a client!<br/>
<a href="https://doc.rust-lang.org/book/ch12-00-an-io-project.html">In&#160;Chapter 12, we’ll demonstrate this organizational practice with a command-line<br/></a>program that will contain both a binary crate and a library crate.<br/>
<a href="tests.html#160"><b>Starting&#160;Relative&#160;Paths&#160;with&#160;</b>super</a><br/>
We can construct relative paths that begin in the parent module, rather than the current<br/>module or the crate root, by using&#160;&#160;super&#160;&#160;at the start of the path. This is like starting a<br/>ﬁlesystem path with the&#160;&#160;..&#160;&#160;syntax. Using&#160;&#160;super&#160;&#160;allows us to reference an item that we<br/>know is in the parent module, which can make rearranging the module tree easier when the<br/>module is closely related to the parent, but the parent might be moved elsewhere in the<br/>module tree someday.<br/>
Consider the code in Listing 7-8 that models the situation in which a chef&#160;ﬁxes an incorrect<br/>order and personally brings it out to the customer. The function&#160;&#160;fix_incorrect_order<br/>deﬁned in the&#160;&#160;back_of_house&#160;&#160;module calls the function&#160;&#160;deliver_order&#160;&#160;deﬁned in the<br/>parent module by specifying the path to&#160;&#160;deliver_order&#160;&#160;starting with&#160;&#160;super&#160;:<br/>
Filename: src/lib.rs<br/>
fn&#160;deliver_order()&#160;{}<br/>
mod&#160;back_of_house&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;fix_incorrect_order()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cook_order();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;super::deliver_order();<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;fn&#160;cook_order()&#160;{}<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
160/627<br/>
<hr/>
<a name=161></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Listing&#160;7-8:&#160;Calling&#160;a&#160;function&#160;using&#160;a&#160;relative&#160;path&#160;starting&#160;with&#160;&#160;</b>super<br/>
The&#160;&#160;fix_incorrect_order&#160;&#160;function is in the&#160;&#160;back_of_house&#160;&#160;module, so we can use&#160;&#160;super<br/>to go to the parent module of&#160;&#160;back_of_house&#160;, which in this case is&#160;&#160;crate&#160;, the root. From<br/>there, we look for&#160;&#160;deliver_order&#160;&#160;and&#160;ﬁnd it. Success! We think the&#160;&#160;back_of_house&#160;&#160;module<br/>and the&#160;&#160;deliver_order&#160;&#160;function are likely to stay in the same relationship to each other<br/>and get moved together should we decide to reorganize the crate’s module tree. Therefore,<br/>we used&#160;&#160;super&#160;&#160;so we’ll have fewer places to update code in the future if this code gets<br/>moved to a diﬀerent module.<br/>
<a href="tests.html#161"><b>Making&#160;Structs&#160;and&#160;Enums&#160;Public</b></a><br/>
We can also use&#160;&#160;pub&#160;&#160;to designate structs and enums as public, but there are a few details<br/>extra to the usage of&#160;&#160;pub&#160;&#160;with structs and enums. If we use&#160;&#160;pub&#160;&#160;before a struct deﬁnition,<br/>we make the struct public, but the struct’s&#160;ﬁelds will still be private. We can make each&#160;ﬁeld<br/>public or not on a case-by-case basis. In Listing 7-9, we’ve deﬁned a public<br/>
back_of_house::Breakfast&#160;&#160;struct with a public&#160;&#160;toast&#160;&#160;ﬁeld but a private&#160;&#160;seasonal_fruit<br/>
ﬁeld. This models the case in a restaurant where the customer can pick the type of bread<br/>that comes with a meal, but the chef decides which fruit accompanies the meal based on<br/>what’s in season and in stock. The available fruit changes quickly, so customers can’t choose<br/>the fruit or even see which fruit they’ll get.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
161/627<br/>
<hr/>
<a name=162></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
mod&#160;back_of_house&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;struct&#160;Breakfast&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pub&#160;toast:&#160;String,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;seasonal_fruit:&#160;String,<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;impl&#160;Breakfast&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pub&#160;fn&#160;summer(toast:&#160;&amp;str)&#160;-&gt;&#160;Breakfast&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Breakfast&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;toast:&#160;String::from(toast),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;seasonal_fruit:&#160;String::from(&#34;peaches&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
pub&#160;fn&#160;eat_at_restaurant()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;Order&#160;a&#160;breakfast&#160;in&#160;the&#160;summer&#160;with&#160;Rye&#160;toast<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;meal&#160;=&#160;back_of_house::Breakfast::summer(&#34;Rye&#34;);<br/>&#160;&#160;&#160;&#160;//&#160;Change&#160;our&#160;mind&#160;about&#160;what&#160;bread&#160;we'd&#160;like<br/>&#160;&#160;&#160;&#160;meal.toast&#160;=&#160;String::from(&#34;Wheat&#34;);<br/>&#160;&#160;&#160;&#160;println!(&#34;I'd&#160;like&#160;{}&#160;toast&#160;please&#34;,&#160;meal.toast);<br/>
&#160;&#160;&#160;&#160;//&#160;The&#160;next&#160;line&#160;won't&#160;compile&#160;if&#160;we&#160;uncomment&#160;it;&#160;we're&#160;not&#160;allowed<br/>&#160;&#160;&#160;&#160;//&#160;to&#160;see&#160;or&#160;modify&#160;the&#160;seasonal&#160;fruit&#160;that&#160;comes&#160;with&#160;the&#160;meal<br/>&#160;&#160;&#160;&#160;//&#160;meal.seasonal_fruit&#160;=&#160;String::from(&#34;blueberries&#34;);<br/>}<br/>
<b>Listing&#160;7-9:&#160;A&#160;struct&#160;with&#160;some&#160;public&#160;ﬁelds&#160;and&#160;some&#160;private&#160;ﬁelds</b><br/>
Because the&#160;&#160;toast&#160;&#160;ﬁeld in the&#160;&#160;back_of_house::Breakfast&#160;&#160;struct is public, in<br/>
eat_at_restaurant&#160;&#160;we can write and read to the&#160;&#160;toast&#160;&#160;ﬁeld using dot notation. Notice<br/>
that we can’t use the&#160;&#160;seasonal_fruit&#160;&#160;ﬁeld in&#160;&#160;eat_at_restaurant&#160;&#160;because<br/>
seasonal_fruit&#160;&#160;is private. Try uncommenting the line modifying the&#160;&#160;seasonal_fruit&#160;&#160;ﬁeld<br/>
value to see what error you get!<br/>
Also, note that because&#160;&#160;back_of_house::Breakfast&#160;&#160;has a private&#160;ﬁeld, the struct needs to<br/>provide a public associated function that constructs an instance of&#160;&#160;Breakfast&#160;&#160;(we’ve<br/>named it&#160;&#160;summer&#160;&#160;here). If&#160;&#160;Breakfast&#160;&#160;didn’t have such a function, we couldn’t create an<br/>instance of&#160;&#160;Breakfast&#160;&#160;in&#160;&#160;eat_at_restaurant&#160;&#160;because we couldn’t set the value of the<br/>private&#160;&#160;seasonal_fruit&#160;&#160;ﬁeld in&#160;&#160;eat_at_restaurant&#160;.<br/>
In contrast, if we make an enum public, all of its variants are then public. We only need the<br/>
pub&#160;&#160;before the&#160;&#160;enum&#160;&#160;keyword, as shown in Listing 7-10.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
162/627<br/>
<hr/>
<a name=163></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
mod&#160;back_of_house&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;enum&#160;Appetizer&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Soup,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Salad,<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
pub&#160;fn&#160;eat_at_restaurant()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;order1&#160;=&#160;back_of_house::Appetizer::Soup;<br/>&#160;&#160;&#160;&#160;let&#160;order2&#160;=&#160;back_of_house::Appetizer::Salad;<br/>}<br/>
<b>Listing&#160;7-10:&#160;Designating&#160;an&#160;enum&#160;as&#160;public&#160;makes&#160;all&#160;its&#160;variants&#160;public</b><br/>
Because we made the&#160;&#160;Appetizer&#160;&#160;enum public, we can use the&#160;&#160;Soup&#160;&#160;and&#160;&#160;Salad&#160;&#160;variants in<br/>
eat_at_restaurant&#160;.<br/>
Enums aren’t very useful unless their variants are public; it would be annoying to have to<br/>annotate all enum variants with&#160;&#160;pub&#160;&#160;in every case, so the default for enum variants is to be<br/>public. Structs are often useful without their&#160;ﬁelds being public, so struct&#160;ﬁelds follow the<br/>general rule of everything being private by default unless annotated with&#160;&#160;pub&#160;.<br/>
There’s one more situation involving&#160;&#160;pub&#160;&#160;that we haven’t covered, and that is our last<br/>module system feature: the&#160;&#160;use&#160;&#160;keyword. We’ll cover&#160;&#160;use&#160;&#160;by itself&#160;ﬁrst, and then we’ll<br/>show how to combine&#160;&#160;pub&#160;&#160;and&#160;&#160;use&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
163/627<br/>
<hr/>
<a name=164></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#164"><b>Bringing Paths into Scope with the&#160;</b>use<b>&#160;Keyword</b></a><br/>
Having to write out the paths to call functions can feel inconvenient and repetitive. In Listing<br/>7-7, whether we chose the absolute or relative path to the&#160;&#160;add_to_waitlist&#160;&#160;function, every<br/>time we wanted to call&#160;&#160;add_to_waitlist&#160;&#160;we had to specify&#160;&#160;front_of_house&#160;&#160;and&#160;&#160;hosting<br/>too. Fortunately, there’s a way to simplify this process: we can create a shortcut to a path<br/>with the&#160;&#160;use&#160;&#160;keyword once, and then use the shorter name everywhere else in the scope.<br/>
In Listing 7-11, we bring the&#160;&#160;crate::front_of_house::hosting&#160;&#160;module into the scope of<br/>the&#160;&#160;eat_at_restaurant&#160;&#160;function so we only have to specify&#160;&#160;hosting::add_to_waitlist&#160;&#160;to<br/>call the&#160;&#160;add_to_waitlist&#160;&#160;function in&#160;&#160;eat_at_restaurant&#160;.<br/>
Filename: src/lib.rs<br/>
mod&#160;front_of_house&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;mod&#160;hosting&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pub&#160;fn&#160;add_to_waitlist()&#160;{}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
use&#160;crate::front_of_house::hosting;<br/>
pub&#160;fn&#160;eat_at_restaurant()&#160;{<br/>&#160;&#160;&#160;&#160;hosting::add_to_waitlist();<br/>}<br/>
<b>Listing&#160;7-11:&#160;Bringing&#160;a&#160;module&#160;into&#160;scope&#160;with&#160;&#160;</b>use<br/>
Adding&#160;&#160;use&#160;&#160;and a path in a scope is similar to creating a symbolic link in the&#160;ﬁlesystem. By<br/>adding&#160;&#160;use&#160;crate::front_of_house::hosting&#160;&#160;in the crate root,&#160;&#160;hosting&#160;&#160;is now a valid<br/>name in that scope, just as though the&#160;&#160;hosting&#160;&#160;module had been deﬁned in the crate root.<br/>Paths brought into scope with&#160;&#160;use&#160;&#160;also check privacy, like any other paths.<br/>
Note that&#160;&#160;use&#160;&#160;only creates the shortcut for the particular scope in which the&#160;&#160;use&#160;&#160;occurs.<br/>Listing 7-12 moves the&#160;&#160;eat_at_restaurant&#160;&#160;function into a new child module named<br/>
customer&#160;, which is then a diﬀerent scope than the&#160;&#160;use&#160;&#160;statement, so the function body<br/>
won’t compile:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
164/627<br/>
<hr/>
<a name=165></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
mod&#160;front_of_house&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;mod&#160;hosting&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pub&#160;fn&#160;add_to_waitlist()&#160;{}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
use&#160;crate::front_of_house::hosting;<br/>
mod&#160;customer&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;eat_at_restaurant()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hosting::add_to_waitlist();<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;7-12:&#160;A&#160;&#160;</b>use&#160;<b>&#160;statement&#160;only&#160;applies&#160;in&#160;the&#160;scope&#160;it’s&#160;in</b><br/>
The compiler error shows that the shortcut no longer applies within the&#160;&#160;customer&#160;&#160;module:<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;Compiling&#160;restaurant&#160;v0.1.0&#160;(file:///projects/restaurant)<br/>warning:&#160;unused&#160;import:&#160;`crate::front_of_house::hosting`<br/>&#160;--&gt;&#160;src/lib.rs:7:5<br/>&#160;&#160;|<br/>7&#160;|&#160;use&#160;crate::front_of_house::hosting;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;`#[warn(unused_imports)]`&#160;on&#160;by&#160;default<br/>
error[E0433]:&#160;failed&#160;to&#160;resolve:&#160;use&#160;of&#160;undeclared&#160;crate&#160;or&#160;module&#160;`hosting`<br/>&#160;&#160;--&gt;&#160;src/lib.rs:11:9<br/>&#160;&#160;&#160;|<br/>11&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hosting::add_to_waitlist();<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^&#160;use&#160;of&#160;undeclared&#160;crate&#160;or&#160;module&#160;`hosting`<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0433`.<br/>warning:&#160;`restaurant`&#160;(lib)&#160;generated&#160;1&#160;warning<br/>error:&#160;could&#160;not&#160;compile&#160;`restaurant`&#160;due&#160;to&#160;previous&#160;error;&#160;1&#160;warning&#160;emitted<br/>
Notice there’s also a warning that the&#160;&#160;use&#160;&#160;is no longer used in its scope! To&#160;ﬁx this problem,<br/>move the&#160;&#160;use&#160;&#160;within the&#160;&#160;customer&#160;&#160;module too, or reference the shortcut in the parent<br/>module with&#160;&#160;super::hosting&#160;&#160;within the child&#160;&#160;customer&#160;&#160;module.<br/>
<a href="tests.html#165"><b>Creating&#160;Idiomatic&#160;</b>use<b>&#160;Paths</b></a><br/>
In Listing 7-11, you might have wondered why we speciﬁed&#160;&#160;use&#160;<br/>crate::front_of_house::hosting&#160;&#160;and then called&#160;&#160;hosting::add_to_waitlist&#160;&#160;in<br/>
eat_at_restaurant&#160;&#160;rather than specifying the&#160;&#160;use&#160;&#160;path all the way out to the<br/>add_to_waitlist&#160;&#160;function to achieve the same result, as in Listing 7-13.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
165/627<br/>
<hr/>
<a name=166></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
mod&#160;front_of_house&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;mod&#160;hosting&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pub&#160;fn&#160;add_to_waitlist()&#160;{}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
use&#160;crate::front_of_house::hosting::add_to_waitlist;<br/>
pub&#160;fn&#160;eat_at_restaurant()&#160;{<br/>&#160;&#160;&#160;&#160;add_to_waitlist();<br/>}<br/>
<b>Listing&#160;7-13:&#160;Bringing&#160;the&#160;&#160;</b>add_to_waitlist&#160;<b>&#160;function&#160;into&#160;scope&#160;with&#160;&#160;</b>use&#160;<b>,&#160;which&#160;is&#160;unidiomatic</b><br/>
Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is the idiomatic<br/>way to bring a function into scope with&#160;&#160;use&#160;. Bringing the function’s parent module into<br/>scope with&#160;&#160;use&#160;&#160;means we have to specify the parent module when calling the function.<br/>Specifying the parent module when calling the function makes it clear that the function isn’t<br/>locally deﬁned while still minimizing repetition of the full path. The code in Listing 7-13 is<br/>unclear as to where&#160;&#160;add_to_waitlist&#160;&#160;is deﬁned.<br/>
On the other hand, when bringing in structs, enums, and other items with&#160;&#160;use&#160;, it’s idiomatic<br/>to specify the full path. Listing 7-14 shows the idiomatic way to bring the standard library’s<br/>
HashMap&#160;&#160;struct into the scope of a binary crate.<br/>
Filename: src/main.rs<br/>
use&#160;std::collections::HashMap;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;map&#160;=&#160;HashMap::new();<br/>&#160;&#160;&#160;&#160;map.insert(1,&#160;2);<br/>}<br/>
<b>Listing&#160;7-14:&#160;Bringing&#160;&#160;</b>HashMap&#160;<b>&#160;into&#160;scope&#160;in&#160;an&#160;idiomatic&#160;way</b><br/>
There’s no strong reason behind this idiom: it’s just the convention that has emerged, and<br/>folks have gotten used to reading and writing Rust code this way.<br/>
The exception to this idiom is if we’re bringing two items with the same name into scope<br/>with&#160;&#160;use&#160;&#160;statements, because Rust doesn’t allow that. Listing 7-15 shows how to bring two<br/>
Result&#160;&#160;types into scope that have the same name but diﬀerent parent modules and how<br/>
to refer to them.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
166/627<br/>
<hr/>
<a name=167></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::fmt;<br/>use&#160;std::io;<br/>
fn&#160;function1()&#160;-&gt;&#160;fmt::Result&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
fn&#160;function2()&#160;-&gt;&#160;io::Result&lt;()&gt;&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
<b>Listing&#160;7-15:&#160;Bringing&#160;two&#160;types&#160;with&#160;the&#160;same&#160;name&#160;into&#160;the&#160;same&#160;scope&#160;requires&#160;using&#160;their&#160;parent&#160;modules.</b><br/>
As you can see, using the parent modules distinguishes the two&#160;&#160;Result&#160;&#160;types. If instead we<br/>speciﬁed&#160;&#160;use&#160;std::fmt::Result&#160;&#160;and&#160;&#160;use&#160;std::io::Result&#160;, we’d have two&#160;&#160;Result&#160;&#160;types<br/>in the same scope and Rust wouldn’t know which one we meant when we used&#160;&#160;Result&#160;.<br/>
<a href="tests.html#167"><b>Providing&#160;New&#160;Names&#160;with&#160;the&#160;</b>as<b>&#160;Keyword</b></a><br/>
There’s another solution to the problem of bringing two types of the same name into the<br/>same scope with&#160;&#160;use&#160;: after the path, we can specify&#160;&#160;as&#160;&#160;and a new local name, or&#160;<i>alias</i>, for<br/>the type. Listing 7-16 shows another way to write the code in Listing 7-15 by renaming one<br/>of the two&#160;&#160;Result&#160;&#160;types using&#160;&#160;as&#160;.<br/>
Filename: src/lib.rs<br/>
use&#160;std::fmt::Result;<br/>use&#160;std::io::Result&#160;as&#160;IoResult;<br/>
fn&#160;function1()&#160;-&gt;&#160;Result&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
fn&#160;function2()&#160;-&gt;&#160;IoResult&lt;()&gt;&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
<b>Listing&#160;7-16:&#160;Renaming&#160;a&#160;type&#160;when&#160;it’s&#160;brought&#160;into&#160;scope&#160;with&#160;the&#160;&#160;</b>as&#160;<b>&#160;keyword</b><br/>
In the second&#160;&#160;use&#160;&#160;statement, we chose the new name&#160;&#160;IoResult&#160;&#160;for the&#160;&#160;std::io::Result<br/>type, which won’t conﬂict with the&#160;&#160;Result&#160;&#160;from&#160;&#160;std::fmt&#160;&#160;that we’ve also brought into<br/>scope. Listing 7-15 and Listing 7-16 are considered idiomatic, so the choice is up to you!<br/>
<a href="tests.html#167"><b>Re-exporting&#160;Names&#160;with&#160;</b>pub&#160;use</a><br/>
When we bring a name into scope with the&#160;&#160;use&#160;&#160;keyword, the name available in the new<br/>scope is private. To enable the code that calls our code to refer to that name as if it had<br/>
https://doc.rust-lang.org/book/print.html<br/>
167/627<br/>
<hr/>
<a name=168></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
been deﬁned in that code’s scope, we can combine&#160;&#160;pub&#160;&#160;and&#160;&#160;use&#160;. This technique is called<br/><i>re-exporting</i>&#160;because we’re bringing an item into scope but also making that item available<br/>for others to bring into their scope.<br/>
Listing 7-17 shows the code in Listing 7-11 with&#160;&#160;use&#160;&#160;in the root module changed to&#160;&#160;pub&#160;<br/>use&#160;.<br/>
Filename: src/lib.rs<br/>
mod&#160;front_of_house&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;mod&#160;hosting&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pub&#160;fn&#160;add_to_waitlist()&#160;{}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
pub&#160;use&#160;crate::front_of_house::hosting;<br/>
pub&#160;fn&#160;eat_at_restaurant()&#160;{<br/>&#160;&#160;&#160;&#160;hosting::add_to_waitlist();<br/>}<br/>
<b>Listing&#160;7-17:&#160;Making&#160;a&#160;name&#160;available&#160;for&#160;any&#160;code&#160;to&#160;use&#160;from&#160;a&#160;new&#160;scope&#160;with&#160;&#160;</b>pub&#160;use<br/>
Before this change, external code would have to call the&#160;&#160;add_to_waitlist&#160;&#160;function by using<br/>the path&#160;&#160;restaurant::front_of_house::hosting::add_to_waitlist()&#160;. Now that this&#160;&#160;pub&#160;<br/>use&#160;&#160;has re-exported the&#160;&#160;hosting&#160;&#160;module from the root module, external code can now use<br/>the path&#160;&#160;restaurant::hosting::add_to_waitlist()&#160;&#160;instead.<br/>
Re-exporting is useful when the internal structure of your code is diﬀerent from how<br/>programmers calling your code would think about the domain. For example, in this<br/>restaurant metaphor, the people running the restaurant think about “front of house” and<br/>“back of house.” But customers visiting a restaurant probably won’t think about the parts of<br/>the restaurant in those terms. With&#160;&#160;pub&#160;use&#160;, we can write our code with one structure but<br/>expose a diﬀerent structure. Doing so makes our library well organized for programmers<br/>working on the library and programmers calling the library. We’ll look at another example of<br/>
<a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use">pub&#160;use&#160;&#160;and how it aﬀects your crate’s documentation in the&#160;“Exporting a Convenient</a><br/>
<a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use">Public API with&#160;&#160;pub&#160;use&#160;”&#160;section of Chapter 14.</a><br/>
<a href="tests.html#168"><b>Using&#160;External&#160;Packages</b></a><br/>
In Chapter 2, we programmed a guessing game project that used an external package called<br/>
rand&#160;&#160;to get random numbers. To use&#160;&#160;rand&#160;&#160;in our project, we added this line to&#160;<i>Cargo.toml</i>:<br/>
Filename: Cargo.toml<br/>
rand&#160;=&#160;&#34;0.8.5&#34;<br/>
https://doc.rust-lang.org/book/print.html<br/>
168/627<br/>
<hr/>
<a name=169></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Adding&#160;&#160;rand&#160;&#160;as a dependency in&#160;<i>Cargo.toml</i>&#160;tells Cargo to download the&#160;&#160;rand&#160;&#160;package and<br/>any dependencies from&#160;<a href="https://crates.io/">crates.io</a>&#160;and make&#160;&#160;rand&#160;&#160;available to our project.<br/>
Then, to bring&#160;&#160;rand&#160;&#160;deﬁnitions into the scope of our package, we added a&#160;&#160;use&#160;&#160;line starting<br/>with the name of the crate,&#160;&#160;rand&#160;, and listed the items we wanted to bring into scope. Recall<br/>that in the&#160;<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#generating-a-random-number">“Generating a Random Number”&#160;section in Chapter 2, we brought the&#160;&#160;</a>Rng&#160;&#160;trait<br/>into scope and called the&#160;&#160;rand::thread_rng&#160;&#160;function:<br/>
use&#160;rand::Rng;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;secret_number&#160;=&#160;rand::thread_rng().gen_range(1..=100);<br/>}<br/>
Members of the Rust community have made many packages available at&#160;<a href="https://crates.io/">crates.io</a>, and<br/>pulling any of them into your package involves these same steps: listing them in your<br/>package’s&#160;<i>Cargo.toml</i>&#160;ﬁle and using&#160;&#160;use&#160;&#160;to bring items from their crates into scope.<br/>
Note that the standard&#160;&#160;std&#160;&#160;library is also a crate that’s external to our package. Because<br/>the standard library is shipped with the Rust language, we don’t need to change&#160;<i>Cargo.toml<br/></i>to include&#160;&#160;std&#160;. But we do need to refer to it with&#160;&#160;use&#160;&#160;to bring items from there into our<br/>package’s scope. For example, with&#160;&#160;HashMap&#160;&#160;we would use this line:<br/>
use&#160;std::collections::HashMap;<br/>
This is an absolute path starting with&#160;&#160;std&#160;, the name of the standard library crate.<br/>
<a href="tests.html#169"><b>Using&#160;Nested&#160;Paths&#160;to&#160;Clean&#160;Up&#160;Large&#160;</b>use<b>&#160;Lists</b></a><br/>
If we’re using multiple items deﬁned in the same crate or same module, listing each item on<br/>its own line can take up a lot of vertical space in our&#160;ﬁles. For example, these two&#160;&#160;use<br/>statements we had in the Guessing Game in Listing 2-4 bring items from&#160;&#160;std&#160;&#160;into scope:<br/>
Filename: src/main.rs<br/>
//&#160;--snip--<br/>use&#160;std::cmp::Ordering;<br/>use&#160;std::io;<br/>//&#160;--snip--<br/>
Instead, we can use nested paths to bring the same items into scope in one line. We do this<br/>by specifying the common part of the path, followed by two colons, and then curly brackets<br/>around a list of the parts of the paths that diﬀer, as shown in Listing 7-18.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
169/627<br/>
<hr/>
<a name=170></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
//&#160;--snip--<br/>use&#160;std::{cmp::Ordering,&#160;io};<br/>//&#160;--snip--<br/>
<b>Listing&#160;7-18:&#160;Specifying&#160;a&#160;nested&#160;path&#160;to&#160;bring&#160;multiple&#160;items&#160;with&#160;the&#160;same&#160;preﬁx&#160;into&#160;scope</b><br/>
In bigger programs, bringing many items into scope from the same crate or module using<br/>nested paths can reduce the number of separate&#160;&#160;use&#160;&#160;statements needed by a lot!<br/>
We can use a nested path at any level in a path, which is useful when combining two&#160;&#160;use<br/>statements that share a subpath. For example, Listing 7-19 shows two&#160;&#160;use&#160;&#160;statements: one<br/>that brings&#160;&#160;std::io&#160;&#160;into scope and one that brings&#160;&#160;std::io::Write&#160;&#160;into scope.<br/>
Filename: src/lib.rs<br/>
use&#160;std::io;<br/>use&#160;std::io::Write;<br/>
<b>Listing&#160;7-19:&#160;Two&#160;&#160;</b>use&#160;<b>&#160;statements&#160;where&#160;one&#160;is&#160;a&#160;subpath&#160;of&#160;the&#160;other</b><br/>
The common part of these two paths is&#160;&#160;std::io&#160;, and that’s the complete&#160;ﬁrst path. To<br/>merge these two paths into one&#160;&#160;use&#160;&#160;statement, we can use&#160;&#160;self&#160;&#160;in the nested path, as<br/>shown in Listing 7-20.<br/>
Filename: src/lib.rs<br/>
use&#160;std::io::{self,&#160;Write};<br/>
<b>Listing&#160;7-20:&#160;Combining&#160;the&#160;paths&#160;in&#160;Listing&#160;7-19&#160;into&#160;one&#160;&#160;</b>use&#160;<b>&#160;statement</b><br/>
This line brings&#160;&#160;std::io&#160;&#160;and&#160;&#160;std::io::Write&#160;&#160;into scope.<br/>
<a href="tests.html#170"><b>The&#160;Glob&#160;Operator</b></a><br/>
If we want to bring&#160;<i>all</i>&#160;public items deﬁned in a path into scope, we can specify that path<br/>followed by the&#160;&#160;*&#160;&#160;glob operator:<br/>
use&#160;std::collections::*;<br/>
This&#160;&#160;use&#160;&#160;statement brings all public items deﬁned in&#160;&#160;std::collections&#160;&#160;into the current<br/>scope. Be careful when using the glob operator! Glob can make it harder to tell what names<br/>are in scope and where a name used in your program was deﬁned.<br/>
The glob operator is often used when testing to bring everything under test into the&#160;&#160;tests<br/><a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html#how-to-write-tests">module; we’ll talk about that in the&#160;“How to Write Tests”&#160;section in Chapter 11. The glob</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
170/627<br/>
<hr/>
<a name=171></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">operator is also sometimes used as part of the prelude pattern: see&#160;the standard library<br/>documentation&#160;for more information on that pattern.</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
171/627<br/>
<hr/>
<a name=172></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#172"><b>Separating Modules into Diﬀerent Files</b></a><br/>
So far, all the examples in this chapter deﬁned multiple modules in one&#160;ﬁle. When modules<br/>get large, you might want to move their deﬁnitions to a separate&#160;ﬁle to make the code<br/>easier to navigate.<br/>
For example, let’s start from the code in Listing 7-17 that had multiple restaurant modules.<br/>We’ll extract modules into&#160;ﬁles instead of having all the modules deﬁned in the crate root<br/>ﬁle. In this case, the crate root&#160;ﬁle is&#160;<i>src/lib.rs</i>, but this procedure also works with binary<br/>crates whose crate root&#160;ﬁle is&#160;<i>src/main.rs</i>.<br/>
First, we’ll extract the&#160;&#160;front_of_house&#160;&#160;module to its own&#160;ﬁle. Remove the code inside the<br/>curly brackets for the&#160;&#160;front_of_house&#160;&#160;module, leaving only the&#160;&#160;mod&#160;front_of_house;<br/>declaration, so that&#160;<i>src/lib.rs</i>&#160;contains the code shown in Listing 7-21. Note that this won’t<br/>compile until we create the&#160;<i>src/front_of_house.rs</i>&#160;ﬁle in Listing 7-22.<br/>
Filename: src/lib.rs<br/>
mod&#160;front_of_house;<br/>
pub&#160;use&#160;crate::front_of_house::hosting;<br/>
pub&#160;fn&#160;eat_at_restaurant()&#160;{<br/>&#160;&#160;&#160;&#160;hosting::add_to_waitlist();<br/>}<br/>
<b>Listing&#160;7-21:&#160;Declaring&#160;the&#160;&#160;</b>front_of_house&#160;<b>&#160;module&#160;whose&#160;body&#160;will&#160;be&#160;in&#160;<i>src/front_of_house.rs</i></b><br/>
Next, place the code that was in the curly brackets into a new&#160;ﬁle named<br/><i>src/front_of_house.rs</i>, as shown in Listing 7-22. The compiler knows to look in this&#160;ﬁle<br/>because it came across the module declaration in the crate root with the name<br/>
front_of_house&#160;.<br/>
Filename: src/front_of_house.rs<br/>
pub&#160;mod&#160;hosting&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;add_to_waitlist()&#160;{}<br/>}<br/>
<b>Listing&#160;7-22:&#160;Deﬁnitions&#160;inside&#160;the&#160;&#160;</b>front_of_house&#160;<b>&#160;module&#160;in&#160;<i>src/front_of_house.rs</i></b><br/>
Note that you only need to load a&#160;ﬁle using a&#160;&#160;mod&#160;&#160;declaration&#160;<i>once</i>&#160;in your module tree.<br/>Once the compiler knows the&#160;ﬁle is part of the project (and knows where in the module tree<br/>the code resides because of where you’ve put the&#160;&#160;mod&#160;&#160;statement), other&#160;ﬁles in your project<br/>should refer to the loaded&#160;ﬁle’s code using a path to where it was declared, as covered in<br/>
https://doc.rust-lang.org/book/print.html<br/>
172/627<br/>
<hr/>
<a name=173></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
the&#160;<a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module Tree”</a>&#160;section. In other words,&#160;&#160;mod&#160;&#160;is&#160;<i>not<br/></i>an “include” operation that you may have seen in other programming languages.<br/>
Next, we’ll extract the&#160;&#160;hosting&#160;&#160;module to its own&#160;ﬁle. The process is a bit diﬀerent because<br/>
hosting&#160;&#160;is a child module of&#160;&#160;front_of_house&#160;, not of the root module. We’ll place the&#160;ﬁle<br/>
for&#160;&#160;hosting&#160;&#160;in a new directory that will be named for its ancestors in the module tree, in<br/>this case&#160;<i>src/front_of_house/</i>.<br/>
To start moving&#160;&#160;hosting&#160;, we change&#160;<i>src/front_of_house.rs</i>&#160;to contain only the declaration of<br/>the&#160;&#160;hosting&#160;&#160;module:<br/>
Filename: src/front_of_house.rs<br/>
pub&#160;mod&#160;hosting;<br/>
Then we create a&#160;<i>src/front_of_house</i>&#160;directory and a&#160;ﬁle&#160;<i>hosting.rs</i>&#160;to contain the deﬁnitions<br/>made in the&#160;&#160;hosting&#160;&#160;module:<br/>
Filename: src/front_of_house/hosting.rs<br/>
pub&#160;fn&#160;add_to_waitlist()&#160;{}<br/>
If we instead put&#160;<i>hosting.rs</i>&#160;in the&#160;<i>src</i>&#160;directory, the compiler would expect the&#160;<i>hosting.rs</i>&#160;code<br/>to be in a&#160;&#160;hosting&#160;&#160;module declared in the crate root, and not declared as a child of the<br/>
front_of_house&#160;&#160;module. The compiler’s rules for which&#160;ﬁles to check for which modules’<br/>
code means the directories and&#160;ﬁles more closely match the module tree.<br/>
<a href="tests.html#173"><b>Alternate&#160;File&#160;Paths</b></a><br/>
So far we’ve covered the most idiomatic&#160;ﬁle paths the Rust compiler uses, but Rust<br/>also supports an older style of&#160;ﬁle path. For a module named&#160;&#160;front_of_house<br/>declared in the crate root, the compiler will look for the module’s code in:<br/>
<i>src/front_of_house.rs</i>&#160;(what we covered)<br/><i>src/front_of_house/mod.rs</i>&#160;(older style, still supported path)<br/>
For a module named&#160;&#160;hosting&#160;&#160;that is a submodule of&#160;&#160;front_of_house&#160;, the compiler<br/>will look for the module’s code in:<br/>
<i>src/front_of_house/hosting.rs</i>&#160;(what we covered)<br/><i>src/front_of_house/hosting/mod.rs</i>&#160;(older style, still supported path)<br/>
If you use both styles for the same module, you’ll get a compiler error. Using a mix of<br/>both styles for diﬀerent modules in the same project is allowed, but might be<br/>confusing for people navigating your project.<br/>
https://doc.rust-lang.org/book/print.html<br/>
173/627<br/>
<hr/>
<a name=174></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The main downside to the style that uses&#160;ﬁles named&#160;<i>mod.rs</i>&#160;is that your project can<br/>end up with many&#160;ﬁles named&#160;<i>mod.rs</i>, which can get confusing when you have them<br/>open in your editor at the same time.<br/>
We’ve moved each module’s code to a separate&#160;ﬁle, and the module tree remains the same.<br/>The function calls in&#160;&#160;eat_at_restaurant&#160;&#160;will work without any modiﬁcation, even though<br/>the deﬁnitions live in diﬀerent&#160;ﬁles. This technique lets you move modules to new&#160;ﬁles as<br/>they grow in size.<br/>
Note that the&#160;&#160;pub&#160;use&#160;crate::front_of_house::hosting&#160;&#160;statement in&#160;<i>src/lib.rs</i>&#160;also hasn’t<br/>changed, nor does&#160;&#160;use&#160;&#160;have any impact on what&#160;ﬁles are compiled as part of the crate. The<br/>
mod&#160;&#160;keyword declares modules, and Rust looks in a&#160;ﬁle with the same name as the module<br/>
for the code that goes into that module.<br/>
<a href="tests.html#174"><b>Summary</b></a><br/>
Rust lets you split a package into multiple crates and a crate into modules so you can refer<br/>to items deﬁned in one module from another module. You can do this by specifying<br/>absolute or relative paths. These paths can be brought into scope with a&#160;&#160;use&#160;&#160;statement so<br/>you can use a shorter path for multiple uses of the item in that scope. Module code is<br/>private by default, but you can make deﬁnitions public by adding the&#160;&#160;pub&#160;&#160;keyword.<br/>
In the next chapter, we’ll look at some collection data structures in the standard library that<br/>you can use in your neatly organized code.<br/>
https://doc.rust-lang.org/book/print.html<br/>
174/627<br/>
<hr/>
<a name=175></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#175"><b>Common Collections</b></a><br/>
Rust’s standard library includes a number of very useful data structures called&#160;<i>collections</i>.<br/>Most other data types represent one speciﬁc value, but collections can contain multiple<br/>values. Unlike the built-in array and tuple types, the data these collections point to is stored<br/>on the heap, which means the amount of data does not need to be known at compile time<br/>and can grow or shrink as the program runs. Each kind of collection has diﬀerent<br/>capabilities and costs, and choosing an appropriate one for your current situation is a skill<br/>you’ll develop over time. In this chapter, we’ll discuss three collections that are used very<br/>often in Rust programs:<br/>
A&#160;<i>vector</i>&#160;allows you to store a variable number of values next to each other.<br/>A&#160;<i>string</i>&#160;is a collection of characters. We’ve mentioned the&#160;&#160;String&#160;&#160;type previously, but<br/>in this chapter we’ll talk about it in depth.<br/>A&#160;<i>hash map</i>&#160;allows you to associate a value with a particular key. It’s a particular<br/>implementation of the more general data structure called a&#160;<i>map</i>.<br/>
<a href="https://doc.rust-lang.org/std/collections/index.html">To learn about the other kinds of collections provided by the standard library, see&#160;the<br/>documentation.</a><br/>
We’ll discuss how to create and update vectors, strings, and hash maps, as well as what<br/>makes each special.<br/>
https://doc.rust-lang.org/book/print.html<br/>
175/627<br/>
<hr/>
<a name=176></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#176"><b>Storing Lists of Values with Vectors</b></a><br/>
The&#160;ﬁrst collection type we’ll look at is&#160;&#160;Vec&lt;T&gt;&#160;, also known as a&#160;<i>vector</i>. Vectors allow you to<br/>store more than one value in a single data structure that puts all the values next to each<br/>other in memory. Vectors can only store values of the same type. They are useful when you<br/>have a list of items, such as the lines of text in a&#160;ﬁle or the prices of items in a shopping cart.<br/>
<a href="tests.html#176"><b>Creating&#160;a&#160;New&#160;Vector</b></a><br/>
To create a new empty vector, we call the&#160;&#160;Vec::new&#160;&#160;function, as shown in Listing 8-1.<br/>
&#160;&#160;&#160;&#160;let&#160;v:&#160;Vec&lt;i32&gt;&#160;=&#160;Vec::new();<br/>
<b>Listing&#160;8-1:&#160;Creating&#160;a&#160;new,&#160;empty&#160;vector&#160;to&#160;hold&#160;values&#160;of&#160;type&#160;&#160;</b>i32<br/>
Note that we added a type annotation here. Because we aren’t inserting any values into this<br/>vector, Rust doesn’t know what kind of elements we intend to store. This is an important<br/>point. Vectors are implemented using generics; we’ll cover how to use generics with your<br/>own types in Chapter 10. For now, know that the&#160;&#160;Vec&lt;T&gt;&#160;&#160;type provided by the standard<br/>library can hold any type. When we create a vector to hold a speciﬁc type, we can specify the<br/>type within angle brackets. In Listing 8-1, we’ve told Rust that the&#160;&#160;Vec&lt;T&gt;&#160;&#160;in&#160;&#160;v&#160;&#160;will hold<br/>elements of the&#160;&#160;i32&#160;&#160;type.<br/>
More often, you’ll create a&#160;&#160;Vec&lt;T&gt;&#160;&#160;with initial values and Rust will infer the type of value you<br/>want to store, so you rarely need to do this type annotation. Rust conveniently provides the<br/>
vec!&#160;&#160;macro, which will create a new vector that holds the values you give it. Listing 8-2<br/>
creates a new&#160;&#160;Vec&lt;i32&gt;&#160;&#160;that holds the values&#160;&#160;1&#160;,&#160;&#160;2&#160;, and&#160;&#160;3&#160;. The integer type is&#160;&#160;i32<br/><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#data-types">because that’s the default integer type, as we discussed in the&#160;“Data Types”</a>&#160;section of<br/>Chapter 3.<br/>
&#160;&#160;&#160;&#160;let&#160;v&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>
<b>Listing&#160;8-2:&#160;Creating&#160;a&#160;new&#160;vector&#160;containing&#160;values</b><br/>
Because we’ve given initial&#160;&#160;i32&#160;&#160;values, Rust can infer that the type of&#160;&#160;v&#160;&#160;is&#160;&#160;Vec&lt;i32&gt;&#160;, and<br/>the type annotation isn’t necessary. Next, we’ll look at how to modify a vector.<br/>
https://doc.rust-lang.org/book/print.html<br/>
176/627<br/>
<hr/>
<a name=177></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#177"><b>Updating&#160;a&#160;Vector</b></a><br/>
To create a vector and then add elements to it, we can use the&#160;&#160;push&#160;&#160;method, as shown in<br/>Listing 8-3.<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;v&#160;=&#160;Vec::new();<br/>
&#160;&#160;&#160;&#160;v.push(5);<br/>&#160;&#160;&#160;&#160;v.push(6);<br/>&#160;&#160;&#160;&#160;v.push(7);<br/>&#160;&#160;&#160;&#160;v.push(8);<br/>
<b>Listing&#160;8-3:&#160;Using&#160;the&#160;&#160;</b>push&#160;<b>&#160;method&#160;to&#160;add&#160;values&#160;to&#160;a&#160;vector</b><br/>
As with any variable, if we want to be able to change its value, we need to make it mutable<br/>using the&#160;&#160;mut&#160;&#160;keyword, as discussed in Chapter 3. The numbers we place inside are all of<br/>type&#160;&#160;i32&#160;, and Rust infers this from the data, so we don’t need the&#160;&#160;Vec&lt;i32&gt;&#160;&#160;annotation.<br/>
<a href="tests.html#177"><b>Reading&#160;Elements&#160;of&#160;Vectors</b></a><br/>
There are two ways to reference a value stored in a vector: via indexing or using the&#160;&#160;get<br/>method. In the following examples, we’ve annotated the types of the values that are<br/>returned from these functions for extra clarity.<br/>
Listing 8-4 shows both methods of accessing a value in a vector, with indexing syntax and<br/>the&#160;&#160;get&#160;&#160;method.<br/>
&#160;&#160;&#160;&#160;let&#160;v&#160;=&#160;vec![1,&#160;2,&#160;3,&#160;4,&#160;5];<br/>
&#160;&#160;&#160;&#160;let&#160;third:&#160;&amp;i32&#160;=&#160;&amp;v[2];<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;third&#160;element&#160;is&#160;{third}&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;third:&#160;Option&lt;&amp;i32&gt;&#160;=&#160;v.get(2);<br/>&#160;&#160;&#160;&#160;match&#160;third&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(third)&#160;=&gt;&#160;println!(&#34;The&#160;third&#160;element&#160;is&#160;{third}&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;None&#160;=&gt;&#160;println!(&#34;There&#160;is&#160;no&#160;third&#160;element.&#34;),<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;8-4:&#160;Using&#160;indexing&#160;syntax&#160;or&#160;the&#160;&#160;</b>get&#160;<b>&#160;method&#160;to&#160;access&#160;an&#160;item&#160;in&#160;a&#160;vector</b><br/>
Note a few details here. We use the index value of&#160;&#160;2&#160;&#160;to get the third element because<br/>vectors are indexed by number, starting at zero. Using&#160;&#160;&amp;&#160;&#160;and&#160;&#160;[]&#160;&#160;gives us a reference to the<br/>element at the index value. When we use the&#160;&#160;get&#160;&#160;method with the index passed as an<br/>argument, we get an&#160;&#160;Option&lt;&amp;T&gt;&#160;&#160;that we can use with&#160;&#160;match&#160;.<br/>
The reason Rust provides these two ways to reference an element is so you can choose how<br/>the program behaves when you try to use an index value outside the range of existing<br/>elements. As an example, let’s see what happens when we have a vector of&#160;ﬁve elements<br/>
https://doc.rust-lang.org/book/print.html<br/>
177/627<br/>
<hr/>
<a name=178></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
and then we try to access an element at index 100 with each technique, as shown in Listing<br/>8-5.<br/>
&#160;&#160;&#160;&#160;let&#160;v&#160;=&#160;vec![1,&#160;2,&#160;3,&#160;4,&#160;5];<br/>
&#160;&#160;&#160;&#160;let&#160;does_not_exist&#160;=&#160;&amp;v[100];<br/>&#160;&#160;&#160;&#160;let&#160;does_not_exist&#160;=&#160;v.get(100);<br/>
<b>Listing&#160;8-5:&#160;Attempting&#160;to&#160;access&#160;the&#160;element&#160;at&#160;index&#160;100&#160;in&#160;a&#160;vector&#160;containing&#160;ﬁve&#160;elements</b><br/>
When we run this code, the&#160;ﬁrst&#160;&#160;[]&#160;&#160;method will cause the program to panic because it<br/>references a nonexistent element. This method is best used when you want your program<br/>to crash if there’s an attempt to access an element past the end of the vector.<br/>
When the&#160;&#160;get&#160;&#160;method is passed an index that is outside the vector, it returns&#160;&#160;None&#160;&#160;without<br/>panicking. You would use this method if accessing an element beyond the range of the<br/>vector may happen occasionally under normal circumstances. Your code will then have logic<br/>to handle having either&#160;&#160;Some(&amp;element)&#160;&#160;or&#160;&#160;None&#160;, as discussed in Chapter 6. For example,<br/>the index could be coming from a person entering a number. If they accidentally enter a<br/>number that’s too large and the program gets a&#160;&#160;None&#160;&#160;value, you could tell the user how<br/>many items are in the current vector and give them another chance to enter a valid value.<br/>That would be more user-friendly than crashing the program due to a typo!<br/>
When the program has a valid reference, the borrow checker enforces the ownership and<br/>borrowing rules (covered in Chapter 4) to ensure this reference and any other references to<br/>the contents of the vector remain valid. Recall the rule that states you can’t have mutable<br/>and immutable references in the same scope. That rule applies in Listing 8-6, where we hold<br/>an immutable reference to the&#160;ﬁrst element in a vector and try to add an element to the<br/>end. This program won’t work if we also try to refer to that element later in the function:<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;v&#160;=&#160;vec![1,&#160;2,&#160;3,&#160;4,&#160;5];<br/>
&#160;&#160;&#160;&#160;let&#160;first&#160;=&#160;&amp;v[0];<br/>
&#160;&#160;&#160;&#160;v.push(6);<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;first&#160;element&#160;is:&#160;{first}&#34;);<br/>
<b>Listing&#160;8-6:&#160;Attempting&#160;to&#160;add&#160;an&#160;element&#160;to&#160;a&#160;vector&#160;while&#160;holding&#160;a&#160;reference&#160;to&#160;an&#160;item</b><br/>
Compiling this code will result in this error:<br/>
https://doc.rust-lang.org/book/print.html<br/>
178/627<br/>
<hr/>
<a name=179></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;collections&#160;v0.1.0&#160;(file:///projects/collections)<br/>error[E0502]:&#160;cannot&#160;borrow&#160;`v`&#160;as&#160;mutable&#160;because&#160;it&#160;is&#160;also&#160;borrowed&#160;as&#160;<br/>immutable<br/>&#160;--&gt;&#160;src/main.rs:6:5<br/>&#160;&#160;|<br/>4&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;first&#160;=&#160;&amp;v[0];<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&#160;immutable&#160;borrow&#160;occurs&#160;here<br/>5&#160;|<br/>6&#160;|&#160;&#160;&#160;&#160;&#160;v.push(6);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^&#160;mutable&#160;borrow&#160;occurs&#160;here<br/>7&#160;|<br/>8&#160;|&#160;&#160;&#160;&#160;&#160;println!(&#34;The&#160;first&#160;element&#160;is:&#160;{first}&#34;);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-----&#160;immutable&#160;borrow&#160;later&#160;used&#160;here<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0502`.<br/>error:&#160;could&#160;not&#160;compile&#160;`collections`&#160;due&#160;to&#160;previous&#160;error<br/>
The code in Listing 8-6 might look like it should work: why should a reference to the&#160;ﬁrst<br/>element care about changes at the end of the vector? This error is due to the way vectors<br/>work: because vectors put the values next to each other in memory, adding a new element<br/>onto the end of the vector might require allocating new memory and copying the old<br/>elements to the new space, if there isn’t enough room to put all the elements next to each<br/>other where the vector is currently stored. In that case, the reference to the&#160;ﬁrst element<br/>would be pointing to deallocated memory. The borrowing rules prevent programs from<br/>ending up in that situation.<br/>
<a href="https://doc.rust-lang.org/nomicon/vec/vec.html">Note: For more on the implementation details of the&#160;&#160;Vec&lt;T&gt;&#160;&#160;type, see&#160;“The<br/>Rustonomicon”.</a><br/>
<a href="tests.html#179"><b>Iterating&#160;over&#160;the&#160;Values&#160;in&#160;a&#160;Vector</b></a><br/>
To access each element in a vector in turn, we would iterate through all of the elements<br/>rather than use indices to access one at a time. Listing 8-7 shows how to use a&#160;&#160;for&#160;&#160;loop to<br/>get immutable references to each element in a vector of&#160;&#160;i32&#160;&#160;values and print them.<br/>
&#160;&#160;&#160;&#160;let&#160;v&#160;=&#160;vec![100,&#160;32,&#160;57];<br/>&#160;&#160;&#160;&#160;for&#160;i&#160;in&#160;&amp;v&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;{i}&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;8-7:&#160;Printing&#160;each&#160;element&#160;in&#160;a&#160;vector&#160;by&#160;iterating&#160;over&#160;the&#160;elements&#160;using&#160;a&#160;&#160;</b>for&#160;<b>&#160;loop</b><br/>
We can also iterate over mutable references to each element in a mutable vector in order to<br/>make changes to all the elements. The&#160;&#160;for&#160;&#160;loop in Listing 8-8 will add&#160;&#160;50&#160;&#160;to each element.<br/>
https://doc.rust-lang.org/book/print.html<br/>
179/627<br/>
<hr/>
<a name=180></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;v&#160;=&#160;vec![100,&#160;32,&#160;57];<br/>&#160;&#160;&#160;&#160;for&#160;i&#160;in&#160;&amp;mut&#160;v&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*i&#160;+=&#160;50;<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;8-8:&#160;Iterating&#160;over&#160;mutable&#160;references&#160;to&#160;elements&#160;in&#160;a&#160;vector</b><br/>
To change the value that the mutable reference refers to, we have to use the&#160;&#160;*&#160;&#160;dereference<br/>operator to get to the value in&#160;&#160;i&#160;&#160;before we can use the&#160;&#160;+=&#160;&#160;operator. We’ll talk more about<br/><a href="https://doc.rust-lang.org/book/ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">the dereference operator in the&#160;“Following the Pointer to the Value with the Dereference<br/>Operator”&#160;section of Chapter 15.</a><br/>
Iterating over a vector, whether immutably or mutably, is safe because of the borrow<br/>checker's rules. If we attempted to insert or remove items in the&#160;&#160;for&#160;&#160;loop bodies in Listing<br/>8-7 and Listing 8-8, we would get a compiler error similar to the one we got with the code in<br/>Listing 8-6. The reference to the vector that the&#160;&#160;for&#160;&#160;loop holds prevents simultaneous<br/>modiﬁcation of the whole vector.<br/>
<a href="tests.html#180"><b>Using&#160;an&#160;Enum&#160;to&#160;Store&#160;Multiple&#160;Types</b></a><br/>
Vectors can only store values that are the same type. This can be inconvenient; there are<br/>deﬁnitely use cases for needing to store a list of items of diﬀerent types. Fortunately, the<br/>variants of an enum are deﬁned under the same enum type, so when we need one type to<br/>represent elements of diﬀerent types, we can deﬁne and use an enum!<br/>
For example, say we want to get values from a row in a spreadsheet in which some of the<br/>columns in the row contain integers, some&#160;ﬂoating-point numbers, and some strings. We<br/>can deﬁne an enum whose variants will hold the diﬀerent value types, and all the enum<br/>variants will be considered the same type: that of the enum. Then we can create a vector to<br/>hold that enum and so, ultimately, holds diﬀerent types. We’ve demonstrated this in Listing<br/>8-9.<br/>
&#160;&#160;&#160;&#160;enum&#160;SpreadsheetCell&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Int(i32),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Float(f64),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Text(String),<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;let&#160;row&#160;=&#160;vec![<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SpreadsheetCell::Int(3),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SpreadsheetCell::Text(String::from(&#34;blue&#34;)),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;SpreadsheetCell::Float(10.12),<br/>&#160;&#160;&#160;&#160;];<br/>
<b>Listing&#160;8-9:&#160;Deﬁning&#160;an&#160;&#160;</b>enum&#160;<b>&#160;to&#160;store&#160;values&#160;of&#160;diﬀerent&#160;types&#160;in&#160;one&#160;vector</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
180/627<br/>
<hr/>
<a name=181></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Rust needs to know what types will be in the vector at compile time so it knows exactly how<br/>much memory on the heap will be needed to store each element. We must also be explicit<br/>about what types are allowed in this vector. If Rust allowed a vector to hold any type, there<br/>would be a chance that one or more of the types would cause errors with the operations<br/>performed on the elements of the vector. Using an enum plus a&#160;&#160;match&#160;&#160;expression means<br/>that Rust will ensure at compile time that every possible case is handled, as discussed in<br/>Chapter 6.<br/>
If you don’t know the exhaustive set of types a program will get at runtime to store in a<br/>vector, the enum technique won’t work. Instead, you can use a trait object, which we’ll cover<br/>in Chapter 17.<br/>
Now that we’ve discussed some of the most common ways to use vectors, be sure to review<br/><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">the API documentation</a>&#160;for all the many useful methods deﬁned on&#160;&#160;Vec&lt;T&gt;&#160;&#160;by the standard<br/>library. For example, in addition to&#160;&#160;push&#160;, a&#160;&#160;pop&#160;&#160;method removes and returns the last<br/>element.<br/>
<a href="tests.html#181"><b>Dropping&#160;a&#160;Vector&#160;Drops&#160;Its&#160;Elements</b></a><br/>
Like any other&#160;&#160;struct&#160;, a vector is freed when it goes out of scope, as annotated in Listing 8-<br/>10.<br/>
&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;v&#160;=&#160;vec![1,&#160;2,&#160;3,&#160;4];<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;do&#160;stuff&#160;with&#160;v<br/>&#160;&#160;&#160;&#160;}&#160;//&#160;&lt;-&#160;v&#160;goes&#160;out&#160;of&#160;scope&#160;and&#160;is&#160;freed&#160;here<br/>
<b>Listing&#160;8-10:&#160;Showing&#160;where&#160;the&#160;vector&#160;and&#160;its&#160;elements&#160;are&#160;dropped</b><br/>
When the vector gets dropped, all of its contents are also dropped, meaning the integers it<br/>holds will be cleaned up. The borrow checker ensures that any references to contents of a<br/>vector are only used while the vector itself is valid.<br/>
Let’s move on to the next collection type:&#160;&#160;String&#160;!<br/>
https://doc.rust-lang.org/book/print.html<br/>
181/627<br/>
<hr/>
<a name=182></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#182"><b>Storing UTF-8 Encoded Text with Strings</b></a><br/>
We talked about strings in Chapter 4, but we’ll look at them in more depth now. New<br/>Rustaceans commonly get stuck on strings for a combination of three reasons: Rust’s<br/>propensity for exposing possible errors, strings being a more complicated data structure<br/>than many programmers give them credit for, and UTF-8. These factors combine in a way<br/>that can seem diﬃcult when you’re coming from other programming languages.<br/>
We discuss strings in the context of collections because strings are implemented as a<br/>collection of bytes, plus some methods to provide useful functionality when those bytes are<br/>interpreted as text. In this section, we’ll talk about the operations on&#160;&#160;String&#160;&#160;that every<br/>collection type has, such as creating, updating, and reading. We’ll also discuss the ways in<br/>which&#160;&#160;String&#160;&#160;is diﬀerent from the other collections, namely how indexing into a&#160;&#160;String&#160;&#160;is<br/>complicated by the diﬀerences between how people and computers interpret&#160;&#160;String&#160;&#160;data.<br/>
<a href="tests.html#182"><b>What&#160;Is&#160;a&#160;String?</b></a><br/>
We’ll&#160;ﬁrst deﬁne what we mean by the term&#160;<i>string</i>. Rust has only one string type in the core<br/>language, which is the string slice&#160;&#160;str&#160;&#160;that is usually seen in its borrowed form&#160;&#160;&amp;str&#160;. In<br/>Chapter 4, we talked about&#160;<i>string slices</i>, which are references to some UTF-8 encoded string<br/>data stored elsewhere. String literals, for example, are stored in the program’s binary and<br/>are therefore string slices.<br/>
The&#160;&#160;String&#160;&#160;type, which is provided by Rust’s standard library rather than coded into the<br/>core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans<br/>refer to “strings” in Rust, they might be referring to either the&#160;&#160;String&#160;&#160;or the string slice<br/>
&amp;str&#160;&#160;types, not just one of those types. Although this section is largely about&#160;&#160;String&#160;, both<br/>
types are used heavily in Rust’s standard library, and both&#160;&#160;String&#160;&#160;and string slices are UTF-<br/>8 encoded.<br/>
<a href="tests.html#182"><b>Creating&#160;a&#160;New&#160;String</b></a><br/>
Many of the same operations available with&#160;&#160;Vec&lt;T&gt;&#160;&#160;are available with&#160;&#160;String&#160;&#160;as well,<br/>because&#160;&#160;String&#160;&#160;is actually implemented as a wrapper around a vector of bytes with some<br/>extra guarantees, restrictions, and capabilities. An example of a function that works the<br/>same way with&#160;&#160;Vec&lt;T&gt;&#160;&#160;and&#160;&#160;String&#160;&#160;is the&#160;&#160;new&#160;&#160;function to create an instance, shown in<br/>Listing 8-11.<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;s&#160;=&#160;String::new();<br/>
https://doc.rust-lang.org/book/print.html<br/>
182/627<br/>
<hr/>
<a name=183></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Listing&#160;8-11:&#160;Creating&#160;a&#160;new,&#160;empty&#160;&#160;</b>String<br/>
This line creates a new empty string called&#160;&#160;s&#160;, which we can then load data into. Often, we’ll<br/>have some initial data that we want to start the string with. For that, we use the&#160;&#160;to_string<br/>method, which is available on any type that implements the&#160;&#160;Display&#160;&#160;trait, as string literals<br/>do. Listing 8-12 shows two examples.<br/>
&#160;&#160;&#160;&#160;let&#160;data&#160;=&#160;&#34;initial&#160;contents&#34;;<br/>
&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;data.to_string();<br/>
&#160;&#160;&#160;&#160;//&#160;the&#160;method&#160;also&#160;works&#160;on&#160;a&#160;literal&#160;directly:<br/>&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;&#34;initial&#160;contents&#34;.to_string();<br/>
<b>Listing&#160;8-12:&#160;Using&#160;the&#160;&#160;</b>to_string&#160;<b>&#160;method&#160;to&#160;create&#160;a&#160;&#160;</b>String&#160;<b>&#160;from&#160;a&#160;string&#160;literal</b><br/>
This code creates a string containing&#160;&#160;initial&#160;contents&#160;.<br/>
We can also use the function&#160;&#160;String::from&#160;&#160;to create a&#160;&#160;String&#160;&#160;from a string literal. The<br/>code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses&#160;&#160;to_string&#160;.<br/>
&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;String::from(&#34;initial&#160;contents&#34;);<br/>
<b>Listing&#160;8-13:&#160;Using&#160;the&#160;&#160;</b>String::from&#160;<b>&#160;function&#160;to&#160;create&#160;a&#160;&#160;</b>String&#160;<b>&#160;from&#160;a&#160;string&#160;literal</b><br/>
Because strings are used for so many things, we can use many diﬀerent generic APIs for<br/>strings, providing us with a lot of options. Some of them can seem redundant, but they all<br/>have their place! In this case,&#160;&#160;String::from&#160;&#160;and&#160;&#160;to_string&#160;&#160;do the same thing, so which<br/>you choose is a matter of style and readability.<br/>
Remember that strings are UTF-8 encoded, so we can include any properly encoded data in<br/>them, as shown in Listing 8-14.<br/>
&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;ﻢﻜﻴﻠﻋ&#160;مﻼﺴﻟا&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;Dobrý&#160;den&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;Hello&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;םוֹל&#160;ָשׁ&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;नम&#160;ते&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;こんにちは&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;안녕하세요&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;你好&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;Olá&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;Здравствуйте&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;Hola&#34;);<br/>
<b>Listing&#160;8-14:&#160;Storing&#160;greetings&#160;in&#160;diﬀerent&#160;languages&#160;in&#160;strings</b><br/>
All of these are valid&#160;&#160;String&#160;&#160;values.<br/>
https://doc.rust-lang.org/book/print.html<br/>
183/627<br/>
<hr/>
<a name=184></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#184"><b>Updating&#160;a&#160;String</b></a><br/>
A&#160;&#160;String&#160;&#160;can grow in size and its contents can change, just like the contents of a&#160;&#160;Vec&lt;T&gt;&#160;, if<br/>you push more data into it. In addition, you can conveniently use the&#160;&#160;+&#160;&#160;operator or the<br/>
format!&#160;&#160;macro to concatenate&#160;&#160;String&#160;&#160;values.<br/>
<a href="tests.html#184"><b>Appending to a String with&#160;</b>push_str<b>&#160;and&#160;</b>push</a><br/>
We can grow a&#160;&#160;String&#160;&#160;by using the&#160;&#160;push_str&#160;&#160;method to append a string slice, as shown in<br/>Listing 8-15.<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;s&#160;=&#160;String::from(&#34;foo&#34;);<br/>&#160;&#160;&#160;&#160;s.push_str(&#34;bar&#34;);<br/>
<b>Listing&#160;8-15:&#160;Appending&#160;a&#160;string&#160;slice&#160;to&#160;a&#160;&#160;</b>String&#160;<b>&#160;using&#160;the&#160;&#160;</b>push_str&#160;<b>&#160;method</b><br/>
After these two lines,&#160;&#160;s&#160;&#160;will contain&#160;&#160;foobar&#160;. The&#160;&#160;push_str&#160;&#160;method takes a string slice<br/>because we don’t necessarily want to take ownership of the parameter. For example, in the<br/>code in Listing 8-16, we want to be able to use&#160;&#160;s2&#160;&#160;after appending its contents to&#160;&#160;s1&#160;.<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;s1&#160;=&#160;String::from(&#34;foo&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;s2&#160;=&#160;&#34;bar&#34;;<br/>&#160;&#160;&#160;&#160;s1.push_str(s2);<br/>&#160;&#160;&#160;&#160;println!(&#34;s2&#160;is&#160;{s2}&#34;);<br/>
<b>Listing&#160;8-16:&#160;Using&#160;a&#160;string&#160;slice&#160;after&#160;appending&#160;its&#160;contents&#160;to&#160;a&#160;&#160;</b>String<br/>
If the&#160;&#160;push_str&#160;&#160;method took ownership of&#160;&#160;s2&#160;, we wouldn’t be able to print its value on the<br/>last line. However, this code works as we’d expect!<br/>
The&#160;&#160;push&#160;&#160;method takes a single character as a parameter and adds it to the&#160;&#160;String&#160;.<br/>Listing 8-17 adds the letter “l” to a&#160;&#160;String&#160;&#160;using the&#160;&#160;push&#160;&#160;method.<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;s&#160;=&#160;String::from(&#34;lo&#34;);<br/>&#160;&#160;&#160;&#160;s.push('l');<br/>
<b>Listing&#160;8-17:&#160;Adding&#160;one&#160;character&#160;to&#160;a&#160;&#160;</b>String&#160;<b>&#160;value&#160;using&#160;&#160;</b>push<br/>
As a result,&#160;&#160;s&#160;&#160;will contain&#160;&#160;lol&#160;.<br/>
<a href="tests.html#184"><b>Concatenation with the&#160;</b>+<b>&#160;Operator or the&#160;</b>format!<b>&#160;Macro</b></a><br/>
Often, you’ll want to combine two existing strings. One way to do so is to use the&#160;&#160;+<br/>operator, as shown in Listing 8-18.<br/>
https://doc.rust-lang.org/book/print.html<br/>
184/627<br/>
<hr/>
<a name=185></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;let&#160;s1&#160;=&#160;String::from(&#34;Hello,&#160;&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;s2&#160;=&#160;String::from(&#34;world!&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;s3&#160;=&#160;s1&#160;+&#160;&amp;s2;&#160;//&#160;note&#160;s1&#160;has&#160;been&#160;moved&#160;here&#160;and&#160;can&#160;no&#160;longer&#160;be&#160;used<br/>
<b>Listing&#160;8-18:&#160;Using&#160;the&#160;&#160;</b>+&#160;<b>&#160;operator&#160;to&#160;combine&#160;two&#160;&#160;</b>String&#160;<b>&#160;values&#160;into&#160;a&#160;new&#160;&#160;</b>String&#160;<b>&#160;value</b><br/>
The string&#160;&#160;s3&#160;&#160;will contain&#160;&#160;Hello,&#160;world!&#160;. The reason&#160;&#160;s1&#160;&#160;is no longer valid after the<br/>addition, and the reason we used a reference to&#160;&#160;s2&#160;, has to do with the signature of the<br/>method that’s called when we use the&#160;&#160;+&#160;&#160;operator. The&#160;&#160;+&#160;&#160;operator uses the&#160;&#160;add&#160;&#160;method,<br/>whose signature looks something like this:<br/>
fn&#160;add(self,&#160;s:&#160;&amp;str)&#160;-&gt;&#160;String&#160;{<br/>
In the standard library, you'll see&#160;&#160;add&#160;&#160;deﬁned using generics and associated types. Here,<br/>we’ve substituted in concrete types, which is what happens when we call this method with<br/>
String&#160;&#160;values. We’ll discuss generics in Chapter 10. This signature gives us the clues we<br/>
need to understand the tricky bits of the&#160;&#160;+&#160;&#160;operator.<br/>
First,&#160;&#160;s2&#160;&#160;has an&#160;&#160;&amp;&#160;, meaning that we’re adding a&#160;<i>reference</i>&#160;of the second string to the&#160;ﬁrst<br/>string. This is because of the&#160;&#160;s&#160;&#160;parameter in the&#160;&#160;add&#160;&#160;function: we can only add a&#160;&#160;&amp;str&#160;&#160;to a<br/>
String&#160;; we can’t add two&#160;&#160;String&#160;&#160;values together. But wait—the type of&#160;&#160;&amp;s2&#160;&#160;is&#160;&#160;&amp;String&#160;,<br/>
not&#160;&#160;&amp;str&#160;, as speciﬁed in the second parameter to&#160;&#160;add&#160;. So why does Listing 8-18 compile?<br/>
The reason we’re able to use&#160;&#160;&amp;s2&#160;&#160;in the call to&#160;&#160;add&#160;&#160;is that the compiler can&#160;<i>coerce</i>&#160;the<br/>
&amp;String&#160;&#160;argument into a&#160;&#160;&amp;str&#160;. When we call the&#160;&#160;add&#160;&#160;method, Rust uses a&#160;<i>deref coercion</i>,<br/>
which here turns&#160;&#160;&amp;s2&#160;&#160;into&#160;&#160;&amp;s2[..]&#160;. We’ll discuss deref coercion in more depth in Chapter<br/>15. Because&#160;&#160;add&#160;&#160;does not take ownership of the&#160;&#160;s&#160;&#160;parameter,&#160;&#160;s2&#160;&#160;will still be a valid<br/>
String&#160;&#160;after this operation.<br/>
Second, we can see in the signature that&#160;&#160;add&#160;&#160;takes ownership of&#160;&#160;self&#160;, because&#160;&#160;self&#160;&#160;does<br/><i>not</i>&#160;have an&#160;&#160;&amp;&#160;. This means&#160;&#160;s1&#160;&#160;in Listing 8-18 will be moved into the&#160;&#160;add&#160;&#160;call and will no<br/>longer be valid after that. So although&#160;&#160;let&#160;s3&#160;=&#160;s1&#160;+&#160;&amp;s2;&#160;&#160;looks like it will copy both<br/>strings and create a new one, this statement actually takes ownership of&#160;&#160;s1&#160;, appends a<br/>copy of the contents of&#160;&#160;s2&#160;, and then returns ownership of the result. In other words, it<br/>looks like it’s making a lot of copies but isn’t; the implementation is more eﬃcient than<br/>copying.<br/>
If we need to concatenate multiple strings, the behavior of the&#160;&#160;+&#160;&#160;operator gets unwieldy:<br/>
&#160;&#160;&#160;&#160;let&#160;s1&#160;=&#160;String::from(&#34;tic&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;s2&#160;=&#160;String::from(&#34;tac&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;s3&#160;=&#160;String::from(&#34;toe&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;s1&#160;+&#160;&#34;-&#34;&#160;+&#160;&amp;s2&#160;+&#160;&#34;-&#34;&#160;+&#160;&amp;s3;<br/>
https://doc.rust-lang.org/book/print.html<br/>
185/627<br/>
<hr/>
<a name=186></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
At this point,&#160;&#160;s&#160;&#160;will be&#160;&#160;tic-tac-toe&#160;. With all of the&#160;&#160;+&#160;&#160;and&#160;&#160;&#34;&#160;&#160;characters, it’s diﬃcult to see<br/>what’s going on. For more complicated string combining, we can instead use the&#160;&#160;format!<br/>macro:<br/>
&#160;&#160;&#160;&#160;let&#160;s1&#160;=&#160;String::from(&#34;tic&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;s2&#160;=&#160;String::from(&#34;tac&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;s3&#160;=&#160;String::from(&#34;toe&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;format!(&#34;{s1}-{s2}-{s3}&#34;);<br/>
This code also sets&#160;&#160;s&#160;&#160;to&#160;&#160;tic-tac-toe&#160;. The&#160;&#160;format!&#160;&#160;macro works like&#160;&#160;println!&#160;, but<br/>instead of printing the output to the screen, it returns a&#160;&#160;String&#160;&#160;with the contents. The<br/>version of the code using&#160;&#160;format!&#160;&#160;is much easier to read, and the code generated by the<br/>
format!&#160;&#160;macro uses references so that this call doesn’t take ownership of any of its<br/>
parameters.<br/>
<a href="tests.html#186"><b>Indexing&#160;into&#160;Strings</b></a><br/>
In many other programming languages, accessing individual characters in a string by<br/>referencing them by index is a valid and common operation. However, if you try to access<br/>parts of a&#160;&#160;String&#160;&#160;using indexing syntax in Rust, you’ll get an error. Consider the invalid<br/>code in Listing 8-19.<br/>
&#160;&#160;&#160;&#160;let&#160;s1&#160;=&#160;String::from(&#34;hello&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;h&#160;=&#160;s1[0];<br/>
<b>Listing&#160;8-19:&#160;Attempting&#160;to&#160;use&#160;indexing&#160;syntax&#160;with&#160;a&#160;String</b><br/>
This code will result in the following error:<br/>
https://doc.rust-lang.org/book/print.html<br/>
186/627<br/>
<hr/>
<a name=187></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;collections&#160;v0.1.0&#160;(file:///projects/collections)<br/>error[E0277]:&#160;the&#160;type&#160;`String`&#160;cannot&#160;be&#160;indexed&#160;by&#160;`{integer}`<br/>&#160;--&gt;&#160;src/main.rs:3:13<br/>&#160;&#160;|<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;h&#160;=&#160;s1[0];<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^&#160;`String`&#160;cannot&#160;be&#160;indexed&#160;by&#160;`{integer}`<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;help:&#160;the&#160;trait&#160;`Index&lt;{integer}&gt;`&#160;is&#160;not&#160;implemented&#160;for&#160;`String`<br/>&#160;&#160;=&#160;help:&#160;the&#160;following&#160;other&#160;types&#160;implement&#160;trait&#160;`Index&lt;Idx&gt;`:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;String&#160;as&#160;Index&lt;RangeFrom&lt;usize&gt;&gt;&gt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;String&#160;as&#160;Index&lt;RangeFull&gt;&gt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;String&#160;as&#160;Index&lt;RangeInclusive&lt;usize&gt;&gt;&gt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;String&#160;as&#160;Index&lt;RangeTo&lt;usize&gt;&gt;&gt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;String&#160;as&#160;Index&lt;RangeToInclusive&lt;usize&gt;&gt;&gt;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;String&#160;as&#160;Index&lt;std::ops::Range&lt;usize&gt;&gt;&gt;<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0277`.<br/>error:&#160;could&#160;not&#160;compile&#160;`collections`&#160;due&#160;to&#160;previous&#160;error<br/>
The error and the note tell the story: Rust strings don’t support indexing. But why not? To<br/>answer that question, we need to discuss how Rust stores strings in memory.<br/>
<a href="tests.html#187"><b>Internal Representation</b></a><br/>
A&#160;&#160;String&#160;&#160;is a wrapper over a&#160;&#160;Vec&lt;u8&gt;&#160;. Let’s look at some of our properly encoded UTF-8<br/>example strings from Listing 8-14. First, this one:<br/>
&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;Hola&#34;);<br/>
In this case,&#160;&#160;len&#160;&#160;will be 4, which means the vector storing the string “Hola” is 4 bytes long.<br/>Each of these letters takes 1 byte when encoded in UTF-8. The following line, however, may<br/>surprise you. (Note that this string begins with the capital Cyrillic letter Ze, not the Arabic<br/>number 3.)<br/>
&#160;&#160;&#160;&#160;let&#160;hello&#160;=&#160;String::from(&#34;Здравствуйте&#34;);<br/>
Asked how long the string is, you might say 12. In fact, Rust’s answer is 24: that’s the number<br/>of bytes it takes to encode “Здравствуйте” in UTF-8, because each Unicode scalar value in<br/>that string takes 2 bytes of storage. Therefore, an index into the string’s bytes will not always<br/>correlate to a valid Unicode scalar value. To demonstrate, consider this invalid Rust code:<br/>
let&#160;hello&#160;=&#160;&#34;Здравствуйте&#34;;<br/>let&#160;answer&#160;=&#160;&amp;hello[0];<br/>
You already know that&#160;&#160;answer&#160;&#160;will not be&#160;&#160;З&#160;, the&#160;ﬁrst letter. When encoded in UTF-8, the<br/>ﬁrst byte of&#160;&#160;З&#160;&#160;is&#160;&#160;208&#160;&#160;and the second is&#160;&#160;151&#160;, so it would seem that&#160;&#160;answer&#160;&#160;should in fact<br/>be&#160;&#160;208&#160;, but&#160;&#160;208&#160;&#160;is not a valid character on its own. Returning&#160;&#160;208&#160;&#160;is likely not what a user<br/>
https://doc.rust-lang.org/book/print.html<br/>
187/627<br/>
<hr/>
<a name=188></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
would want if they asked for the&#160;ﬁrst letter of this string; however, that’s the only data that<br/>Rust has at byte index 0. Users generally don’t want the byte value returned, even if the<br/>string contains only Latin letters: if&#160;&#160;&amp;&#34;hello&#34;[0]&#160;&#160;were valid code that returned the byte<br/>value, it would return&#160;&#160;104&#160;, not&#160;&#160;h&#160;.<br/>
The answer, then, is that to avoid returning an unexpected value and causing bugs that<br/>might not be discovered immediately, Rust doesn’t compile this code at all and prevents<br/>misunderstandings early in the development process.<br/>
<a href="tests.html#188"><b>Bytes and Scalar Values and Grapheme Clusters! Oh My!</b></a><br/>
Another point about UTF-8 is that there are actually three relevant ways to look at strings<br/>from Rust’s perspective: as bytes, scalar values, and grapheme clusters (the closest thing to<br/>what we would call&#160;<i>letters</i>).<br/>
If we look at the Hindi word “नम&#160;ते” written in the Devanagari script, it is stored as a vector of<br/>
u8&#160;&#160;values that looks like this:<br/>
[224,&#160;164,&#160;168,&#160;224,&#160;164,&#160;174,&#160;224,&#160;164,&#160;184,&#160;224,&#160;165,&#160;141,&#160;224,&#160;164,&#160;164,<br/>224,&#160;165,&#160;135]<br/>
That’s 18 bytes and is how computers ultimately store this data. If we look at them as<br/>Unicode scalar values, which are what Rust’s&#160;&#160;char&#160;&#160;type is, those bytes look like this:<br/>
['न',&#160;'म',&#160;'स',&#160;'◌्',&#160;'त',&#160;'◌े']<br/>
There are six&#160;&#160;char&#160;&#160;values here, but the fourth and sixth are not letters: they’re diacritics<br/>that don’t make sense on their own. Finally, if we look at them as grapheme clusters, we’d<br/>get what a person would call the four letters that make up the Hindi word:<br/>
[&#34;न&#34;,&#160;&#34;म&#34;,&#160;&#34;स्&#34;,&#160;&#34;ते&#34;]<br/>
Rust provides diﬀerent ways of interpreting the raw string data that computers store so that<br/>each program can choose the interpretation it needs, no matter what human language the<br/>data is in.<br/>
A&#160;ﬁnal reason Rust doesn’t allow us to index into a&#160;&#160;String&#160;&#160;to get a character is that<br/>indexing operations are expected to always take constant time (O(1)). But it isn’t possible to<br/>guarantee that performance with a&#160;&#160;String&#160;, because Rust would have to walk through the<br/>contents from the beginning to the index to determine how many valid characters there<br/>were.<br/>
https://doc.rust-lang.org/book/print.html<br/>
188/627<br/>
<hr/>
<a name=189></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#189"><b>Slicing&#160;Strings</b></a><br/>
Indexing into a string is often a bad idea because it’s not clear what the return type of the<br/>string-indexing operation should be: a byte value, a character, a grapheme cluster, or a<br/>string slice. If you really need to use indices to create string slices, therefore, Rust asks you<br/>to be more speciﬁc.<br/>
Rather than indexing using&#160;&#160;[]&#160;&#160;with a single number, you can use&#160;&#160;[]&#160;&#160;with a range to create<br/>a string slice containing particular bytes:<br/>
let&#160;hello&#160;=&#160;&#34;Здравствуйте&#34;;<br/>
let&#160;s&#160;=&#160;&amp;hello[0..4];<br/>
Here,&#160;&#160;s&#160;&#160;will be a&#160;&#160;&amp;str&#160;&#160;that contains the&#160;ﬁrst 4 bytes of the string. Earlier, we mentioned<br/>that each of these characters was 2 bytes, which means&#160;&#160;s&#160;&#160;will be&#160;&#160;Зд&#160;.<br/>
If we were to try to slice only part of a character’s bytes with something like&#160;&#160;&amp;hello[0..1]&#160;,<br/>Rust would panic at runtime in the same way as if an invalid index were accessed in a<br/>vector:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;collections&#160;v0.1.0&#160;(file:///projects/collections)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.43s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/collections`<br/>thread&#160;'main'&#160;panicked&#160;at&#160;'byte&#160;index&#160;1&#160;is&#160;not&#160;a&#160;char&#160;boundary;&#160;it&#160;is&#160;inside&#160;<br/>'З'&#160;(bytes&#160;0..2)&#160;of&#160;`Здравствуйте`',&#160;src/main.rs:4:14<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
You should use ranges to create string slices with caution, because doing so can crash your<br/>program.<br/>
<a href="tests.html#189"><b>Methods&#160;for&#160;Iterating&#160;Over&#160;Strings</b></a><br/>
The best way to operate on pieces of strings is to be explicit about whether you want<br/>characters or bytes. For individual Unicode scalar values, use the&#160;&#160;chars&#160;&#160;method. Calling<br/>
chars&#160;&#160;on “Зд” separates out and returns two values of type&#160;&#160;char&#160;, and you can iterate over<br/>
the result to access each element:<br/>
for&#160;c&#160;in&#160;&#34;Зд&#34;.chars()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;{c}&#34;);<br/>}<br/>
This code will print the following:<br/>
https://doc.rust-lang.org/book/print.html<br/>
189/627<br/>
<hr/>
<a name=190></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
З<br/>д<br/>
Alternatively, the&#160;&#160;bytes&#160;&#160;method returns each raw byte, which might be appropriate for<br/>your domain:<br/>
for&#160;b&#160;in&#160;&#34;Зд&#34;.bytes()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;{b}&#34;);<br/>}<br/>
This code will print the four bytes that make up this string:<br/>
208<br/>151<br/>208<br/>180<br/>
But be sure to remember that valid Unicode scalar values may be made up of more than 1<br/>byte.<br/>
Getting grapheme clusters from strings as with the Devanagari script is complex, so this<br/><a href="https://crates.io/">functionality is not provided by the standard library. Crates are available on&#160;crates.io</a>&#160;if this<br/>is the functionality you need.<br/>
<a href="tests.html#190"><b>Strings&#160;Are&#160;Not&#160;So&#160;Simple</b></a><br/>
To summarize, strings are complicated. Diﬀerent programming languages make diﬀerent<br/>choices about how to present this complexity to the programmer. Rust has chosen to make<br/>the correct handling of&#160;&#160;String&#160;&#160;data the default behavior for all Rust programs, which<br/>means programmers have to put more thought into handling UTF-8 data upfront. This<br/>trade-oﬀ&#160;exposes more of the complexity of strings than is apparent in other programming<br/>languages, but it prevents you from having to handle errors involving non-ASCII characters<br/>later in your development life cycle.<br/>
The good news is that the standard library oﬀers a lot of functionality built oﬀ&#160;the&#160;&#160;String<br/>and&#160;&#160;&amp;str&#160;&#160;types to help handle these complex situations correctly. Be sure to check out the<br/>documentation for useful methods like&#160;&#160;contains&#160;&#160;for searching in a string and&#160;&#160;replace&#160;&#160;for<br/>substituting parts of a string with another string.<br/>
Let’s switch to something a bit less complex: hash maps!<br/>
https://doc.rust-lang.org/book/print.html<br/>
190/627<br/>
<hr/>
<a name=191></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#191"><b>Storing Keys with Associated Values in Hash Maps</b></a><br/>
The last of our common collections is the&#160;<i>hash map</i>. The type&#160;&#160;HashMap&lt;K,&#160;V&gt;&#160;&#160;stores a<br/>mapping of keys of type&#160;&#160;K&#160;&#160;to values of type&#160;&#160;V&#160;&#160;using a&#160;<i>hashing function</i>, which determines<br/>how it places these keys and values into memory. Many programming languages support<br/>this kind of data structure, but they often use a diﬀerent name, such as hash, map, object,<br/>hash table, dictionary, or associative array, just to name a few.<br/>
Hash maps are useful when you want to look up data not by using an index, as you can with<br/>vectors, but by using a key that can be of any type. For example, in a game, you could keep<br/>track of each team’s score in a hash map in which each key is a team’s name and the values<br/>are each team’s score. Given a team name, you can retrieve its score.<br/>
We’ll go over the basic API of hash maps in this section, but many more goodies are hiding<br/>in the functions deﬁned on&#160;&#160;HashMap&lt;K,&#160;V&gt;&#160;&#160;by the standard library. As always, check the<br/>standard library documentation for more information.<br/>
<a href="tests.html#191"><b>Creating&#160;a&#160;New&#160;Hash&#160;Map</b></a><br/>
One way to create an empty hash map is using&#160;&#160;new&#160;&#160;and adding elements with&#160;&#160;insert&#160;. In<br/>Listing 8-20, we’re keeping track of the scores of two teams whose names are&#160;<i>Blue</i>&#160;and<br/><i>Yellow</i>. The Blue team starts with 10 points, and the Yellow team starts with 50.<br/>
&#160;&#160;&#160;&#160;use&#160;std::collections::HashMap;<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;scores&#160;=&#160;HashMap::new();<br/>
&#160;&#160;&#160;&#160;scores.insert(String::from(&#34;Blue&#34;),&#160;10);<br/>&#160;&#160;&#160;&#160;scores.insert(String::from(&#34;Yellow&#34;),&#160;50);<br/>
<b>Listing&#160;8-20:&#160;Creating&#160;a&#160;new&#160;hash&#160;map&#160;and&#160;inserting&#160;some&#160;keys&#160;and&#160;values</b><br/>
Note that we need to&#160;ﬁrst&#160;&#160;use&#160;&#160;the&#160;&#160;HashMap&#160;&#160;from the collections portion of the standard<br/>library. Of our three common collections, this one is the least often used, so it’s not included<br/>in the features brought into scope automatically in the prelude. Hash maps also have less<br/>support from the standard library; there’s no built-in macro to construct them, for example.<br/>
Just like vectors, hash maps store their data on the heap. This&#160;&#160;HashMap&#160;&#160;has keys of type<br/>
String&#160;&#160;and values of type&#160;&#160;i32&#160;. Like vectors, hash maps are homogeneous: all of the keys<br/>
must have the same type as each other, and all of the values must have the same type.<br/>
https://doc.rust-lang.org/book/print.html<br/>
191/627<br/>
<hr/>
<a name=192></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#192"><b>Accessing&#160;Values&#160;in&#160;a&#160;Hash&#160;Map</b></a><br/>
We can get a value out of the hash map by providing its key to the&#160;&#160;get&#160;&#160;method, as shown in<br/>Listing 8-21.<br/>
&#160;&#160;&#160;&#160;use&#160;std::collections::HashMap;<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;scores&#160;=&#160;HashMap::new();<br/>
&#160;&#160;&#160;&#160;scores.insert(String::from(&#34;Blue&#34;),&#160;10);<br/>&#160;&#160;&#160;&#160;scores.insert(String::from(&#34;Yellow&#34;),&#160;50);<br/>
&#160;&#160;&#160;&#160;let&#160;team_name&#160;=&#160;String::from(&#34;Blue&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;score&#160;=&#160;scores.get(&amp;team_name).copied().unwrap_or(0);<br/>
<b>Listing&#160;8-21:&#160;Accessing&#160;the&#160;score&#160;for&#160;the&#160;Blue&#160;team&#160;stored&#160;in&#160;the&#160;hash&#160;map</b><br/>
Here,&#160;&#160;score&#160;&#160;will have the value that’s associated with the Blue team, and the result will be<br/>
10&#160;. The&#160;&#160;get&#160;&#160;method returns an&#160;&#160;Option&lt;&amp;V&gt;&#160;; if there’s no value for that key in the hash<br/>
map,&#160;&#160;get&#160;&#160;will return&#160;&#160;None&#160;. This program handles the&#160;&#160;Option&#160;&#160;by calling&#160;&#160;copied&#160;&#160;to get an<br/>
Option&lt;i32&gt;&#160;&#160;rather than an&#160;&#160;Option&lt;&amp;i32&gt;&#160;, then&#160;&#160;unwrap_or&#160;&#160;to set&#160;&#160;score&#160;&#160;to zero if<br/>scores&#160;&#160;doesn't have an entry for the key.<br/>
We can iterate over each key/value pair in a hash map in a similar manner as we do with<br/>vectors, using a&#160;&#160;for&#160;&#160;loop:<br/>
&#160;&#160;&#160;&#160;use&#160;std::collections::HashMap;<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;scores&#160;=&#160;HashMap::new();<br/>
&#160;&#160;&#160;&#160;scores.insert(String::from(&#34;Blue&#34;),&#160;10);<br/>&#160;&#160;&#160;&#160;scores.insert(String::from(&#34;Yellow&#34;),&#160;50);<br/>
&#160;&#160;&#160;&#160;for&#160;(key,&#160;value)&#160;in&#160;&amp;scores&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;{key}:&#160;{value}&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>
This code will print each pair in an arbitrary order:<br/>
Yellow:&#160;50<br/>Blue:&#160;10<br/>
<a href="tests.html#192"><b>Hash&#160;Maps&#160;and&#160;Ownership</b></a><br/>
For types that implement the&#160;&#160;Copy&#160;&#160;trait, like&#160;&#160;i32&#160;, the values are copied into the hash map.<br/>For owned values like&#160;&#160;String&#160;, the values will be moved and the hash map will be the owner<br/>of those values, as demonstrated in Listing 8-22.<br/>
https://doc.rust-lang.org/book/print.html<br/>
192/627<br/>
<hr/>
<a name=193></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;use&#160;std::collections::HashMap;<br/>
&#160;&#160;&#160;&#160;let&#160;field_name&#160;=&#160;String::from(&#34;Favorite&#160;color&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;field_value&#160;=&#160;String::from(&#34;Blue&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;map&#160;=&#160;HashMap::new();<br/>&#160;&#160;&#160;&#160;map.insert(field_name,&#160;field_value);<br/>&#160;&#160;&#160;&#160;//&#160;field_name&#160;and&#160;field_value&#160;are&#160;invalid&#160;at&#160;this&#160;point,&#160;try&#160;using&#160;them&#160;and<br/>&#160;&#160;&#160;&#160;//&#160;see&#160;what&#160;compiler&#160;error&#160;you&#160;get!<br/>
<b>Listing&#160;8-22:&#160;Showing&#160;that&#160;keys&#160;and&#160;values&#160;are&#160;owned&#160;by&#160;the&#160;hash&#160;map&#160;once&#160;they’re&#160;inserted</b><br/>
We aren’t able to use the variables&#160;&#160;field_name&#160;&#160;and&#160;&#160;field_value&#160;&#160;after they’ve been moved<br/>into the hash map with the call to&#160;&#160;insert&#160;.<br/>
If we insert references to values into the hash map, the values won’t be moved into the hash<br/>map. The values that the references point to must be valid for at least as long as the hash<br/>map is valid. We’ll talk more about these issues in the&#160;<a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“Validating References with Lifetimes”<br/></a>section in Chapter 10.<br/>
<a href="tests.html#193"><b>Updating&#160;a&#160;Hash&#160;Map</b></a><br/>
Although the number of key and value pairs is growable, each unique key can only have one<br/>value associated with it at a time (but not vice versa: for example, both the Blue team and<br/>the Yellow team could have value 10 stored in the&#160;&#160;scores&#160;&#160;hash map).<br/>
When you want to change the data in a hash map, you have to decide how to handle the<br/>case when a key already has a value assigned. You could replace the old value with the new<br/>value, completely disregarding the old value. You could keep the old value and ignore the<br/>new value, only adding the new value if the key&#160;<i>doesn’t</i>&#160;already have a value. Or you could<br/>combine the old value and the new value. Let’s look at how to do each of these!<br/>
<a href="tests.html#193"><b>Overwriting a Value</b></a><br/>
If we insert a key and a value into a hash map and then insert that same key with a diﬀerent<br/>value, the value associated with that key will be replaced. Even though the code in Listing 8-<br/>23 calls&#160;&#160;insert&#160;&#160;twice, the hash map will only contain one key/value pair because we’re<br/>inserting the value for the Blue team’s key both times.<br/>
https://doc.rust-lang.org/book/print.html<br/>
193/627<br/>
<hr/>
<a name=194></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;use&#160;std::collections::HashMap;<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;scores&#160;=&#160;HashMap::new();<br/>
&#160;&#160;&#160;&#160;scores.insert(String::from(&#34;Blue&#34;),&#160;10);<br/>&#160;&#160;&#160;&#160;scores.insert(String::from(&#34;Blue&#34;),&#160;25);<br/>
&#160;&#160;&#160;&#160;println!(&#34;{:?}&#34;,&#160;scores);<br/>
<b>Listing&#160;8-23:&#160;Replacing&#160;a&#160;value&#160;stored&#160;with&#160;a&#160;particular&#160;key</b><br/>
This code will print&#160;&#160;{&#34;Blue&#34;:&#160;25}&#160;. The original value of&#160;&#160;10&#160;&#160;has been overwritten.<br/>
<a href="tests.html#194"><b>Adding a Key and Value Only If a Key Isn’t Present</b></a><br/>
It’s common to check whether a particular key already exists in the hash map with a value<br/>then take the following actions: if the key does exist in the hash map, the existing value<br/>should remain the way it is. If the key doesn’t exist, insert it and a value for it.<br/>
Hash maps have a special API for this called&#160;&#160;entry&#160;&#160;that takes the key you want to check as<br/>a parameter. The return value of the&#160;&#160;entry&#160;&#160;method is an enum called&#160;&#160;Entry&#160;&#160;that<br/>represents a value that might or might not exist. Let’s say we want to check whether the key<br/>for the Yellow team has a value associated with it. If it doesn’t, we want to insert the value<br/>50, and the same for the Blue team. Using the&#160;&#160;entry&#160;&#160;API, the code looks like Listing 8-24.<br/>
&#160;&#160;&#160;&#160;use&#160;std::collections::HashMap;<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;scores&#160;=&#160;HashMap::new();<br/>&#160;&#160;&#160;&#160;scores.insert(String::from(&#34;Blue&#34;),&#160;10);<br/>
&#160;&#160;&#160;&#160;scores.entry(String::from(&#34;Yellow&#34;)).or_insert(50);<br/>&#160;&#160;&#160;&#160;scores.entry(String::from(&#34;Blue&#34;)).or_insert(50);<br/>
&#160;&#160;&#160;&#160;println!(&#34;{:?}&#34;,&#160;scores);<br/>
<b>Listing&#160;8-24:&#160;Using&#160;the&#160;&#160;</b>entry&#160;<b>&#160;method&#160;to&#160;only&#160;insert&#160;if&#160;the&#160;key&#160;does&#160;not&#160;already&#160;have&#160;a&#160;value</b><br/>
The&#160;&#160;or_insert&#160;&#160;method on&#160;&#160;Entry&#160;&#160;is deﬁned to return a mutable reference to the value for<br/>the corresponding&#160;&#160;Entry&#160;&#160;key if that key exists, and if not, inserts the parameter as the new<br/>value for this key and returns a mutable reference to the new value. This technique is much<br/>cleaner than writing the logic ourselves and, in addition, plays more nicely with the borrow<br/>checker.<br/>
Running the code in Listing 8-24 will print&#160;&#160;{&#34;Yellow&#34;:&#160;50,&#160;&#34;Blue&#34;:&#160;10}&#160;. The&#160;ﬁrst call to<br/>
entry&#160;&#160;will insert the key for the Yellow team with the value 50 because the Yellow team<br/>
doesn’t have a value already. The second call to&#160;&#160;entry&#160;&#160;will not change the hash map<br/>because the Blue team already has the value 10.<br/>
https://doc.rust-lang.org/book/print.html<br/>
194/627<br/>
<hr/>
<a name=195></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#195"><b>Updating a Value Based on the Old Value</b></a><br/>
Another common use case for hash maps is to look up a key’s value and then update it<br/>based on the old value. For instance, Listing 8-25 shows code that counts how many times<br/>each word appears in some text. We use a hash map with the words as keys and increment<br/>the value to keep track of how many times we’ve seen that word. If it’s the&#160;ﬁrst time we’ve<br/>seen a word, we’ll&#160;ﬁrst insert the value 0.<br/>
&#160;&#160;&#160;&#160;use&#160;std::collections::HashMap;<br/>
&#160;&#160;&#160;&#160;let&#160;text&#160;=&#160;&#34;hello&#160;world&#160;wonderful&#160;world&#34;;<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;map&#160;=&#160;HashMap::new();<br/>
&#160;&#160;&#160;&#160;for&#160;word&#160;in&#160;text.split_whitespace()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;count&#160;=&#160;map.entry(word).or_insert(0);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*count&#160;+=&#160;1;<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;{:?}&#34;,&#160;map);<br/>
<b>Listing&#160;8-25:&#160;Counting&#160;occurrences&#160;of&#160;words&#160;using&#160;a&#160;hash&#160;map&#160;that&#160;stores&#160;words&#160;and&#160;counts</b><br/>
This code will print&#160;&#160;{&#34;world&#34;:&#160;2,&#160;&#34;hello&#34;:&#160;1,&#160;&#34;wonderful&#34;:&#160;1}&#160;. You might see the same<br/>key/value pairs printed in a diﬀ<a href="https://doc.rust-lang.org/book/ch08-03-hash-maps.html#accessing-values-in-a-hash-map">erent order: recall from the&#160;“Accessing Values in a Hash Map”<br/></a>section that iterating over a hash map happens in an arbitrary order.<br/>
The&#160;&#160;split_whitespace&#160;&#160;method returns an iterator over sub-slices, separated by<br/>whitespace, of the value in&#160;&#160;text&#160;. The&#160;&#160;or_insert&#160;&#160;method returns a mutable reference<br/>(&#160;&amp;mut&#160;V&#160;) to the value for the speciﬁed key. Here we store that mutable reference in the<br/>
count&#160;&#160;variable, so in order to assign to that value, we must&#160;ﬁrst dereference&#160;&#160;count&#160;&#160;using<br/>
the asterisk (&#160;*&#160;). The mutable reference goes out of scope at the end of the&#160;&#160;for&#160;&#160;loop, so all<br/>of these changes are safe and allowed by the borrowing rules.<br/>
<a href="tests.html#195"><b>Hashing&#160;Functions</b></a><br/>
By default,&#160;&#160;HashMap&#160;&#160;uses a hashing function called&#160;<i>SipHash</i>&#160;that can provide resistance to<br/>Denial of Service (DoS) attacks involving hash tables<a href="tests.html#196">1. This is not the fastest hashing<br/></a>algorithm available, but the trade-oﬀ&#160;for better security that comes with the drop in<br/>performance is worth it. If you proﬁle your code and&#160;ﬁnd that the default hash function is<br/>too slow for your purposes, you can switch to another function by specifying a diﬀerent<br/>hasher. A&#160;<i>hasher</i>&#160;is a type that implements the&#160;&#160;BuildHasher&#160;&#160;trait. We’ll talk about traits and<br/>how to implement them in Chapter 10. You don’t necessarily have to implement your own<br/>hasher from scratch;&#160;<a href="https://crates.io/">crates.io</a>&#160;has libraries shared by other Rust users that provide hashers<br/>implementing many common hashing algorithms.<br/>
https://doc.rust-lang.org/book/print.html<br/>
195/627<br/>
<hr/>
<a name=196></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
1&#160;<a href="https://en.wikipedia.org/wiki/SipHash">https://en.wikipedia.org/wiki/SipHash</a><br/>
<a href="tests.html#196"><b>Summary</b></a><br/>
Vectors, strings, and hash maps will provide a large amount of functionality necessary in<br/>programs when you need to store, access, and modify data. Here are some exercises you<br/>should now be equipped to solve:<br/>
Given a list of integers, use a vector and return the median (when sorted, the value in<br/>the middle position) and mode (the value that occurs most often; a hash map will be<br/>helpful here) of the list.<br/>Convert strings to pig latin. The&#160;ﬁrst consonant of each word is moved to the end of<br/>the word and “ay” is added, so “ﬁrst” becomes “irst-fay.” Words that start with a vowel<br/>have “hay” added to the end instead (“apple” becomes “apple-hay”). Keep in mind the<br/>details about UTF-8 encoding!<br/>Using a hash map and vectors, create a text interface to allow a user to add employee<br/>names to a department in a company. For example, “Add Sally to Engineering” or “Add<br/>Amir to Sales.” Then let the user retrieve a list of all people in a department or all<br/>people in the company by department, sorted alphabetically.<br/>
The standard library API documentation describes methods that vectors, strings, and hash<br/>maps have that will be helpful for these exercises!<br/>
We’re getting into more complex programs in which operations can fail, so, it’s a perfect<br/>time to discuss error handling. We’ll do that next!<br/>
https://doc.rust-lang.org/book/print.html<br/>
196/627<br/>
<hr/>
<a name=197></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#197"><b>Error Handling</b></a><br/>
Errors are a fact of life in software, so Rust has a number of features for handling situations<br/>in which something goes wrong. In many cases, Rust requires you to acknowledge the<br/>possibility of an error and take some action before your code will compile. This requirement<br/>makes your program more robust by ensuring that you’ll discover errors and handle them<br/>appropriately before you’ve deployed your code to production!<br/>
Rust groups errors into two major categories:&#160;<i>recoverable</i>&#160;and&#160;<i>unrecoverable</i>&#160;errors. For a<br/>recoverable error, such as a&#160;<i>ﬁle not found</i>&#160;error, we most likely just want to report the<br/>problem to the user and retry the operation. Unrecoverable errors are always symptoms of<br/>bugs, like trying to access a location beyond the end of an array, and so we want to<br/>immediately stop the program.<br/>
Most languages don’t distinguish between these two kinds of errors and handle both in the<br/>same way, using mechanisms such as exceptions. Rust doesn’t have exceptions. Instead, it<br/>has the type&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;for recoverable errors and the&#160;&#160;panic!&#160;&#160;macro that stops<br/>execution when the program encounters an unrecoverable error. This chapter covers calling<br/>
panic!&#160;&#160;ﬁrst and then talks about returning&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;values. Additionally, we’ll explore<br/>
considerations when deciding whether to try to recover from an error or to stop execution.<br/>
https://doc.rust-lang.org/book/print.html<br/>
197/627<br/>
<hr/>
<a name=198></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#198"><b>Unrecoverable Errors with&#160;</b>panic!</a><br/>
Sometimes, bad things happen in your code, and there’s nothing you can do about it. In<br/>these cases, Rust has the&#160;&#160;panic!&#160;&#160;macro. There are two ways to cause a panic in practice: by<br/>taking an action that causes our code to panic (such as accessing an array past the end) or<br/>by explicitly calling the&#160;&#160;panic!&#160;&#160;macro. In both cases, we cause a panic in our program. By<br/>default, these panics will print a failure message, unwind, clean up the stack, and quit. Via<br/>an environment variable, you can also have Rust display the call stack when a panic occurs<br/>to make it easier to track down the source of the panic.<br/>
<a href="tests.html#198"><b>Unwinding&#160;the&#160;Stack&#160;or&#160;Aborting&#160;in&#160;Response&#160;to&#160;a&#160;Panic</b></a><br/>
By default, when a panic occurs, the program starts&#160;<i>unwinding</i>, which means Rust<br/>walks back up the stack and cleans up the data from each function it encounters.<br/>However, this walking back and cleanup is a lot of work. Rust, therefore, allows you to<br/>choose the alternative of immediately&#160;<i>aborting</i>, which ends the program without<br/>cleaning up.<br/>
Memory that the program was using will then need to be cleaned up by the operating<br/>system. If in your project you need to make the resulting binary as small as possible,<br/>you can switch from unwinding to aborting upon a panic by adding&#160;&#160;panic&#160;=&#160;'abort'<br/>to the appropriate&#160;&#160;[profile]&#160;&#160;sections in your&#160;<i>Cargo.toml</i>&#160;ﬁle. For example, if you want<br/>to abort on panic in release mode, add this:<br/>
[profile.release]<br/>panic&#160;=&#160;'abort'<br/>
Let’s try calling&#160;&#160;panic!&#160;&#160;in a simple program:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;panic!(&#34;crash&#160;and&#160;burn&#34;);<br/>}<br/>
When you run the program, you’ll see something like this:<br/>
https://doc.rust-lang.org/book/print.html<br/>
198/627<br/>
<hr/>
<a name=199></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;panic&#160;v0.1.0&#160;(file:///projects/panic)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.25s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/panic`<br/>thread&#160;'main'&#160;panicked&#160;at&#160;'crash&#160;and&#160;burn',&#160;src/main.rs:2:5<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
The call to&#160;&#160;panic!&#160;&#160;causes the error message contained in the last two lines. The&#160;ﬁrst line<br/>shows our panic message and the place in our source code where the panic occurred:<br/><i>src/main.rs:2:5</i>&#160;indicates that it’s the second line,&#160;ﬁfth character of our&#160;<i>src/main.rs</i>&#160;ﬁle.<br/>
In this case, the line indicated is part of our code, and if we go to that line, we see the<br/>
panic!&#160;&#160;macro call. In other cases, the&#160;&#160;panic!&#160;&#160;call might be in code that our code calls, and<br/>
the&#160;ﬁlename and line number reported by the error message will be someone else’s code<br/>where the&#160;&#160;panic!&#160;&#160;macro is called, not the line of our code that eventually led to the<br/>
panic!&#160;&#160;call. We can use the backtrace of the functions the&#160;&#160;panic!&#160;&#160;call came from to&#160;ﬁgure<br/>
out the part of our code that is causing the problem. We’ll discuss backtraces in more detail<br/>next.<br/>
<a href="tests.html#199"><b>Using&#160;a&#160;</b>panic!<b>&#160;Backtrace</b></a><br/>
Let’s look at another example to see what it’s like when a&#160;&#160;panic!&#160;&#160;call comes from a library<br/>because of a bug in our code instead of from our code calling the macro directly. Listing 9-1<br/>has some code that attempts to access an index in a vector beyond the range of valid<br/>indexes.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;v&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>
&#160;&#160;&#160;&#160;v[99];<br/>}<br/>
<b>Listing&#160;9-1:&#160;Attempting&#160;to&#160;access&#160;an&#160;element&#160;beyond&#160;the&#160;end&#160;of&#160;a&#160;vector,&#160;which&#160;will&#160;cause&#160;a&#160;call&#160;to&#160;&#160;</b>panic!<br/>
Here, we’re attempting to access the 100th element of our vector (which is at index 99<br/>because indexing starts at zero), but the vector has only 3 elements. In this situation, Rust<br/>will panic. Using&#160;&#160;[]&#160;&#160;is supposed to return an element, but if you pass an invalid index,<br/>there’s no element that Rust could return here that would be correct.<br/>
In C, attempting to read beyond the end of a data structure is undeﬁned behavior. You<br/>might get whatever is at the location in memory that would correspond to that element in<br/>the data structure, even though the memory doesn’t belong to that structure. This is called a<br/><i>buﬀer overread</i>&#160;and can lead to security vulnerabilities if an attacker is able to manipulate<br/>
https://doc.rust-lang.org/book/print.html<br/>
199/627<br/>
<hr/>
<a name=200></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
the index in such a way as to read data they shouldn’t be allowed to that is stored after the<br/>data structure.<br/>
To protect your program from this sort of vulnerability, if you try to read an element at an<br/>index that doesn’t exist, Rust will stop execution and refuse to continue. Let’s try it and see:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;panic&#160;v0.1.0&#160;(file:///projects/panic)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.27s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/panic`<br/>thread&#160;'main'&#160;panicked&#160;at&#160;'index&#160;out&#160;of&#160;bounds:&#160;the&#160;len&#160;is&#160;3&#160;but&#160;the&#160;index&#160;is&#160;<br/>99',&#160;src/main.rs:4:5<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
This error points at line 4 of our&#160;&#160;main.rs&#160;&#160;where we attempt to access index 99. The next<br/>note line tells us that we can set the&#160;&#160;RUST_BACKTRACE&#160;&#160;environment variable to get a<br/>backtrace of exactly what happened to cause the error. A&#160;<i>backtrace</i>&#160;is a list of all the<br/>functions that have been called to get to this point. Backtraces in Rust work as they do in<br/>other languages: the key to reading the backtrace is to start from the top and read until you<br/>see&#160;ﬁles you wrote. That’s the spot where the problem originated. The lines above that spot<br/>are code that your code has called; the lines below are code that called your code. These<br/>before-and-after lines might include core Rust code, standard library code, or crates that<br/>you’re using. Let’s try getting a backtrace by setting the&#160;&#160;RUST_BACKTRACE&#160;&#160;environment<br/>variable to any value except 0. Listing 9-2 shows output similar to what you’ll see.<br/>
https://doc.rust-lang.org/book/print.html<br/>
200/627<br/>
<hr/>
<a name=201></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;RUST_BACKTRACE=1&#160;cargo&#160;run<br/>thread&#160;'main'&#160;panicked&#160;at&#160;'index&#160;out&#160;of&#160;bounds:&#160;the&#160;len&#160;is&#160;3&#160;but&#160;the&#160;index&#160;is&#160;<br/>99',&#160;src/main.rs:4:5<br/>stack&#160;backtrace:<br/>&#160;&#160;&#160;0:&#160;rust_begin_unwind<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;at&#160;<br/>/rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:58<br/>4:5<br/>&#160;&#160;&#160;1:&#160;core::panicking::panic_fmt<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;at&#160;<br/>/rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:1<br/>42:14<br/>&#160;&#160;&#160;2:&#160;core::panicking::panic_bounds_check<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;at&#160;<br/>/rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:8<br/>4:5<br/>&#160;&#160;&#160;3:&#160;&lt;usize&#160;as&#160;core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;at&#160;<br/>/rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs<br/>:242:10<br/>&#160;&#160;&#160;4:&#160;core::slice::index::&lt;impl&#160;core::ops::index::Index&lt;I&gt;&#160;for&#160;[T]&gt;::index<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;at&#160;<br/>/rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs<br/>:18:9<br/>&#160;&#160;&#160;5:&#160;&lt;alloc::vec::Vec&lt;T,A&gt;&#160;as&#160;core::ops::index::Index&lt;I&gt;&gt;::index<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;at&#160;<br/>/rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:25<br/>91:9<br/>&#160;&#160;&#160;6:&#160;panic::main<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;at&#160;./src/main.rs:4:5<br/>&#160;&#160;&#160;7:&#160;core::ops::function::FnOnce::call_once<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;at&#160;<br/>/rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.r<br/>s:248:5<br/>note:&#160;Some&#160;details&#160;are&#160;omitted,&#160;run&#160;with&#160;`RUST_BACKTRACE=full`&#160;for&#160;a&#160;verbose&#160;<br/>backtrace.<br/>
<b>Listing&#160;9-2:&#160;The&#160;backtrace&#160;generated&#160;by&#160;a&#160;call&#160;to&#160;&#160;</b>panic!&#160;<b>&#160;displayed&#160;when&#160;the&#160;environment&#160;variable</b><br/>
RUST_BACKTRACE&#160;<b>&#160;is&#160;set</b><br/>
That’s a lot of output! The exact output you see might be diﬀerent depending on your<br/>operating system and Rust version. In order to get backtraces with this information, debug<br/>symbols must be enabled. Debug symbols are enabled by default when using&#160;&#160;cargo&#160;build<br/>or&#160;&#160;cargo&#160;run&#160;&#160;without the&#160;&#160;--release&#160;&#160;ﬂag, as we have here.<br/>
In the output in Listing 9-2, line 6 of the backtrace points to the line in our project that’s<br/>causing the problem: line 4 of&#160;<i>src/main.rs</i>. If we don’t want our program to panic, we should<br/>start our investigation at the location pointed to by the&#160;ﬁrst line mentioning a&#160;ﬁle we wrote.<br/>In Listing 9-1, where we deliberately wrote code that would panic, the way to&#160;ﬁx the panic is<br/>to not request an element beyond the range of the vector indexes. When your code panics<br/>in the future, you’ll need to&#160;ﬁgure out what action the code is taking with what values to<br/>cause the panic and what the code should do instead.<br/>
https://doc.rust-lang.org/book/print.html<br/>
201/627<br/>
<hr/>
<a name=202></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We’ll come back to&#160;&#160;panic!&#160;&#160;and when we should and should not use&#160;&#160;panic!&#160;&#160;to handle<br/>error conditions in the&#160;<a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">“To&#160;&#160;panic!&#160;&#160;or Not to&#160;&#160;panic!&#160;”</a>&#160;section later in this chapter. Next,<br/>we’ll look at how to recover from an error using&#160;&#160;Result&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
202/627<br/>
<hr/>
<a name=203></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#203"><b>Recoverable Errors with&#160;</b>Result</a><br/>
Most errors aren’t serious enough to require the program to stop entirely. Sometimes,<br/>when a function fails, it’s for a reason that you can easily interpret and respond to. For<br/>example, if you try to open a&#160;ﬁle and that operation fails because the&#160;ﬁle doesn’t exist, you<br/>might want to create the&#160;ﬁle instead of terminating the process.<br/>
<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result">Recall from&#160;“Handling Potential Failure with&#160;&#160;Result&#160;”</a>&#160;in Chapter 2 that the&#160;&#160;Result&#160;&#160;enum is<br/>deﬁned as having two variants,&#160;&#160;Ok&#160;&#160;and&#160;&#160;Err&#160;, as follows:<br/>
enum&#160;Result&lt;T,&#160;E&gt;&#160;{<br/>&#160;&#160;&#160;&#160;Ok(T),<br/>&#160;&#160;&#160;&#160;Err(E),<br/>}<br/>
The&#160;&#160;T&#160;&#160;and&#160;&#160;E&#160;&#160;are generic type parameters: we’ll discuss generics in more detail in Chapter<br/>10. What you need to know right now is that&#160;&#160;T&#160;&#160;represents the type of the value that will be<br/>returned in a success case within the&#160;&#160;Ok&#160;&#160;variant, and&#160;&#160;E&#160;&#160;represents the type of the error<br/>that will be returned in a failure case within the&#160;&#160;Err&#160;&#160;variant. Because&#160;&#160;Result&#160;&#160;has these<br/>generic type parameters, we can use the&#160;&#160;Result&#160;&#160;type and the functions deﬁned on it in<br/>many diﬀerent situations where the successful value and error value we want to return may<br/>diﬀer.<br/>
Let’s call a function that returns a&#160;&#160;Result&#160;&#160;value because the function could fail. In Listing 9-<br/>3 we try to open a&#160;ﬁle.<br/>
Filename: src/main.rs<br/>
use&#160;std::fs::File;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;greeting_file_result&#160;=&#160;File::open(&#34;hello.txt&#34;);<br/>}<br/>
<b>Listing&#160;9-3:&#160;Opening&#160;a&#160;ﬁle</b><br/>
The return type of&#160;&#160;File::open&#160;&#160;is a&#160;&#160;Result&lt;T,&#160;E&gt;&#160;. The generic parameter&#160;&#160;T&#160;&#160;has been&#160;ﬁlled<br/>in by the implementation of&#160;&#160;File::open&#160;&#160;with the type of the success value,<br/>
std::fs::File&#160;, which is a&#160;ﬁle handle. The type of&#160;&#160;E&#160;&#160;used in the error value is<br/>std::io::Error&#160;. This return type means the call to&#160;&#160;File::open&#160;&#160;might succeed and return<br/>
a&#160;ﬁle handle that we can read from or write to. The function call also might fail: for example,<br/>the&#160;ﬁle might not exist, or we might not have permission to access the&#160;ﬁle. The&#160;&#160;File::open<br/>function needs to have a way to tell us whether it succeeded or failed and at the same time<br/>
https://doc.rust-lang.org/book/print.html<br/>
203/627<br/>
<hr/>
<a name=204></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
give us either the&#160;ﬁle handle or error information. This information is exactly what the<br/>
Result&#160;&#160;enum conveys.<br/>
In the case where&#160;&#160;File::open&#160;&#160;succeeds, the value in the variable&#160;&#160;greeting_file_result<br/>will be an instance of&#160;&#160;Ok&#160;&#160;that contains a&#160;ﬁle handle. In the case where it fails, the value in<br/>
greeting_file_result&#160;&#160;will be an instance of&#160;&#160;Err&#160;&#160;that contains more information about<br/>
the kind of error that happened.<br/>
We need to add to the code in Listing 9-3 to take diﬀerent actions depending on the value<br/>
File::open&#160;&#160;returns. Listing 9-4 shows one way to handle the&#160;&#160;Result&#160;&#160;using a basic tool, the<br/>match&#160;&#160;expression that we discussed in Chapter 6.<br/>
Filename: src/main.rs<br/>
use&#160;std::fs::File;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;greeting_file_result&#160;=&#160;File::open(&#34;hello.txt&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;greeting_file&#160;=&#160;match&#160;greeting_file_result&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(file)&#160;=&gt;&#160;file,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(error)&#160;=&gt;&#160;panic!(&#34;Problem&#160;opening&#160;the&#160;file:&#160;{:?}&#34;,&#160;error),<br/>&#160;&#160;&#160;&#160;};<br/>}<br/>
<b>Listing&#160;9-4:&#160;Using&#160;a&#160;&#160;</b>match&#160;<b>&#160;expression&#160;to&#160;handle&#160;the&#160;&#160;</b>Result&#160;<b>&#160;variants&#160;that&#160;might&#160;be&#160;returned</b><br/>
Note that, like the&#160;&#160;Option&#160;&#160;enum, the&#160;&#160;Result&#160;&#160;enum and its variants have been brought into<br/>scope by the prelude, so we don’t need to specify&#160;&#160;Result::&#160;&#160;before the&#160;&#160;Ok&#160;&#160;and&#160;&#160;Err<br/>variants in the&#160;&#160;match&#160;&#160;arms.<br/>
When the result is&#160;&#160;Ok&#160;, this code will return the inner&#160;&#160;file&#160;&#160;value out of the&#160;&#160;Ok&#160;&#160;variant, and<br/>we then assign that&#160;ﬁle handle value to the variable&#160;&#160;greeting_file&#160;. After the&#160;&#160;match&#160;, we<br/>can use the&#160;ﬁle handle for reading or writing.<br/>
The other arm of the&#160;&#160;match&#160;&#160;handles the case where we get an&#160;&#160;Err&#160;&#160;value from<br/>
File::open&#160;. In this example, we’ve chosen to call the&#160;&#160;panic!&#160;&#160;macro. If there’s no&#160;ﬁle<br/>
named&#160;<i>hello.txt</i>&#160;in our current directory and we run this code, we’ll see the following output<br/>from the&#160;&#160;panic!&#160;&#160;macro:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;error-handling&#160;v0.1.0&#160;(file:///projects/error-handling)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.73s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/error-handling`<br/>thread&#160;'main'&#160;panicked&#160;at&#160;'Problem&#160;opening&#160;the&#160;file:&#160;Os&#160;{&#160;code:&#160;2,&#160;kind:&#160;<br/>NotFound,&#160;message:&#160;&#34;No&#160;such&#160;file&#160;or&#160;directory&#34;&#160;}',&#160;src/main.rs:8:23<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
As usual, this output tells us exactly what has gone wrong.<br/>
https://doc.rust-lang.org/book/print.html<br/>
204/627<br/>
<hr/>
<a name=205></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#205"><b>Matching&#160;on&#160;Diﬀerent&#160;Errors</b></a><br/>
The code in Listing 9-4 will&#160;&#160;panic!&#160;&#160;no matter why&#160;&#160;File::open&#160;&#160;failed. However, we want to<br/>take diﬀerent actions for diﬀerent failure reasons: if&#160;&#160;File::open&#160;&#160;failed because the&#160;ﬁle<br/>doesn’t exist, we want to create the&#160;ﬁle and return the handle to the new&#160;ﬁle. If&#160;&#160;File::open<br/>failed for any other reason—for example, because we didn’t have permission to open the<br/>ﬁle—we still want the code to&#160;&#160;panic!&#160;&#160;in the same way as it did in Listing 9-4. For this we<br/>add an inner&#160;&#160;match&#160;&#160;expression, shown in Listing 9-5.<br/>
Filename: src/main.rs<br/>
use&#160;std::fs::File;<br/>use&#160;std::io::ErrorKind;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;greeting_file_result&#160;=&#160;File::open(&#34;hello.txt&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;greeting_file&#160;=&#160;match&#160;greeting_file_result&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(file)&#160;=&gt;&#160;file,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(error)&#160;=&gt;&#160;match&#160;error.kind()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ErrorKind::NotFound&#160;=&gt;&#160;match&#160;File::create(&#34;hello.txt&#34;)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(fc)&#160;=&gt;&#160;fc,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(e)&#160;=&gt;&#160;panic!(&#34;Problem&#160;creating&#160;the&#160;file:&#160;{:?}&#34;,&#160;e),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;other_error&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic!(&#34;Problem&#160;opening&#160;the&#160;file:&#160;{:?}&#34;,&#160;other_error);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;},<br/>&#160;&#160;&#160;&#160;};<br/>}<br/>
<b>Listing&#160;9-5:&#160;Handling&#160;diﬀerent&#160;kinds&#160;of&#160;errors&#160;in&#160;diﬀerent&#160;ways</b><br/>
The type of the value that&#160;&#160;File::open&#160;&#160;returns inside the&#160;&#160;Err&#160;&#160;variant is&#160;&#160;io::Error&#160;, which<br/>is a struct provided by the standard library. This struct has a method&#160;&#160;kind&#160;&#160;that we can call<br/>to get an&#160;&#160;io::ErrorKind&#160;&#160;value. The enum&#160;&#160;io::ErrorKind&#160;&#160;is provided by the standard<br/>library and has variants representing the diﬀerent kinds of errors that might result from an<br/>
io&#160;&#160;operation. The variant we want to use is&#160;&#160;ErrorKind::NotFound&#160;, which indicates the&#160;ﬁle<br/>
we’re trying to open doesn’t exist yet. So we match on&#160;&#160;greeting_file_result&#160;, but we also<br/>have an inner match on&#160;&#160;error.kind()&#160;.<br/>
The condition we want to check in the inner match is whether the value returned by<br/>
error.kind()&#160;&#160;is the&#160;&#160;NotFound&#160;&#160;variant of the&#160;&#160;ErrorKind&#160;&#160;enum. If it is, we try to create the<br/>
ﬁle with&#160;&#160;File::create&#160;. However, because&#160;&#160;File::create&#160;&#160;could also fail, we need a second<br/>arm in the inner&#160;&#160;match&#160;&#160;expression. When the&#160;ﬁle can’t be created, a diﬀerent error<br/>message is printed. The second arm of the outer&#160;&#160;match&#160;&#160;stays the same, so the program<br/>panics on any error besides the missing&#160;ﬁle error.<br/>
https://doc.rust-lang.org/book/print.html<br/>
205/627<br/>
<hr/>
<a name=206></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#206"><b>Alternatives&#160;to&#160;Using&#160;</b>match<b>&#160;with&#160;</b>Result&lt;T,&#160;E&gt;</a><br/>
That’s a lot of&#160;&#160;match&#160;! The&#160;&#160;match&#160;&#160;expression is very useful but also very much a<br/>primitive. In Chapter 13, you’ll learn about closures, which are used with many of the<br/>methods deﬁned on&#160;&#160;Result&lt;T,&#160;E&gt;&#160;. These methods can be more concise than using<br/>
match&#160;&#160;when handling&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;values in your code.<br/>
For example, here’s another way to write the same logic as shown in Listing 9-5, this<br/>time using closures and the&#160;&#160;unwrap_or_else&#160;&#160;method:<br/>
use&#160;std::fs::File;<br/>use&#160;std::io::ErrorKind;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;greeting_file&#160;=&#160;File::open(&#34;hello.txt&#34;).unwrap_or_else(|error|&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;error.kind()&#160;==&#160;ErrorKind::NotFound&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;File::create(&#34;hello.txt&#34;).unwrap_or_else(|error|&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic!(&#34;Problem&#160;creating&#160;the&#160;file:&#160;{:?}&#34;,&#160;error);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;})<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic!(&#34;Problem&#160;opening&#160;the&#160;file:&#160;{:?}&#34;,&#160;error);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;});<br/>}<br/>
Although this code has the same behavior as Listing 9-5, it doesn’t contain any&#160;&#160;match<br/>expressions and is cleaner to read. Come back to this example after you’ve read<br/>Chapter 13, and look up the&#160;&#160;unwrap_or_else&#160;&#160;method in the standard library<br/>documentation. Many more of these methods can clean up huge nested&#160;&#160;match<br/>expressions when you’re dealing with errors.<br/>
<a href="tests.html#206"><b>Shortcuts&#160;for&#160;Panic&#160;on&#160;Error:&#160;</b>unwrap<b>&#160;and&#160;</b>expect</a><br/>
Using&#160;&#160;match&#160;&#160;works well enough, but it can be a bit verbose and doesn’t always<br/>communicate intent well. The&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;type has many helper methods deﬁned on it to<br/>do various, more speciﬁc tasks. The&#160;&#160;unwrap&#160;&#160;method is a shortcut method implemented just<br/>like the&#160;&#160;match&#160;&#160;expression we wrote in Listing 9-4. If the&#160;&#160;Result&#160;&#160;value is the&#160;&#160;Ok&#160;&#160;variant,<br/>
unwrap&#160;&#160;will return the value inside the&#160;&#160;Ok&#160;. If the&#160;&#160;Result&#160;&#160;is the&#160;&#160;Err&#160;&#160;variant,&#160;&#160;unwrap&#160;&#160;will<br/>
call the&#160;&#160;panic!&#160;&#160;macro for us. Here is an example of&#160;&#160;unwrap&#160;&#160;in action:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
206/627<br/>
<hr/>
<a name=207></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::fs::File;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;greeting_file&#160;=&#160;File::open(&#34;hello.txt&#34;).unwrap();<br/>}<br/>
If we run this code without a&#160;<i>hello.txt</i>&#160;ﬁle, we’ll see an error message from the&#160;&#160;panic!&#160;&#160;call<br/>that the&#160;&#160;unwrap&#160;&#160;method makes:<br/>
thread&#160;'main'&#160;panicked&#160;at&#160;'called&#160;`Result::unwrap()`&#160;on&#160;an&#160;`Err`&#160;value:&#160;Os&#160;{<br/>code:&#160;2,&#160;kind:&#160;NotFound,&#160;message:&#160;&#34;No&#160;such&#160;file&#160;or&#160;directory&#34;&#160;}',<br/>src/main.rs:4:49<br/>
Similarly, the&#160;&#160;expect&#160;&#160;method lets us also choose the&#160;&#160;panic!&#160;&#160;error message. Using&#160;&#160;expect<br/>instead of&#160;&#160;unwrap&#160;&#160;and providing good error messages can convey your intent and make<br/>tracking down the source of a panic easier. The syntax of&#160;&#160;expect&#160;&#160;looks like this:<br/>
Filename: src/main.rs<br/>
use&#160;std::fs::File;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;greeting_file&#160;=&#160;File::open(&#34;hello.txt&#34;)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;hello.txt&#160;should&#160;be&#160;included&#160;in&#160;this&#160;project&#34;);<br/>}<br/>
We use&#160;&#160;expect&#160;&#160;in the same way as&#160;&#160;unwrap&#160;: to return the&#160;ﬁle handle or call the&#160;&#160;panic!<br/>macro. The error message used by&#160;&#160;expect&#160;&#160;in its call to&#160;&#160;panic!&#160;&#160;will be the parameter that<br/>we pass to&#160;&#160;expect&#160;, rather than the default&#160;&#160;panic!&#160;&#160;message that&#160;&#160;unwrap&#160;&#160;uses. Here’s what<br/>it looks like:<br/>
thread&#160;'main'&#160;panicked&#160;at&#160;'hello.txt&#160;should&#160;be&#160;included&#160;in&#160;this&#160;project:&#160;Os&#160;{<br/>code:&#160;2,&#160;kind:&#160;NotFound,&#160;message:&#160;&#34;No&#160;such&#160;file&#160;or&#160;directory&#34;&#160;}',<br/>src/main.rs:5:10<br/>
In production-quality code, most Rustaceans choose&#160;&#160;expect&#160;&#160;rather than&#160;&#160;unwrap&#160;&#160;and give<br/>more context about why the operation is expected to always succeed. That way, if your<br/>assumptions are ever proven wrong, you have more information to use in debugging.<br/>
<a href="tests.html#207"><b>Propagating&#160;Errors</b></a><br/>
When a function’s implementation calls something that might fail, instead of handling the<br/>error within the function itself, you can return the error to the calling code so that it can<br/>decide what to do. This is known as&#160;<i>propagating</i>&#160;the error and gives more control to the<br/>calling code, where there might be more information or logic that dictates how the error<br/>should be handled than what you have available in the context of your code.<br/>
https://doc.rust-lang.org/book/print.html<br/>
207/627<br/>
<hr/>
<a name=208></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
For example, Listing 9-6 shows a function that reads a username from a&#160;ﬁle. If the&#160;ﬁle<br/>doesn’t exist or can’t be read, this function will return those errors to the code that called<br/>the function.<br/>
Filename: src/main.rs<br/>
use&#160;std::fs::File;<br/>use&#160;std::io::{self,&#160;Read};<br/>
fn&#160;read_username_from_file()&#160;-&gt;&#160;Result&lt;String,&#160;io::Error&gt;&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;username_file_result&#160;=&#160;File::open(&#34;hello.txt&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;username_file&#160;=&#160;match&#160;username_file_result&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(file)&#160;=&gt;&#160;file,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(e)&#160;=&gt;&#160;return&#160;Err(e),<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;username&#160;=&#160;String::new();<br/>
&#160;&#160;&#160;&#160;match&#160;username_file.read_to_string(&amp;mut&#160;username)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(_)&#160;=&gt;&#160;Ok(username),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(e)&#160;=&gt;&#160;Err(e),<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;9-6:&#160;A&#160;function&#160;that&#160;returns&#160;errors&#160;to&#160;the&#160;calling&#160;code&#160;using&#160;&#160;</b>match<br/>
This function can be written in a much shorter way, but we’re going to start by doing a lot of<br/>it manually in order to explore error handling; at the end, we’ll show the shorter way. Let’s<br/>look at the return type of the function&#160;ﬁrst:&#160;&#160;Result&lt;String,&#160;io::Error&gt;&#160;. This means the<br/>function is returning a value of the type&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;where the generic parameter&#160;&#160;T&#160;&#160;has<br/>been&#160;ﬁlled in with the concrete type&#160;&#160;String&#160;, and the generic type&#160;&#160;E&#160;&#160;has been&#160;ﬁlled in with<br/>the concrete type&#160;&#160;io::Error&#160;.<br/>
If this function succeeds without any problems, the code that calls this function will receive<br/>an&#160;&#160;Ok&#160;&#160;value that holds a&#160;&#160;String&#160;—the username that this function read from the&#160;ﬁle. If this<br/>function encounters any problems, the calling code will receive an&#160;&#160;Err&#160;&#160;value that holds an<br/>instance of&#160;&#160;io::Error&#160;&#160;that contains more information about what the problems were. We<br/>chose&#160;&#160;io::Error&#160;&#160;as the return type of this function because that happens to be the type of<br/>the error value returned from both of the operations we’re calling in this function’s body<br/>that might fail: the&#160;&#160;File::open&#160;&#160;function and the&#160;&#160;read_to_string&#160;&#160;method.<br/>
The body of the function starts by calling the&#160;&#160;File::open&#160;&#160;function. Then we handle the<br/>
Result&#160;&#160;value with a&#160;&#160;match&#160;&#160;similar to the&#160;&#160;match&#160;&#160;in Listing 9-4. If&#160;&#160;File::open&#160;&#160;succeeds, the<br/>
ﬁle handle in the pattern variable&#160;&#160;file&#160;&#160;becomes the value in the mutable variable<br/>
username_file&#160;&#160;and the function continues. In the&#160;&#160;Err&#160;&#160;case, instead of calling&#160;&#160;panic!&#160;, we<br/>
use the&#160;&#160;return&#160;&#160;keyword to return early out of the function entirely and pass the error value<br/>from&#160;&#160;File::open&#160;, now in the pattern variable&#160;&#160;e&#160;, back to the calling code as this function’s<br/>error value.<br/>
https://doc.rust-lang.org/book/print.html<br/>
208/627<br/>
<hr/>
<a name=209></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
So if we have a&#160;ﬁle handle in&#160;&#160;username_file&#160;, the function then creates a new&#160;&#160;String&#160;&#160;in<br/>variable&#160;&#160;username&#160;&#160;and calls the&#160;&#160;read_to_string&#160;&#160;method on the&#160;ﬁle handle in<br/>
username_file&#160;&#160;to read the contents of the&#160;ﬁle into&#160;&#160;username&#160;. The&#160;&#160;read_to_string<br/>
method also returns a&#160;&#160;Result&#160;&#160;because it might fail, even though&#160;&#160;File::open&#160;&#160;succeeded.<br/>So we need another&#160;&#160;match&#160;&#160;to handle that&#160;&#160;Result&#160;: if&#160;&#160;read_to_string&#160;&#160;succeeds, then our<br/>function has succeeded, and we return the username from the&#160;ﬁle that’s now in&#160;&#160;username<br/>wrapped in an&#160;&#160;Ok&#160;. If&#160;&#160;read_to_string&#160;&#160;fails, we return the error value in the same way that<br/>we returned the error value in the&#160;&#160;match&#160;&#160;that handled the return value of&#160;&#160;File::open&#160;.<br/>However, we don’t need to explicitly say&#160;&#160;return&#160;, because this is the last expression in the<br/>function.<br/>
The code that calls this code will then handle getting either an&#160;&#160;Ok&#160;&#160;value that contains a<br/>username or an&#160;&#160;Err&#160;&#160;value that contains an&#160;&#160;io::Error&#160;. It’s up to the calling code to decide<br/>what to do with those values. If the calling code gets an&#160;&#160;Err&#160;&#160;value, it could call&#160;&#160;panic!&#160;&#160;and<br/>crash the program, use a default username, or look up the username from somewhere<br/>other than a&#160;ﬁle, for example. We don’t have enough information on what the calling code is<br/>actually trying to do, so we propagate all the success or error information upward for it to<br/>handle appropriately.<br/>
This pattern of propagating errors is so common in Rust that Rust provides the question<br/>mark operator&#160;&#160;?&#160;&#160;to make this easier.<br/>
<a href="tests.html#209"><b>A Shortcut for Propagating Errors: the&#160;</b>?<b>&#160;Operator</b></a><br/>
Listing 9-7 shows an implementation of&#160;&#160;read_username_from_file&#160;&#160;that has the same<br/>functionality as in Listing 9-6, but this implementation uses the&#160;&#160;?&#160;&#160;operator.<br/>
Filename: src/main.rs<br/>
use&#160;std::fs::File;<br/>use&#160;std::io::{self,&#160;Read};<br/>
fn&#160;read_username_from_file()&#160;-&gt;&#160;Result&lt;String,&#160;io::Error&gt;&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;username_file&#160;=&#160;File::open(&#34;hello.txt&#34;)?;<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;username&#160;=&#160;String::new();<br/>&#160;&#160;&#160;&#160;username_file.read_to_string(&amp;mut&#160;username)?;<br/>&#160;&#160;&#160;&#160;Ok(username)<br/>}<br/>
<b>Listing&#160;9-7:&#160;A&#160;function&#160;that&#160;returns&#160;errors&#160;to&#160;the&#160;calling&#160;code&#160;using&#160;the&#160;&#160;</b>?&#160;<b>&#160;operator</b><br/>
The&#160;&#160;?&#160;&#160;placed after a&#160;&#160;Result&#160;&#160;value is deﬁned to work in almost the same way as the&#160;&#160;match<br/>expressions we deﬁned to handle the&#160;&#160;Result&#160;&#160;values in Listing 9-6. If the value of the<br/>
Result&#160;&#160;is an&#160;&#160;Ok&#160;, the value inside the&#160;&#160;Ok&#160;&#160;will get returned from this expression, and the<br/>
program will continue. If the value is an&#160;&#160;Err&#160;, the&#160;&#160;Err&#160;&#160;will be returned from the whole<br/>
https://doc.rust-lang.org/book/print.html<br/>
209/627<br/>
<hr/>
<a name=210></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
function as if we had used the&#160;&#160;return&#160;&#160;keyword so the error value gets propagated to the<br/>calling code.<br/>
There is a diﬀerence between what the&#160;&#160;match&#160;&#160;expression from Listing 9-6 does and what<br/>the&#160;&#160;?&#160;&#160;operator does: error values that have the&#160;&#160;?&#160;&#160;operator called on them go through the<br/>
from&#160;&#160;function, deﬁned in the&#160;&#160;From&#160;&#160;trait in the standard library, which is used to convert<br/>
values from one type into another. When the&#160;&#160;?&#160;&#160;operator calls the&#160;&#160;from&#160;&#160;function, the error<br/>type received is converted into the error type deﬁned in the return type of the current<br/>function. This is useful when a function returns one error type to represent all the ways a<br/>function might fail, even if parts might fail for many diﬀerent reasons.<br/>
For example, we could change the&#160;&#160;read_username_from_file&#160;&#160;function in Listing 9-7 to<br/>return a custom error type named&#160;&#160;OurError&#160;&#160;that we deﬁne. If we also deﬁne&#160;&#160;impl&#160;<br/>From&lt;io::Error&gt;&#160;for&#160;OurError&#160;&#160;to construct an instance of&#160;&#160;OurError&#160;&#160;from an&#160;&#160;io::Error&#160;,<br/>then the&#160;&#160;?&#160;&#160;operator calls in the body of&#160;&#160;read_username_from_file&#160;&#160;will call&#160;&#160;from&#160;&#160;and<br/>convert the error types without needing to add any more code to the function.<br/>
In the context of Listing 9-7, the&#160;&#160;?&#160;&#160;at the end of the&#160;&#160;File::open&#160;&#160;call will return the value<br/>inside an&#160;&#160;Ok&#160;&#160;to the variable&#160;&#160;username_file&#160;. If an error occurs, the&#160;&#160;?&#160;&#160;operator will return<br/>early out of the whole function and give any&#160;&#160;Err&#160;&#160;value to the calling code. The same thing<br/>applies to the&#160;&#160;?&#160;&#160;at the end of the&#160;&#160;read_to_string&#160;&#160;call.<br/>
The&#160;&#160;?&#160;&#160;operator eliminates a lot of boilerplate and makes this function’s implementation<br/>simpler. We could even shorten this code further by chaining method calls immediately<br/>after the&#160;&#160;?&#160;, as shown in Listing 9-8.<br/>
Filename: src/main.rs<br/>
use&#160;std::fs::File;<br/>use&#160;std::io::{self,&#160;Read};<br/>
fn&#160;read_username_from_file()&#160;-&gt;&#160;Result&lt;String,&#160;io::Error&gt;&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;username&#160;=&#160;String::new();<br/>
&#160;&#160;&#160;&#160;File::open(&#34;hello.txt&#34;)?.read_to_string(&amp;mut&#160;username)?;<br/>
&#160;&#160;&#160;&#160;Ok(username)<br/>}<br/>
<b>Listing&#160;9-8:&#160;Chaining&#160;method&#160;calls&#160;after&#160;the&#160;&#160;</b>?&#160;<b>&#160;operator</b><br/>
We’ve moved the creation of the new&#160;&#160;String&#160;&#160;in&#160;&#160;username&#160;&#160;to the beginning of the function;<br/>that part hasn’t changed. Instead of creating a variable&#160;&#160;username_file&#160;, we’ve chained the<br/>call to&#160;&#160;read_to_string&#160;&#160;directly onto the result of&#160;&#160;File::open(&#34;hello.txt&#34;)?&#160;. We still have<br/>a&#160;&#160;?&#160;&#160;at the end of the&#160;&#160;read_to_string&#160;&#160;call, and we still return an&#160;&#160;Ok&#160;&#160;value containing<br/>
username&#160;&#160;when both&#160;&#160;File::open&#160;&#160;and&#160;&#160;read_to_string&#160;&#160;succeed rather than returning<br/>
errors. The functionality is again the same as in Listing 9-6 and Listing 9-7; this is just a<br/>diﬀerent, more ergonomic way to write it.<br/>
https://doc.rust-lang.org/book/print.html<br/>
210/627<br/>
<hr/>
<a name=211></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Listing 9-9 shows a way to make this even shorter using&#160;&#160;fs::read_to_string&#160;.<br/>
Filename: src/main.rs<br/>
use&#160;std::fs;<br/>use&#160;std::io;<br/>
fn&#160;read_username_from_file()&#160;-&gt;&#160;Result&lt;String,&#160;io::Error&gt;&#160;{<br/>&#160;&#160;&#160;&#160;fs::read_to_string(&#34;hello.txt&#34;)<br/>}<br/>
<b>Listing&#160;9-9:&#160;Using&#160;&#160;</b>fs::read_to_string&#160;<b>&#160;instead&#160;of&#160;opening&#160;and&#160;then&#160;reading&#160;the&#160;ﬁle</b><br/>
Reading a&#160;ﬁle into a string is a fairly common operation, so the standard library provides the<br/>convenient&#160;&#160;fs::read_to_string&#160;&#160;function that opens the&#160;ﬁle, creates a new&#160;&#160;String&#160;, reads<br/>the contents of the&#160;ﬁle, puts the contents into that&#160;&#160;String&#160;, and returns it. Of course, using<br/>
fs::read_to_string&#160;&#160;doesn’t give us the opportunity to explain all the error handling, so we<br/>
did it the longer way&#160;ﬁrst.<br/>
<a href="tests.html#211"><b>Where The&#160;</b>?<b>&#160;Operator Can Be Used</b></a><br/>
The&#160;&#160;?&#160;&#160;operator can only be used in functions whose return type is compatible with the<br/>value the&#160;&#160;?&#160;&#160;is used on. This is because the&#160;&#160;?&#160;&#160;operator is deﬁned to perform an early return<br/>of a value out of the function, in the same manner as the&#160;&#160;match&#160;&#160;expression we deﬁned in<br/>Listing 9-6. In Listing 9-6, the&#160;&#160;match&#160;&#160;was using a&#160;&#160;Result&#160;&#160;value, and the early return arm<br/>returned an&#160;&#160;Err(e)&#160;&#160;value. The return type of the function has to be a&#160;&#160;Result&#160;&#160;so that it’s<br/>compatible with this&#160;&#160;return&#160;.<br/>
In Listing 9-10, let’s look at the error we’ll get if we use the&#160;&#160;?&#160;&#160;operator in a&#160;&#160;main&#160;&#160;function<br/>with a return type incompatible with the type of the value we use&#160;&#160;?&#160;&#160;on:<br/>
Filename: src/main.rs<br/>
use&#160;std::fs::File;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;greeting_file&#160;=&#160;File::open(&#34;hello.txt&#34;)?;<br/>}<br/>
<b>Listing&#160;9-10:&#160;Attempting&#160;to&#160;use&#160;the&#160;&#160;</b>?&#160;<b>&#160;in&#160;the&#160;&#160;</b>main&#160;<b>&#160;function&#160;that&#160;returns&#160;&#160;</b>()&#160;<b>&#160;won’t&#160;compile</b><br/>
This code opens a&#160;ﬁle, which might fail. The&#160;&#160;?&#160;&#160;operator follows the&#160;&#160;Result&#160;&#160;value returned<br/>by&#160;&#160;File::open&#160;, but this&#160;&#160;main&#160;&#160;function has the return type of&#160;&#160;()&#160;, not&#160;&#160;Result&#160;. When we<br/>compile this code, we get the following error message:<br/>
https://doc.rust-lang.org/book/print.html<br/>
211/627<br/>
<hr/>
<a name=212></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;error-handling&#160;v0.1.0&#160;(file:///projects/error-handling)<br/>error[E0277]:&#160;the&#160;`?`&#160;operator&#160;can&#160;only&#160;be&#160;used&#160;in&#160;a&#160;function&#160;that&#160;returns&#160;<br/>`Result`&#160;or&#160;`Option`&#160;(or&#160;another&#160;type&#160;that&#160;implements&#160;`FromResidual`)<br/>&#160;--&gt;&#160;src/main.rs:4:48<br/>&#160;&#160;|<br/>3&#160;|&#160;fn&#160;main()&#160;{<br/>&#160;&#160;|&#160;---------&#160;this&#160;function&#160;should&#160;return&#160;`Result`&#160;or&#160;`Option`&#160;to&#160;accept&#160;`?`<br/>4&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;greeting_file&#160;=&#160;File::open(&#34;hello.txt&#34;)?;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^&#160;cannot&#160;use&#160;the&#160;`?`&#160;<br/>operator&#160;in&#160;a&#160;function&#160;that&#160;returns&#160;`()`<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;help:&#160;the&#160;trait&#160;`FromResidual&lt;Result&lt;Infallible,&#160;std::io::Error&gt;&gt;`&#160;is&#160;not&#160;<br/>implemented&#160;for&#160;`()`<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0277`.<br/>error:&#160;could&#160;not&#160;compile&#160;`error-handling`&#160;due&#160;to&#160;previous&#160;error<br/>
This error points out that we’re only allowed to use the&#160;&#160;?&#160;&#160;operator in a function that<br/>returns&#160;&#160;Result&#160;,&#160;&#160;Option&#160;, or another type that implements&#160;&#160;FromResidual&#160;.<br/>
To&#160;ﬁx the error, you have two choices. One choice is to change the return type of your<br/>function to be compatible with the value you’re using the&#160;&#160;?&#160;&#160;operator on as long as you<br/>have no restrictions preventing that. The other technique is to use a&#160;&#160;match&#160;&#160;or one of the<br/>
Result&lt;T,&#160;E&gt;&#160;&#160;methods to handle the&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;in whatever way is appropriate.<br/>
The error message also mentioned that&#160;&#160;?&#160;&#160;can be used with&#160;&#160;Option&lt;T&gt;&#160;&#160;values as well. As<br/>with using&#160;&#160;?&#160;&#160;on&#160;&#160;Result&#160;, you can only use&#160;&#160;?&#160;&#160;on&#160;&#160;Option&#160;&#160;in a function that returns an<br/>
Option&#160;. The behavior of the&#160;&#160;?&#160;&#160;operator when called on an&#160;&#160;Option&lt;T&gt;&#160;&#160;is similar to its<br/>
behavior when called on a&#160;&#160;Result&lt;T,&#160;E&gt;&#160;: if the value is&#160;&#160;None&#160;, the&#160;&#160;None&#160;&#160;will be returned<br/>early from the function at that point. If the value is&#160;&#160;Some&#160;, the value inside the&#160;&#160;Some&#160;&#160;is the<br/>resulting value of the expression and the function continues. Listing 9-11 has an example of<br/>a function that&#160;ﬁnds the last character of the&#160;ﬁrst line in the given text:<br/>
fn&#160;last_char_of_first_line(text:&#160;&amp;str)&#160;-&gt;&#160;Option&lt;char&gt;&#160;{<br/>&#160;&#160;&#160;&#160;text.lines().next()?.chars().last()<br/>}<br/>
<b>Listing&#160;9-11:&#160;Using&#160;the&#160;&#160;</b>?&#160;<b>&#160;operator&#160;on&#160;an&#160;&#160;</b>Option&lt;T&gt;&#160;<b>&#160;value</b><br/>
This function returns&#160;&#160;Option&lt;char&gt;&#160;&#160;because it’s possible that there is a character there, but<br/>it’s also possible that there isn’t. This code takes the&#160;&#160;text&#160;&#160;string slice argument and calls<br/>the&#160;&#160;lines&#160;&#160;method on it, which returns an iterator over the lines in the string. Because this<br/>function wants to examine the&#160;ﬁrst line, it calls&#160;&#160;next&#160;&#160;on the iterator to get the&#160;ﬁrst value<br/>from the iterator. If&#160;&#160;text&#160;&#160;is the empty string, this call to&#160;&#160;next&#160;&#160;will return&#160;&#160;None&#160;, in which<br/>case we use&#160;&#160;?&#160;&#160;to stop and return&#160;&#160;None&#160;&#160;from&#160;&#160;last_char_of_first_line&#160;. If&#160;&#160;text&#160;&#160;is not the<br/>empty string,&#160;&#160;next&#160;&#160;will return a&#160;&#160;Some&#160;&#160;value containing a string slice of the&#160;ﬁrst line in&#160;&#160;text&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
212/627<br/>
<hr/>
<a name=213></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The&#160;&#160;?&#160;&#160;extracts the string slice, and we can call&#160;&#160;chars&#160;&#160;on that string slice to get an iterator<br/>of its characters. We’re interested in the last character in this&#160;ﬁrst line, so we call&#160;&#160;last&#160;&#160;to<br/>return the last item in the iterator. This is an&#160;&#160;Option&#160;&#160;because it’s possible that the&#160;ﬁrst line<br/>is the empty string, for example if&#160;&#160;text&#160;&#160;starts with a blank line but has characters on other<br/>lines, as in&#160;&#160;&#34;\nhi&#34;&#160;. However, if there is a last character on the&#160;ﬁrst line, it will be returned in<br/>the&#160;&#160;Some&#160;&#160;variant. The&#160;&#160;?&#160;&#160;operator in the middle gives us a concise way to express this logic,<br/>allowing us to implement the function in one line. If we couldn’t use the&#160;&#160;?&#160;&#160;operator on<br/>
Option&#160;, we’d have to implement this logic using more method calls or a&#160;&#160;match&#160;&#160;expression.<br/>
Note that you can use the&#160;&#160;?&#160;&#160;operator on a&#160;&#160;Result&#160;&#160;in a function that returns&#160;&#160;Result&#160;, and<br/>you can use the&#160;&#160;?&#160;&#160;operator on an&#160;&#160;Option&#160;&#160;in a function that returns&#160;&#160;Option&#160;, but you can’t<br/>mix and match. The&#160;&#160;?&#160;&#160;operator won’t automatically convert a&#160;&#160;Result&#160;&#160;to an&#160;&#160;Option&#160;&#160;or vice<br/>versa; in those cases, you can use methods like the&#160;&#160;ok&#160;&#160;method on&#160;&#160;Result&#160;&#160;or the&#160;&#160;ok_or<br/>method on&#160;&#160;Option&#160;&#160;to do the conversion explicitly.<br/>
So far, all the&#160;&#160;main&#160;&#160;functions we’ve used return&#160;&#160;()&#160;. The&#160;&#160;main&#160;&#160;function is special because<br/>it’s the entry and exit point of executable programs, and there are restrictions on what its<br/>return type can be for the programs to behave as expected.<br/>
Luckily,&#160;&#160;main&#160;&#160;can also return a&#160;&#160;Result&lt;(),&#160;E&gt;&#160;. Listing 9-12 has the code from Listing 9-10<br/>but we’ve changed the return type of&#160;&#160;main&#160;&#160;to be&#160;&#160;Result&lt;(),&#160;Box&lt;dyn&#160;Error&gt;&gt;&#160;&#160;and added<br/>a return value&#160;&#160;Ok(())&#160;&#160;to the end. This code will now compile:<br/>
use&#160;std::error::Error;<br/>use&#160;std::fs::File;<br/>
fn&#160;main()&#160;-&gt;&#160;Result&lt;(),&#160;Box&lt;dyn&#160;Error&gt;&gt;&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;greeting_file&#160;=&#160;File::open(&#34;hello.txt&#34;)?;<br/>
&#160;&#160;&#160;&#160;Ok(())<br/>}<br/>
<b>Listing&#160;9-12:&#160;Changing&#160;&#160;</b>main&#160;<b>&#160;to&#160;return&#160;&#160;</b>Result&lt;(),&#160;E&gt;&#160;<b>&#160;allows&#160;the&#160;use&#160;of&#160;the&#160;&#160;</b>?&#160;<b>&#160;operator&#160;on&#160;&#160;</b>Result&#160;<b>&#160;values</b><br/>
<a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">The&#160;&#160;Box&lt;dyn&#160;Error&gt;&#160;&#160;type is a&#160;<i>trait object</i>, which we’ll talk about in the&#160;“Using Trait Objects<br/>that Allow for Values of Diﬀerent Types”&#160;section in Chapter 17. For now, you can read</a><br/>
Box&lt;dyn&#160;Error&gt;&#160;&#160;to mean “any kind of error.” Using&#160;&#160;?&#160;&#160;on a&#160;&#160;Result&#160;&#160;value in a&#160;&#160;main<br/>
function with the error type&#160;&#160;Box&lt;dyn&#160;Error&gt;&#160;&#160;is allowed, because it allows any&#160;&#160;Err&#160;&#160;value to<br/>be returned early. Even though the body of this&#160;&#160;main&#160;&#160;function will only ever return errors of<br/>type&#160;&#160;std::io::Error&#160;, by specifying&#160;&#160;Box&lt;dyn&#160;Error&gt;&#160;, this signature will continue to be<br/>correct even if more code that returns other errors is added to the body of&#160;&#160;main&#160;.<br/>
When a&#160;&#160;main&#160;&#160;function returns a&#160;&#160;Result&lt;(),&#160;E&gt;&#160;, the executable will exit with a value of&#160;&#160;0<br/>if&#160;&#160;main&#160;&#160;returns&#160;&#160;Ok(())&#160;&#160;and will exit with a nonzero value if&#160;&#160;main&#160;&#160;returns an&#160;&#160;Err&#160;&#160;value.<br/>Executables written in C return integers when they exit: programs that exit successfully<br/>return the integer&#160;&#160;0&#160;, and programs that error return some integer other than&#160;&#160;0&#160;. Rust also<br/>returns integers from executables to be compatible with this convention.<br/>
https://doc.rust-lang.org/book/print.html<br/>
213/627<br/>
<hr/>
<a name=214></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="https://doc.rust-lang.org/std/process/trait.Termination.html">The&#160;&#160;main&#160;&#160;function may return any types that implement&#160;the&#160;&#160;std::process::Termination<br/>trait, which contains a function&#160;&#160;report&#160;&#160;that returns an&#160;&#160;ExitCode&#160;. Consult the standard<br/></a>library documentation for more information on implementing the&#160;&#160;Termination&#160;&#160;trait for<br/>your own types.<br/>
Now that we’ve discussed the details of calling&#160;&#160;panic!&#160;&#160;or returning&#160;&#160;Result&#160;, let’s return to<br/>the topic of how to decide which is appropriate to use in which cases.<br/>
https://doc.rust-lang.org/book/print.html<br/>
214/627<br/>
<hr/>
<a name=215></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#215"><b>To&#160;</b>panic!<b>&#160;or Not to&#160;</b>panic!</a><br/>
So how do you decide when you should call&#160;&#160;panic!&#160;&#160;and when you should return&#160;&#160;Result&#160;?<br/>When code panics, there’s no way to recover. You could call&#160;&#160;panic!&#160;&#160;for any error situation,<br/>whether there’s a possible way to recover or not, but then you’re making the decision that a<br/>situation is unrecoverable on behalf of the calling code. When you choose to return a<br/>
Result&#160;&#160;value, you give the calling code options. The calling code could choose to attempt to<br/>
recover in a way that’s appropriate for its situation, or it could decide that an&#160;&#160;Err&#160;&#160;value in<br/>this case is unrecoverable, so it can call&#160;&#160;panic!&#160;&#160;and turn your recoverable error into an<br/>unrecoverable one. Therefore, returning&#160;&#160;Result&#160;&#160;is a good default choice when you’re<br/>deﬁning a function that might fail.<br/>
In situations such as examples, prototype code, and tests, it’s more appropriate to write<br/>code that panics instead of returning a&#160;&#160;Result&#160;. Let’s explore why, then discuss situations in<br/>which the compiler can’t tell that failure is impossible, but you as a human can. The chapter<br/>will conclude with some general guidelines on how to decide whether to panic in library<br/>code.<br/>
<a href="tests.html#215"><b>Examples,&#160;Prototype&#160;Code,&#160;and&#160;Tests</b></a><br/>
When you’re writing an example to illustrate some concept, also including robust error-<br/>handling code can make the example less clear. In examples, it’s understood that a call to a<br/>method like&#160;&#160;unwrap&#160;&#160;that could panic is meant as a placeholder for the way you’d want your<br/>application to handle errors, which can diﬀer based on what the rest of your code is doing.<br/>
Similarly, the&#160;&#160;unwrap&#160;&#160;and&#160;&#160;expect&#160;&#160;methods are very handy when prototyping, before you’re<br/>ready to decide how to handle errors. They leave clear markers in your code for when<br/>you’re ready to make your program more robust.<br/>
If a method call fails in a test, you’d want the whole test to fail, even if that method isn’t the<br/>functionality under test. Because&#160;&#160;panic!&#160;&#160;is how a test is marked as a failure, calling&#160;&#160;unwrap<br/>or&#160;&#160;expect&#160;&#160;is exactly what should happen.<br/>
<a href="tests.html#215"><b>Cases&#160;in&#160;Which&#160;You&#160;Have&#160;More&#160;Information&#160;Than&#160;the&#160;Compiler</b></a><br/>
It would also be appropriate to call&#160;&#160;unwrap&#160;&#160;or&#160;&#160;expect&#160;&#160;when you have some other logic that<br/>ensures the&#160;&#160;Result&#160;&#160;will have an&#160;&#160;Ok&#160;&#160;value, but the logic isn’t something the compiler<br/>understands. You’ll still have a&#160;&#160;Result&#160;&#160;value that you need to handle: whatever operation<br/>you’re calling still has the possibility of failing in general, even though it’s logically impossible<br/>in your particular situation. If you can ensure by manually inspecting the code that you’ll<br/>
https://doc.rust-lang.org/book/print.html<br/>
215/627<br/>
<hr/>
<a name=216></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
never have an&#160;&#160;Err&#160;&#160;variant, it’s perfectly acceptable to call&#160;&#160;unwrap&#160;, and even better to<br/>document the reason you think you’ll never have an&#160;&#160;Err&#160;&#160;variant in the&#160;&#160;expect&#160;&#160;text. Here’s<br/>an example:<br/>
&#160;&#160;&#160;&#160;use&#160;std::net::IpAddr;<br/>
&#160;&#160;&#160;&#160;let&#160;home:&#160;IpAddr&#160;=&#160;&#34;127.0.0.1&#34;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.parse()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;Hardcoded&#160;IP&#160;address&#160;should&#160;be&#160;valid&#34;);<br/>
We’re creating an&#160;&#160;IpAddr&#160;&#160;instance by parsing a hardcoded string. We can see that<br/>
127.0.0.1&#160;&#160;is a valid IP address, so it’s acceptable to use&#160;&#160;expect&#160;&#160;here. However, having a<br/>
hardcoded, valid string doesn’t change the return type of the&#160;&#160;parse&#160;&#160;method: we still get a<br/>
Result&#160;&#160;value, and the compiler will still make us handle the&#160;&#160;Result&#160;&#160;as if the&#160;&#160;Err&#160;&#160;variant is<br/>
a possibility because the compiler isn’t smart enough to see that this string is always a valid<br/>IP address. If the IP address string came from a user rather than being hardcoded into the<br/>program and therefore&#160;<i>did</i>&#160;have a possibility of failure, we’d deﬁnitely want to handle the<br/>
Result&#160;&#160;in a more robust way instead. Mentioning the assumption that this IP address is<br/>
hardcoded will prompt us to change&#160;&#160;expect&#160;&#160;to better error handling code if in the future,<br/>we need to get the IP address from some other source instead.<br/>
<a href="tests.html#216"><b>Guidelines&#160;for&#160;Error&#160;Handling</b></a><br/>
It’s advisable to have your code panic when it’s possible that your code could end up in a<br/>bad state. In this context, a&#160;<i>bad state</i>&#160;is when some assumption, guarantee, contract, or<br/>invariant has been broken, such as when invalid values, contradictory values, or missing<br/>values are passed to your code—plus one or more of the following:<br/>
The bad state is something that is unexpected, as opposed to something that will likely<br/>happen occasionally, like a user entering data in the wrong format.<br/>Your code after this point needs to rely on not being in this bad state, rather than<br/>checking for the problem at every step.<br/>There’s not a good way to encode this information in the types you use. We’ll work<br/><a href="https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html#encoding-states-and-behavior-as-types">through an example of what we mean in the&#160;“Encoding States and Behavior as Types”<br/></a>section of Chapter 17.<br/>
If someone calls your code and passes in values that don’t make sense, it’s best to return an<br/>error if you can so the user of the library can decide what they want to do in that case.<br/>However, in cases where continuing could be insecure or harmful, the best choice might be<br/>to call&#160;&#160;panic!&#160;&#160;and alert the person using your library to the bug in their code so they can&#160;ﬁx<br/>it during development. Similarly,&#160;&#160;panic!&#160;&#160;is often appropriate if you’re calling external code<br/>that is out of your control and it returns an invalid state that you have no way of&#160;ﬁxing.<br/>
However, when failure is expected, it’s more appropriate to return a&#160;&#160;Result&#160;&#160;than to make a<br/>
panic!&#160;&#160;call. Examples include a parser being given malformed data or an HTTP request<br/>
https://doc.rust-lang.org/book/print.html<br/>
216/627<br/>
<hr/>
<a name=217></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
returning a status that indicates you have hit a rate limit. In these cases, returning a&#160;&#160;Result<br/>indicates that failure is an expected possibility that the calling code must decide how to<br/>handle.<br/>
When your code performs an operation that could put a user at risk if it’s called using invalid<br/>values, your code should verify the values are valid&#160;ﬁrst and panic if the values aren’t valid.<br/>This is mostly for safety reasons: attempting to operate on invalid data can expose your<br/>code to vulnerabilities. This is the main reason the standard library will call&#160;&#160;panic!&#160;&#160;if you<br/>attempt an out-of-bounds memory access: trying to access memory that doesn’t belong to<br/>the current data structure is a common security problem. Functions often have&#160;<i>contracts</i>:<br/>their behavior is only guaranteed if the inputs meet particular requirements. Panicking<br/>when the contract is violated makes sense because a contract violation always indicates a<br/>caller-side bug and it’s not a kind of error you want the calling code to have to explicitly<br/>handle. In fact, there’s no reasonable way for calling code to recover; the calling<br/><i>programmers</i>&#160;need to&#160;ﬁx the code. Contracts for a function, especially when a violation will<br/>cause a panic, should be explained in the API documentation for the function.<br/>
However, having lots of error checks in all of your functions would be verbose and<br/>annoying. Fortunately, you can use Rust’s type system (and thus the type checking done by<br/>the compiler) to do many of the checks for you. If your function has a particular type as a<br/>parameter, you can proceed with your code’s logic knowing that the compiler has already<br/>ensured you have a valid value. For example, if you have a type rather than an&#160;&#160;Option&#160;, your<br/>program expects to have&#160;<i>something</i>&#160;rather than&#160;<i>nothing</i>. Your code then doesn’t have to<br/>handle two cases for the&#160;&#160;Some&#160;&#160;and&#160;&#160;None&#160;&#160;variants: it will only have one case for deﬁnitely<br/>having a value. Code trying to pass nothing to your function won’t even compile, so your<br/>function doesn’t have to check for that case at runtime. Another example is using an<br/>unsigned integer type such as&#160;&#160;u32&#160;, which ensures the parameter is never negative.<br/>
<a href="tests.html#217"><b>Creating&#160;Custom&#160;Types&#160;for&#160;Validation</b></a><br/>
Let’s take the idea of using Rust’s type system to ensure we have a valid value one step<br/>further and look at creating a custom type for validation. Recall the guessing game in<br/>Chapter 2 in which our code asked the user to guess a number between 1 and 100. We<br/>never validated that the user’s guess was between those numbers before checking it against<br/>our secret number; we only validated that the guess was positive. In this case, the<br/>consequences were not very dire: our output of “Too high” or “Too low” would still be<br/>correct. But it would be a useful enhancement to guide the user toward valid guesses and<br/>have diﬀerent behavior when a user guesses a number that’s out of range versus when a<br/>user types, for example, letters instead.<br/>
One way to do this would be to parse the guess as an&#160;&#160;i32&#160;&#160;instead of only a&#160;&#160;u32&#160;&#160;to allow<br/>potentially negative numbers, and then add a check for the number being in range, like so:<br/>
https://doc.rust-lang.org/book/print.html<br/>
217/627<br/>
<hr/>
<a name=218></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;loop&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;guess:&#160;i32&#160;=&#160;match&#160;guess.trim().parse()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(num)&#160;=&gt;&#160;num,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(_)&#160;=&gt;&#160;continue,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;guess&#160;&lt;&#160;1&#160;||&#160;guess&#160;&gt;&#160;100&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;The&#160;secret&#160;number&#160;will&#160;be&#160;between&#160;1&#160;and&#160;100.&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;guess.cmp(&amp;secret_number)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;}<br/>
The&#160;&#160;if&#160;&#160;expression checks whether our value is out of range, tells the user about the<br/>problem, and calls&#160;&#160;continue&#160;&#160;to start the next iteration of the loop and ask for another<br/>guess. After the&#160;&#160;if&#160;&#160;expression, we can proceed with the comparisons between&#160;&#160;guess&#160;&#160;and<br/>the secret number knowing that&#160;&#160;guess&#160;&#160;is between 1 and 100.<br/>
However, this is not an ideal solution: if it was absolutely critical that the program only<br/>operated on values between 1 and 100, and it had many functions with this requirement,<br/>having a check like this in every function would be tedious (and might impact performance).<br/>
Instead, we can make a new type and put the validations in a function to create an instance<br/>of the type rather than repeating the validations everywhere. That way, it’s safe for<br/>functions to use the new type in their signatures and conﬁdently use the values they<br/>receive. Listing 9-13 shows one way to deﬁne a&#160;&#160;Guess&#160;&#160;type that will only create an instance<br/>of&#160;&#160;Guess&#160;&#160;if the&#160;&#160;new&#160;&#160;function receives a value between 1 and 100.<br/>
pub&#160;struct&#160;Guess&#160;{<br/>&#160;&#160;&#160;&#160;value:&#160;i32,<br/>}<br/>
impl&#160;Guess&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(value:&#160;i32)&#160;-&gt;&#160;Guess&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;value&#160;&lt;&#160;1&#160;||&#160;value&#160;&gt;&#160;100&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic!(&#34;Guess&#160;value&#160;must&#160;be&#160;between&#160;1&#160;and&#160;100,&#160;got&#160;{}.&#34;,&#160;value);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Guess&#160;{&#160;value&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;pub&#160;fn&#160;value(&amp;self)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.value<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;9-13:&#160;A&#160;&#160;</b>Guess&#160;<b>&#160;type&#160;that&#160;will&#160;only&#160;continue&#160;with&#160;values&#160;between&#160;1&#160;and&#160;100</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
218/627<br/>
<hr/>
<a name=219></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
First, we deﬁne a struct named&#160;&#160;Guess&#160;&#160;that has a&#160;ﬁeld named&#160;&#160;value&#160;&#160;that holds an&#160;&#160;i32&#160;.<br/>This is where the number will be stored.<br/>
Then we implement an associated function named&#160;&#160;new&#160;&#160;on&#160;&#160;Guess&#160;&#160;that creates instances of<br/>
Guess&#160;&#160;values. The&#160;&#160;new&#160;&#160;function is deﬁned to have one parameter named&#160;&#160;value&#160;&#160;of type<br/>i32&#160;&#160;and to return a&#160;&#160;Guess&#160;. The code in the body of the&#160;&#160;new&#160;&#160;function tests&#160;&#160;value&#160;&#160;to make<br/>
sure it’s between 1 and 100. If&#160;&#160;value&#160;&#160;doesn’t pass this test, we make a&#160;&#160;panic!&#160;&#160;call, which<br/>will alert the programmer who is writing the calling code that they have a bug they need to<br/>ﬁx, because creating a&#160;&#160;Guess&#160;&#160;with a&#160;&#160;value&#160;&#160;outside this range would violate the contract<br/>that&#160;&#160;Guess::new&#160;&#160;is relying on. The conditions in which&#160;&#160;Guess::new&#160;&#160;might panic should be<br/>discussed in its public-facing API documentation; we’ll cover documentation conventions<br/>indicating the possibility of a&#160;&#160;panic!&#160;&#160;in the API documentation that you create in Chapter<br/>14. If&#160;&#160;value&#160;&#160;does pass the test, we create a new&#160;&#160;Guess&#160;&#160;with its&#160;&#160;value&#160;&#160;ﬁeld set to the<br/>
value&#160;&#160;parameter and return the&#160;&#160;Guess&#160;.<br/>
Next, we implement a method named&#160;&#160;value&#160;&#160;that borrows&#160;&#160;self&#160;, doesn’t have any other<br/>parameters, and returns an&#160;&#160;i32&#160;. This kind of method is sometimes called a&#160;<i>getter</i>, because<br/>its purpose is to get some data from its&#160;ﬁelds and return it. This public method is necessary<br/>because the&#160;&#160;value&#160;&#160;ﬁeld of the&#160;&#160;Guess&#160;&#160;struct is private. It’s important that the&#160;&#160;value&#160;&#160;ﬁeld<br/>be private so code using the&#160;&#160;Guess&#160;&#160;struct is not allowed to set&#160;&#160;value&#160;&#160;directly: code outside<br/>the module&#160;<i>must</i>&#160;use the&#160;&#160;Guess::new&#160;&#160;function to create an instance of&#160;&#160;Guess&#160;, thereby<br/>ensuring there’s no way for a&#160;&#160;Guess&#160;&#160;to have a&#160;&#160;value&#160;&#160;that hasn’t been checked by the<br/>conditions in the&#160;&#160;Guess::new&#160;&#160;function.<br/>
A function that has a parameter or returns only numbers between 1 and 100 could then<br/>declare in its signature that it takes or returns a&#160;&#160;Guess&#160;&#160;rather than an&#160;&#160;i32&#160;&#160;and wouldn’t<br/>need to do any additional checks in its body.<br/>
<a href="tests.html#219"><b>Summary</b></a><br/>
Rust’s error handling features are designed to help you write more robust code. The<br/>
panic!&#160;&#160;macro signals that your program is in a state it can’t handle and lets you tell the<br/>
process to stop instead of trying to proceed with invalid or incorrect values. The&#160;&#160;Result<br/>enum uses Rust’s type system to indicate that operations might fail in a way that your code<br/>could recover from. You can use&#160;&#160;Result&#160;&#160;to tell code that calls your code that it needs to<br/>handle potential success or failure as well. Using&#160;&#160;panic!&#160;&#160;and&#160;&#160;Result&#160;&#160;in the appropriate<br/>situations will make your code more reliable in the face of inevitable problems.<br/>
Now that you’ve seen useful ways that the standard library uses generics with the&#160;&#160;Option<br/>and&#160;&#160;Result&#160;&#160;enums, we’ll talk about how generics work and how you can use them in your<br/>code.<br/>
https://doc.rust-lang.org/book/print.html<br/>
219/627<br/>
<hr/>
<a name=220></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#220"><b>Generic Types, Traits, and Lifetimes</b></a><br/>
Every programming language has tools for eﬀectively handling the duplication of concepts.<br/>In Rust, one such tool is&#160;<i>generics</i>: abstract stand-ins for concrete types or other properties.<br/>We can express the behavior of generics or how they relate to other generics without<br/>knowing what will be in their place when compiling and running the code.<br/>
Functions can take parameters of some generic type, instead of a concrete type like&#160;&#160;i32&#160;&#160;or<br/>
String&#160;, in the same way a function takes parameters with unknown values to run the same<br/>
code on multiple concrete values. In fact, we’ve already used generics in Chapter 6 with<br/>
Option&lt;T&gt;&#160;, Chapter 8 with&#160;&#160;Vec&lt;T&gt;&#160;&#160;and&#160;&#160;HashMap&lt;K,&#160;V&gt;&#160;, and Chapter 9 with&#160;&#160;Result&lt;T,&#160;E&gt;&#160;.<br/>
In this chapter, you’ll explore how to deﬁne your own types, functions, and methods with<br/>generics!<br/>
First, we’ll review how to extract a function to reduce code duplication. We’ll then use the<br/>same technique to make a generic function from two functions that diﬀer only in the types<br/>of their parameters. We’ll also explain how to use generic types in struct and enum<br/>deﬁnitions.<br/>
Then you’ll learn how to use&#160;<i>traits</i>&#160;to deﬁne behavior in a generic way. You can combine<br/>traits with generic types to constrain a generic type to accept only those types that have a<br/>particular behavior, as opposed to just any type.<br/>
Finally, we’ll discuss&#160;<i>lifetimes</i>: a variety of generics that give the compiler information about<br/>how references relate to each other. Lifetimes allow us to give the compiler enough<br/>information about borrowed values so that it can ensure references will be valid in more<br/>situations than it could without our help.<br/>
<a href="tests.html#220"><b>Removing Duplication by Extracting a Function</b></a><br/>
Generics allow us to replace speciﬁc types with a placeholder that represents multiple types<br/>to remove code duplication. Before diving into generics syntax, then, let’s&#160;ﬁrst look at how to<br/>remove duplication in a way that doesn’t involve generic types by extracting a function that<br/>replaces speciﬁc values with a placeholder that represents multiple values. Then we’ll apply<br/>the same technique to extract a generic function! By looking at how to recognize duplicated<br/>code you can extract into a function, you’ll start to recognize duplicated code that can use<br/>generics.<br/>
We begin with the short program in Listing 10-1 that&#160;ﬁnds the largest number in a list.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
220/627<br/>
<hr/>
<a name=221></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;number_list&#160;=&#160;vec![34,&#160;50,&#160;25,&#160;100,&#160;65];<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;largest&#160;=&#160;&amp;number_list[0];<br/>
&#160;&#160;&#160;&#160;for&#160;number&#160;in&#160;&amp;number_list&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;number&#160;&gt;&#160;largest&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;largest&#160;=&#160;number;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;largest&#160;number&#160;is&#160;{}&#34;,&#160;largest);<br/>}<br/>
<b>Listing&#160;10-1:&#160;Finding&#160;the&#160;largest&#160;number&#160;in&#160;a&#160;list&#160;of&#160;numbers</b><br/>
We store a list of integers in the variable&#160;&#160;number_list&#160;&#160;and place a reference to the&#160;ﬁrst<br/>number in the list in a variable named&#160;&#160;largest&#160;. We then iterate through all the numbers in<br/>the list, and if the current number is greater than the number stored in&#160;&#160;largest&#160;, replace<br/>the reference in that variable. However, if the current number is less than or equal to the<br/>largest number seen so far, the variable doesn’t change, and the code moves on to the next<br/>number in the list. After considering all the numbers in the list,&#160;&#160;largest&#160;&#160;should refer to the<br/>largest number, which in this case is 100.<br/>
We've now been tasked with&#160;ﬁnding the largest number in two diﬀerent lists of numbers. To<br/>do so, we can choose to duplicate the code in Listing 10-1 and use the same logic at two<br/>diﬀerent places in the program, as shown in Listing 10-2.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
221/627<br/>
<hr/>
<a name=222></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;number_list&#160;=&#160;vec![34,&#160;50,&#160;25,&#160;100,&#160;65];<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;largest&#160;=&#160;&amp;number_list[0];<br/>
&#160;&#160;&#160;&#160;for&#160;number&#160;in&#160;&amp;number_list&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;number&#160;&gt;&#160;largest&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;largest&#160;=&#160;number;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;largest&#160;number&#160;is&#160;{}&#34;,&#160;largest);<br/>
&#160;&#160;&#160;&#160;let&#160;number_list&#160;=&#160;vec![102,&#160;34,&#160;6000,&#160;89,&#160;54,&#160;2,&#160;43,&#160;8];<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;largest&#160;=&#160;&amp;number_list[0];<br/>
&#160;&#160;&#160;&#160;for&#160;number&#160;in&#160;&amp;number_list&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;number&#160;&gt;&#160;largest&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;largest&#160;=&#160;number;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;largest&#160;number&#160;is&#160;{}&#34;,&#160;largest);<br/>}<br/>
<b>Listing&#160;10-2:&#160;Code&#160;to&#160;ﬁnd&#160;the&#160;largest&#160;number&#160;in&#160;<i>two</i></b><b>&#160;lists&#160;of&#160;numbers</b><br/>
Although this code works, duplicating code is tedious and error prone. We also have to<br/>remember to update the code in multiple places when we want to change it.<br/>
To eliminate this duplication, we’ll create an abstraction by deﬁning a function that operates<br/>on any list of integers passed in a parameter. This solution makes our code clearer and lets<br/>us express the concept of&#160;ﬁnding the largest number in a list abstractly.<br/>
In Listing 10-3, we extract the code that&#160;ﬁnds the largest number into a function named<br/>
largest&#160;. Then we call the function to&#160;ﬁnd the largest number in the two lists from Listing<br/>
10-2. We could also use the function on any other list of&#160;&#160;i32&#160;&#160;values we might have in the<br/>future.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
222/627<br/>
<hr/>
<a name=223></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;largest(list:&#160;&amp;[i32])&#160;-&gt;&#160;&amp;i32&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;largest&#160;=&#160;&amp;list[0];<br/>
&#160;&#160;&#160;&#160;for&#160;item&#160;in&#160;list&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;item&#160;&gt;&#160;largest&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;largest&#160;=&#160;item;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;largest<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;number_list&#160;=&#160;vec![34,&#160;50,&#160;25,&#160;100,&#160;65];<br/>
&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;largest(&amp;number_list);<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;largest&#160;number&#160;is&#160;{}&#34;,&#160;result);<br/>
&#160;&#160;&#160;&#160;let&#160;number_list&#160;=&#160;vec![102,&#160;34,&#160;6000,&#160;89,&#160;54,&#160;2,&#160;43,&#160;8];<br/>
&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;largest(&amp;number_list);<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;largest&#160;number&#160;is&#160;{}&#34;,&#160;result);<br/>}<br/>
<b>Listing&#160;10-3:&#160;Abstracted&#160;code&#160;to&#160;ﬁnd&#160;the&#160;largest&#160;number&#160;in&#160;two&#160;lists</b><br/>
The&#160;&#160;largest&#160;&#160;function has a parameter called&#160;&#160;list&#160;, which represents any concrete slice of<br/>
i32&#160;&#160;values we might pass into the function. As a result, when we call the function, the code<br/>
runs on the speciﬁc values that we pass in.<br/>
In summary, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:<br/>
1.&#160;Identify duplicate code.<br/>2.&#160;Extract the duplicate code into the body of the function and specify the inputs and<br/>
return values of that code in the function signature.<br/>
3.&#160;Update the two instances of duplicated code to call the function instead.<br/>
Next, we’ll use these same steps with generics to reduce code duplication. In the same way<br/>that the function body can operate on an abstract&#160;&#160;list&#160;&#160;instead of speciﬁc values, generics<br/>allow code to operate on abstract types.<br/>
For example, say we had two functions: one that&#160;ﬁnds the largest item in a slice of&#160;&#160;i32<br/>values and one that&#160;ﬁnds the largest item in a slice of&#160;&#160;char&#160;&#160;values. How would we eliminate<br/>that duplication? Let’s&#160;ﬁnd out!<br/>
https://doc.rust-lang.org/book/print.html<br/>
223/627<br/>
<hr/>
<a name=224></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#224"><b>Generic Data Types</b></a><br/>
We use generics to create deﬁnitions for items like function signatures or structs, which we<br/>can then use with many diﬀerent concrete data types. Let’s&#160;ﬁrst look at how to deﬁne<br/>functions, structs, enums, and methods using generics. Then we’ll discuss how generics<br/>aﬀect code performance.<br/>
<a href="tests.html#224"><b>In&#160;Function&#160;Deﬁnitions</b></a><br/>
When deﬁning a function that uses generics, we place the generics in the signature of the<br/>function where we would usually specify the data types of the parameters and return value.<br/>Doing so makes our code more&#160;ﬂexible and provides more functionality to callers of our<br/>function while preventing code duplication.<br/>
Continuing with our&#160;&#160;largest&#160;&#160;function, Listing 10-4 shows two functions that both&#160;ﬁnd the<br/>largest value in a slice. We'll then combine these into a single function that uses generics.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
224/627<br/>
<hr/>
<a name=225></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;largest_i32(list:&#160;&amp;[i32])&#160;-&gt;&#160;&amp;i32&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;largest&#160;=&#160;&amp;list[0];<br/>
&#160;&#160;&#160;&#160;for&#160;item&#160;in&#160;list&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;item&#160;&gt;&#160;largest&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;largest&#160;=&#160;item;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;largest<br/>}<br/>
fn&#160;largest_char(list:&#160;&amp;[char])&#160;-&gt;&#160;&amp;char&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;largest&#160;=&#160;&amp;list[0];<br/>
&#160;&#160;&#160;&#160;for&#160;item&#160;in&#160;list&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;item&#160;&gt;&#160;largest&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;largest&#160;=&#160;item;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;largest<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;number_list&#160;=&#160;vec![34,&#160;50,&#160;25,&#160;100,&#160;65];<br/>
&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;largest_i32(&amp;number_list);<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;largest&#160;number&#160;is&#160;{}&#34;,&#160;result);<br/>
&#160;&#160;&#160;&#160;let&#160;char_list&#160;=&#160;vec!['y',&#160;'m',&#160;'a',&#160;'q'];<br/>
&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;largest_char(&amp;char_list);<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;largest&#160;char&#160;is&#160;{}&#34;,&#160;result);<br/>}<br/>
<b>Listing&#160;10-4:&#160;Two&#160;functions&#160;that&#160;diﬀer&#160;only&#160;in&#160;their&#160;names&#160;and&#160;the&#160;types&#160;in&#160;their&#160;signatures</b><br/>
The&#160;&#160;largest_i32&#160;&#160;function is the one we extracted in Listing 10-3 that&#160;ﬁnds the largest&#160;&#160;i32<br/>in a slice. The&#160;&#160;largest_char&#160;&#160;function&#160;ﬁnds the largest&#160;&#160;char&#160;&#160;in a slice. The function bodies<br/>have the same code, so let’s eliminate the duplication by introducing a generic type<br/>parameter in a single function.<br/>
To parameterize the types in a new single function, we need to name the type parameter,<br/>just as we do for the value parameters to a function. You can use any identiﬁer as a type<br/>parameter name. But we’ll use&#160;&#160;T&#160;&#160;because, by convention, type parameter names in Rust<br/>are short, often just a letter, and Rust’s type-naming convention is UpperCamelCase. Short<br/>for “type,”&#160;&#160;T&#160;&#160;is the default choice of most Rust programmers.<br/>
When we use a parameter in the body of the function, we have to declare the parameter<br/>name in the signature so the compiler knows what that name means. Similarly, when we<br/>use a type parameter name in a function signature, we have to declare the type parameter<br/>name before we use it. To deﬁne the generic&#160;&#160;largest&#160;&#160;function, place type name<br/>
https://doc.rust-lang.org/book/print.html<br/>
225/627<br/>
<hr/>
<a name=226></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
declarations inside angle brackets,&#160;&#160;&lt;&gt;&#160;, between the name of the function and the<br/>parameter list, like this:<br/>
fn&#160;largest&lt;T&gt;(list:&#160;&amp;[T])&#160;-&gt;&#160;&amp;T&#160;{<br/>
We read this deﬁnition as: the function&#160;&#160;largest&#160;&#160;is generic over some type&#160;&#160;T&#160;. This function<br/>has one parameter named&#160;&#160;list&#160;, which is a slice of values of type&#160;&#160;T&#160;. The&#160;&#160;largest&#160;&#160;function<br/>will return a reference to a value of the same type&#160;&#160;T&#160;.<br/>
Listing 10-5 shows the combined&#160;&#160;largest&#160;&#160;function deﬁnition using the generic data type in<br/>its signature. The listing also shows how we can call the function with either a slice of&#160;&#160;i32<br/>values or&#160;&#160;char&#160;&#160;values. Note that this code won’t compile yet, but we’ll&#160;ﬁx it later in this<br/>chapter.<br/>
Filename: src/main.rs<br/>
fn&#160;largest&lt;T&gt;(list:&#160;&amp;[T])&#160;-&gt;&#160;&amp;T&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;largest&#160;=&#160;&amp;list[0];<br/>
&#160;&#160;&#160;&#160;for&#160;item&#160;in&#160;list&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;item&#160;&gt;&#160;largest&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;largest&#160;=&#160;item;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;largest<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;number_list&#160;=&#160;vec![34,&#160;50,&#160;25,&#160;100,&#160;65];<br/>
&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;largest(&amp;number_list);<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;largest&#160;number&#160;is&#160;{}&#34;,&#160;result);<br/>
&#160;&#160;&#160;&#160;let&#160;char_list&#160;=&#160;vec!['y',&#160;'m',&#160;'a',&#160;'q'];<br/>
&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;largest(&amp;char_list);<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;largest&#160;char&#160;is&#160;{}&#34;,&#160;result);<br/>}<br/>
<b>Listing&#160;10-5:&#160;The&#160;&#160;</b>largest&#160;<b>&#160;function&#160;using&#160;generic&#160;type&#160;parameters;&#160;this&#160;doesn’t&#160;yet&#160;compile</b><br/>
If we compile this code right now, we’ll get this error:<br/>
https://doc.rust-lang.org/book/print.html<br/>
226/627<br/>
<hr/>
<a name=227></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;chapter10&#160;v0.1.0&#160;(file:///projects/chapter10)<br/>error[E0369]:&#160;binary&#160;operation&#160;`&gt;`&#160;cannot&#160;be&#160;applied&#160;to&#160;type&#160;`&amp;T`<br/>&#160;--&gt;&#160;src/main.rs:5:17<br/>&#160;&#160;|<br/>5&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;item&#160;&gt;&#160;largest&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;----&#160;^&#160;-------&#160;&amp;T<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&amp;T<br/>&#160;&#160;|<br/>help:&#160;consider&#160;restricting&#160;type&#160;parameter&#160;`T`<br/>&#160;&#160;|<br/>1&#160;|&#160;fn&#160;largest&lt;T:&#160;std::cmp::PartialOrd&gt;(list:&#160;&amp;[T])&#160;-&gt;&#160;&amp;T&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++++++++++++++++++++++<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0369`.<br/>error:&#160;could&#160;not&#160;compile&#160;`chapter10`&#160;due&#160;to&#160;previous&#160;error<br/>
The help text mentions&#160;&#160;std::cmp::PartialOrd&#160;, which is a&#160;<i>trait</i>, and we’re going to talk<br/>about traits in the next section. For now, know that this error states that the body of<br/>
largest&#160;&#160;won’t work for all possible types that&#160;&#160;T&#160;&#160;could be. Because we want to compare<br/>
values of type&#160;&#160;T&#160;&#160;in the body, we can only use types whose values can be ordered. To enable<br/>comparisons, the standard library has the&#160;&#160;std::cmp::PartialOrd&#160;&#160;trait that you can<br/>implement on types (see Appendix C for more on this trait). By following the help text's<br/>suggestion, we restrict the types valid for&#160;&#160;T&#160;&#160;to only those that implement&#160;&#160;PartialOrd&#160;&#160;and<br/>this example will compile, because the standard library implements&#160;&#160;PartialOrd&#160;&#160;on both<br/>
i32&#160;&#160;and&#160;&#160;char&#160;.<br/>
<a href="tests.html#227"><b>In&#160;Struct&#160;Deﬁnitions</b></a><br/>
We can also deﬁne structs to use a generic type parameter in one or more&#160;ﬁelds using the<br/>
&lt;&gt;&#160;&#160;syntax. Listing 10-6 deﬁnes a&#160;&#160;Point&lt;T&gt;&#160;&#160;struct to hold&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;&#160;coordinate values of<br/>
any type.<br/>
Filename: src/main.rs<br/>
struct&#160;Point&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;x:&#160;T,<br/>&#160;&#160;&#160;&#160;y:&#160;T,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;integer&#160;=&#160;Point&#160;{&#160;x:&#160;5,&#160;y:&#160;10&#160;};<br/>&#160;&#160;&#160;&#160;let&#160;float&#160;=&#160;Point&#160;{&#160;x:&#160;1.0,&#160;y:&#160;4.0&#160;};<br/>}<br/>
<b>Listing&#160;10-6:&#160;A&#160;&#160;</b>Point&lt;T&gt;&#160;<b>&#160;struct&#160;that&#160;holds&#160;&#160;</b>x&#160;<b>&#160;and&#160;&#160;</b>y&#160;<b>&#160;values&#160;of&#160;type&#160;&#160;</b>T<br/>
https://doc.rust-lang.org/book/print.html<br/>
227/627<br/>
<hr/>
<a name=228></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The syntax for using generics in struct deﬁnitions is similar to that used in function<br/>deﬁnitions. First, we declare the name of the type parameter inside angle brackets just after<br/>the name of the struct. Then we use the generic type in the struct deﬁnition where we<br/>would otherwise specify concrete data types.<br/>
Note that because we’ve used only one generic type to deﬁne&#160;&#160;Point&lt;T&gt;&#160;, this deﬁnition says<br/>that the&#160;&#160;Point&lt;T&gt;&#160;&#160;struct is generic over some type&#160;&#160;T&#160;, and the&#160;ﬁelds&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;&#160;are&#160;<i>both</i>&#160;that<br/>same type, whatever that type may be. If we create an instance of a&#160;&#160;Point&lt;T&gt;&#160;&#160;that has<br/>values of diﬀerent types, as in Listing 10-7, our code won’t compile.<br/>
Filename: src/main.rs<br/>
struct&#160;Point&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;x:&#160;T,<br/>&#160;&#160;&#160;&#160;y:&#160;T,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;wont_work&#160;=&#160;Point&#160;{&#160;x:&#160;5,&#160;y:&#160;4.0&#160;};<br/>}<br/>
<b>Listing&#160;10-7:&#160;The&#160;ﬁelds&#160;&#160;</b>x&#160;<b>&#160;and&#160;&#160;</b>y&#160;<b>&#160;must&#160;be&#160;the&#160;same&#160;type&#160;because&#160;both&#160;have&#160;the&#160;same&#160;generic&#160;data&#160;type&#160;&#160;</b>T&#160;<b>.</b><br/>
In this example, when we assign the integer value 5 to&#160;&#160;x&#160;, we let the compiler know that the<br/>generic type&#160;&#160;T&#160;&#160;will be an integer for this instance of&#160;&#160;Point&lt;T&gt;&#160;. Then when we specify 4.0<br/>for&#160;&#160;y&#160;, which we’ve deﬁned to have the same type as&#160;&#160;x&#160;, we’ll get a type mismatch error like<br/>this:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;chapter10&#160;v0.1.0&#160;(file:///projects/chapter10)<br/>error[E0308]:&#160;mismatched&#160;types<br/>&#160;--&gt;&#160;src/main.rs:7:38<br/>&#160;&#160;|<br/>7&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;wont_work&#160;=&#160;Point&#160;{&#160;x:&#160;5,&#160;y:&#160;4.0&#160;};<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^&#160;expected&#160;integer,&#160;found&#160;floating-<br/>point&#160;number<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0308`.<br/>error:&#160;could&#160;not&#160;compile&#160;`chapter10`&#160;due&#160;to&#160;previous&#160;error<br/>
To deﬁne a&#160;&#160;Point&#160;&#160;struct where&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;&#160;are both generics but could have diﬀerent types,<br/>we can use multiple generic type parameters. For example, in Listing 10-8, we change the<br/>deﬁnition of&#160;&#160;Point&#160;&#160;to be generic over types&#160;&#160;T&#160;&#160;and&#160;&#160;U&#160;&#160;where&#160;&#160;x&#160;&#160;is of type&#160;&#160;T&#160;&#160;and&#160;&#160;y&#160;&#160;is of<br/>type&#160;&#160;U&#160;.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
228/627<br/>
<hr/>
<a name=229></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
struct&#160;Point&lt;T,&#160;U&gt;&#160;{<br/>&#160;&#160;&#160;&#160;x:&#160;T,<br/>&#160;&#160;&#160;&#160;y:&#160;U,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;both_integer&#160;=&#160;Point&#160;{&#160;x:&#160;5,&#160;y:&#160;10&#160;};<br/>&#160;&#160;&#160;&#160;let&#160;both_float&#160;=&#160;Point&#160;{&#160;x:&#160;1.0,&#160;y:&#160;4.0&#160;};<br/>&#160;&#160;&#160;&#160;let&#160;integer_and_float&#160;=&#160;Point&#160;{&#160;x:&#160;5,&#160;y:&#160;4.0&#160;};<br/>}<br/>
<b>Listing&#160;10-8:&#160;A&#160;&#160;</b>Point&lt;T,&#160;U&gt;&#160;<b>&#160;generic&#160;over&#160;two&#160;types&#160;so&#160;that&#160;&#160;</b>x&#160;<b>&#160;and&#160;&#160;</b>y&#160;<b>&#160;can&#160;be&#160;values&#160;of&#160;diﬀerent&#160;types</b><br/>
Now all the instances of&#160;&#160;Point&#160;&#160;shown are allowed! You can use as many generic type<br/>parameters in a deﬁnition as you want, but using more than a few makes your code hard to<br/>read. If you're&#160;ﬁnding you need lots of generic types in your code, it could indicate that your<br/>code needs restructuring into smaller pieces.<br/>
<a href="tests.html#229"><b>In&#160;Enum&#160;Deﬁnitions</b></a><br/>
As we did with structs, we can deﬁne enums to hold generic data types in their variants.<br/>Let’s take another look at the&#160;&#160;Option&lt;T&gt;&#160;&#160;enum that the standard library provides, which we<br/>used in Chapter 6:<br/>
enum&#160;Option&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;Some(T),<br/>&#160;&#160;&#160;&#160;None,<br/>}<br/>
This deﬁnition should now make more sense to you. As you can see, the&#160;&#160;Option&lt;T&gt;&#160;&#160;enum is<br/>generic over type&#160;&#160;T&#160;&#160;and has two variants:&#160;&#160;Some&#160;, which holds one value of type&#160;&#160;T&#160;, and a<br/>
None&#160;&#160;variant that doesn’t hold any value. By using the&#160;&#160;Option&lt;T&gt;&#160;&#160;enum, we can express<br/>
the abstract concept of an optional value, and because&#160;&#160;Option&lt;T&gt;&#160;&#160;is generic, we can use<br/>this abstraction no matter what the type of the optional value is.<br/>
Enums can use multiple generic types as well. The deﬁnition of the&#160;&#160;Result&#160;&#160;enum that we<br/>used in Chapter 9 is one example:<br/>
enum&#160;Result&lt;T,&#160;E&gt;&#160;{<br/>&#160;&#160;&#160;&#160;Ok(T),<br/>&#160;&#160;&#160;&#160;Err(E),<br/>}<br/>
The&#160;&#160;Result&#160;&#160;enum is generic over two types,&#160;&#160;T&#160;&#160;and&#160;&#160;E&#160;, and has two variants:&#160;&#160;Ok&#160;, which<br/>holds a value of type&#160;&#160;T&#160;, and&#160;&#160;Err&#160;, which holds a value of type&#160;&#160;E&#160;. This deﬁnition makes it<br/>convenient to use the&#160;&#160;Result&#160;&#160;enum anywhere we have an operation that might succeed<br/>(return a value of some type&#160;&#160;T&#160;) or fail (return an error of some type&#160;&#160;E&#160;). In fact, this is what<br/>
https://doc.rust-lang.org/book/print.html<br/>
229/627<br/>
<hr/>
<a name=230></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
we used to open a&#160;ﬁle in Listing 9-3, where&#160;&#160;T&#160;&#160;was&#160;ﬁlled in with the type&#160;&#160;std::fs::File<br/>when the&#160;ﬁle was opened successfully and&#160;&#160;E&#160;&#160;was&#160;ﬁlled in with the type&#160;&#160;std::io::Error<br/>when there were problems opening the&#160;ﬁle.<br/>
When you recognize situations in your code with multiple struct or enum deﬁnitions that<br/>diﬀer only in the types of the values they hold, you can avoid duplication by using generic<br/>types instead.<br/>
<a href="tests.html#230"><b>In&#160;Method&#160;Deﬁnitions</b></a><br/>
We can implement methods on structs and enums (as we did in Chapter 5) and use generic<br/>types in their deﬁnitions, too. Listing 10-9 shows the&#160;&#160;Point&lt;T&gt;&#160;&#160;struct we deﬁned in Listing<br/>10-6 with a method named&#160;&#160;x&#160;&#160;implemented on it.<br/>
Filename: src/main.rs<br/>
struct&#160;Point&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;x:&#160;T,<br/>&#160;&#160;&#160;&#160;y:&#160;T,<br/>}<br/>
impl&lt;T&gt;&#160;Point&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;x(&amp;self)&#160;-&gt;&#160;&amp;T&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&amp;self.x<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;p&#160;=&#160;Point&#160;{&#160;x:&#160;5,&#160;y:&#160;10&#160;};<br/>
&#160;&#160;&#160;&#160;println!(&#34;p.x&#160;=&#160;{}&#34;,&#160;p.x());<br/>}<br/>
<b>Listing&#160;10-9:&#160;Implementing&#160;a&#160;method&#160;named&#160;&#160;</b>x&#160;<b>&#160;on&#160;the&#160;&#160;</b>Point&lt;T&gt;&#160;<b>&#160;struct&#160;that&#160;will&#160;return&#160;a&#160;reference&#160;to&#160;the&#160;&#160;</b>x<br/>
<b>ﬁeld&#160;of&#160;type&#160;&#160;</b>T<br/>
Here, we’ve deﬁned a method named&#160;&#160;x&#160;&#160;on&#160;&#160;Point&lt;T&gt;&#160;&#160;that returns a reference to the data<br/>in the&#160;ﬁeld&#160;&#160;x&#160;.<br/>
Note that we have to declare&#160;&#160;T&#160;&#160;just after&#160;&#160;impl&#160;&#160;so we can use&#160;&#160;T&#160;&#160;to specify that we’re<br/>implementing methods on the type&#160;&#160;Point&lt;T&gt;&#160;. By declaring&#160;&#160;T&#160;&#160;as a generic type after&#160;&#160;impl&#160;,<br/>Rust can identify that the type in the angle brackets in&#160;&#160;Point&#160;&#160;is a generic type rather than a<br/>concrete type. We could have chosen a diﬀerent name for this generic parameter than the<br/>generic parameter declared in the struct deﬁnition, but using the same name is<br/>conventional. Methods written within an&#160;&#160;impl&#160;&#160;that declares the generic type will be deﬁned<br/>on any instance of the type, no matter what concrete type ends up substituting for the<br/>generic type.<br/>
https://doc.rust-lang.org/book/print.html<br/>
230/627<br/>
<hr/>
<a name=231></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We can also specify constraints on generic types when deﬁning methods on the type. We<br/>could, for example, implement methods only on&#160;&#160;Point&lt;f32&gt;&#160;&#160;instances rather than on<br/>
Point&lt;T&gt;&#160;&#160;instances with any generic type. In Listing 10-10 we use the concrete type&#160;&#160;f32&#160;,<br/>
meaning we don’t declare any types after&#160;&#160;impl&#160;.<br/>
Filename: src/main.rs<br/>
impl&#160;Point&lt;f32&gt;&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;distance_from_origin(&amp;self)&#160;-&gt;&#160;f32&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(self.x.powi(2)&#160;+&#160;self.y.powi(2)).sqrt()<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;10-10:&#160;An&#160;&#160;</b>impl&#160;<b>&#160;block&#160;that&#160;only&#160;applies&#160;to&#160;a&#160;struct&#160;with&#160;a&#160;particular&#160;concrete&#160;type&#160;for&#160;the&#160;generic&#160;type<br/>parameter&#160;&#160;</b>T<br/>
This code means the type&#160;&#160;Point&lt;f32&gt;&#160;&#160;will have a&#160;&#160;distance_from_origin&#160;&#160;method; other<br/>instances of&#160;&#160;Point&lt;T&gt;&#160;&#160;where&#160;&#160;T&#160;&#160;is not of type&#160;&#160;f32&#160;&#160;will not have this method deﬁned. The<br/>method measures how far our point is from the point at coordinates (0.0, 0.0) and uses<br/>mathematical operations that are available only for&#160;ﬂoating point types.<br/>
Generic type parameters in a struct deﬁnition aren’t always the same as those you use in<br/>that same struct’s method signatures. Listing 10-11 uses the generic types&#160;&#160;X1&#160;&#160;and&#160;&#160;Y1&#160;&#160;for<br/>the&#160;&#160;Point&#160;&#160;struct and&#160;&#160;X2&#160;&#160;&#160;Y2&#160;&#160;for the&#160;&#160;mixup&#160;&#160;method signature to make the example clearer.<br/>The method creates a new&#160;&#160;Point&#160;&#160;instance with the&#160;&#160;x&#160;&#160;value from the&#160;&#160;self&#160;&#160;&#160;Point&#160;&#160;(of type<br/>
X1&#160;) and the&#160;&#160;y&#160;&#160;value from the passed-in&#160;&#160;Point&#160;&#160;(of type&#160;&#160;Y2&#160;).<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
231/627<br/>
<hr/>
<a name=232></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
struct&#160;Point&lt;X1,&#160;Y1&gt;&#160;{<br/>&#160;&#160;&#160;&#160;x:&#160;X1,<br/>&#160;&#160;&#160;&#160;y:&#160;Y1,<br/>}<br/>
impl&lt;X1,&#160;Y1&gt;&#160;Point&lt;X1,&#160;Y1&gt;&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;mixup&lt;X2,&#160;Y2&gt;(self,&#160;other:&#160;Point&lt;X2,&#160;Y2&gt;)&#160;-&gt;&#160;Point&lt;X1,&#160;Y2&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Point&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x:&#160;self.x,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;other.y,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;p1&#160;=&#160;Point&#160;{&#160;x:&#160;5,&#160;y:&#160;10.4&#160;};<br/>&#160;&#160;&#160;&#160;let&#160;p2&#160;=&#160;Point&#160;{&#160;x:&#160;&#34;Hello&#34;,&#160;y:&#160;'c'&#160;};<br/>
&#160;&#160;&#160;&#160;let&#160;p3&#160;=&#160;p1.mixup(p2);<br/>
&#160;&#160;&#160;&#160;println!(&#34;p3.x&#160;=&#160;{},&#160;p3.y&#160;=&#160;{}&#34;,&#160;p3.x,&#160;p3.y);<br/>}<br/>
<b>Listing&#160;10-11:&#160;A&#160;method&#160;that&#160;uses&#160;generic&#160;types&#160;diﬀerent&#160;from&#160;its&#160;struct’s&#160;deﬁnition</b><br/>
In&#160;&#160;main&#160;, we’ve deﬁned a&#160;&#160;Point&#160;&#160;that has an&#160;&#160;i32&#160;&#160;for&#160;&#160;x&#160;&#160;(with value&#160;&#160;5&#160;) and an&#160;&#160;f64&#160;&#160;for&#160;&#160;y<br/>(with value&#160;&#160;10.4&#160;). The&#160;&#160;p2&#160;&#160;variable is a&#160;&#160;Point&#160;&#160;struct that has a string slice for&#160;&#160;x&#160;&#160;(with value<br/>
&#34;Hello&#34;&#160;) and a&#160;&#160;char&#160;&#160;for&#160;&#160;y&#160;&#160;(with value&#160;&#160;c&#160;). Calling&#160;&#160;mixup&#160;&#160;on&#160;&#160;p1&#160;&#160;with the argument&#160;&#160;p2<br/>
gives us&#160;&#160;p3&#160;, which will have an&#160;&#160;i32&#160;&#160;for&#160;&#160;x&#160;, because&#160;&#160;x&#160;&#160;came from&#160;&#160;p1&#160;. The&#160;&#160;p3&#160;&#160;variable will<br/>have a&#160;&#160;char&#160;&#160;for&#160;&#160;y&#160;, because&#160;&#160;y&#160;&#160;came from&#160;&#160;p2&#160;. The&#160;&#160;println!&#160;&#160;macro call will print&#160;&#160;p3.x&#160;=&#160;<br/>5,&#160;p3.y&#160;=&#160;c&#160;.<br/>
The purpose of this example is to demonstrate a situation in which some generic<br/>parameters are declared with&#160;&#160;impl&#160;&#160;and some are declared with the method deﬁnition.<br/>Here, the generic parameters&#160;&#160;X1&#160;&#160;and&#160;&#160;Y1&#160;&#160;are declared after&#160;&#160;impl&#160;&#160;because they go with the<br/>struct deﬁnition. The generic parameters&#160;&#160;X2&#160;&#160;and&#160;&#160;Y2&#160;&#160;are declared after&#160;&#160;fn&#160;mixup&#160;, because<br/>they’re only relevant to the method.<br/>
<a href="tests.html#232"><b>Performance&#160;of&#160;Code&#160;Using&#160;Generics</b></a><br/>
You might be wondering whether there is a runtime cost when using generic type<br/>parameters. The good news is that using generic types won't make your program run any<br/>slower than it would with concrete types.<br/>
Rust accomplishes this by performing monomorphization of the code using generics at<br/>compile time.&#160;<i>Monomorphization</i>&#160;is the process of turning generic code into speciﬁc code by<br/>ﬁlling in the concrete types that are used when compiled. In this process, the compiler does<br/>the opposite of the steps we used to create the generic function in Listing 10-5: the compiler<br/>
https://doc.rust-lang.org/book/print.html<br/>
232/627<br/>
<hr/>
<a name=233></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
looks at all the places where generic code is called and generates code for the concrete<br/>types the generic code is called with.<br/>
Let’s look at how this works by using the standard library’s generic&#160;&#160;Option&lt;T&gt;&#160;&#160;enum:<br/>
let&#160;integer&#160;=&#160;Some(5);<br/>let&#160;float&#160;=&#160;Some(5.0);<br/>
When Rust compiles this code, it performs monomorphization. During that process, the<br/>compiler reads the values that have been used in&#160;&#160;Option&lt;T&gt;&#160;&#160;instances and identiﬁes two<br/>kinds of&#160;&#160;Option&lt;T&gt;&#160;: one is&#160;&#160;i32&#160;&#160;and the other is&#160;&#160;f64&#160;. As such, it expands the generic<br/>deﬁnition of&#160;&#160;Option&lt;T&gt;&#160;&#160;into two deﬁnitions specialized to&#160;&#160;i32&#160;&#160;and&#160;&#160;f64&#160;, thereby replacing<br/>the generic deﬁnition with the speciﬁc ones.<br/>
The monomorphized version of the code looks similar to the following (the compiler uses<br/>diﬀerent names than what we’re using here for illustration):<br/>
Filename: src/main.rs<br/>
enum&#160;Option_i32&#160;{<br/>&#160;&#160;&#160;&#160;Some(i32),<br/>&#160;&#160;&#160;&#160;None,<br/>}<br/>
enum&#160;Option_f64&#160;{<br/>&#160;&#160;&#160;&#160;Some(f64),<br/>&#160;&#160;&#160;&#160;None,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;integer&#160;=&#160;Option_i32::Some(5);<br/>&#160;&#160;&#160;&#160;let&#160;float&#160;=&#160;Option_f64::Some(5.0);<br/>}<br/>
The generic&#160;&#160;Option&lt;T&gt;&#160;&#160;is replaced with the speciﬁc deﬁnitions created by the compiler.<br/>Because Rust compiles generic code into code that speciﬁes the type in each instance, we<br/>pay no runtime cost for using generics. When the code runs, it performs just as it would if<br/>we had duplicated each deﬁnition by hand. The process of monomorphization makes Rust’s<br/>generics extremely eﬃcient at runtime.<br/>
https://doc.rust-lang.org/book/print.html<br/>
233/627<br/>
<hr/>
<a name=234></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#234"><b>Traits: Deﬁning Shared Behavior</b></a><br/>
A&#160;<i>trait</i>&#160;deﬁnes functionality a particular type has and can share with other types. We can use<br/>traits to deﬁne shared behavior in an abstract way. We can use&#160;<i>trait bounds</i>&#160;to specify that a<br/>generic type can be any type that has certain behavior.<br/>
Note: Traits are similar to a feature often called&#160;<i>interfaces</i>&#160;in other languages, although<br/>with some diﬀerences.<br/>
<a href="tests.html#234"><b>Deﬁning&#160;a&#160;Trait</b></a><br/>
A type’s behavior consists of the methods we can call on that type. Diﬀerent types share the<br/>same behavior if we can call the same methods on all of those types. Trait deﬁnitions are a<br/>way to group method signatures together to deﬁne a set of behaviors necessary to<br/>accomplish some purpose.<br/>
For example, let’s say we have multiple structs that hold various kinds and amounts of text:<br/>a&#160;&#160;NewsArticle&#160;&#160;struct that holds a news story&#160;ﬁled in a particular location and a&#160;&#160;Tweet&#160;&#160;that<br/>can have at most 280 characters along with metadata that indicates whether it was a new<br/>tweet, a retweet, or a reply to another tweet.<br/>
We want to make a media aggregator library crate named&#160;&#160;aggregator&#160;&#160;that can display<br/>summaries of data that might be stored in a&#160;&#160;NewsArticle&#160;&#160;or&#160;&#160;Tweet&#160;&#160;instance. To do this, we<br/>need a summary from each type, and we’ll request that summary by calling a&#160;&#160;summarize<br/>method on an instance. Listing 10-12 shows the deﬁnition of a public&#160;&#160;Summary&#160;&#160;trait that<br/>expresses this behavior.<br/>
Filename: src/lib.rs<br/>
pub&#160;trait&#160;Summary&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;summarize(&amp;self)&#160;-&gt;&#160;String;<br/>}<br/>
<b>Listing&#160;10-12:&#160;A&#160;&#160;</b>Summary&#160;<b>&#160;trait&#160;that&#160;consists&#160;of&#160;the&#160;behavior&#160;provided&#160;by&#160;a&#160;&#160;</b>summarize&#160;<b>&#160;method</b><br/>
Here, we declare a trait using the&#160;&#160;trait&#160;&#160;keyword and then the trait’s name, which is<br/>
Summary&#160;&#160;in this case. We’ve also declared the trait as&#160;&#160;pub&#160;&#160;so that crates depending on this<br/>
crate can make use of this trait too, as we’ll see in a few examples. Inside the curly brackets,<br/>we declare the method signatures that describe the behaviors of the types that implement<br/>this trait, which in this case is&#160;&#160;fn&#160;summarize(&amp;self)&#160;-&gt;&#160;String&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
234/627<br/>
<hr/>
<a name=235></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
After the method signature, instead of providing an implementation within curly brackets,<br/>we use a semicolon. Each type implementing this trait must provide its own custom<br/>behavior for the body of the method. The compiler will enforce that any type that has the<br/>
Summary&#160;&#160;trait will have the method&#160;&#160;summarize&#160;&#160;deﬁned with this signature exactly.<br/>
A trait can have multiple methods in its body: the method signatures are listed one per line<br/>and each line ends in a semicolon.<br/>
<a href="tests.html#235"><b>Implementing&#160;a&#160;Trait&#160;on&#160;a&#160;Type</b></a><br/>
Now that we’ve deﬁned the desired signatures of the&#160;&#160;Summary&#160;&#160;trait’s methods, we can<br/>implement it on the types in our media aggregator. Listing 10-13 shows an implementation<br/>of the&#160;&#160;Summary&#160;&#160;trait on the&#160;&#160;NewsArticle&#160;&#160;struct that uses the headline, the author, and the<br/>location to create the return value of&#160;&#160;summarize&#160;. For the&#160;&#160;Tweet&#160;&#160;struct, we deﬁne<br/>
summarize&#160;&#160;as the username followed by the entire text of the tweet, assuming that tweet<br/>
content is already limited to 280 characters.<br/>
Filename: src/lib.rs<br/>
pub&#160;struct&#160;NewsArticle&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;headline:&#160;String,<br/>&#160;&#160;&#160;&#160;pub&#160;location:&#160;String,<br/>&#160;&#160;&#160;&#160;pub&#160;author:&#160;String,<br/>&#160;&#160;&#160;&#160;pub&#160;content:&#160;String,<br/>}<br/>
impl&#160;Summary&#160;for&#160;NewsArticle&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;summarize(&amp;self)&#160;-&gt;&#160;String&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;format!(&#34;{},&#160;by&#160;{}&#160;({})&#34;,&#160;self.headline,&#160;self.author,&#160;self.location)<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
pub&#160;struct&#160;Tweet&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;username:&#160;String,<br/>&#160;&#160;&#160;&#160;pub&#160;content:&#160;String,<br/>&#160;&#160;&#160;&#160;pub&#160;reply:&#160;bool,<br/>&#160;&#160;&#160;&#160;pub&#160;retweet:&#160;bool,<br/>}<br/>
impl&#160;Summary&#160;for&#160;Tweet&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;summarize(&amp;self)&#160;-&gt;&#160;String&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;format!(&#34;{}:&#160;{}&#34;,&#160;self.username,&#160;self.content)<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;10-13:&#160;Implementing&#160;the&#160;&#160;</b>Summary&#160;<b>&#160;trait&#160;on&#160;the&#160;&#160;</b>NewsArticle&#160;<b>&#160;and&#160;&#160;</b>Tweet&#160;<b>&#160;types</b><br/>
Implementing a trait on a type is similar to implementing regular methods. The diﬀerence is<br/>that after&#160;&#160;impl&#160;, we put the trait name we want to implement, then use the&#160;&#160;for&#160;&#160;keyword,<br/>and then specify the name of the type we want to implement the trait for. Within the&#160;&#160;impl<br/>
https://doc.rust-lang.org/book/print.html<br/>
235/627<br/>
<hr/>
<a name=236></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
block, we put the method signatures that the trait deﬁnition has deﬁned. Instead of adding<br/>a semicolon after each signature, we use curly brackets and&#160;ﬁll in the method body with the<br/>speciﬁc behavior that we want the methods of the trait to have for the particular type.<br/>
Now that the library has implemented the&#160;&#160;Summary&#160;&#160;trait on&#160;&#160;NewsArticle&#160;&#160;and&#160;&#160;Tweet&#160;, users<br/>of the crate can call the trait methods on instances of&#160;&#160;NewsArticle&#160;&#160;and&#160;&#160;Tweet&#160;&#160;in the same<br/>way we call regular methods. The only diﬀerence is that the user must bring the trait into<br/>scope as well as the types. Here’s an example of how a binary crate could use our<br/>
aggregator&#160;&#160;library crate:<br/>
use&#160;aggregator::{Summary,&#160;Tweet};<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;tweet&#160;=&#160;Tweet&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;username:&#160;String::from(&#34;horse_ebooks&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content:&#160;String::from(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;of&#160;course,&#160;as&#160;you&#160;probably&#160;already&#160;know,&#160;people&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;reply:&#160;false,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;retweet:&#160;false,<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;println!(&#34;1&#160;new&#160;tweet:&#160;{}&#34;,&#160;tweet.summarize());<br/>}<br/>
This code prints&#160;&#160;1&#160;new&#160;tweet:&#160;horse_ebooks:&#160;of&#160;course,&#160;as&#160;you&#160;probably&#160;already&#160;<br/>know,&#160;people&#160;.<br/>
Other crates that depend on the&#160;&#160;aggregator&#160;&#160;crate can also bring the&#160;&#160;Summary&#160;&#160;trait into<br/>scope to implement&#160;&#160;Summary&#160;&#160;on their own types. One restriction to note is that we can<br/>implement a trait on a type only if at least one of the trait or the type is local to our crate.<br/>For example, we can implement standard library traits like&#160;&#160;Display&#160;&#160;on a custom type like<br/>
Tweet&#160;&#160;as part of our&#160;&#160;aggregator&#160;&#160;crate functionality, because the type&#160;&#160;Tweet&#160;&#160;is local to our<br/>aggregator&#160;&#160;crate. We can also implement&#160;&#160;Summary&#160;&#160;on&#160;&#160;Vec&lt;T&gt;&#160;&#160;in our&#160;&#160;aggregator&#160;&#160;crate,<br/>
because the trait&#160;&#160;Summary&#160;&#160;is local to our&#160;&#160;aggregator&#160;&#160;crate.<br/>
But we can’t implement external traits on external types. For example, we can’t implement<br/>the&#160;&#160;Display&#160;&#160;trait on&#160;&#160;Vec&lt;T&gt;&#160;&#160;within our&#160;&#160;aggregator&#160;&#160;crate, because&#160;&#160;Display&#160;&#160;and&#160;&#160;Vec&lt;T&gt;<br/>are both deﬁned in the standard library and aren’t local to our&#160;&#160;aggregator&#160;&#160;crate. This<br/>restriction is part of a property called&#160;<i>coherence</i>, and more speciﬁcally the&#160;<i>orphan rule</i>, so<br/>named because the parent type is not present. This rule ensures that other people’s code<br/>can’t break your code and vice versa. Without the rule, two crates could implement the<br/>same trait for the same type, and Rust wouldn’t know which implementation to use.<br/>
https://doc.rust-lang.org/book/print.html<br/>
236/627<br/>
<hr/>
<a name=237></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#237"><b>Default&#160;Implementations</b></a><br/>
Sometimes it’s useful to have default behavior for some or all of the methods in a trait<br/>instead of requiring implementations for all methods on every type. Then, as we implement<br/>the trait on a particular type, we can keep or override each method’s default behavior.<br/>
In Listing 10-14 we specify a default string for the&#160;&#160;summarize&#160;&#160;method of the&#160;&#160;Summary&#160;&#160;trait<br/>instead of only deﬁning the method signature, as we did in Listing 10-12.<br/>
Filename: src/lib.rs<br/>
pub&#160;trait&#160;Summary&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;summarize(&amp;self)&#160;-&gt;&#160;String&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;(Read&#160;more...)&#34;)<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;10-14:&#160;Deﬁning&#160;a&#160;&#160;</b>Summary&#160;<b>&#160;trait&#160;with&#160;a&#160;default&#160;implementation&#160;of&#160;the&#160;&#160;</b>summarize&#160;<b>&#160;method</b><br/>
To use a default implementation to summarize instances of&#160;&#160;NewsArticle&#160;, we specify an<br/>empty&#160;&#160;impl&#160;&#160;block with&#160;&#160;impl&#160;Summary&#160;for&#160;NewsArticle&#160;{}&#160;.<br/>
Even though we’re no longer deﬁning the&#160;&#160;summarize&#160;&#160;method on&#160;&#160;NewsArticle&#160;&#160;directly,<br/>we’ve provided a default implementation and speciﬁed that&#160;&#160;NewsArticle&#160;&#160;implements the<br/>
Summary&#160;&#160;trait. As a result, we can still call the&#160;&#160;summarize&#160;&#160;method on an instance of<br/>NewsArticle&#160;, like this:<br/>
&#160;&#160;&#160;&#160;let&#160;article&#160;=&#160;NewsArticle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;headline:&#160;String::from(&#34;Penguins&#160;win&#160;the&#160;Stanley&#160;Cup&#160;Championship!&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;location:&#160;String::from(&#34;Pittsburgh,&#160;PA,&#160;USA&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;author:&#160;String::from(&#34;Iceburgh&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content:&#160;String::from(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;The&#160;Pittsburgh&#160;Penguins&#160;once&#160;again&#160;are&#160;the&#160;best&#160;\<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hockey&#160;team&#160;in&#160;the&#160;NHL.&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;),<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;println!(&#34;New&#160;article&#160;available!&#160;{}&#34;,&#160;article.summarize());<br/>
This code prints&#160;&#160;New&#160;article&#160;available!&#160;(Read&#160;more...)&#160;.<br/>
Creating a default implementation doesn’t require us to change anything about the<br/>implementation of&#160;&#160;Summary&#160;&#160;on&#160;&#160;Tweet&#160;&#160;in Listing 10-13. The reason is that the syntax for<br/>overriding a default implementation is the same as the syntax for implementing a trait<br/>method that doesn’t have a default implementation.<br/>
Default implementations can call other methods in the same trait, even if those other<br/>methods don’t have a default implementation. In this way, a trait can provide a lot of useful<br/>functionality and only require implementors to specify a small part of it. For example, we<br/>
https://doc.rust-lang.org/book/print.html<br/>
237/627<br/>
<hr/>
<a name=238></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
could deﬁne the&#160;&#160;Summary&#160;&#160;trait to have a&#160;&#160;summarize_author&#160;&#160;method whose implementation<br/>is required, and then deﬁne a&#160;&#160;summarize&#160;&#160;method that has a default implementation that<br/>calls the&#160;&#160;summarize_author&#160;&#160;method:<br/>
pub&#160;trait&#160;Summary&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;summarize_author(&amp;self)&#160;-&gt;&#160;String;<br/>
&#160;&#160;&#160;&#160;fn&#160;summarize(&amp;self)&#160;-&gt;&#160;String&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;format!(&#34;(Read&#160;more&#160;from&#160;{}...)&#34;,&#160;self.summarize_author())<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
To use this version of&#160;&#160;Summary&#160;, we only need to deﬁne&#160;&#160;summarize_author&#160;&#160;when we<br/>implement the trait on a type:<br/>
impl&#160;Summary&#160;for&#160;Tweet&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;summarize_author(&amp;self)&#160;-&gt;&#160;String&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;format!(&#34;@{}&#34;,&#160;self.username)<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
After we deﬁne&#160;&#160;summarize_author&#160;, we can call&#160;&#160;summarize&#160;&#160;on instances of the&#160;&#160;Tweet<br/>struct, and the default implementation of&#160;&#160;summarize&#160;&#160;will call the deﬁnition of<br/>
summarize_author&#160;&#160;that we’ve provided. Because we’ve implemented&#160;&#160;summarize_author&#160;,<br/>
the&#160;&#160;Summary&#160;&#160;trait has given us the behavior of the&#160;&#160;summarize&#160;&#160;method without requiring us<br/>to write any more code.<br/>
&#160;&#160;&#160;&#160;let&#160;tweet&#160;=&#160;Tweet&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;username:&#160;String::from(&#34;horse_ebooks&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content:&#160;String::from(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;of&#160;course,&#160;as&#160;you&#160;probably&#160;already&#160;know,&#160;people&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;reply:&#160;false,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;retweet:&#160;false,<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;println!(&#34;1&#160;new&#160;tweet:&#160;{}&#34;,&#160;tweet.summarize());<br/>
This code prints&#160;&#160;1&#160;new&#160;tweet:&#160;(Read&#160;more&#160;from&#160;@horse_ebooks...)&#160;.<br/>
Note that it isn’t possible to call the default implementation from an overriding<br/>implementation of that same method.<br/>
<a href="tests.html#238"><b>Traits&#160;as&#160;Parameters</b></a><br/>
Now that you know how to deﬁne and implement traits, we can explore how to use traits to<br/>deﬁne functions that accept many diﬀerent types. We'll use the&#160;&#160;Summary&#160;&#160;trait we<br/>implemented on the&#160;&#160;NewsArticle&#160;&#160;and&#160;&#160;Tweet&#160;&#160;types in Listing 10-13 to deﬁne a&#160;&#160;notify<br/>
https://doc.rust-lang.org/book/print.html<br/>
238/627<br/>
<hr/>
<a name=239></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
function that calls the&#160;&#160;summarize&#160;&#160;method on its&#160;&#160;item&#160;&#160;parameter, which is of some type<br/>that implements the&#160;&#160;Summary&#160;&#160;trait. To do this, we use the&#160;&#160;impl&#160;Trait&#160;&#160;syntax, like this:<br/>
pub&#160;fn&#160;notify(item:&#160;&amp;impl&#160;Summary)&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Breaking&#160;news!&#160;{}&#34;,&#160;item.summarize());<br/>}<br/>
Instead of a concrete type for the&#160;&#160;item&#160;&#160;parameter, we specify the&#160;&#160;impl&#160;&#160;keyword and the<br/>trait name. This parameter accepts any type that implements the speciﬁed trait. In the body<br/>of&#160;&#160;notify&#160;, we can call any methods on&#160;&#160;item&#160;&#160;that come from the&#160;&#160;Summary&#160;&#160;trait, such as<br/>
summarize&#160;. We can call&#160;&#160;notify&#160;&#160;and pass in any instance of&#160;&#160;NewsArticle&#160;&#160;or&#160;&#160;Tweet&#160;. Code<br/>
that calls the function with any other type, such as a&#160;&#160;String&#160;&#160;or an&#160;&#160;i32&#160;, won’t compile<br/>because those types don’t implement&#160;&#160;Summary&#160;.<br/>
<a href="tests.html#239"><b>Trait Bound Syntax</b></a><br/>
The&#160;&#160;impl&#160;Trait&#160;&#160;syntax works for straightforward cases but is actually syntax sugar for a<br/>longer form known as a&#160;<i>trait bound</i>; it looks like this:<br/>
pub&#160;fn&#160;notify&lt;T:&#160;Summary&gt;(item:&#160;&amp;T)&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Breaking&#160;news!&#160;{}&#34;,&#160;item.summarize());<br/>}<br/>
This longer form is equivalent to the example in the previous section but is more verbose.<br/>We place trait bounds with the declaration of the generic type parameter after a colon and<br/>inside angle brackets.<br/>
The&#160;&#160;impl&#160;Trait&#160;&#160;syntax is convenient and makes for more concise code in simple cases,<br/>while the fuller trait bound syntax can express more complexity in other cases. For example,<br/>we can have two parameters that implement&#160;&#160;Summary&#160;. Doing so with the&#160;&#160;impl&#160;Trait<br/>syntax looks like this:<br/>
pub&#160;fn&#160;notify(item1:&#160;&amp;impl&#160;Summary,&#160;item2:&#160;&amp;impl&#160;Summary)&#160;{<br/>
Using&#160;&#160;impl&#160;Trait&#160;&#160;is appropriate if we want this function to allow&#160;&#160;item1&#160;&#160;and&#160;&#160;item2&#160;&#160;to<br/>have diﬀerent types (as long as both types implement&#160;&#160;Summary&#160;). If we want to force both<br/>parameters to have the same type, however, we must use a trait bound, like this:<br/>
pub&#160;fn&#160;notify&lt;T:&#160;Summary&gt;(item1:&#160;&amp;T,&#160;item2:&#160;&amp;T)&#160;{<br/>
The generic type&#160;&#160;T&#160;&#160;speciﬁed as the type of the&#160;&#160;item1&#160;&#160;and&#160;&#160;item2&#160;&#160;parameters constrains<br/>the function such that the concrete type of the value passed as an argument for&#160;&#160;item1&#160;&#160;and<br/>
item2&#160;&#160;must be the same.<br/>
https://doc.rust-lang.org/book/print.html<br/>
239/627<br/>
<hr/>
<a name=240></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#240"><b>Specifying Multiple Trait Bounds with the&#160;</b>+<b>&#160;Syntax</b></a><br/>
We can also specify more than one trait bound. Say we wanted&#160;&#160;notify&#160;&#160;to use display<br/>formatting as well as&#160;&#160;summarize&#160;&#160;on&#160;&#160;item&#160;: we specify in the&#160;&#160;notify&#160;&#160;deﬁnition that&#160;&#160;item<br/>must implement both&#160;&#160;Display&#160;&#160;and&#160;&#160;Summary&#160;. We can do so using the&#160;&#160;+&#160;&#160;syntax:<br/>
pub&#160;fn&#160;notify(item:&#160;&amp;(impl&#160;Summary&#160;+&#160;Display))&#160;{<br/>
The&#160;&#160;+&#160;&#160;syntax is also valid with trait bounds on generic types:<br/>
pub&#160;fn&#160;notify&lt;T:&#160;Summary&#160;+&#160;Display&gt;(item:&#160;&amp;T)&#160;{<br/>
With the two trait bounds speciﬁed, the body of&#160;&#160;notify&#160;&#160;can call&#160;&#160;summarize&#160;&#160;and use&#160;&#160;{}&#160;&#160;to<br/>format&#160;&#160;item&#160;.<br/>
<a href="tests.html#240"><b>Clearer Trait Bounds with&#160;</b>where<b>&#160;Clauses</b></a><br/>
Using too many trait bounds has its downsides. Each generic has its own trait bounds, so<br/>functions with multiple generic type parameters can contain lots of trait bound information<br/>between the function’s name and its parameter list, making the function signature hard to<br/>read. For this reason, Rust has alternate syntax for specifying trait bounds inside a&#160;&#160;where<br/>clause after the function signature. So instead of writing this:<br/>
fn&#160;some_function&lt;T:&#160;Display&#160;+&#160;Clone,&#160;U:&#160;Clone&#160;+&#160;Debug&gt;(t:&#160;&amp;T,&#160;u:&#160;&amp;U)&#160;-&gt;&#160;i32&#160;{<br/>
we can use a&#160;&#160;where&#160;&#160;clause, like this:<br/>
fn&#160;some_function&lt;T,&#160;U&gt;(t:&#160;&amp;T,&#160;u:&#160;&amp;U)&#160;-&gt;&#160;i32<br/>where<br/>&#160;&#160;&#160;&#160;T:&#160;Display&#160;+&#160;Clone,<br/>&#160;&#160;&#160;&#160;U:&#160;Clone&#160;+&#160;Debug,<br/>{<br/>
This function’s signature is less cluttered: the function name, parameter list, and return type<br/>are close together, similar to a function without lots of trait bounds.<br/>
<a href="tests.html#240"><b>Returning&#160;Types&#160;that&#160;Implement&#160;Traits</b></a><br/>
We can also use the&#160;&#160;impl&#160;Trait&#160;&#160;syntax in the return position to return a value of some<br/>type that implements a trait, as shown here:<br/>
https://doc.rust-lang.org/book/print.html<br/>
240/627<br/>
<hr/>
<a name=241></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;returns_summarizable()&#160;-&gt;&#160;impl&#160;Summary&#160;{<br/>&#160;&#160;&#160;&#160;Tweet&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;username:&#160;String::from(&#34;horse_ebooks&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content:&#160;String::from(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;of&#160;course,&#160;as&#160;you&#160;probably&#160;already&#160;know,&#160;people&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;reply:&#160;false,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;retweet:&#160;false,<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
By using&#160;&#160;impl&#160;Summary&#160;&#160;for the return type, we specify that the&#160;&#160;returns_summarizable<br/>function returns some type that implements the&#160;&#160;Summary&#160;&#160;trait without naming the concrete<br/>type. In this case,&#160;&#160;returns_summarizable&#160;&#160;returns a&#160;&#160;Tweet&#160;, but the code calling this function<br/>doesn’t need to know that.<br/>
The ability to specify a return type only by the trait it implements is especially useful in the<br/>context of closures and iterators, which we cover in Chapter 13. Closures and iterators<br/>create types that only the compiler knows or types that are very long to specify. The&#160;&#160;impl&#160;<br/>Trait&#160;&#160;syntax lets you concisely specify that a function returns some type that implements<br/>the&#160;&#160;Iterator&#160;&#160;trait without needing to write out a very long type.<br/>
However, you can only use&#160;&#160;impl&#160;Trait&#160;&#160;if you’re returning a single type. For example, this<br/>code that returns either a&#160;&#160;NewsArticle&#160;&#160;or a&#160;&#160;Tweet&#160;&#160;with the return type speciﬁed as&#160;&#160;impl&#160;<br/>Summary&#160;&#160;wouldn’t work:<br/>
fn&#160;returns_summarizable(switch:&#160;bool)&#160;-&gt;&#160;impl&#160;Summary&#160;{<br/>&#160;&#160;&#160;&#160;if&#160;switch&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;NewsArticle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;headline:&#160;String::from(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;Penguins&#160;win&#160;the&#160;Stanley&#160;Cup&#160;Championship!&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;location:&#160;String::from(&#34;Pittsburgh,&#160;PA,&#160;USA&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;author:&#160;String::from(&#34;Iceburgh&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content:&#160;String::from(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;The&#160;Pittsburgh&#160;Penguins&#160;once&#160;again&#160;are&#160;the&#160;best&#160;\<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hockey&#160;team&#160;in&#160;the&#160;NHL.&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Tweet&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;username:&#160;String::from(&#34;horse_ebooks&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content:&#160;String::from(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;of&#160;course,&#160;as&#160;you&#160;probably&#160;already&#160;know,&#160;people&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;reply:&#160;false,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;retweet:&#160;false,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
241/627<br/>
<hr/>
<a name=242></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Returning either a&#160;&#160;NewsArticle&#160;&#160;or a&#160;&#160;Tweet&#160;&#160;isn’t allowed due to restrictions around how<br/>the&#160;&#160;impl&#160;Trait&#160;&#160;syntax is implemented in the compiler. We’ll cover how to write a function<br/><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">with this behavior in the&#160;“Using Trait Objects That Allow for Values of Diﬀerent Types”<br/></a>section of Chapter 17.<br/>
<a href="tests.html#242"><b>Using&#160;Trait&#160;Bounds&#160;to&#160;Conditionally&#160;Implement&#160;Methods</b></a><br/>
By using a trait bound with an&#160;&#160;impl&#160;&#160;block that uses generic type parameters, we can<br/>implement methods conditionally for types that implement the speciﬁed traits. For<br/>example, the type&#160;&#160;Pair&lt;T&gt;&#160;&#160;in Listing 10-15 always implements the&#160;&#160;new&#160;&#160;function to return a<br/>new instance of&#160;&#160;Pair&lt;T&gt;&#160;<a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#defining-methods">&#160;(recall from the&#160;“Deﬁning Methods”</a>&#160;section of Chapter 5 that<br/>
Self&#160;&#160;is a type alias for the type of the&#160;&#160;impl&#160;&#160;block, which in this case is&#160;&#160;Pair&lt;T&gt;&#160;). But in the<br/>
next&#160;&#160;impl&#160;&#160;block,&#160;&#160;Pair&lt;T&gt;&#160;&#160;only implements the&#160;&#160;cmp_display&#160;&#160;method if its inner type&#160;&#160;T<br/>implements the&#160;&#160;PartialOrd&#160;&#160;trait that enables comparison&#160;<i>and</i>&#160;the&#160;&#160;Display&#160;&#160;trait that<br/>enables printing.<br/>
Filename: src/lib.rs<br/>
use&#160;std::fmt::Display;<br/>
struct&#160;Pair&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;x:&#160;T,<br/>&#160;&#160;&#160;&#160;y:&#160;T,<br/>}<br/>
impl&lt;T&gt;&#160;Pair&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;new(x:&#160;T,&#160;y:&#160;T)&#160;-&gt;&#160;Self&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Self&#160;{&#160;x,&#160;y&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
impl&lt;T:&#160;Display&#160;+&#160;PartialOrd&gt;&#160;Pair&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;cmp_display(&amp;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;self.x&#160;&gt;=&#160;self.y&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;The&#160;largest&#160;member&#160;is&#160;x&#160;=&#160;{}&#34;,&#160;self.x);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;The&#160;largest&#160;member&#160;is&#160;y&#160;=&#160;{}&#34;,&#160;self.y);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;10-15:&#160;Conditionally&#160;implementing&#160;methods&#160;on&#160;a&#160;generic&#160;type&#160;depending&#160;on&#160;trait&#160;bounds</b><br/>
We can also conditionally implement a trait for any type that implements another trait.<br/>Implementations of a trait on any type that satisﬁes the trait bounds are called&#160;<i>blanket<br/>implementations</i>&#160;and are extensively used in the Rust standard library. For example, the<br/>standard library implements the&#160;&#160;ToString&#160;&#160;trait on any type that implements the&#160;&#160;Display<br/>trait. The&#160;&#160;impl&#160;&#160;block in the standard library looks similar to this code:<br/>
https://doc.rust-lang.org/book/print.html<br/>
242/627<br/>
<hr/>
<a name=243></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
impl&lt;T:&#160;Display&gt;&#160;ToString&#160;for&#160;T&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
Because the standard library has this blanket implementation, we can call the&#160;&#160;to_string<br/>method deﬁned by the&#160;&#160;ToString&#160;&#160;trait on any type that implements the&#160;&#160;Display&#160;&#160;trait. For<br/>example, we can turn integers into their corresponding&#160;&#160;String&#160;&#160;values like this because<br/>integers implement&#160;&#160;Display&#160;:<br/>
let&#160;s&#160;=&#160;3.to_string();<br/>
Blanket implementations appear in the documentation for the trait in the “Implementors”<br/>section.<br/>
Traits and trait bounds let us write code that uses generic type parameters to reduce<br/>duplication but also specify to the compiler that we want the generic type to have particular<br/>behavior. The compiler can then use the trait bound information to check that all the<br/>concrete types used with our code provide the correct behavior. In dynamically typed<br/>languages, we would get an error at runtime if we called a method on a type which didn’t<br/>deﬁne the method. But Rust moves these errors to compile time so we’re forced to&#160;ﬁx the<br/>problems before our code is even able to run. Additionally, we don’t have to write code that<br/>checks for behavior at runtime because we’ve already checked at compile time. Doing so<br/>improves performance without having to give up the&#160;ﬂexibility of generics.<br/>
https://doc.rust-lang.org/book/print.html<br/>
243/627<br/>
<hr/>
<a name=244></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#244"><b>Validating References with Lifetimes</b></a><br/>
Lifetimes are another kind of generic that we’ve already been using. Rather than ensuring<br/>that a type has the behavior we want, lifetimes ensure that references are valid as long as<br/>we need them to be.<br/>
One detail we didn’t discuss in the&#160;<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#references-and-borrowing">“References and Borrowing”</a>&#160;section in Chapter 4 is that<br/>every reference in Rust has a&#160;<i>lifetime</i>, which is the scope for which that reference is valid.<br/>Most of the time, lifetimes are implicit and inferred, just like most of the time, types are<br/>inferred. We only must annotate types when multiple types are possible. In a similar way,<br/>we must annotate lifetimes when the lifetimes of references could be related in a few<br/>diﬀerent ways. Rust requires us to annotate the relationships using generic lifetime<br/>parameters to ensure the actual references used at runtime will deﬁnitely be valid.<br/>
Annotating lifetimes is not even a concept most other programming languages have, so this<br/>is going to feel unfamiliar. Although we won’t cover lifetimes in their entirety in this chapter,<br/>we’ll discuss common ways you might encounter lifetime syntax so you can get comfortable<br/>with the concept.<br/>
<a href="tests.html#244"><b>Preventing&#160;Dangling&#160;References&#160;with&#160;Lifetimes</b></a><br/>
The main aim of lifetimes is to prevent&#160;<i>dangling references</i>, which cause a program to<br/>reference data other than the data it’s intended to reference. Consider the program in<br/>Listing 10-16, which has an outer scope and an inner scope.<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;r;<br/>
&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;r&#160;=&#160;&amp;x;<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;r:&#160;{}&#34;,&#160;r);<br/>}<br/>
<b>Listing&#160;10-16:&#160;An&#160;attempt&#160;to&#160;use&#160;a&#160;reference&#160;whose&#160;value&#160;has&#160;gone&#160;out&#160;of&#160;scope</b><br/>
Note: The examples in Listings 10-16, 10-17, and 10-23 declare variables without giving<br/>them an initial value, so the variable name exists in the outer scope. At&#160;ﬁrst glance, this<br/>might appear to be in conﬂict with Rust’s having no null values. However, if we try to<br/>
https://doc.rust-lang.org/book/print.html<br/>
244/627<br/>
<hr/>
<a name=245></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use a variable before giving it a value, we’ll get a compile-time error, which shows that<br/>Rust indeed does not allow null values.<br/>
The outer scope declares a variable named&#160;&#160;r&#160;&#160;with no initial value, and the inner scope<br/>declares a variable named&#160;&#160;x&#160;&#160;with the initial value of 5. Inside the inner scope, we attempt<br/>to set the value of&#160;&#160;r&#160;&#160;as a reference to&#160;&#160;x&#160;. Then the inner scope ends, and we attempt to<br/>print the value in&#160;&#160;r&#160;. This code won’t compile because the value&#160;&#160;r&#160;&#160;is referring to has gone<br/>out of scope before we try to use it. Here is the error message:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;chapter10&#160;v0.1.0&#160;(file:///projects/chapter10)<br/>error[E0597]:&#160;`x`&#160;does&#160;not&#160;live&#160;long&#160;enough<br/>&#160;--&gt;&#160;src/main.rs:6:13<br/>&#160;&#160;|<br/>6&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;r&#160;=&#160;&amp;x;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^&#160;borrowed&#160;value&#160;does&#160;not&#160;live&#160;long&#160;enough<br/>7&#160;|&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;-&#160;`x`&#160;dropped&#160;here&#160;while&#160;still&#160;borrowed<br/>8&#160;|<br/>9&#160;|&#160;&#160;&#160;&#160;&#160;println!(&#34;r:&#160;{}&#34;,&#160;r);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&#160;borrow&#160;later&#160;used&#160;here<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0597`.<br/>error:&#160;could&#160;not&#160;compile&#160;`chapter10`&#160;due&#160;to&#160;previous&#160;error<br/>
The variable&#160;&#160;x&#160;&#160;doesn’t “live long enough.” The reason is that&#160;&#160;x&#160;&#160;will be out of scope when<br/>the inner scope ends on line 7. But&#160;&#160;r&#160;&#160;is still valid for the outer scope; because its scope is<br/>larger, we say that it “lives longer.” If Rust allowed this code to work,&#160;&#160;r&#160;&#160;would be<br/>referencing memory that was deallocated when&#160;&#160;x&#160;&#160;went out of scope, and anything we tried<br/>to do with&#160;&#160;r&#160;&#160;wouldn’t work correctly. So how does Rust determine that this code is invalid?<br/>It uses a borrow checker.<br/>
<a href="tests.html#245"><b>The&#160;Borrow&#160;Checker</b></a><br/>
The Rust compiler has a&#160;<i>borrow checker</i>&#160;that compares scopes to determine whether all<br/>borrows are valid. Listing 10-17 shows the same code as Listing 10-16 but with annotations<br/>showing the lifetimes of the variables.<br/>
https://doc.rust-lang.org/book/print.html<br/>
245/627<br/>
<hr/>
<a name=246></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;r;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;---------+--&#160;'a<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;&#160;&#160;{&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;-+--&#160;'b&#160;&#160;|<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;r&#160;=&#160;&amp;x;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;&#160;&#160;}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;-+&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;&#160;&#160;println!(&#34;r:&#160;{}&#34;,&#160;r);&#160;//&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;---------+<br/>
<b>Listing&#160;10-17:&#160;Annotations&#160;of&#160;the&#160;lifetimes&#160;of&#160;&#160;</b>r&#160;<b>&#160;and&#160;&#160;</b>x&#160;<b>,&#160;named&#160;&#160;</b>'a&#160;<b>&#160;and&#160;&#160;</b>'b&#160;<b>,&#160;respectively</b><br/>
Here, we’ve annotated the lifetime of&#160;&#160;r&#160;&#160;with&#160;&#160;'a&#160;&#160;and the lifetime of&#160;&#160;x&#160;&#160;with&#160;&#160;'b&#160;. As you can<br/>see, the inner&#160;&#160;'b&#160;&#160;block is much smaller than the outer&#160;&#160;'a&#160;&#160;lifetime block. At compile time,<br/>Rust compares the size of the two lifetimes and sees that&#160;&#160;r&#160;&#160;has a lifetime of&#160;&#160;'a&#160;&#160;but that it<br/>refers to memory with a lifetime of&#160;&#160;'b&#160;. The program is rejected because&#160;&#160;'b&#160;&#160;is shorter than<br/>
'a&#160;: the subject of the reference doesn’t live as long as the reference.<br/>
Listing 10-18&#160;ﬁxes the code so it doesn’t have a dangling reference and compiles without<br/>any errors.<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;----------+--&#160;'b<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;&#160;&#160;let&#160;r&#160;=&#160;&amp;x;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--+--&#160;'a&#160;&#160;|<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;&#160;&#160;println!(&#34;r:&#160;{}&#34;,&#160;r);&#160;//&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--+&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>}&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;----------+<br/>
<b>Listing&#160;10-18:&#160;A&#160;valid&#160;reference&#160;because&#160;the&#160;data&#160;has&#160;a&#160;longer&#160;lifetime&#160;than&#160;the&#160;reference</b><br/>
Here,&#160;&#160;x&#160;&#160;has the lifetime&#160;&#160;'b&#160;, which in this case is larger than&#160;&#160;'a&#160;. This means&#160;&#160;r&#160;&#160;can<br/>reference&#160;&#160;x&#160;&#160;because Rust knows that the reference in&#160;&#160;r&#160;&#160;will always be valid while&#160;&#160;x&#160;&#160;is<br/>valid.<br/>
Now that you know where the lifetimes of references are and how Rust analyzes lifetimes to<br/>ensure references will always be valid, let’s explore generic lifetimes of parameters and<br/>return values in the context of functions.<br/>
<a href="tests.html#246"><b>Generic&#160;Lifetimes&#160;in&#160;Functions</b></a><br/>
We’ll write a function that returns the longer of two string slices. This function will take two<br/>string slices and return a single string slice. After we’ve implemented the&#160;&#160;longest&#160;&#160;function,<br/>the code in Listing 10-19 should print&#160;&#160;The&#160;longest&#160;string&#160;is&#160;abcd&#160;.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
246/627<br/>
<hr/>
<a name=247></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;string1&#160;=&#160;String::from(&#34;abcd&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;string2&#160;=&#160;&#34;xyz&#34;;<br/>
&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;longest(string1.as_str(),&#160;string2);<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;longest&#160;string&#160;is&#160;{}&#34;,&#160;result);<br/>}<br/>
<b>Listing&#160;10-19:&#160;A&#160;&#160;</b>main&#160;<b>&#160;function&#160;that&#160;calls&#160;the&#160;&#160;</b>longest&#160;<b>&#160;function&#160;to&#160;ﬁnd&#160;the&#160;longer&#160;of&#160;two&#160;string&#160;slices</b><br/>
Note that we want the function to take string slices, which are references, rather than<br/>strings, because we don’t want the&#160;&#160;longest&#160;&#160;function to take ownership of its parameters.<br/>Refer to the&#160;<a href="https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices-as-parameters">“String Slices as Parameters”&#160;section in Chapter 4 for more discussion about<br/></a>why the parameters we use in Listing 10-19 are the ones we want.<br/>
If we try to implement the&#160;&#160;longest&#160;&#160;function as shown in Listing 10-20, it won’t compile.<br/>
Filename: src/main.rs<br/>
fn&#160;longest(x:&#160;&amp;str,&#160;y:&#160;&amp;str)&#160;-&gt;&#160;&amp;str&#160;{<br/>&#160;&#160;&#160;&#160;if&#160;x.len()&#160;&gt;&#160;y.len()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;y<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;10-20:&#160;An&#160;implementation&#160;of&#160;the&#160;&#160;</b>longest&#160;<b>&#160;function&#160;that&#160;returns&#160;the&#160;longer&#160;of&#160;two&#160;string&#160;slices&#160;but&#160;does</b><br/>
<b>not&#160;yet&#160;compile</b><br/>
Instead, we get the following error that talks about lifetimes:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;chapter10&#160;v0.1.0&#160;(file:///projects/chapter10)<br/>error[E0106]:&#160;missing&#160;lifetime&#160;specifier<br/>&#160;--&gt;&#160;src/main.rs:9:33<br/>&#160;&#160;|<br/>9&#160;|&#160;fn&#160;longest(x:&#160;&amp;str,&#160;y:&#160;&amp;str)&#160;-&gt;&#160;&amp;str&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;----&#160;&#160;&#160;&#160;&#160;----&#160;&#160;&#160;&#160;&#160;^&#160;expected&#160;named&#160;lifetime&#160;parameter<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;help:&#160;this&#160;function's&#160;return&#160;type&#160;contains&#160;a&#160;borrowed&#160;value,&#160;but&#160;the&#160;<br/>signature&#160;does&#160;not&#160;say&#160;whether&#160;it&#160;is&#160;borrowed&#160;from&#160;`x`&#160;or&#160;`y`<br/>help:&#160;consider&#160;introducing&#160;a&#160;named&#160;lifetime&#160;parameter<br/>&#160;&#160;|<br/>9&#160;|&#160;fn&#160;longest&lt;'a&gt;(x:&#160;&amp;'a&#160;str,&#160;y:&#160;&amp;'a&#160;str)&#160;-&gt;&#160;&amp;'a&#160;str&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++++&#160;&#160;&#160;&#160;&#160;++&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0106`.<br/>error:&#160;could&#160;not&#160;compile&#160;`chapter10`&#160;due&#160;to&#160;previous&#160;error<br/>
https://doc.rust-lang.org/book/print.html<br/>
247/627<br/>
<hr/>
<a name=248></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The help text reveals that the return type needs a generic lifetime parameter on it because<br/>Rust can’t tell whether the reference being returned refers to&#160;&#160;x&#160;&#160;or&#160;&#160;y&#160;. Actually, we don’t<br/>know either, because the&#160;&#160;if&#160;&#160;block in the body of this function returns a reference to&#160;&#160;x&#160;&#160;and<br/>the&#160;&#160;else&#160;&#160;block returns a reference to&#160;&#160;y&#160;!<br/>
When we’re deﬁning this function, we don’t know the concrete values that will be passed<br/>into this function, so we don’t know whether the&#160;&#160;if&#160;&#160;case or the&#160;&#160;else&#160;&#160;case will execute. We<br/>also don’t know the concrete lifetimes of the references that will be passed in, so we can’t<br/>look at the scopes as we did in Listings 10-17 and 10-18 to determine whether the reference<br/>we return will always be valid. The borrow checker can’t determine this either, because it<br/>doesn’t know how the lifetimes of&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;&#160;relate to the lifetime of the return value. To&#160;ﬁx<br/>this error, we’ll add generic lifetime parameters that deﬁne the relationship between the<br/>references so the borrow checker can perform its analysis.<br/>
<a href="tests.html#248"><b>Lifetime&#160;Annotation&#160;Syntax</b></a><br/>
Lifetime annotations don’t change how long any of the references live. Rather, they describe<br/>the relationships of the lifetimes of multiple references to each other without aﬀecting the<br/>lifetimes. Just as functions can accept any type when the signature speciﬁes a generic type<br/>parameter, functions can accept references with any lifetime by specifying a generic lifetime<br/>parameter.<br/>
Lifetime annotations have a slightly unusual syntax: the names of lifetime parameters must<br/>start with an apostrophe (&#160;'&#160;) and are usually all lowercase and very short, like generic types.<br/>Most people use the name&#160;&#160;'a&#160;&#160;for the&#160;ﬁrst lifetime annotation. We place lifetime parameter<br/>annotations after the&#160;&#160;&amp;&#160;&#160;of a reference, using a space to separate the annotation from the<br/>reference’s type.<br/>
Here are some examples: a reference to an&#160;&#160;i32&#160;&#160;without a lifetime parameter, a reference<br/>to an&#160;&#160;i32&#160;&#160;that has a lifetime parameter named&#160;&#160;'a&#160;, and a mutable reference to an&#160;&#160;i32<br/>that also has the lifetime&#160;&#160;'a&#160;.<br/>
&amp;i32&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;a&#160;reference<br/>&amp;'a&#160;i32&#160;&#160;&#160;&#160;&#160;//&#160;a&#160;reference&#160;with&#160;an&#160;explicit&#160;lifetime<br/>&amp;'a&#160;mut&#160;i32&#160;//&#160;a&#160;mutable&#160;reference&#160;with&#160;an&#160;explicit&#160;lifetime<br/>
One lifetime annotation by itself doesn’t have much meaning, because the annotations are<br/>meant to tell Rust how generic lifetime parameters of multiple references relate to each<br/>other. Let’s examine how the lifetime annotations relate to each other in the context of the<br/>
longest&#160;&#160;function.<br/>
https://doc.rust-lang.org/book/print.html<br/>
248/627<br/>
<hr/>
<a name=249></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#249"><b>Lifetime&#160;Annotations&#160;in&#160;Function&#160;Signatures</b></a><br/>
To use lifetime annotations in function signatures, we need to declare the generic&#160;<i>lifetime<br/></i>parameters inside angle brackets between the function name and the parameter list, just as<br/>we did with generic&#160;<i>type</i>&#160;parameters.<br/>
We want the signature to express the following constraint: the returned reference will be<br/>valid as long as both the parameters are valid. This is the relationship between lifetimes of<br/>the parameters and the return value. We’ll name the lifetime&#160;&#160;'a&#160;&#160;and then add it to each<br/>reference, as shown in Listing 10-21.<br/>
Filename: src/main.rs<br/>
fn&#160;longest&lt;'a&gt;(x:&#160;&amp;'a&#160;str,&#160;y:&#160;&amp;'a&#160;str)&#160;-&gt;&#160;&amp;'a&#160;str&#160;{<br/>&#160;&#160;&#160;&#160;if&#160;x.len()&#160;&gt;&#160;y.len()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;y<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;10-21:&#160;The&#160;&#160;</b>longest&#160;<b>&#160;function&#160;deﬁnition&#160;specifying&#160;that&#160;all&#160;the&#160;references&#160;in&#160;the&#160;signature&#160;must&#160;have&#160;the<br/>same&#160;lifetime&#160;&#160;</b>'a<br/>
This code should compile and produce the result we want when we use it with the&#160;&#160;main<br/>function in Listing 10-19.<br/>
The function signature now tells Rust that for some lifetime&#160;&#160;'a&#160;, the function takes two<br/>parameters, both of which are string slices that live at least as long as lifetime&#160;&#160;'a&#160;. The<br/>function signature also tells Rust that the string slice returned from the function will live at<br/>least as long as lifetime&#160;&#160;'a&#160;. In practice, it means that the lifetime of the reference returned<br/>by the&#160;&#160;longest&#160;&#160;function is the same as the smaller of the lifetimes of the values referred to<br/>by the function arguments. These relationships are what we want Rust to use when<br/>analyzing this code.<br/>
Remember, when we specify the lifetime parameters in this function signature, we’re not<br/>changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the<br/>borrow checker should reject any values that don’t adhere to these constraints. Note that<br/>the&#160;&#160;longest&#160;&#160;function doesn’t need to know exactly how long&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;&#160;will live, only that<br/>some scope can be substituted for&#160;&#160;'a&#160;&#160;that will satisfy this signature.<br/>
When annotating lifetimes in functions, the annotations go in the function signature, not in<br/>the function body. The lifetime annotations become part of the contract of the function,<br/>much like the types in the signature. Having function signatures contain the lifetime<br/>contract means the analysis the Rust compiler does can be simpler. If there’s a problem with<br/>the way a function is annotated or the way it is called, the compiler errors can point to the<br/>part of our code and the constraints more precisely. If, instead, the Rust compiler made<br/>
https://doc.rust-lang.org/book/print.html<br/>
249/627<br/>
<hr/>
<a name=250></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
more inferences about what we intended the relationships of the lifetimes to be, the<br/>compiler might only be able to point to a use of our code many steps away from the cause<br/>of the problem.<br/>
When we pass concrete references to&#160;&#160;longest&#160;, the concrete lifetime that is substituted for<br/>
'a&#160;&#160;is the part of the scope of&#160;&#160;x&#160;&#160;that overlaps with the scope of&#160;&#160;y&#160;. In other words, the<br/>
generic lifetime&#160;&#160;'a&#160;&#160;will get the concrete lifetime that is equal to the smaller of the lifetimes<br/>of&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;. Because we’ve annotated the returned reference with the same lifetime<br/>parameter&#160;&#160;'a&#160;, the returned reference will also be valid for the length of the smaller of the<br/>lifetimes of&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;.<br/>
Let’s look at how the lifetime annotations restrict the&#160;&#160;longest&#160;&#160;function by passing in<br/>references that have diﬀerent concrete lifetimes. Listing 10-22 is a straightforward example.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;string1&#160;=&#160;String::from(&#34;long&#160;string&#160;is&#160;long&#34;);<br/>
&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;string2&#160;=&#160;String::from(&#34;xyz&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;longest(string1.as_str(),&#160;string2.as_str());<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;The&#160;longest&#160;string&#160;is&#160;{}&#34;,&#160;result);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;10-22:&#160;Using&#160;the&#160;&#160;</b>longest&#160;<b>&#160;function&#160;with&#160;references&#160;to&#160;&#160;</b>String&#160;<b>&#160;values&#160;that&#160;have&#160;diﬀerent&#160;concrete<br/>lifetimes</b><br/>
In this example,&#160;&#160;string1&#160;&#160;is valid until the end of the outer scope,&#160;&#160;string2&#160;&#160;is valid until the<br/>end of the inner scope, and&#160;&#160;result&#160;&#160;references something that is valid until the end of the<br/>inner scope. Run this code, and you’ll see that the borrow checker approves; it will compile<br/>and print&#160;&#160;The&#160;longest&#160;string&#160;is&#160;long&#160;string&#160;is&#160;long&#160;.<br/>
Next, let’s try an example that shows that the lifetime of the reference in&#160;&#160;result&#160;&#160;must be<br/>the smaller lifetime of the two arguments. We’ll move the declaration of the&#160;&#160;result<br/>variable outside the inner scope but leave the assignment of the value to the&#160;&#160;result<br/>variable inside the scope with&#160;&#160;string2&#160;. Then we’ll move the&#160;&#160;println!&#160;&#160;that uses&#160;&#160;result&#160;&#160;to<br/>outside the inner scope, after the inner scope has ended. The code in Listing 10-23 will not<br/>compile.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
250/627<br/>
<hr/>
<a name=251></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;string1&#160;=&#160;String::from(&#34;long&#160;string&#160;is&#160;long&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;result;<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;string2&#160;=&#160;String::from(&#34;xyz&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result&#160;=&#160;longest(string1.as_str(),&#160;string2.as_str());<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;println!(&#34;The&#160;longest&#160;string&#160;is&#160;{}&#34;,&#160;result);<br/>}<br/>
<b>Listing&#160;10-23:&#160;Attempting&#160;to&#160;use&#160;&#160;</b>result&#160;<b>&#160;after&#160;&#160;</b>string2&#160;<b>&#160;has&#160;gone&#160;out&#160;of&#160;scope</b><br/>
When we try to compile this code, we get this error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;chapter10&#160;v0.1.0&#160;(file:///projects/chapter10)<br/>error[E0597]:&#160;`string2`&#160;does&#160;not&#160;live&#160;long&#160;enough<br/>&#160;--&gt;&#160;src/main.rs:6:44<br/>&#160;&#160;|<br/>6&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result&#160;=&#160;longest(string1.as_str(),&#160;string2.as_str());<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^&#160;borrowed&#160;value&#160;<br/>does&#160;not&#160;live&#160;long&#160;enough<br/>7&#160;|&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;-&#160;`string2`&#160;dropped&#160;here&#160;while&#160;still&#160;borrowed<br/>8&#160;|&#160;&#160;&#160;&#160;&#160;println!(&#34;The&#160;longest&#160;string&#160;is&#160;{}&#34;,&#160;result);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;------&#160;borrow&#160;later&#160;used&#160;here<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0597`.<br/>error:&#160;could&#160;not&#160;compile&#160;`chapter10`&#160;due&#160;to&#160;previous&#160;error<br/>
The error shows that for&#160;&#160;result&#160;&#160;to be valid for the&#160;&#160;println!&#160;&#160;statement,&#160;&#160;string2&#160;&#160;would<br/>need to be valid until the end of the outer scope. Rust knows this because we annotated the<br/>lifetimes of the function parameters and return values using the same lifetime parameter<br/>
'a&#160;.<br/>
As humans, we can look at this code and see that&#160;&#160;string1&#160;&#160;is longer than&#160;&#160;string2&#160;&#160;and<br/>therefore&#160;&#160;result&#160;&#160;will contain a reference to&#160;&#160;string1&#160;. Because&#160;&#160;string1&#160;&#160;has not gone out<br/>of scope yet, a reference to&#160;&#160;string1&#160;&#160;will still be valid for the&#160;&#160;println!&#160;&#160;statement. However,<br/>the compiler can’t see that the reference is valid in this case. We’ve told Rust that the<br/>lifetime of the reference returned by the&#160;&#160;longest&#160;&#160;function is the same as the smaller of the<br/>lifetimes of the references passed in. Therefore, the borrow checker disallows the code in<br/>Listing 10-23 as possibly having an invalid reference.<br/>
Try designing more experiments that vary the values and lifetimes of the references passed<br/>in to the&#160;&#160;longest&#160;&#160;function and how the returned reference is used. Make hypotheses about<br/>whether or not your experiments will pass the borrow checker before you compile; then<br/>check to see if you’re right!<br/>
https://doc.rust-lang.org/book/print.html<br/>
251/627<br/>
<hr/>
<a name=252></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#252"><b>Thinking&#160;in&#160;Terms&#160;of&#160;Lifetimes</b></a><br/>
The way in which you need to specify lifetime parameters depends on what your function is<br/>doing. For example, if we changed the implementation of the&#160;&#160;longest&#160;&#160;function to always<br/>return the&#160;ﬁrst parameter rather than the longest string slice, we wouldn’t need to specify a<br/>lifetime on the&#160;&#160;y&#160;&#160;parameter. The following code will compile:<br/>
Filename: src/main.rs<br/>
fn&#160;longest&lt;'a&gt;(x:&#160;&amp;'a&#160;str,&#160;y:&#160;&amp;str)&#160;-&gt;&#160;&amp;'a&#160;str&#160;{<br/>&#160;&#160;&#160;&#160;x<br/>}<br/>
We’ve speciﬁed a lifetime parameter&#160;&#160;'a&#160;&#160;for the parameter&#160;&#160;x&#160;&#160;and the return type, but not<br/>for the parameter&#160;&#160;y&#160;, because the lifetime of&#160;&#160;y&#160;&#160;does not have any relationship with the<br/>lifetime of&#160;&#160;x&#160;&#160;or the return value.<br/>
When returning a reference from a function, the lifetime parameter for the return type<br/>needs to match the lifetime parameter for one of the parameters. If the reference returned<br/>does&#160;<i>not</i>&#160;refer to one of the parameters, it must refer to a value created within this function.<br/>However, this would be a dangling reference because the value will go out of scope at the<br/>end of the function. Consider this attempted implementation of the&#160;&#160;longest&#160;&#160;function that<br/>won’t compile:<br/>
Filename: src/main.rs<br/>
fn&#160;longest&lt;'a&gt;(x:&#160;&amp;str,&#160;y:&#160;&amp;str)&#160;-&gt;&#160;&amp;'a&#160;str&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;String::from(&#34;really&#160;long&#160;string&#34;);<br/>&#160;&#160;&#160;&#160;result.as_str()<br/>}<br/>
Here, even though we’ve speciﬁed a lifetime parameter&#160;&#160;'a&#160;&#160;for the return type, this<br/>implementation will fail to compile because the return value lifetime is not related to the<br/>lifetime of the parameters at all. Here is the error message we get:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;chapter10&#160;v0.1.0&#160;(file:///projects/chapter10)<br/>error[E0515]:&#160;cannot&#160;return&#160;reference&#160;to&#160;local&#160;variable&#160;`result`<br/>&#160;&#160;--&gt;&#160;src/main.rs:11:5<br/>&#160;&#160;&#160;|<br/>11&#160;|&#160;&#160;&#160;&#160;&#160;result.as_str()<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^&#160;returns&#160;a&#160;reference&#160;to&#160;data&#160;owned&#160;by&#160;the&#160;current&#160;<br/>function<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0515`.<br/>error:&#160;could&#160;not&#160;compile&#160;`chapter10`&#160;due&#160;to&#160;previous&#160;error<br/>
The problem is that&#160;&#160;result&#160;&#160;goes out of scope and gets cleaned up at the end of the<br/>
longest&#160;&#160;function. We’re also trying to return a reference to&#160;&#160;result&#160;&#160;from the function.<br/>
https://doc.rust-lang.org/book/print.html<br/>
252/627<br/>
<hr/>
<a name=253></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
There is no way we can specify lifetime parameters that would change the dangling<br/>reference, and Rust won’t let us create a dangling reference. In this case, the best&#160;ﬁx would<br/>be to return an owned data type rather than a reference so the calling function is then<br/>responsible for cleaning up the value.<br/>
Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and<br/>return values of functions. Once they’re connected, Rust has enough information to allow<br/>memory-safe operations and disallow operations that would create dangling pointers or<br/>otherwise violate memory safety.<br/>
<a href="tests.html#253"><b>Lifetime&#160;Annotations&#160;in&#160;Struct&#160;Deﬁnitions</b></a><br/>
So far, the structs we’ve deﬁned all hold owned types. We can deﬁne structs to hold<br/>references, but in that case we would need to add a lifetime annotation on every reference<br/>in the struct’s deﬁnition. Listing 10-24 has a struct named&#160;&#160;ImportantExcerpt&#160;&#160;that holds a<br/>string slice.<br/>
Filename: src/main.rs<br/>
struct&#160;ImportantExcerpt&lt;'a&gt;&#160;{<br/>&#160;&#160;&#160;&#160;part:&#160;&amp;'a&#160;str,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;novel&#160;=&#160;String::from(&#34;Call&#160;me&#160;Ishmael.&#160;Some&#160;years&#160;ago...&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;first_sentence&#160;=&#160;novel.split('.').next().expect(&#34;Could&#160;not&#160;find&#160;a&#160;<br/>'.'&#34;);<br/>&#160;&#160;&#160;&#160;let&#160;i&#160;=&#160;ImportantExcerpt&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;part:&#160;first_sentence,<br/>&#160;&#160;&#160;&#160;};<br/>}<br/>
<b>Listing&#160;10-24:&#160;A&#160;struct&#160;that&#160;holds&#160;a&#160;reference,&#160;requiring&#160;a&#160;lifetime&#160;annotation</b><br/>
This struct has the single&#160;ﬁeld&#160;&#160;part&#160;&#160;that holds a string slice, which is a reference. As with<br/>generic data types, we declare the name of the generic lifetime parameter inside angle<br/>brackets after the name of the struct so we can use the lifetime parameter in the body of<br/>the struct deﬁnition. This annotation means an instance of&#160;&#160;ImportantExcerpt&#160;&#160;can’t outlive<br/>the reference it holds in its&#160;&#160;part&#160;&#160;ﬁeld.<br/>
The&#160;&#160;main&#160;&#160;function here creates an instance of the&#160;&#160;ImportantExcerpt&#160;&#160;struct that holds a<br/>reference to the&#160;ﬁrst sentence of the&#160;&#160;String&#160;&#160;owned by the variable&#160;&#160;novel&#160;. The data in<br/>
novel&#160;&#160;exists before the&#160;&#160;ImportantExcerpt&#160;&#160;instance is created. In addition,&#160;&#160;novel&#160;&#160;doesn’t<br/>
go out of scope until after the&#160;&#160;ImportantExcerpt&#160;&#160;goes out of scope, so the reference in the<br/>
ImportantExcerpt&#160;&#160;instance is valid.<br/>
https://doc.rust-lang.org/book/print.html<br/>
253/627<br/>
<hr/>
<a name=254></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#254"><b>Lifetime&#160;Elision</b></a><br/>
You’ve learned that every reference has a lifetime and that you need to specify lifetime<br/>parameters for functions or structs that use references. However, in Chapter 4 we had a<br/>function in Listing 4-9, shown again in Listing 10-25, that compiled without lifetime<br/>annotations.<br/>
Filename: src/lib.rs<br/>
fn&#160;first_word(s:&#160;&amp;str)&#160;-&gt;&#160;&amp;str&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;bytes&#160;=&#160;s.as_bytes();<br/>
&#160;&#160;&#160;&#160;for&#160;(i,&#160;&amp;item)&#160;in&#160;bytes.iter().enumerate()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;item&#160;==&#160;b'&#160;'&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;&amp;s[0..i];<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&amp;s[..]<br/>}<br/>
<b>Listing&#160;10-25:&#160;A&#160;function&#160;we&#160;deﬁned&#160;in&#160;Listing&#160;4-9&#160;that&#160;compiled&#160;without&#160;lifetime&#160;annotations,&#160;even&#160;though&#160;the<br/>parameter&#160;and&#160;return&#160;type&#160;are&#160;references</b><br/>
The reason this function compiles without lifetime annotations is historical: in early versions<br/>(pre-1.0) of Rust, this code wouldn’t have compiled because every reference needed an<br/>explicit lifetime. At that time, the function signature would have been written like this:<br/>
fn&#160;first_word&lt;'a&gt;(s:&#160;&amp;'a&#160;str)&#160;-&gt;&#160;&amp;'a&#160;str&#160;{<br/>
After writing a lot of Rust code, the Rust team found that Rust programmers were entering<br/>the same lifetime annotations over and over in particular situations. These situations were<br/>predictable and followed a few deterministic patterns. The developers programmed these<br/>patterns into the compiler’s code so the borrow checker could infer the lifetimes in these<br/>situations and wouldn’t need explicit annotations.<br/>
This piece of Rust history is relevant because it’s possible that more deterministic patterns<br/>will emerge and be added to the compiler. In the future, even fewer lifetime annotations<br/>might be required.<br/>
The patterns programmed into Rust’s analysis of references are called the&#160;<i>lifetime elision<br/>rules</i>. These aren’t rules for programmers to follow; they’re a set of particular cases that the<br/>compiler will consider, and if your code&#160;ﬁts these cases, you don’t need to write the lifetimes<br/>explicitly.<br/>
The elision rules don’t provide full inference. If Rust deterministically applies the rules but<br/>there is still ambiguity as to what lifetimes the references have, the compiler won’t guess<br/>
https://doc.rust-lang.org/book/print.html<br/>
254/627<br/>
<hr/>
<a name=255></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
what the lifetime of the remaining references should be. Instead of guessing, the compiler<br/>will give you an error that you can resolve by adding the lifetime annotations.<br/>
Lifetimes on function or method parameters are called&#160;<i>input lifetimes</i>, and lifetimes on<br/>return values are called&#160;<i>output lifetimes</i>.<br/>
The compiler uses three rules to&#160;ﬁgure out the lifetimes of the references when there aren’t<br/>explicit annotations. The&#160;ﬁrst rule applies to input lifetimes, and the second and third rules<br/>apply to output lifetimes. If the compiler gets to the end of the three rules and there are still<br/>references for which it can’t&#160;ﬁgure out lifetimes, the compiler will stop with an error. These<br/>rules apply to&#160;&#160;fn&#160;&#160;deﬁnitions as well as&#160;&#160;impl&#160;&#160;blocks.<br/>
The&#160;ﬁrst rule is that the compiler assigns a lifetime parameter to each parameter that’s a<br/>reference. In other words, a function with one parameter gets one lifetime parameter:&#160;&#160;fn&#160;<br/>foo&lt;'a&gt;(x:&#160;&amp;'a&#160;i32)&#160;; a function with two parameters gets two separate lifetime<br/>parameters:&#160;&#160;fn&#160;foo&lt;'a,&#160;'b&gt;(x:&#160;&amp;'a&#160;i32,&#160;y:&#160;&amp;'b&#160;i32)&#160;; and so on.<br/>
The second rule is that, if there is exactly one input lifetime parameter, that lifetime is<br/>assigned to all output lifetime parameters:&#160;&#160;fn&#160;foo&lt;'a&gt;(x:&#160;&amp;'a&#160;i32)&#160;-&gt;&#160;&amp;'a&#160;i32&#160;.<br/>
The third rule is that, if there are multiple input lifetime parameters, but one of them is<br/>
&amp;self&#160;&#160;or&#160;&#160;&amp;mut&#160;self&#160;&#160;because this is a method, the lifetime of&#160;&#160;self&#160;&#160;is assigned to all output<br/>
lifetime parameters. This third rule makes methods much nicer to read and write because<br/>fewer symbols are necessary.<br/>
Let’s pretend we’re the compiler. We’ll apply these rules to&#160;ﬁgure out the lifetimes of the<br/>references in the signature of the&#160;&#160;first_word&#160;&#160;function in Listing 10-25. The signature starts<br/>without any lifetimes associated with the references:<br/>
fn&#160;first_word(s:&#160;&amp;str)&#160;-&gt;&#160;&amp;str&#160;{<br/>
Then the compiler applies the&#160;ﬁrst rule, which speciﬁes that each parameter gets its own<br/>lifetime. We’ll call it&#160;&#160;'a&#160;&#160;as usual, so now the signature is this:<br/>
fn&#160;first_word&lt;'a&gt;(s:&#160;&amp;'a&#160;str)&#160;-&gt;&#160;&amp;str&#160;{<br/>
The second rule applies because there is exactly one input lifetime. The second rule<br/>speciﬁes that the lifetime of the one input parameter gets assigned to the output lifetime,<br/>so the signature is now this:<br/>
fn&#160;first_word&lt;'a&gt;(s:&#160;&amp;'a&#160;str)&#160;-&gt;&#160;&amp;'a&#160;str&#160;{<br/>
Now all the references in this function signature have lifetimes, and the compiler can<br/>continue its analysis without needing the programmer to annotate the lifetimes in this<br/>function signature.<br/>
https://doc.rust-lang.org/book/print.html<br/>
255/627<br/>
<hr/>
<a name=256></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Let’s look at another example, this time using the&#160;&#160;longest&#160;&#160;function that had no lifetime<br/>parameters when we started working with it in Listing 10-20:<br/>
fn&#160;longest(x:&#160;&amp;str,&#160;y:&#160;&amp;str)&#160;-&gt;&#160;&amp;str&#160;{<br/>
Let’s apply the&#160;ﬁrst rule: each parameter gets its own lifetime. This time we have two<br/>parameters instead of one, so we have two lifetimes:<br/>
fn&#160;longest&lt;'a,&#160;'b&gt;(x:&#160;&amp;'a&#160;str,&#160;y:&#160;&amp;'b&#160;str)&#160;-&gt;&#160;&amp;str&#160;{<br/>
You can see that the second rule doesn’t apply because there is more than one input<br/>lifetime. The third rule doesn’t apply either, because&#160;&#160;longest&#160;&#160;is a function rather than a<br/>method, so none of the parameters are&#160;&#160;self&#160;. After working through all three rules, we still<br/>haven’t&#160;ﬁgured out what the return type’s lifetime is. This is why we got an error trying to<br/>compile the code in Listing 10-20: the compiler worked through the lifetime elision rules but<br/>still couldn’t&#160;ﬁgure out all the lifetimes of the references in the signature.<br/>
Because the third rule really only applies in method signatures, we’ll look at lifetimes in that<br/>context next to see why the third rule means we don’t have to annotate lifetimes in method<br/>signatures very often.<br/>
<a href="tests.html#256"><b>Lifetime&#160;Annotations&#160;in&#160;Method&#160;Deﬁnitions</b></a><br/>
When we implement methods on a struct with lifetimes, we use the same syntax as that of<br/>generic type parameters shown in Listing 10-11. Where we declare and use the lifetime<br/>parameters depends on whether they’re related to the struct&#160;ﬁelds or the method<br/>parameters and return values.<br/>
Lifetime names for struct&#160;ﬁelds always need to be declared after the&#160;&#160;impl&#160;&#160;keyword and<br/>then used after the struct’s name, because those lifetimes are part of the struct’s type.<br/>
In method signatures inside the&#160;&#160;impl&#160;&#160;block, references might be tied to the lifetime of<br/>references in the struct’s&#160;ﬁelds, or they might be independent. In addition, the lifetime<br/>elision rules often make it so that lifetime annotations aren’t necessary in method<br/>signatures. Let’s look at some examples using the struct named&#160;&#160;ImportantExcerpt&#160;&#160;that we<br/>deﬁned in Listing 10-24.<br/>
First, we’ll use a method named&#160;&#160;level&#160;&#160;whose only parameter is a reference to&#160;&#160;self&#160;&#160;and<br/>whose return value is an&#160;&#160;i32&#160;, which is not a reference to anything:<br/>
https://doc.rust-lang.org/book/print.html<br/>
256/627<br/>
<hr/>
<a name=257></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
impl&lt;'a&gt;&#160;ImportantExcerpt&lt;'a&gt;&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;level(&amp;self)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
The lifetime parameter declaration after&#160;&#160;impl&#160;&#160;and its use after the type name are required,<br/>but we’re not required to annotate the lifetime of the reference to&#160;&#160;self&#160;&#160;because of the&#160;ﬁrst<br/>elision rule.<br/>
Here is an example where the third lifetime elision rule applies:<br/>
impl&lt;'a&gt;&#160;ImportantExcerpt&lt;'a&gt;&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;announce_and_return_part(&amp;self,&#160;announcement:&#160;&amp;str)&#160;-&gt;&#160;&amp;str&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Attention&#160;please:&#160;{}&#34;,&#160;announcement);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.part<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
There are two input lifetimes, so Rust applies the&#160;ﬁrst lifetime elision rule and gives both<br/>
&amp;self&#160;&#160;and&#160;&#160;announcement&#160;&#160;their own lifetimes. Then, because one of the parameters is<br/>&amp;self&#160;, the return type gets the lifetime of&#160;&#160;&amp;self&#160;, and all lifetimes have been accounted<br/>
for.<br/>
<a href="tests.html#257"><b>The&#160;Static&#160;Lifetime</b></a><br/>
One special lifetime we need to discuss is&#160;&#160;'static&#160;, which denotes that the aﬀected<br/>reference&#160;<i>can</i>&#160;live for the entire duration of the program. All string literals have the&#160;&#160;'static<br/>lifetime, which we can annotate as follows:<br/>
let&#160;s:&#160;&amp;'static&#160;str&#160;=&#160;&#34;I&#160;have&#160;a&#160;static&#160;lifetime.&#34;;<br/>
The text of this string is stored directly in the program’s binary, which is always available.<br/>Therefore, the lifetime of all string literals is&#160;&#160;'static&#160;.<br/>
You might see suggestions to use the&#160;&#160;'static&#160;&#160;lifetime in error messages. But before<br/>specifying&#160;&#160;'static&#160;&#160;as the lifetime for a reference, think about whether the reference you<br/>have actually lives the entire lifetime of your program or not, and whether you want it to.<br/>Most of the time, an error message suggesting the&#160;&#160;'static&#160;&#160;lifetime results from<br/>attempting to create a dangling reference or a mismatch of the available lifetimes. In such<br/>cases, the solution is&#160;ﬁxing those problems, not specifying the&#160;&#160;'static&#160;&#160;lifetime.<br/>
https://doc.rust-lang.org/book/print.html<br/>
257/627<br/>
<hr/>
<a name=258></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#258"><b>Generic Type Parameters, Trait Bounds, and Lifetimes<br/>Together</b></a><br/>
Let’s brieﬂy look at the syntax of specifying generic type parameters, trait bounds, and<br/>lifetimes all in one function!<br/>
use&#160;std::fmt::Display;<br/>
fn&#160;longest_with_an_announcement&lt;'a,&#160;T&gt;(<br/>&#160;&#160;&#160;&#160;x:&#160;&amp;'a&#160;str,<br/>&#160;&#160;&#160;&#160;y:&#160;&amp;'a&#160;str,<br/>&#160;&#160;&#160;&#160;ann:&#160;T,<br/>)&#160;-&gt;&#160;&amp;'a&#160;str<br/>where<br/>&#160;&#160;&#160;&#160;T:&#160;Display,<br/>{<br/>&#160;&#160;&#160;&#160;println!(&#34;Announcement!&#160;{}&#34;,&#160;ann);<br/>&#160;&#160;&#160;&#160;if&#160;x.len()&#160;&gt;&#160;y.len()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;y<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
This is the&#160;&#160;longest&#160;&#160;function from Listing 10-21 that returns the longer of two string slices.<br/>But now it has an extra parameter named&#160;&#160;ann&#160;&#160;of the generic type&#160;&#160;T&#160;, which can be&#160;ﬁlled in<br/>by any type that implements the&#160;&#160;Display&#160;&#160;trait as speciﬁed by the&#160;&#160;where&#160;&#160;clause. This extra<br/>parameter will be printed using&#160;&#160;{}&#160;, which is why the&#160;&#160;Display&#160;&#160;trait bound is necessary.<br/>Because lifetimes are a type of generic, the declarations of the lifetime parameter&#160;&#160;'a&#160;&#160;and<br/>the generic type parameter&#160;&#160;T&#160;&#160;go in the same list inside the angle brackets after the<br/>function name.<br/>
<a href="tests.html#258"><b>Summary</b></a><br/>
We covered a lot in this chapter! Now that you know about generic type parameters, traits<br/>and trait bounds, and generic lifetime parameters, you’re ready to write code without<br/>repetition that works in many diﬀerent situations. Generic type parameters let you apply<br/>the code to diﬀerent types. Traits and trait bounds ensure that even though the types are<br/>generic, they’ll have the behavior the code needs. You learned how to use lifetime<br/>annotations to ensure that this&#160;ﬂexible code won’t have any dangling references. And all of<br/>this analysis happens at compile time, which doesn’t aﬀect runtime performance!<br/>
Believe it or not, there is much more to learn on the topics we discussed in this chapter:<br/>Chapter 17 discusses trait objects, which are another way to use traits. There are also more<br/>complex scenarios involving lifetime annotations that you will only need in very advanced<br/>
https://doc.rust-lang.org/book/print.html<br/>
258/627<br/>
<hr/>
<a name=259></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="https://doc.rust-lang.org/reference/index.html">scenarios; for those, you should read the&#160;Rust Reference. But next, you’ll learn how to write<br/></a>tests in Rust so you can make sure your code is working the way it should.<br/>
https://doc.rust-lang.org/book/print.html<br/>
259/627<br/>
<hr/>
<a name=260></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#260"><b>Writing Automated Tests</b></a><br/>
In his 1972 essay “The Humble Programmer,” Edsger W. Dijkstra said that “Program testing<br/>can be a very eﬀective way to show the presence of bugs, but it is hopelessly inadequate for<br/>showing their absence.” That doesn’t mean we shouldn’t try to test as much as we can!<br/>
Correctness in our programs is the extent to which our code does what we intend it to do.<br/>Rust is designed with a high degree of concern about the correctness of programs, but<br/>correctness is complex and not easy to prove. Rust’s type system shoulders a huge part of<br/>this burden, but the type system cannot catch everything. As such, Rust includes support for<br/>writing automated software tests.<br/>
Say we write a function&#160;&#160;add_two&#160;&#160;that adds 2 to whatever number is passed to it. This<br/>function’s signature accepts an integer as a parameter and returns an integer as a result.<br/>When we implement and compile that function, Rust does all the type checking and borrow<br/>checking that you’ve learned so far to ensure that, for instance, we aren’t passing a&#160;&#160;String<br/>value or an invalid reference to this function. But Rust&#160;<i>can’t</i>&#160;check that this function will do<br/>precisely what we intend, which is return the parameter plus 2 rather than, say, the<br/>parameter plus 10 or the parameter minus 50! That’s where tests come in.<br/>
We can write tests that assert, for example, that when we pass&#160;&#160;3&#160;&#160;to the&#160;&#160;add_two&#160;&#160;function,<br/>the returned value is&#160;&#160;5&#160;. We can run these tests whenever we make changes to our code to<br/>make sure any existing correct behavior has not changed.<br/>
Testing is a complex skill: although we can’t cover every detail about how to write good tests<br/>in one chapter, we’ll discuss the mechanics of Rust’s testing facilities. We’ll talk about the<br/>annotations and macros available to you when writing your tests, the default behavior and<br/>options provided for running your tests, and how to organize tests into unit tests and<br/>integration tests.<br/>
https://doc.rust-lang.org/book/print.html<br/>
260/627<br/>
<hr/>
<a name=261></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#261"><b>How to Write Tests</b></a><br/>
Tests are Rust functions that verify that the non-test code is functioning in the expected<br/>manner. The bodies of test functions typically perform these three actions:<br/>
1.&#160;Set up any needed data or state.<br/>2.&#160;Run the code you want to test.<br/>3.&#160;Assert the results are what you expect.<br/>
Let’s look at the features Rust provides speciﬁcally for writing tests that take these actions,<br/>which include the&#160;&#160;test&#160;&#160;attribute, a few macros, and the&#160;&#160;should_panic&#160;&#160;attribute.<br/>
<a href="tests.html#261"><b>The&#160;Anatomy&#160;of&#160;a&#160;Test&#160;Function</b></a><br/>
At its simplest, a test in Rust is a function that’s annotated with the&#160;&#160;test&#160;&#160;attribute.<br/>Attributes are metadata about pieces of Rust code; one example is the&#160;&#160;derive&#160;&#160;attribute we<br/>used with structs in Chapter 5. To change a function into a test function, add&#160;&#160;#[test]&#160;&#160;on<br/>the line before&#160;&#160;fn&#160;. When you run your tests with the&#160;&#160;cargo&#160;test&#160;&#160;command, Rust builds a<br/>test runner binary that runs the annotated functions and reports on whether each test<br/>function passes or fails.<br/>
Whenever we make a new library project with Cargo, a test module with a test function in it<br/>is automatically generated for us. This module gives you a template for writing your tests so<br/>you don’t have to look up the exact structure and syntax every time you start a new project.<br/>You can add as many additional test functions and as many test modules as you want!<br/>
We’ll explore some aspects of how tests work by experimenting with the template test<br/>before we actually test any code. Then we’ll write some real-world tests that call some code<br/>that we’ve written and assert that its behavior is correct.<br/>
Let’s create a new library project called&#160;&#160;adder&#160;&#160;that will add two numbers:<br/>
$&#160;cargo&#160;new&#160;adder&#160;--lib<br/>&#160;&#160;&#160;&#160;&#160;Created&#160;library&#160;`adder`&#160;project<br/>$&#160;cd&#160;adder<br/>
The contents of the&#160;<i>src/lib.rs</i>&#160;ﬁle in your&#160;&#160;adder&#160;&#160;library should look like Listing 11-1.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
261/627<br/>
<hr/>
<a name=262></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;it_works()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;2&#160;+&#160;2;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(result,&#160;4);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;11-1:&#160;The&#160;test&#160;module&#160;and&#160;function&#160;generated&#160;automatically&#160;by&#160;&#160;</b>cargo&#160;new<br/>
For now, let’s ignore the top two lines and focus on the function. Note the&#160;&#160;#[test]<br/>annotation: this attribute indicates this is a test function, so the test runner knows to treat<br/>this function as a test. We might also have non-test functions in the&#160;&#160;tests&#160;&#160;module to help<br/>set up common scenarios or perform common operations, so we always need to indicate<br/>which functions are tests.<br/>
The example function body uses the&#160;&#160;assert_eq!&#160;&#160;macro to assert that&#160;&#160;result&#160;, which<br/>contains the result of adding 2 and 2, equals 4. This assertion serves as an example of the<br/>format for a typical test. Let’s run it to see that this test passes.<br/>
The&#160;&#160;cargo&#160;test&#160;&#160;command runs all tests in our project, as shown in Listing 11-2.<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.57s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/adder-92948b65e88960b4)<br/>
running&#160;1&#160;test<br/>test&#160;tests::it_works&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;adder<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
<b>Listing&#160;11-2:&#160;The&#160;output&#160;from&#160;running&#160;the&#160;automatically&#160;generated&#160;test</b><br/>
Cargo compiled and ran the test. We see the line&#160;&#160;running&#160;1&#160;test&#160;. The next line shows the<br/>name of the generated test function, called&#160;&#160;it_works&#160;, and that the result of running that<br/>test is&#160;&#160;ok&#160;. The overall summary&#160;&#160;test&#160;result:&#160;ok.&#160;&#160;means that all the tests passed, and the<br/>portion that reads&#160;&#160;1&#160;passed;&#160;0&#160;failed&#160;&#160;totals the number of tests that passed or failed.<br/>
It’s possible to mark a test as ignored so it doesn’t run in a particular instance; we’ll cover<br/>that in the&#160;<a href="https://doc.rust-lang.org/book/ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested">“Ignoring Some Tests Unless Speciﬁcally Requested”</a>&#160;section later in this chapter.<br/>
https://doc.rust-lang.org/book/print.html<br/>
262/627<br/>
<hr/>
<a name=263></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Because we haven’t done that here, the summary shows&#160;&#160;0&#160;ignored&#160;. We can also pass an<br/>argument to the&#160;&#160;cargo&#160;test&#160;&#160;command to run only tests whose name matches a string; this<br/>is called&#160;<i>ﬁltering</i><a href="https://doc.rust-lang.org/book/ch11-02-running-tests.html#running-a-subset-of-tests-by-name">&#160;and we’ll cover that in the&#160;“Running a Subset of Tests by Name”</a>&#160;section. We<br/>also haven’t&#160;ﬁltered the tests being run, so the end of the summary shows&#160;&#160;0&#160;filtered&#160;out&#160;.<br/>
The&#160;&#160;0&#160;measured&#160;&#160;statistic is for benchmark tests that measure performance. Benchmark<br/><a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">tests are, as of this writing, only available in nightly Rust. See&#160;the documentation about<br/>benchmark tests&#160;to learn more.</a><br/>
The next part of the test output starting at&#160;&#160;Doc-tests&#160;adder&#160;&#160;is for the results of any<br/>documentation tests. We don’t have any documentation tests yet, but Rust can compile any<br/>code examples that appear in our API documentation. This feature helps keep your docs<br/>and your code in sync! We’ll discuss how to write documentation tests in the<br/><a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“Documentation Comments as Tests”&#160;section of Chapter 14. For now, we’ll ignore the&#160;&#160;</a>Doc-<br/>tests&#160;&#160;output.<br/>
Let’s start to customize the test to our own needs. First change the name of the&#160;&#160;it_works<br/>function to a diﬀerent name, such as&#160;&#160;exploration&#160;, like so:<br/>
Filename: src/lib.rs<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;exploration()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(2&#160;+&#160;2,&#160;4);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
Then run&#160;&#160;cargo&#160;test&#160;&#160;again. The output now shows&#160;&#160;exploration&#160;&#160;instead of&#160;&#160;it_works&#160;:<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.59s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/adder-92948b65e88960b4)<br/>
running&#160;1&#160;test<br/>test&#160;tests::exploration&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;adder<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
https://doc.rust-lang.org/book/print.html<br/>
263/627<br/>
<hr/>
<a name=264></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Now we’ll add another test, but this time we’ll make a test that fails! Tests fail when<br/>something in the test function panics. Each test is run in a new thread, and when the main<br/>thread sees that a test thread has died, the test is marked as failed. In Chapter 9, we talked<br/>about how the simplest way to panic is to call the&#160;&#160;panic!&#160;&#160;macro. Enter the new test as a<br/>function named&#160;&#160;another&#160;, so your&#160;<i>src/lib.rs</i>&#160;ﬁle looks like Listing 11-3.<br/>
Filename: src/lib.rs<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;exploration()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(2&#160;+&#160;2,&#160;4);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;another()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic!(&#34;Make&#160;this&#160;test&#160;fail&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;11-3:&#160;Adding&#160;a&#160;second&#160;test&#160;that&#160;will&#160;fail&#160;because&#160;we&#160;call&#160;the&#160;&#160;</b>panic!&#160;<b>&#160;macro</b><br/>
Run the tests again using&#160;&#160;cargo&#160;test&#160;. The output should look like Listing 11-4, which shows<br/>that our&#160;&#160;exploration&#160;&#160;test passed and&#160;&#160;another&#160;&#160;failed.<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.72s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/adder-92948b65e88960b4)<br/>
running&#160;2&#160;tests<br/>test&#160;tests::another&#160;...&#160;FAILED<br/>test&#160;tests::exploration&#160;...&#160;ok<br/>
failures:<br/>
----&#160;tests::another&#160;stdout&#160;----<br/>thread&#160;'tests::another'&#160;panicked&#160;at&#160;'Make&#160;this&#160;test&#160;fail',&#160;src/lib.rs:10:9<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
failures:<br/>&#160;&#160;&#160;&#160;tests::another<br/>
test&#160;result:&#160;FAILED.&#160;1&#160;passed;&#160;1&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
error:&#160;test&#160;failed,&#160;to&#160;rerun&#160;pass&#160;`--lib`<br/>
<b>Listing&#160;11-4:&#160;Test&#160;results&#160;when&#160;one&#160;test&#160;passes&#160;and&#160;one&#160;test&#160;fails</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
264/627<br/>
<hr/>
<a name=265></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Instead of&#160;&#160;ok&#160;, the line&#160;&#160;test&#160;tests::another&#160;&#160;shows&#160;&#160;FAILED&#160;. Two new sections appear<br/>between the individual results and the summary: the&#160;ﬁrst displays the detailed reason for<br/>each test failure. In this case, we get the details that&#160;&#160;another&#160;&#160;failed because it&#160;&#160;panicked&#160;at&#160;<br/>'Make&#160;this&#160;test&#160;fail'&#160;&#160;on line 10 in the&#160;<i>src/lib.rs</i>&#160;ﬁle. The next section lists just the names<br/>of all the failing tests, which is useful when there are lots of tests and lots of detailed failing<br/>test output. We can use the name of a failing test to run just that test to more easily debug<br/><a href="https://doc.rust-lang.org/book/ch11-02-running-tests.html#controlling-how-tests-are-run">it; we’ll talk more about ways to run tests in the&#160;“Controlling How Tests Are Run”&#160;section.</a><br/>
The summary line displays at the end: overall, our test result is&#160;&#160;FAILED&#160;. We had one test<br/>pass and one test fail.<br/>
Now that you’ve seen what the test results look like in diﬀerent scenarios, let’s look at some<br/>macros other than&#160;&#160;panic!&#160;&#160;that are useful in tests.<br/>
<a href="tests.html#265"><b>Checking&#160;Results&#160;with&#160;the&#160;</b>assert!<b>&#160;Macro</b></a><br/>
The&#160;&#160;assert!&#160;&#160;macro, provided by the standard library, is useful when you want to ensure<br/>that some condition in a test evaluates to&#160;&#160;true&#160;. We give the&#160;&#160;assert!&#160;&#160;macro an argument<br/>that evaluates to a Boolean. If the value is&#160;&#160;true&#160;, nothing happens and the test passes. If the<br/>value is&#160;&#160;false&#160;, the&#160;&#160;assert!&#160;&#160;macro calls&#160;&#160;panic!&#160;&#160;to cause the test to fail. Using the<br/>
assert!&#160;&#160;macro helps us check that our code is functioning in the way we intend.<br/>
In Chapter 5, Listing 5-15, we used a&#160;&#160;Rectangle&#160;&#160;struct and a&#160;&#160;can_hold&#160;&#160;method, which are<br/>repeated here in Listing 11-5. Let’s put this code in the&#160;<i>src/lib.rs</i>&#160;ﬁle, then write some tests<br/>for it using the&#160;&#160;assert!&#160;&#160;macro.<br/>
Filename: src/lib.rs<br/>
#[derive(Debug)]<br/>struct&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;width:&#160;u32,<br/>&#160;&#160;&#160;&#160;height:&#160;u32,<br/>}<br/>
impl&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;can_hold(&amp;self,&#160;other:&#160;&amp;Rectangle)&#160;-&gt;&#160;bool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.width&#160;&gt;&#160;other.width&#160;&amp;&amp;&#160;self.height&#160;&gt;&#160;other.height<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;11-5:&#160;Using&#160;the&#160;&#160;</b>Rectangle&#160;<b>&#160;struct&#160;and&#160;its&#160;&#160;</b>can_hold&#160;<b>&#160;method&#160;from&#160;Chapter&#160;5</b><br/>
The&#160;&#160;can_hold&#160;&#160;method returns a Boolean, which means it’s a perfect use case for the<br/>
assert!&#160;&#160;macro. In Listing 11-6, we write a test that exercises the&#160;&#160;can_hold&#160;&#160;method by<br/>
creating a&#160;&#160;Rectangle&#160;&#160;instance that has a width of 8 and a height of 7 and asserting that it<br/>can hold another&#160;&#160;Rectangle&#160;&#160;instance that has a width of 5 and a height of 1.<br/>
https://doc.rust-lang.org/book/print.html<br/>
265/627<br/>
<hr/>
<a name=266></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Filename: src/lib.rs<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;larger_can_hold_smaller()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;larger&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;8,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;7,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;smaller&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;5,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert!(larger.can_hold(&amp;smaller));<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;11-6:&#160;A&#160;test&#160;for&#160;&#160;</b>can_hold&#160;<b>&#160;that&#160;checks&#160;whether&#160;a&#160;larger&#160;rectangle&#160;can&#160;indeed&#160;hold&#160;a&#160;smaller&#160;rectangle</b><br/>
Note that we’ve added a new line inside the&#160;&#160;tests&#160;&#160;module:&#160;&#160;use&#160;super::*;&#160;. The&#160;&#160;tests<br/>module is a regular module that follows the usual visibility rules we covered in Chapter 7 in<br/>the&#160;<a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module Tree”</a>&#160;section. Because the&#160;&#160;tests&#160;&#160;module<br/>is an inner module, we need to bring the code under test in the outer module into the scope<br/>of the inner module. We use a glob here so anything we deﬁne in the outer module is<br/>available to this&#160;&#160;tests&#160;&#160;module.<br/>
We’ve named our test&#160;&#160;larger_can_hold_smaller&#160;, and we’ve created the two&#160;&#160;Rectangle<br/>instances that we need. Then we called the&#160;&#160;assert!&#160;&#160;macro and passed it the result of<br/>calling&#160;&#160;larger.can_hold(&amp;smaller)&#160;. This expression is supposed to return&#160;&#160;true&#160;, so our<br/>test should pass. Let’s&#160;ﬁnd out!<br/>
https://doc.rust-lang.org/book/print.html<br/>
266/627<br/>
<hr/>
<a name=267></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;rectangle&#160;v0.1.0&#160;(file:///projects/rectangle)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.66s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/rectangle-<br/>6584c4561e48942e)<br/>
running&#160;1&#160;test<br/>test&#160;tests::larger_can_hold_smaller&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;rectangle<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
It does pass! Let’s add another test, this time asserting that a smaller rectangle cannot hold<br/>a larger rectangle:<br/>
Filename: src/lib.rs<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;larger_can_hold_smaller()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;smaller_cannot_hold_larger()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;larger&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;8,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;7,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;smaller&#160;=&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;5,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert!(!smaller.can_hold(&amp;larger));<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
Because the correct result of the&#160;&#160;can_hold&#160;&#160;function in this case is&#160;&#160;false&#160;, we need to<br/>negate that result before we pass it to the&#160;&#160;assert!&#160;&#160;macro. As a result, our test will pass if<br/>
can_hold&#160;&#160;returns&#160;&#160;false&#160;:<br/>
https://doc.rust-lang.org/book/print.html<br/>
267/627<br/>
<hr/>
<a name=268></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;rectangle&#160;v0.1.0&#160;(file:///projects/rectangle)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.66s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/rectangle-<br/>6584c4561e48942e)<br/>
running&#160;2&#160;tests<br/>test&#160;tests::larger_can_hold_smaller&#160;...&#160;ok<br/>test&#160;tests::smaller_cannot_hold_larger&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;2&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;rectangle<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
Two tests that pass! Now let’s see what happens to our test results when we introduce a bug<br/>in our code. We’ll change the implementation of the&#160;&#160;can_hold&#160;&#160;method by replacing the<br/>greater-than sign with a less-than sign when it compares the widths:<br/>
//&#160;--snip--<br/>impl&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;can_hold(&amp;self,&#160;other:&#160;&amp;Rectangle)&#160;-&gt;&#160;bool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.width&#160;&lt;&#160;other.width&#160;&amp;&amp;&#160;self.height&#160;&gt;&#160;other.height<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
Running the tests now produces the following:<br/>
https://doc.rust-lang.org/book/print.html<br/>
268/627<br/>
<hr/>
<a name=269></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;rectangle&#160;v0.1.0&#160;(file:///projects/rectangle)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.66s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/rectangle-<br/>6584c4561e48942e)<br/>
running&#160;2&#160;tests<br/>test&#160;tests::larger_can_hold_smaller&#160;...&#160;FAILED<br/>test&#160;tests::smaller_cannot_hold_larger&#160;...&#160;ok<br/>
failures:<br/>
----&#160;tests::larger_can_hold_smaller&#160;stdout&#160;----<br/>thread&#160;'tests::larger_can_hold_smaller'&#160;panicked&#160;at&#160;'assertion&#160;failed:&#160;<br/>larger.can_hold(&amp;smaller)',&#160;src/lib.rs:28:9<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
failures:<br/>&#160;&#160;&#160;&#160;tests::larger_can_hold_smaller<br/>
test&#160;result:&#160;FAILED.&#160;1&#160;passed;&#160;1&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
error:&#160;test&#160;failed,&#160;to&#160;rerun&#160;pass&#160;`--lib`<br/>
Our tests caught the bug! Because&#160;&#160;larger.width&#160;&#160;is 8 and&#160;&#160;smaller.width&#160;&#160;is 5, the<br/>comparison of the widths in&#160;&#160;can_hold&#160;&#160;now returns&#160;&#160;false&#160;: 8 is not less than 5.<br/>
<a href="tests.html#269"><b>Testing&#160;Equality&#160;with&#160;the&#160;</b>assert_eq!<b>&#160;and&#160;</b>assert_ne!<b>&#160;Macros</b></a><br/>
A common way to verify functionality is to test for equality between the result of the code<br/>under test and the value you expect the code to return. You could do this using the<br/>
assert!&#160;&#160;macro and passing it an expression using the&#160;&#160;==&#160;&#160;operator. However, this is such a<br/>
common test that the standard library provides a pair of macros—&#160;assert_eq!&#160;&#160;and<br/>
assert_ne!&#160;—to perform this test more conveniently. These macros compare two<br/>
arguments for equality or inequality, respectively. They’ll also print the two values if the<br/>assertion fails, which makes it easier to see&#160;<i>why</i>&#160;the test failed; conversely, the&#160;&#160;assert!<br/>macro only indicates that it got a&#160;&#160;false&#160;&#160;value for the&#160;&#160;==&#160;&#160;expression, without printing the<br/>values that led to the&#160;&#160;false&#160;&#160;value.<br/>
In Listing 11-7, we write a function named&#160;&#160;add_two&#160;&#160;that adds&#160;&#160;2&#160;&#160;to its parameter, then we<br/>test this function using the&#160;&#160;assert_eq!&#160;&#160;macro.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
269/627<br/>
<hr/>
<a name=270></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;fn&#160;add_two(a:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;a&#160;+&#160;2<br/>}<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;it_adds_two()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(4,&#160;add_two(2));<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;11-7:&#160;Testing&#160;the&#160;function&#160;&#160;</b>add_two&#160;<b>&#160;using&#160;the&#160;&#160;</b>assert_eq!&#160;<b>&#160;macro</b><br/>
Let’s check that it passes!<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.58s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/adder-92948b65e88960b4)<br/>
running&#160;1&#160;test<br/>test&#160;tests::it_adds_two&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;adder<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
We pass&#160;&#160;4&#160;&#160;as the argument to&#160;&#160;assert_eq!&#160;, which is equal to the result of calling<br/>
add_two(2)&#160;. The line for this test is&#160;&#160;test&#160;tests::it_adds_two&#160;...&#160;ok&#160;, and the&#160;&#160;ok&#160;&#160;text<br/>
indicates that our test passed!<br/>
Let’s introduce a bug into our code to see what&#160;&#160;assert_eq!&#160;&#160;looks like when it fails. Change<br/>the implementation of the&#160;&#160;add_two&#160;&#160;function to instead add&#160;&#160;3&#160;:<br/>
pub&#160;fn&#160;add_two(a:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;a&#160;+&#160;3<br/>}<br/>
Run the tests again:<br/>
https://doc.rust-lang.org/book/print.html<br/>
270/627<br/>
<hr/>
<a name=271></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.61s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/adder-92948b65e88960b4)<br/>
running&#160;1&#160;test<br/>test&#160;tests::it_adds_two&#160;...&#160;FAILED<br/>
failures:<br/>
----&#160;tests::it_adds_two&#160;stdout&#160;----<br/>thread&#160;'tests::it_adds_two'&#160;panicked&#160;at&#160;'assertion&#160;failed:&#160;`(left&#160;==&#160;right)`<br/>&#160;&#160;left:&#160;`4`,<br/>&#160;right:&#160;`5`',&#160;src/lib.rs:11:9<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
failures:<br/>&#160;&#160;&#160;&#160;tests::it_adds_two<br/>
test&#160;result:&#160;FAILED.&#160;0&#160;passed;&#160;1&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
error:&#160;test&#160;failed,&#160;to&#160;rerun&#160;pass&#160;`--lib`<br/>
Our test caught the bug! The&#160;&#160;it_adds_two&#160;&#160;test failed, and the message tells us that the<br/>assertion that fails was&#160;&#160;assertion&#160;failed:&#160;`(left&#160;==&#160;right)`&#160;&#160;and what the&#160;&#160;left&#160;&#160;and<br/>
right&#160;&#160;values are. This message helps us start debugging: the&#160;&#160;left&#160;&#160;argument was&#160;&#160;4&#160;&#160;but<br/>
the&#160;&#160;right&#160;&#160;argument, where we had&#160;&#160;add_two(2)&#160;, was&#160;&#160;5&#160;. You can imagine that this would<br/>be especially helpful when we have a lot of tests going on.<br/>
Note that in some languages and test frameworks, the parameters to equality assertion<br/>functions are called&#160;&#160;expected&#160;&#160;and&#160;&#160;actual&#160;, and the order in which we specify the<br/>arguments matters. However, in Rust, they’re called&#160;&#160;left&#160;&#160;and&#160;&#160;right&#160;, and the order in<br/>which we specify the value we expect and the value the code produces doesn’t matter. We<br/>could write the assertion in this test as&#160;&#160;assert_eq!(add_two(2),&#160;4)&#160;, which would result in<br/>the same failure message that displays&#160;&#160;assertion&#160;failed:&#160;`(left&#160;==&#160;right)`&#160;.<br/>
The&#160;&#160;assert_ne!&#160;&#160;macro will pass if the two values we give it are not equal and fail if they’re<br/>equal. This macro is most useful for cases when we’re not sure what a value&#160;<i>will</i>&#160;be, but we<br/>know what the value deﬁnitely&#160;<i>shouldn’t</i>&#160;be. For example, if we’re testing a function that is<br/>guaranteed to change its input in some way, but the way in which the input is changed<br/>depends on the day of the week that we run our tests, the best thing to assert might be that<br/>the output of the function is not equal to the input.<br/>
Under the surface, the&#160;&#160;assert_eq!&#160;&#160;and&#160;&#160;assert_ne!&#160;&#160;macros use the operators&#160;&#160;==&#160;&#160;and&#160;&#160;!=&#160;,<br/>respectively. When the assertions fail, these macros print their arguments using debug<br/>formatting, which means the values being compared must implement the&#160;&#160;PartialEq&#160;&#160;and<br/>
Debug&#160;&#160;traits. All primitive types and most of the standard library types implement these<br/>
traits. For structs and enums that you deﬁne yourself, you’ll need to implement&#160;&#160;PartialEq<br/>
https://doc.rust-lang.org/book/print.html<br/>
271/627<br/>
<hr/>
<a name=272></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
to assert equality of those types. You’ll also need to implement&#160;&#160;Debug&#160;&#160;to print the values<br/>when the assertion fails. Because both traits are derivable traits, as mentioned in Listing 5-<br/>12 in Chapter 5, this is usually as straightforward as adding the&#160;&#160;#[derive(PartialEq,&#160;<br/>Debug)]&#160;&#160;annotation to your struct or enum deﬁnition. See Appendix C,&#160;<a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">“Derivable Traits,”<br/></a>for more details about these and other derivable traits.<br/>
<a href="tests.html#272"><b>Adding&#160;Custom&#160;Failure&#160;Messages</b></a><br/>
You can also add a custom message to be printed with the failure message as optional<br/>arguments to the&#160;&#160;assert!&#160;,&#160;&#160;assert_eq!&#160;, and&#160;&#160;assert_ne!&#160;&#160;macros. Any arguments speciﬁed<br/>after the required arguments are passed along to the&#160;&#160;format!&#160;&#160;macro (discussed in Chapter<br/>8 in the&#160;<a href="https://doc.rust-lang.org/book/ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">“Concatenation with the&#160;&#160;+&#160;&#160;Operator or the&#160;&#160;format!&#160;&#160;Macro”</a>&#160;section), so you can<br/>pass a format string that contains&#160;&#160;{}&#160;&#160;placeholders and values to go in those placeholders.<br/>Custom messages are useful for documenting what an assertion means; when a test fails,<br/>you’ll have a better idea of what the problem is with the code.<br/>
For example, let’s say we have a function that greets people by name and we want to test<br/>that the name we pass into the function appears in the output:<br/>
Filename: src/lib.rs<br/>
pub&#160;fn&#160;greeting(name:&#160;&amp;str)&#160;-&gt;&#160;String&#160;{<br/>&#160;&#160;&#160;&#160;format!(&#34;Hello&#160;{}!&#34;,&#160;name)<br/>}<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;greeting_contains_name()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;greeting(&#34;Carol&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert!(result.contains(&#34;Carol&#34;));<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
The requirements for this program haven’t been agreed upon yet, and we’re pretty sure the<br/>
Hello&#160;&#160;text at the beginning of the greeting will change. We decided we don’t want to have<br/>
to update the test when the requirements change, so instead of checking for exact equality<br/>to the value returned from the&#160;&#160;greeting&#160;&#160;function, we’ll just assert that the output contains<br/>the text of the input parameter.<br/>
Now let’s introduce a bug into this code by changing&#160;&#160;greeting&#160;&#160;to exclude&#160;&#160;name&#160;&#160;to see what<br/>the default test failure looks like:<br/>
https://doc.rust-lang.org/book/print.html<br/>
272/627<br/>
<hr/>
<a name=273></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;fn&#160;greeting(name:&#160;&amp;str)&#160;-&gt;&#160;String&#160;{<br/>&#160;&#160;&#160;&#160;String::from(&#34;Hello!&#34;)<br/>}<br/>
Running this test produces the following:<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;greeter&#160;v0.1.0&#160;(file:///projects/greeter)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.91s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/greeter-170b942eb5bf5e3a)<br/>
running&#160;1&#160;test<br/>test&#160;tests::greeting_contains_name&#160;...&#160;FAILED<br/>
failures:<br/>
----&#160;tests::greeting_contains_name&#160;stdout&#160;----<br/>thread&#160;'tests::greeting_contains_name'&#160;panicked&#160;at&#160;'assertion&#160;failed:&#160;<br/>result.contains(\&#34;Carol\&#34;)',&#160;src/lib.rs:12:9<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
failures:<br/>&#160;&#160;&#160;&#160;tests::greeting_contains_name<br/>
test&#160;result:&#160;FAILED.&#160;0&#160;passed;&#160;1&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
error:&#160;test&#160;failed,&#160;to&#160;rerun&#160;pass&#160;`--lib`<br/>
This result just indicates that the assertion failed and which line the assertion is on. A more<br/>useful failure message would print the value from the&#160;&#160;greeting&#160;&#160;function. Let’s add a<br/>custom failure message composed of a format string with a placeholder&#160;ﬁlled in with the<br/>actual value we got from the&#160;&#160;greeting&#160;&#160;function:<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;greeting_contains_name()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;greeting(&#34;Carol&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result.contains(&#34;Carol&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;Greeting&#160;did&#160;not&#160;contain&#160;name,&#160;value&#160;was&#160;`{}`&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;&#160;}<br/>
Now when we run the test, we’ll get a more informative error message:<br/>
https://doc.rust-lang.org/book/print.html<br/>
273/627<br/>
<hr/>
<a name=274></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;greeter&#160;v0.1.0&#160;(file:///projects/greeter)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.93s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/greeter-170b942eb5bf5e3a)<br/>
running&#160;1&#160;test<br/>test&#160;tests::greeting_contains_name&#160;...&#160;FAILED<br/>
failures:<br/>
----&#160;tests::greeting_contains_name&#160;stdout&#160;----<br/>thread&#160;'tests::greeting_contains_name'&#160;panicked&#160;at&#160;'Greeting&#160;did&#160;not&#160;contain&#160;<br/>name,&#160;value&#160;was&#160;`Hello!`',&#160;src/lib.rs:12:9<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
failures:<br/>&#160;&#160;&#160;&#160;tests::greeting_contains_name<br/>
test&#160;result:&#160;FAILED.&#160;0&#160;passed;&#160;1&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
error:&#160;test&#160;failed,&#160;to&#160;rerun&#160;pass&#160;`--lib`<br/>
We can see the value we actually got in the test output, which would help us debug what<br/>happened instead of what we were expecting to happen.<br/>
<a href="tests.html#274"><b>Checking&#160;for&#160;Panics&#160;with&#160;</b>should_panic</a><br/>
In addition to checking return values, it’s important to check that our code handles error<br/>conditions as we expect. For example, consider the&#160;&#160;Guess&#160;&#160;type that we created in Chapter<br/>9, Listing 9-13. Other code that uses&#160;&#160;Guess&#160;&#160;depends on the guarantee that&#160;&#160;Guess&#160;&#160;instances<br/>will contain only values between 1 and 100. We can write a test that ensures that attempting<br/>to create a&#160;&#160;Guess&#160;&#160;instance with a value outside that range panics.<br/>
We do this by adding the attribute&#160;&#160;should_panic&#160;&#160;to our test function. The test passes if the<br/>code inside the function panics; the test fails if the code inside the function doesn’t panic.<br/>
Listing 11-8 shows a test that checks that the error conditions of&#160;&#160;Guess::new&#160;&#160;happen when<br/>we expect them to.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
274/627<br/>
<hr/>
<a name=275></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;struct&#160;Guess&#160;{<br/>&#160;&#160;&#160;&#160;value:&#160;i32,<br/>}<br/>
impl&#160;Guess&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(value:&#160;i32)&#160;-&gt;&#160;Guess&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;value&#160;&lt;&#160;1&#160;||&#160;value&#160;&gt;&#160;100&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic!(&#34;Guess&#160;value&#160;must&#160;be&#160;between&#160;1&#160;and&#160;100,&#160;got&#160;{}.&#34;,&#160;value);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Guess&#160;{&#160;value&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;#[should_panic]<br/>&#160;&#160;&#160;&#160;fn&#160;greater_than_100()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Guess::new(200);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;11-8:&#160;Testing&#160;that&#160;a&#160;condition&#160;will&#160;cause&#160;a&#160;&#160;</b>panic!<br/>
We place the&#160;&#160;#[should_panic]&#160;&#160;attribute after the&#160;&#160;#[test]&#160;&#160;attribute and before the test<br/>function it applies to. Let’s look at the result when this test passes:<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.58s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/guessing_game-<br/>57d70c3acb738f4d)<br/>
running&#160;1&#160;test<br/>test&#160;tests::greater_than_100&#160;-&#160;should&#160;panic&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;guessing_game<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
Looks good! Now let’s introduce a bug in our code by removing the condition that the&#160;&#160;new<br/>function will panic if the value is greater than 100:<br/>
https://doc.rust-lang.org/book/print.html<br/>
275/627<br/>
<hr/>
<a name=276></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
//&#160;--snip--<br/>impl&#160;Guess&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(value:&#160;i32)&#160;-&gt;&#160;Guess&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;value&#160;&lt;&#160;1&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic!(&#34;Guess&#160;value&#160;must&#160;be&#160;between&#160;1&#160;and&#160;100,&#160;got&#160;{}.&#34;,&#160;value);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Guess&#160;{&#160;value&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
When we run the test in Listing 11-8, it will fail:<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.62s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/guessing_game-<br/>57d70c3acb738f4d)<br/>
running&#160;1&#160;test<br/>test&#160;tests::greater_than_100&#160;-&#160;should&#160;panic&#160;...&#160;FAILED<br/>
failures:<br/>
----&#160;tests::greater_than_100&#160;stdout&#160;----<br/>note:&#160;test&#160;did&#160;not&#160;panic&#160;as&#160;expected<br/>
failures:<br/>&#160;&#160;&#160;&#160;tests::greater_than_100<br/>
test&#160;result:&#160;FAILED.&#160;0&#160;passed;&#160;1&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
error:&#160;test&#160;failed,&#160;to&#160;rerun&#160;pass&#160;`--lib`<br/>
We don’t get a very helpful message in this case, but when we look at the test function, we<br/>see that it’s annotated with&#160;&#160;#[should_panic]&#160;. The failure we got means that the code in the<br/>test function did not cause a panic.<br/>
Tests that use&#160;&#160;should_panic&#160;&#160;can be imprecise. A&#160;&#160;should_panic&#160;&#160;test would pass even if the<br/>test panics for a diﬀerent reason from the one we were expecting. To make&#160;&#160;should_panic<br/>tests more precise, we can add an optional&#160;&#160;expected&#160;&#160;parameter to the&#160;&#160;should_panic<br/>attribute. The test harness will make sure that the failure message contains the provided<br/>text. For example, consider the modiﬁed code for&#160;&#160;Guess&#160;&#160;in Listing 11-9 where the&#160;&#160;new<br/>function panics with diﬀerent messages depending on whether the value is too small or too<br/>large.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
276/627<br/>
<hr/>
<a name=277></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
//&#160;--snip--<br/>
impl&#160;Guess&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(value:&#160;i32)&#160;-&gt;&#160;Guess&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;value&#160;&lt;&#160;1&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;Guess&#160;value&#160;must&#160;be&#160;greater&#160;than&#160;or&#160;equal&#160;to&#160;1,&#160;got&#160;{}.&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;else&#160;if&#160;value&#160;&gt;&#160;100&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;Guess&#160;value&#160;must&#160;be&#160;less&#160;than&#160;or&#160;equal&#160;to&#160;100,&#160;got&#160;{}.&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Guess&#160;{&#160;value&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;#[should_panic(expected&#160;=&#160;&#34;less&#160;than&#160;or&#160;equal&#160;to&#160;100&#34;)]<br/>&#160;&#160;&#160;&#160;fn&#160;greater_than_100()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Guess::new(200);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;11-9:&#160;Testing&#160;for&#160;a&#160;&#160;</b>panic!&#160;<b>&#160;with&#160;a&#160;panic&#160;message&#160;containing&#160;a&#160;speciﬁed&#160;substring</b><br/>
This test will pass because the value we put in the&#160;&#160;should_panic&#160;&#160;attribute’s&#160;&#160;expected<br/>parameter is a substring of the message that the&#160;&#160;Guess::new&#160;&#160;function panics with. We<br/>could have speciﬁed the entire panic message that we expect, which in this case would be<br/>
Guess&#160;value&#160;must&#160;be&#160;less&#160;than&#160;or&#160;equal&#160;to&#160;100,&#160;got&#160;200.&#160;&#160;What you choose to specify<br/>
depends on how much of the panic message is unique or dynamic and how precise you<br/>want your test to be. In this case, a substring of the panic message is enough to ensure that<br/>the code in the test function executes the&#160;&#160;else&#160;if&#160;value&#160;&gt;&#160;100&#160;&#160;case.<br/>
To see what happens when a&#160;&#160;should_panic&#160;&#160;test with an&#160;&#160;expected&#160;&#160;message fails, let’s again<br/>introduce a bug into our code by swapping the bodies of the&#160;&#160;if&#160;value&#160;&lt;&#160;1&#160;&#160;and the&#160;&#160;else&#160;<br/>if&#160;value&#160;&gt;&#160;100&#160;&#160;blocks:<br/>
https://doc.rust-lang.org/book/print.html<br/>
277/627<br/>
<hr/>
<a name=278></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;value&#160;&lt;&#160;1&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;Guess&#160;value&#160;must&#160;be&#160;less&#160;than&#160;or&#160;equal&#160;to&#160;100,&#160;got&#160;{}.<a href="https://doc.rust-lang.org/book/ch00-00-introduction.html#ferris">&#34;,<br/></a>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;else&#160;if&#160;value&#160;&gt;&#160;100&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;Guess&#160;value&#160;must&#160;be&#160;greater&#160;than&#160;or&#160;equal&#160;to&#160;1,&#160;got&#160;{}.&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
This time when we run the&#160;&#160;should_panic&#160;&#160;test, it will fail:<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.66s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/guessing_game-<br/>57d70c3acb738f4d)<br/>
running&#160;1&#160;test<br/>test&#160;tests::greater_than_100&#160;-&#160;should&#160;panic&#160;...&#160;FAILED<br/>
failures:<br/>
----&#160;tests::greater_than_100&#160;stdout&#160;----<br/>thread&#160;'tests::greater_than_100'&#160;panicked&#160;at&#160;'Guess&#160;value&#160;must&#160;be&#160;greater&#160;than&#160;<br/>or&#160;equal&#160;to&#160;1,&#160;got&#160;200.',&#160;src/lib.rs:13:13<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>note:&#160;panic&#160;did&#160;not&#160;contain&#160;expected&#160;string<br/>&#160;&#160;&#160;&#160;&#160;&#160;panic&#160;message:&#160;`&#34;Guess&#160;value&#160;must&#160;be&#160;greater&#160;than&#160;or&#160;equal&#160;to&#160;1,&#160;got&#160;<br/>200.&#34;`,<br/>&#160;expected&#160;substring:&#160;`&#34;less&#160;than&#160;or&#160;equal&#160;to&#160;100&#34;`<br/>
failures:<br/>&#160;&#160;&#160;&#160;tests::greater_than_100<br/>
test&#160;result:&#160;FAILED.&#160;0&#160;passed;&#160;1&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
error:&#160;test&#160;failed,&#160;to&#160;rerun&#160;pass&#160;`--lib`<br/>
The failure message indicates that this test did indeed panic as we expected, but the panic<br/>message did not include the expected string&#160;&#160;'Guess&#160;value&#160;must&#160;be&#160;less&#160;than&#160;or&#160;equal&#160;<br/>to&#160;100'&#160;. The panic message that we did get in this case was&#160;&#160;Guess&#160;value&#160;must&#160;be&#160;greater&#160;<br/>than&#160;or&#160;equal&#160;to&#160;1,&#160;got&#160;200.&#160;&#160;Now we can start&#160;ﬁguring out where our bug is!<br/>
<a href="tests.html#278"><b>Using&#160;</b>Result&lt;T,&#160;E&gt;<b>&#160;in&#160;Tests</b></a><br/>
Our tests so far all panic when they fail. We can also write tests that use&#160;&#160;Result&lt;T,&#160;E&gt;&#160;!<br/>Here’s the test from Listing 11-1, rewritten to use&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;and return an&#160;&#160;Err&#160;&#160;instead<br/>
https://doc.rust-lang.org/book/print.html<br/>
278/627<br/>
<hr/>
<a name=279></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
of panicking:<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;it_works()&#160;-&gt;&#160;Result&lt;(),&#160;String&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;2&#160;+&#160;2&#160;==&#160;4&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(String::from(&#34;two&#160;plus&#160;two&#160;does&#160;not&#160;equal&#160;four&#34;))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
The&#160;&#160;it_works&#160;&#160;function now has the&#160;&#160;Result&lt;(),&#160;String&gt;&#160;&#160;return type. In the body of the<br/>function, rather than calling the&#160;&#160;assert_eq!&#160;&#160;macro, we return&#160;&#160;Ok(())&#160;&#160;when the test<br/>passes and an&#160;&#160;Err&#160;&#160;with a&#160;&#160;String&#160;&#160;inside when the test fails.<br/>
Writing tests so they return a&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;enables you to use the question mark operator<br/>in the body of tests, which can be a convenient way to write tests that should fail if any<br/>operation within them returns an&#160;&#160;Err&#160;&#160;variant.<br/>
You can’t use the&#160;&#160;#[should_panic]&#160;&#160;annotation on tests that use&#160;&#160;Result&lt;T,&#160;E&gt;&#160;. To assert<br/>that an operation returns an&#160;&#160;Err&#160;&#160;variant,&#160;<i>don’t</i>&#160;use the question mark operator on the<br/>
Result&lt;T,&#160;E&gt;&#160;&#160;value. Instead, use&#160;&#160;assert!(value.is_err())&#160;.<br/>
Now that you know several ways to write tests, let’s look at what is happening when we run<br/>our tests and explore the diﬀerent options we can use with&#160;&#160;cargo&#160;test&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
279/627<br/>
<hr/>
<a name=280></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#280"><b>Controlling How Tests Are Run</b></a><br/>
Just as&#160;&#160;cargo&#160;run&#160;&#160;compiles your code and then runs the resulting binary,&#160;&#160;cargo&#160;test<br/>compiles your code in test mode and runs the resulting test binary. The default behavior of<br/>the binary produced by&#160;&#160;cargo&#160;test&#160;&#160;is to run all the tests in parallel and capture output<br/>generated during test runs, preventing the output from being displayed and making it<br/>easier to read the output related to the test results. You can, however, specify command<br/>line options to change this default behavior.<br/>
Some command line options go to&#160;&#160;cargo&#160;test&#160;, and some go to the resulting test binary. To<br/>separate these two types of arguments, you list the arguments that go to&#160;&#160;cargo&#160;test<br/>followed by the separator&#160;&#160;--&#160;&#160;and then the ones that go to the test binary. Running&#160;&#160;cargo&#160;<br/>test&#160;--help&#160;&#160;displays the options you can use with&#160;&#160;cargo&#160;test&#160;, and running&#160;&#160;cargo&#160;test&#160;-<br/>-&#160;--help&#160;&#160;displays the options you can use after the separator.<br/>
<a href="tests.html#280"><b>Running&#160;Tests&#160;in&#160;Parallel&#160;or&#160;Consecutively</b></a><br/>
When you run multiple tests, by default they run in parallel using threads, meaning they<br/>ﬁnish running faster and you get feedback quicker. Because the tests are running at the<br/>same time, you must make sure your tests don’t depend on each other or on any shared<br/>state, including a shared environment, such as the current working directory or<br/>environment variables.<br/>
For example, say each of your tests runs some code that creates a&#160;ﬁle on disk named&#160;<i>test-<br/>output.txt</i>&#160;and writes some data to that&#160;ﬁle. Then each test reads the data in that&#160;ﬁle and<br/>asserts that the&#160;ﬁle contains a particular value, which is diﬀerent in each test. Because the<br/>tests run at the same time, one test might overwrite the&#160;ﬁle in the time between another<br/>test writing and reading the&#160;ﬁle. The second test will then fail, not because the code is<br/>incorrect but because the tests have interfered with each other while running in parallel.<br/>One solution is to make sure each test writes to a diﬀerent&#160;ﬁle; another solution is to run<br/>the tests one at a time.<br/>
If you don’t want to run the tests in parallel or if you want more&#160;ﬁne-grained control over<br/>the number of threads used, you can send the&#160;&#160;--test-threads&#160;&#160;ﬂag and the number of<br/>threads you want to use to the test binary. Take a look at the following example:<br/>
$&#160;cargo&#160;test&#160;--&#160;--test-threads=1<br/>
We set the number of test threads to&#160;&#160;1&#160;, telling the program not to use any parallelism.<br/>Running the tests using one thread will take longer than running them in parallel, but the<br/>tests won’t interfere with each other if they share state.<br/>
https://doc.rust-lang.org/book/print.html<br/>
280/627<br/>
<hr/>
<a name=281></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#281"><b>Showing&#160;Function&#160;Output</b></a><br/>
By default, if a test passes, Rust’s test library captures anything printed to standard output.<br/>For example, if we call&#160;&#160;println!&#160;&#160;in a test and the test passes, we won’t see the&#160;&#160;println!<br/>output in the terminal; we’ll see only the line that indicates the test passed. If a test fails,<br/>we’ll see whatever was printed to standard output with the rest of the failure message.<br/>
As an example, Listing 11-10 has a silly function that prints the value of its parameter and<br/>returns 10, as well as a test that passes and a test that fails.<br/>
Filename: src/lib.rs<br/>
fn&#160;prints_and_returns_10(a:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;I&#160;got&#160;the&#160;value&#160;{}&#34;,&#160;a);<br/>&#160;&#160;&#160;&#160;10<br/>}<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;this_test_will_pass()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;value&#160;=&#160;prints_and_returns_10(4);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(10,&#160;value);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;this_test_will_fail()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;value&#160;=&#160;prints_and_returns_10(8);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(5,&#160;value);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;11-10:&#160;Tests&#160;for&#160;a&#160;function&#160;that&#160;calls&#160;&#160;</b>println!<br/>
When we run these tests with&#160;&#160;cargo&#160;test&#160;, we’ll see the following output:<br/>
https://doc.rust-lang.org/book/print.html<br/>
281/627<br/>
<hr/>
<a name=282></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;silly-function&#160;v0.1.0&#160;(file:///projects/silly-function)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.58s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/silly_function-<br/>160869f38cff9166)<br/>
running&#160;2&#160;tests<br/>test&#160;tests::this_test_will_fail&#160;...&#160;FAILED<br/>test&#160;tests::this_test_will_pass&#160;...&#160;ok<br/>
failures:<br/>
----&#160;tests::this_test_will_fail&#160;stdout&#160;----<br/>I&#160;got&#160;the&#160;value&#160;8<br/>thread&#160;'tests::this_test_will_fail'&#160;panicked&#160;at&#160;'assertion&#160;failed:&#160;`(left&#160;==&#160;<br/>right)`<br/>&#160;&#160;left:&#160;`5`,<br/>&#160;right:&#160;`10`',&#160;src/lib.rs:19:9<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
failures:<br/>&#160;&#160;&#160;&#160;tests::this_test_will_fail<br/>
test&#160;result:&#160;FAILED.&#160;1&#160;passed;&#160;1&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
error:&#160;test&#160;failed,&#160;to&#160;rerun&#160;pass&#160;`--lib`<br/>
Note that nowhere in this output do we see&#160;&#160;I&#160;got&#160;the&#160;value&#160;4&#160;, which is what is printed<br/>when the test that passes runs. That output has been captured. The output from the test<br/>that failed,&#160;&#160;I&#160;got&#160;the&#160;value&#160;8&#160;, appears in the section of the test summary output, which<br/>also shows the cause of the test failure.<br/>
If we want to see printed values for passing tests as well, we can tell Rust to also show the<br/>output of successful tests with&#160;&#160;--show-output&#160;.<br/>
$&#160;cargo&#160;test&#160;--&#160;--show-output<br/>
When we run the tests in Listing 11-10 again with the&#160;&#160;--show-output&#160;&#160;ﬂag, we see the<br/>following output:<br/>
https://doc.rust-lang.org/book/print.html<br/>
282/627<br/>
<hr/>
<a name=283></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test&#160;--&#160;--show-output<br/>&#160;&#160;&#160;Compiling&#160;silly-function&#160;v0.1.0&#160;(file:///projects/silly-function)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.60s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/silly_function-<br/>160869f38cff9166)<br/>
running&#160;2&#160;tests<br/>test&#160;tests::this_test_will_fail&#160;...&#160;FAILED<br/>test&#160;tests::this_test_will_pass&#160;...&#160;ok<br/>
successes:<br/>
----&#160;tests::this_test_will_pass&#160;stdout&#160;----<br/>I&#160;got&#160;the&#160;value&#160;4<br/>
successes:<br/>&#160;&#160;&#160;&#160;tests::this_test_will_pass<br/>
failures:<br/>
----&#160;tests::this_test_will_fail&#160;stdout&#160;----<br/>I&#160;got&#160;the&#160;value&#160;8<br/>thread&#160;'tests::this_test_will_fail'&#160;panicked&#160;at&#160;'assertion&#160;failed:&#160;`(left&#160;==&#160;<br/>right)`<br/>&#160;&#160;left:&#160;`5`,<br/>&#160;right:&#160;`10`',&#160;src/lib.rs:19:9<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
failures:<br/>&#160;&#160;&#160;&#160;tests::this_test_will_fail<br/>
test&#160;result:&#160;FAILED.&#160;1&#160;passed;&#160;1&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
error:&#160;test&#160;failed,&#160;to&#160;rerun&#160;pass&#160;`--lib`<br/>
<a href="tests.html#283"><b>Running&#160;a&#160;Subset&#160;of&#160;Tests&#160;by&#160;Name</b></a><br/>
Sometimes, running a full test suite can take a long time. If you’re working on code in a<br/>particular area, you might want to run only the tests pertaining to that code. You can choose<br/>which tests to run by passing&#160;&#160;cargo&#160;test&#160;&#160;the name or names of the test(s) you want to run<br/>as an argument.<br/>
To demonstrate how to run a subset of tests, we’ll&#160;ﬁrst create three tests for our&#160;&#160;add_two<br/>function, as shown in Listing 11-11, and choose which ones to run.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
283/627<br/>
<hr/>
<a name=284></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;fn&#160;add_two(a:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;a&#160;+&#160;2<br/>}<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;add_two_and_two()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(4,&#160;add_two(2));<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;add_three_and_two()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(5,&#160;add_two(3));<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;one_hundred()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(102,&#160;add_two(100));<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;11-11:&#160;Three&#160;tests&#160;with&#160;three&#160;diﬀerent&#160;names</b><br/>
If we run the tests without passing any arguments, as we saw earlier, all the tests will run in<br/>parallel:<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.62s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/adder-92948b65e88960b4)<br/>
running&#160;3&#160;tests<br/>test&#160;tests::add_three_and_two&#160;...&#160;ok<br/>test&#160;tests::add_two_and_two&#160;...&#160;ok<br/>test&#160;tests::one_hundred&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;3&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;adder<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
<a href="tests.html#284"><b>Running Single Tests</b></a><br/>
We can pass the name of any test function to&#160;&#160;cargo&#160;test&#160;&#160;to run only that test:<br/>
https://doc.rust-lang.org/book/print.html<br/>
284/627<br/>
<hr/>
<a name=285></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test&#160;one_hundred<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.69s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/adder-92948b65e88960b4)<br/>
running&#160;1&#160;test<br/>test&#160;tests::one_hundred&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;2&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
Only the test with the name&#160;&#160;one_hundred&#160;&#160;ran; the other two tests didn’t match that name.<br/>The test output lets us know we had more tests that didn’t run by displaying&#160;&#160;2&#160;filtered&#160;<br/>out&#160;&#160;at the end.<br/>
We can’t specify the names of multiple tests in this way; only the&#160;ﬁrst value given to&#160;&#160;cargo&#160;<br/>test&#160;&#160;will be used. But there is a way to run multiple tests.<br/>
<a href="tests.html#285"><b>Filtering to Run Multiple Tests</b></a><br/>
We can specify part of a test name, and any test whose name matches that value will be<br/>run. For example, because two of our tests’ names contain&#160;&#160;add&#160;, we can run those two by<br/>running&#160;&#160;cargo&#160;test&#160;add&#160;:<br/>
$&#160;cargo&#160;test&#160;add<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.61s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/adder-92948b65e88960b4)<br/>
running&#160;2&#160;tests<br/>test&#160;tests::add_three_and_two&#160;...&#160;ok<br/>test&#160;tests::add_two_and_two&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;2&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;1&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
This command ran all tests with&#160;&#160;add&#160;&#160;in the name and&#160;ﬁltered out the test named<br/>
one_hundred&#160;. Also note that the module in which a test appears becomes part of the test’s<br/>
name, so we can run all the tests in a module by&#160;ﬁltering on the module’s name.<br/>
<a href="tests.html#285"><b>Ignoring&#160;Some&#160;Tests&#160;Unless&#160;Speciﬁcally&#160;Requested</b></a><br/>
Sometimes a few speciﬁc tests can be very time-consuming to execute, so you might want<br/>to exclude them during most runs of&#160;&#160;cargo&#160;test&#160;. Rather than listing as arguments all tests<br/>you do want to run, you can instead annotate the time-consuming tests using the&#160;&#160;ignore<br/>attribute to exclude them, as shown here:<br/>
https://doc.rust-lang.org/book/print.html<br/>
285/627<br/>
<hr/>
<a name=286></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Filename: src/lib.rs<br/>
#[test]<br/>fn&#160;it_works()&#160;{<br/>&#160;&#160;&#160;&#160;assert_eq!(2&#160;+&#160;2,&#160;4);<br/>}<br/>
#[test]<br/>#[ignore]<br/>fn&#160;expensive_test()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;code&#160;that&#160;takes&#160;an&#160;hour&#160;to&#160;run<br/>}<br/>
After&#160;&#160;#[test]&#160;&#160;we add the&#160;&#160;#[ignore]&#160;&#160;line to the test we want to exclude. Now when we run<br/>our tests,&#160;&#160;it_works&#160;&#160;runs, but&#160;&#160;expensive_test&#160;&#160;doesn’t:<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.60s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/adder-92948b65e88960b4)<br/>
running&#160;2&#160;tests<br/>test&#160;expensive_test&#160;...&#160;ignored<br/>test&#160;it_works&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;1&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;adder<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
The&#160;&#160;expensive_test&#160;&#160;function is listed as&#160;&#160;ignored&#160;. If we want to run only the ignored tests,<br/>we can use&#160;&#160;cargo&#160;test&#160;--&#160;--ignored&#160;:<br/>
https://doc.rust-lang.org/book/print.html<br/>
286/627<br/>
<hr/>
<a name=287></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test&#160;--&#160;--ignored<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.61s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/adder-92948b65e88960b4)<br/>
running&#160;1&#160;test<br/>test&#160;expensive_test&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;1&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;adder<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
By controlling which tests run, you can make sure your&#160;&#160;cargo&#160;test&#160;&#160;results will be fast.<br/>When you’re at a point where it makes sense to check the results of the&#160;&#160;ignored&#160;&#160;tests and<br/>you have time to wait for the results, you can run&#160;&#160;cargo&#160;test&#160;--&#160;--ignored&#160;&#160;instead. If you<br/>want to run all tests whether they’re ignored or not, you can run&#160;&#160;cargo&#160;test&#160;--&#160;--include-<br/>ignored&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
287/627<br/>
<hr/>
<a name=288></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#288"><b>Test Organization</b></a><br/>
As mentioned at the start of the chapter, testing is a complex discipline, and diﬀerent<br/>people use diﬀerent terminology and organization. The Rust community thinks about tests<br/>in terms of two main categories: unit tests and integration tests.&#160;<i>Unit tests</i>&#160;are small and<br/>more focused, testing one module in isolation at a time, and can test private interfaces.<br/><i>Integration tests</i>&#160;are entirely external to your library and use your code in the same way any<br/>other external code would, using only the public interface and potentially exercising<br/>multiple modules per test.<br/>
Writing both kinds of tests is important to ensure that the pieces of your library are doing<br/>what you expect them to, separately and together.<br/>
<a href="tests.html#288"><b>Unit&#160;Tests</b></a><br/>
The purpose of unit tests is to test each unit of code in isolation from the rest of the code to<br/>quickly pinpoint where code is and isn’t working as expected. You’ll put unit tests in the&#160;<i>src<br/></i>directory in each&#160;ﬁle with the code that they’re testing. The convention is to create a module<br/>named&#160;&#160;tests&#160;&#160;in each&#160;ﬁle to contain the test functions and to annotate the module with<br/>
cfg(test)&#160;.<br/>
<a href="tests.html#288"><b>The Tests Module and&#160;</b>#[cfg(test)]</a><br/>
The&#160;&#160;#[cfg(test)]&#160;&#160;annotation on the tests module tells Rust to compile and run the test<br/>code only when you run&#160;&#160;cargo&#160;test&#160;, not when you run&#160;&#160;cargo&#160;build&#160;. This saves compile<br/>time when you only want to build the library and saves space in the resulting compiled<br/>artifact because the tests are not included. You’ll see that because integration tests go in a<br/>diﬀerent directory, they don’t need the&#160;&#160;#[cfg(test)]&#160;&#160;annotation. However, because unit<br/>tests go in the same&#160;ﬁles as the code, you’ll use&#160;&#160;#[cfg(test)]&#160;&#160;to specify that they shouldn’t<br/>be included in the compiled result.<br/>
Recall that when we generated the new&#160;&#160;adder&#160;&#160;project in the&#160;ﬁrst section of this chapter,<br/>Cargo generated this code for us:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
288/627<br/>
<hr/>
<a name=289></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;it_works()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;2&#160;+&#160;2;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(result,&#160;4);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
This code is the automatically generated test module. The attribute&#160;&#160;cfg&#160;&#160;stands for<br/><i>conﬁguration</i>&#160;and tells Rust that the following item should only be included given a certain<br/>conﬁguration option. In this case, the conﬁguration option is&#160;&#160;test&#160;, which is provided by<br/>Rust for compiling and running tests. By using the&#160;&#160;cfg&#160;&#160;attribute, Cargo compiles our test<br/>code only if we actively run the tests with&#160;&#160;cargo&#160;test&#160;. This includes any helper functions<br/>that might be within this module, in addition to the functions annotated with&#160;&#160;#[test]&#160;.<br/>
<a href="tests.html#289"><b>Testing Private Functions</b></a><br/>
There’s debate within the testing community about whether or not private functions should<br/>be tested directly, and other languages make it diﬃcult or impossible to test private<br/>functions. Regardless of which testing ideology you adhere to, Rust’s privacy rules do allow<br/>you to test private functions. Consider the code in Listing 11-12 with the private function<br/>
internal_adder&#160;.<br/>
Filename: src/lib.rs<br/>
pub&#160;fn&#160;add_two(a:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;internal_adder(a,&#160;2)<br/>}<br/>
fn&#160;internal_adder(a:&#160;i32,&#160;b:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;a&#160;+&#160;b<br/>}<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;internal()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(4,&#160;internal_adder(2,&#160;2));<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;11-12:&#160;Testing&#160;a&#160;private&#160;function</b><br/>
Note that the&#160;&#160;internal_adder&#160;&#160;function is not marked as&#160;&#160;pub&#160;. Tests are just Rust code, and<br/><a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">the&#160;&#160;tests&#160;&#160;module is just another module. As we discussed in the&#160;“Paths for Referring to an<br/>Item in the Module Tree”&#160;section, items in child modules can use the items in their ancestor</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
289/627<br/>
<hr/>
<a name=290></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
modules. In this test, we bring all of the&#160;&#160;test&#160;&#160;module’s parent’s items into scope with&#160;&#160;use&#160;<br/>super::*&#160;, and then the test can call&#160;&#160;internal_adder&#160;. If you don’t think private functions<br/>should be tested, there’s nothing in Rust that will compel you to do so.<br/>
<a href="tests.html#290"><b>Integration&#160;Tests</b></a><br/>
In Rust, integration tests are entirely external to your library. They use your library in the<br/>same way any other code would, which means they can only call functions that are part of<br/>your library’s public API. Their purpose is to test whether many parts of your library work<br/>together correctly. Units of code that work correctly on their own could have problems<br/>when integrated, so test coverage of the integrated code is important as well. To create<br/>integration tests, you&#160;ﬁrst need a&#160;<i>tests</i>&#160;directory.<br/>
<a href="tests.html#290"><b>The&#160;<i>tests</i></b><b>&#160;Directory</b></a><br/>
We create a&#160;<i>tests</i>&#160;directory at the top level of our project directory, next to&#160;<i>src</i>. Cargo knows<br/>to look for integration test&#160;ﬁles in this directory. We can then make as many test&#160;ﬁles as we<br/>want, and Cargo will compile each of the&#160;ﬁles as an individual crate.<br/>
Let’s create an integration test. With the code in Listing 11-12 still in the&#160;<i>src/lib.rs</i>&#160;ﬁle, make a<br/><i>tests</i>&#160;directory, and create a new&#160;ﬁle named&#160;<i>tests/integration_test.rs</i>. Your directory structure<br/>should look like this:<br/>
adder<br/>├──&#160;Cargo.lock<br/>├──&#160;Cargo.toml<br/>├──&#160;src<br/>│  &#160;└──&#160;lib.rs<br/>└──&#160;tests<br/>&#160;&#160;&#160;&#160;└──&#160;integration_test.rs<br/>
Enter the code in Listing 11-13 into the&#160;<i>tests/integration_test.rs</i>&#160;ﬁle:<br/>
Filename: tests/integration_test.rs<br/>
use&#160;adder;<br/>
#[test]<br/>fn&#160;it_adds_two()&#160;{<br/>&#160;&#160;&#160;&#160;assert_eq!(4,&#160;adder::add_two(2));<br/>}<br/>
<b>Listing&#160;11-13:&#160;An&#160;integration&#160;test&#160;of&#160;a&#160;function&#160;in&#160;the&#160;&#160;</b>adder&#160;<b>&#160;crate</b><br/>
Each&#160;ﬁle in the&#160;&#160;tests&#160;&#160;directory is a separate crate, so we need to bring our library into each<br/>test crate’s scope. For that reason we add&#160;&#160;use&#160;adder&#160;&#160;at the top of the code, which we didn’t<br/>need in the unit tests.<br/>
https://doc.rust-lang.org/book/print.html<br/>
290/627<br/>
<hr/>
<a name=291></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We don’t need to annotate any code in&#160;<i>tests/integration_test.rs</i>&#160;with&#160;&#160;#[cfg(test)]&#160;. Cargo<br/>treats the&#160;&#160;tests&#160;&#160;directory specially and compiles&#160;ﬁles in this directory only when we run<br/>
cargo&#160;test&#160;. Run&#160;&#160;cargo&#160;test&#160;&#160;now:<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;1.31s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/adder-1082c4b063a8fbe6)<br/>
running&#160;1&#160;test<br/>test&#160;tests::internal&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;&#160;&#160;Running&#160;tests/integration_test.rs&#160;(target/debug/deps/integration_test-<br/>1082c4b063a8fbe6)<br/>
running&#160;1&#160;test<br/>test&#160;it_adds_two&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;adder<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
The three sections of output include the unit tests, the integration test, and the doc tests.<br/>Note that if any test in a section fails, the following sections will not be run. For example, if a<br/>unit test fails, there won’t be any output for integration and doc tests because those tests<br/>will only be run if all unit tests are passing.<br/>
The&#160;ﬁrst section for the unit tests is the same as we’ve been seeing: one line for each unit<br/>test (one named&#160;&#160;internal&#160;&#160;that we added in Listing 11-12) and then a summary line for the<br/>unit tests.<br/>
The integration tests section starts with the line&#160;&#160;Running&#160;tests/integration_test.rs&#160;.<br/>Next, there is a line for each test function in that integration test and a summary line for the<br/>results of the integration test just before the&#160;&#160;Doc-tests&#160;adder&#160;&#160;section starts.<br/>
Each integration test&#160;ﬁle has its own section, so if we add more&#160;ﬁles in the&#160;<i>tests</i>&#160;directory,<br/>there will be more integration test sections.<br/>
We can still run a particular integration test function by specifying the test function’s name<br/>as an argument to&#160;&#160;cargo&#160;test&#160;. To run all the tests in a particular integration test&#160;ﬁle, use<br/>the&#160;&#160;--test&#160;&#160;argument of&#160;&#160;cargo&#160;test&#160;&#160;followed by the name of the&#160;ﬁle:<br/>
https://doc.rust-lang.org/book/print.html<br/>
291/627<br/>
<hr/>
<a name=292></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test&#160;--test&#160;integration_test<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.64s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;tests/integration_test.rs&#160;(target/debug/deps/integration_test-<br/>82e7799c1bc62298)<br/>
running&#160;1&#160;test<br/>test&#160;it_adds_two&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
This command runs only the tests in the&#160;<i>tests/integration_test.rs</i>&#160;ﬁle.<br/>
<a href="tests.html#292"><b>Submodules in Integration Tests</b></a><br/>
As you add more integration tests, you might want to make more&#160;ﬁles in the&#160;<i>tests</i>&#160;directory<br/>to help organize them; for example, you can group the test functions by the functionality<br/>they’re testing. As mentioned earlier, each&#160;ﬁle in the&#160;<i>tests</i>&#160;directory is compiled as its own<br/>separate crate, which is useful for creating separate scopes to more closely imitate the way<br/>end users will be using your crate. However, this means&#160;ﬁles in the&#160;<i>tests</i>&#160;directory don’t<br/>share the same behavior as&#160;ﬁles in&#160;<i>src</i>&#160;do, as you learned in Chapter 7 regarding how to<br/>separate code into modules and&#160;ﬁles.<br/>
The diﬀerent behavior of&#160;<i>tests</i>&#160;directory&#160;ﬁles is most noticeable when you have a set of<br/>helper functions to use in multiple integration test&#160;ﬁles and you try to follow the steps in the<br/><a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html">“Separating Modules into Diﬀerent Files”</a>&#160;section of Chapter 7 to extract them into a<br/>common module. For example, if we create&#160;<i>tests/common.rs</i>&#160;and place a function named<br/>
setup&#160;&#160;in it, we can add some code to&#160;&#160;setup&#160;&#160;that we want to call from multiple test<br/>
functions in multiple test&#160;ﬁles:<br/>
Filename: tests/common.rs<br/>
pub&#160;fn&#160;setup()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;setup&#160;code&#160;specific&#160;to&#160;your&#160;library's&#160;tests&#160;would&#160;go&#160;here<br/>}<br/>
When we run the tests again, we’ll see a new section in the test output for the&#160;<i>common.rs<br/></i>ﬁle, even though this&#160;ﬁle doesn’t contain any test functions nor did we call the&#160;&#160;setup<br/>function from anywhere:<br/>
https://doc.rust-lang.org/book/print.html<br/>
292/627<br/>
<hr/>
<a name=293></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.89s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/adder-92948b65e88960b4)<br/>
running&#160;1&#160;test<br/>test&#160;tests::internal&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;&#160;&#160;Running&#160;tests/common.rs&#160;(target/debug/deps/common-92948b65e88960b4)<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;&#160;&#160;Running&#160;tests/integration_test.rs&#160;(target/debug/deps/integration_test-<br/>92948b65e88960b4)<br/>
running&#160;1&#160;test<br/>test&#160;it_adds_two&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;adder<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
Having&#160;&#160;common&#160;&#160;appear in the test results with&#160;&#160;running&#160;0&#160;tests&#160;&#160;displayed for it is not what<br/>we wanted. We just wanted to share some code with the other integration test&#160;ﬁles.<br/>
To avoid having&#160;&#160;common&#160;&#160;appear in the test output, instead of creating&#160;<i>tests/common.rs</i>, we’ll<br/>create&#160;<i>tests/common/mod.rs</i>. The project directory now looks like this:<br/>
├──&#160;Cargo.lock<br/>├──&#160;Cargo.toml<br/>├──&#160;src<br/>│  &#160;└──&#160;lib.rs<br/>└──&#160;tests<br/>&#160;&#160;&#160;&#160;├──&#160;common<br/>&#160;&#160;&#160;&#160;│  &#160;└──&#160;mod.rs<br/>&#160;&#160;&#160;&#160;└──&#160;integration_test.rs<br/>
This is the older naming convention that Rust also understands that we mentioned in the<br/><a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html#alternate-file-paths">“Alternate File Paths”</a>&#160;section of Chapter 7. Naming the&#160;ﬁle this way tells Rust not to treat the<br/>
common&#160;&#160;module as an integration test&#160;ﬁle. When we move the&#160;&#160;setup&#160;&#160;function code into<br/>
https://doc.rust-lang.org/book/print.html<br/>
293/627<br/>
<hr/>
<a name=294></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<i>tests/common/mod.rs</i>&#160;and delete the&#160;<i>tests/common.rs</i>&#160;ﬁle, the section in the test output will<br/>no longer appear. Files in subdirectories of the&#160;<i>tests</i>&#160;directory don’t get compiled as separate<br/>crates or have sections in the test output.<br/>
After we’ve created&#160;<i>tests/common/mod.rs</i>, we can use it from any of the integration test&#160;ﬁles<br/>as a module. Here’s an example of calling the&#160;&#160;setup&#160;&#160;function from the&#160;&#160;it_adds_two&#160;&#160;test in<br/><i>tests/integration_test.rs</i>:<br/>
Filename: tests/integration_test.rs<br/>
use&#160;adder;<br/>
mod&#160;common;<br/>
#[test]<br/>fn&#160;it_adds_two()&#160;{<br/>&#160;&#160;&#160;&#160;common::setup();<br/>&#160;&#160;&#160;&#160;assert_eq!(4,&#160;adder::add_two(2));<br/>}<br/>
Note that the&#160;&#160;mod&#160;common;&#160;&#160;declaration is the same as the module declaration we<br/>demonstrated in Listing 7-21. Then in the test function, we can call the&#160;&#160;common::setup()<br/>function.<br/>
<a href="tests.html#294"><b>Integration Tests for Binary Crates</b></a><br/>
If our project is a binary crate that only contains a&#160;<i>src/main.rs</i>&#160;ﬁle and doesn’t have a<br/><i>src/lib.rs</i>&#160;ﬁle, we can’t create integration tests in the&#160;<i>tests</i>&#160;directory and bring functions<br/>deﬁned in the&#160;<i>src/main.rs</i>&#160;ﬁle into scope with a&#160;&#160;use&#160;&#160;statement. Only library crates expose<br/>functions that other crates can use; binary crates are meant to be run on their own.<br/>
This is one of the reasons Rust projects that provide a binary have a straightforward<br/><i>src/main.rs</i>&#160;ﬁle that calls logic that lives in the&#160;<i>src/lib.rs</i>&#160;ﬁle. Using that structure, integration<br/>tests&#160;<i>can</i>&#160;test the library crate with&#160;&#160;use&#160;&#160;to make the important functionality available. If the<br/>important functionality works, the small amount of code in the&#160;<i>src/main.rs</i>&#160;ﬁle will work as<br/>well, and that small amount of code doesn’t need to be tested.<br/>
<a href="tests.html#294"><b>Summary</b></a><br/>
Rust’s testing features provide a way to specify how code should function to ensure it<br/>continues to work as you expect, even as you make changes. Unit tests exercise diﬀerent<br/>parts of a library separately and can test private implementation details. Integration tests<br/>check that many parts of the library work together correctly, and they use the library’s<br/>public API to test the code in the same way external code will use it. Even though Rust’s type<br/>
https://doc.rust-lang.org/book/print.html<br/>
294/627<br/>
<hr/>
<a name=295></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
system and ownership rules help prevent some kinds of bugs, tests are still important to<br/>reduce logic bugs having to do with how your code is expected to behave.<br/>
Let’s combine the knowledge you learned in this chapter and in previous chapters to work<br/>on a project!<br/>
https://doc.rust-lang.org/book/print.html<br/>
295/627<br/>
<hr/>
<a name=296></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#296"><b>An I/O Project: Building a Command Line<br/>Program</b></a><br/>
This chapter is a recap of the many skills you’ve learned so far and an exploration of a few<br/>more standard library features. We’ll build a command line tool that interacts with&#160;ﬁle and<br/>command line input/output to practice some of the Rust concepts you now have under your<br/>belt.<br/>
Rust’s speed, safety, single binary output, and cross-platform support make it an ideal<br/>language for creating command line tools, so for our project, we’ll make our own version of<br/>the classic command line search tool&#160;&#160;grep&#160;&#160;(<b>g</b>lobally search a&#160;<b>r</b>egular&#160;<b>e</b>xpression and&#160;<b>p</b>rint).<br/>In the simplest use case,&#160;&#160;grep&#160;&#160;searches a speciﬁed&#160;ﬁle for a speciﬁed string. To do so,&#160;&#160;grep<br/>takes as its arguments a&#160;ﬁle path and a string. Then it reads the&#160;ﬁle,&#160;ﬁnds lines in that&#160;ﬁle<br/>that contain the string argument, and prints those lines.<br/>
Along the way, we’ll show how to make our command line tool use the terminal features<br/>that many other command line tools use. We’ll read the value of an environment variable to<br/>allow the user to conﬁgure the behavior of our tool. We’ll also print error messages to the<br/>standard error console stream (&#160;stderr&#160;) instead of standard output (&#160;stdout&#160;), so, for<br/>example, the user can redirect successful output to a&#160;ﬁle while still seeing error messages<br/>onscreen.<br/>
One Rust community member, Andrew Gallant, has already created a fully featured, very<br/>fast version of&#160;&#160;grep&#160;, called&#160;&#160;ripgrep&#160;. By comparison, our version will be fairly simple, but<br/>this chapter will give you some of the background knowledge you need to understand a<br/>real-world project such as&#160;&#160;ripgrep&#160;.<br/>
Our&#160;&#160;grep&#160;&#160;project will combine a number of concepts you’ve learned so far:<br/>
Organizing code (using what you learned about modules in&#160;<a href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Chapter 7</a>)<br/>Using vectors and strings (collections,&#160;<a href="https://doc.rust-lang.org/book/ch08-00-common-collections.html">Chapter 8)<br/></a><a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">Handling errors (Chapter 9</a>)<br/>Using traits and lifetimes where appropriate (<a href="https://doc.rust-lang.org/book/ch10-00-generics.html">Chapter 10)<br/></a><a href="https://doc.rust-lang.org/book/ch11-00-testing.html">Writing tests (Chapter 11)</a><br/>
We’ll also brieﬂy introduce closures, iterators, and trait objects, which Chapters&#160;<a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">13&#160;and&#160;</a><a href="https://doc.rust-lang.org/book/ch17-00-oop.html">17<br/></a>will cover in detail.<br/>
https://doc.rust-lang.org/book/print.html<br/>
296/627<br/>
<hr/>
<a name=297></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#297"><b>Accepting Command Line Arguments</b></a><br/>
Let’s create a new project with, as always,&#160;&#160;cargo&#160;new&#160;. We’ll call our project&#160;&#160;minigrep&#160;&#160;to<br/>distinguish it from the&#160;&#160;grep&#160;&#160;tool that you might already have on your system.<br/>
$&#160;cargo&#160;new&#160;minigrep<br/>&#160;&#160;&#160;&#160;&#160;Created&#160;binary&#160;(application)&#160;`minigrep`&#160;project<br/>$&#160;cd&#160;minigrep<br/>
The&#160;ﬁrst task is to make&#160;&#160;minigrep&#160;&#160;accept its two command line arguments: the&#160;ﬁle path<br/>and a string to search for. That is, we want to be able to run our program with&#160;&#160;cargo&#160;run&#160;,<br/>two hyphens to indicate the following arguments are for our program rather than for<br/>
cargo&#160;, a string to search for, and a path to a&#160;ﬁle to search in, like so:<br/>
$&#160;cargo&#160;run&#160;--&#160;searchstring&#160;example-filename.txt<br/>
Right now, the program generated by&#160;&#160;cargo&#160;new&#160;&#160;cannot process arguments we give it.<br/><a href="https://crates.io/">Some existing libraries on&#160;crates.io&#160;can help with writing a program that accepts command<br/></a>line arguments, but because you’re just learning this concept, let’s implement this capability<br/>ourselves.<br/>
<a href="tests.html#297"><b>Reading&#160;the&#160;Argument&#160;Values</b></a><br/>
To enable&#160;&#160;minigrep&#160;&#160;to read the values of command line arguments we pass to it, we’ll need<br/>the&#160;&#160;std::env::args&#160;&#160;function provided in Rust’s standard library. This function returns an<br/>iterator of the command line arguments passed to&#160;&#160;minigrep&#160;. We’ll cover iterators fully in<br/><a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">Chapter 13. For now, you only need to know two details about iterators: iterators produce a<br/></a>series of values, and we can call the&#160;&#160;collect&#160;&#160;method on an iterator to turn it into a<br/>collection, such as a vector, that contains all the elements the iterator produces.<br/>
The code in Listing 12-1 allows your&#160;&#160;minigrep&#160;&#160;program to read any command line<br/>arguments passed to it and then collect the values into a vector.<br/>
Filename: src/main.rs<br/>
use&#160;std::env;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;args:&#160;Vec&lt;String&gt;&#160;=&#160;env::args().collect();<br/>&#160;&#160;&#160;&#160;dbg!(args);<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
297/627<br/>
<hr/>
<a name=298></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Listing&#160;12-1:&#160;Collecting&#160;the&#160;command&#160;line&#160;arguments&#160;into&#160;a&#160;vector&#160;and&#160;printing&#160;them</b><br/>
First, we bring the&#160;&#160;std::env&#160;&#160;module into scope with a&#160;&#160;use&#160;&#160;statement so we can use its<br/>
args&#160;&#160;function. Notice that the&#160;&#160;std::env::args&#160;&#160;function is nested in two levels of modules.<br/>
As we discussed in&#160;<a href="https://doc.rust-lang.org/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths">Chapter 7</a>, in cases where the desired function is nested in more than<br/>one module, we’ve chosen to bring the parent module into scope rather than the function.<br/>By doing so, we can easily use other functions from&#160;&#160;std::env&#160;. It’s also less ambiguous than<br/>adding&#160;&#160;use&#160;std::env::args&#160;&#160;and then calling the function with just&#160;&#160;args&#160;, because&#160;&#160;args<br/>might easily be mistaken for a function that’s deﬁned in the current module.<br/>
<a href="tests.html#298"><b>The&#160;</b>args<b>&#160;Function&#160;and&#160;Invalid&#160;Unicode</b></a><br/>
Note that&#160;&#160;std::env::args&#160;&#160;will panic if any argument contains invalid Unicode. If your<br/>program needs to accept arguments containing invalid Unicode, use<br/>
std::env::args_os&#160;&#160;instead. That function returns an iterator that produces<br/>OsString&#160;&#160;values instead of&#160;&#160;String&#160;&#160;values. We’ve chosen to use&#160;&#160;std::env::args<br/>
here for simplicity, because&#160;&#160;OsString&#160;&#160;values diﬀer per platform and are more<br/>complex to work with than&#160;&#160;String&#160;&#160;values.<br/>
On the&#160;ﬁrst line of&#160;&#160;main&#160;, we call&#160;&#160;env::args&#160;, and we immediately use&#160;&#160;collect&#160;&#160;to turn the<br/>iterator into a vector containing all the values produced by the iterator. We can use the<br/>
collect&#160;&#160;function to create many kinds of collections, so we explicitly annotate the type of<br/>args&#160;&#160;to specify that we want a vector of strings. Although we very rarely need to annotate<br/>
types in Rust,&#160;&#160;collect&#160;&#160;is one function you do often need to annotate because Rust isn’t<br/>able to infer the kind of collection you want.<br/>
Finally, we print the vector using the debug macro. Let’s try running the code&#160;ﬁrst with no<br/>arguments and then with two arguments:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.61s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/minigrep`<br/>[src/main.rs:5]&#160;args&#160;=&#160;[<br/>&#160;&#160;&#160;&#160;&#34;target/debug/minigrep&#34;,<br/>]<br/>
https://doc.rust-lang.org/book/print.html<br/>
298/627<br/>
<hr/>
<a name=299></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run&#160;--&#160;needle&#160;haystack<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;1.57s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/minigrep&#160;needle&#160;haystack`<br/>[src/main.rs:5]&#160;args&#160;=&#160;[<br/>&#160;&#160;&#160;&#160;&#34;target/debug/minigrep&#34;,<br/>&#160;&#160;&#160;&#160;&#34;needle&#34;,<br/>&#160;&#160;&#160;&#160;&#34;haystack&#34;,<br/>]<br/>
Notice that the&#160;ﬁrst value in the vector is&#160;&#160;&#34;target/debug/minigrep&#34;&#160;, which is the name of<br/>our binary. This matches the behavior of the arguments list in C, letting programs use the<br/>name by which they were invoked in their execution. It’s often convenient to have access to<br/>the program name in case you want to print it in messages or change behavior of the<br/>program based on what command line alias was used to invoke the program. But for the<br/>purposes of this chapter, we’ll ignore it and save only the two arguments we need.<br/>
<a href="tests.html#299"><b>Saving&#160;the&#160;Argument&#160;Values&#160;in&#160;Variables</b></a><br/>
The program is currently able to access the values speciﬁed as command line arguments.<br/>Now we need to save the values of the two arguments in variables so we can use the values<br/>throughout the rest of the program. We do that in Listing 12-2.<br/>
Filename: src/main.rs<br/>
use&#160;std::env;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;args:&#160;Vec&lt;String&gt;&#160;=&#160;env::args().collect();<br/>
&#160;&#160;&#160;&#160;let&#160;query&#160;=&#160;&amp;args[1];<br/>&#160;&#160;&#160;&#160;let&#160;file_path&#160;=&#160;&amp;args[2];<br/>
&#160;&#160;&#160;&#160;println!(&#34;Searching&#160;for&#160;{}&#34;,&#160;query);<br/>&#160;&#160;&#160;&#160;println!(&#34;In&#160;file&#160;{}&#34;,&#160;file_path);<br/>}<br/>
<b>Listing&#160;12-2:&#160;Creating&#160;variables&#160;to&#160;hold&#160;the&#160;query&#160;argument&#160;and&#160;ﬁle&#160;path&#160;argument</b><br/>
As we saw when we printed the vector, the program’s name takes up the&#160;ﬁrst value in the<br/>vector at&#160;&#160;args[0]&#160;, so we’re starting arguments at index&#160;&#160;1&#160;. The&#160;ﬁrst argument&#160;&#160;minigrep<br/>takes is the string we’re searching for, so we put a reference to the&#160;ﬁrst argument in the<br/>variable&#160;&#160;query&#160;. The second argument will be the&#160;ﬁle path, so we put a reference to the<br/>second argument in the variable&#160;&#160;file_path&#160;.<br/>
We temporarily print the values of these variables to prove that the code is working as we<br/>intend. Let’s run this program again with the arguments&#160;&#160;test&#160;&#160;and&#160;&#160;sample.txt&#160;:<br/>
https://doc.rust-lang.org/book/print.html<br/>
299/627<br/>
<hr/>
<a name=300></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run&#160;--&#160;test&#160;sample.txt<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.0s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/minigrep&#160;test&#160;sample.txt`<br/>Searching&#160;for&#160;test<br/>In&#160;file&#160;sample.txt<br/>
Great, the program is working! The values of the arguments we need are being saved into<br/>the right variables. Later we’ll add some error handling to deal with certain potential<br/>erroneous situations, such as when the user provides no arguments; for now, we’ll ignore<br/>that situation and work on adding&#160;ﬁle-reading capabilities instead.<br/>
https://doc.rust-lang.org/book/print.html<br/>
300/627<br/>
<hr/>
<a name=301></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#301"><b>Reading a File</b></a><br/>
Now we’ll add functionality to read the&#160;ﬁle speciﬁed in the&#160;&#160;file_path&#160;&#160;argument. First, we<br/>need a sample&#160;ﬁle to test it with: we’ll use a&#160;ﬁle with a small amount of text over multiple<br/>lines with some repeated words. Listing 12-3 has an Emily Dickinson poem that will work<br/>well! Create a&#160;ﬁle called&#160;<i>poem.txt</i>&#160;at the root level of your project, and enter the poem “I’m<br/>Nobody! Who are you?”<br/>
Filename: poem.txt<br/>
I'm&#160;nobody!&#160;Who&#160;are&#160;you?<br/>Are&#160;you&#160;nobody,&#160;too?<br/>Then&#160;there's&#160;a&#160;pair&#160;of&#160;us&#160;-&#160;don't&#160;tell!<br/>They'd&#160;banish&#160;us,&#160;you&#160;know.<br/>
How&#160;dreary&#160;to&#160;be&#160;somebody!<br/>How&#160;public,&#160;like&#160;a&#160;frog<br/>To&#160;tell&#160;your&#160;name&#160;the&#160;livelong&#160;day<br/>To&#160;an&#160;admiring&#160;bog!<br/>
<b>Listing&#160;12-3:&#160;A&#160;poem&#160;by&#160;Emily&#160;Dickinson&#160;makes&#160;a&#160;good&#160;test&#160;case</b><br/>
With the text in place, edit&#160;<i>src/main.rs</i>&#160;and add code to read the&#160;ﬁle, as shown in Listing 12-4.<br/>
Filename: src/main.rs<br/>
use&#160;std::env;<br/>use&#160;std::fs;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;println!(&#34;In&#160;file&#160;{}&#34;,&#160;file_path);<br/>
&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;fs::read_to_string(file_path)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;Should&#160;have&#160;been&#160;able&#160;to&#160;read&#160;the&#160;file&#34;);<br/>
&#160;&#160;&#160;&#160;println!(&#34;With&#160;text:\n{contents}&#34;);<br/>}<br/>
<b>Listing&#160;12-4:&#160;Reading&#160;the&#160;contents&#160;of&#160;the&#160;ﬁle&#160;speciﬁed&#160;by&#160;the&#160;second&#160;argument</b><br/>
First, we bring in a relevant part of the standard library with a&#160;&#160;use&#160;&#160;statement: we need<br/>
std::fs&#160;&#160;to handle&#160;ﬁles.<br/>
In&#160;&#160;main&#160;, the new statement&#160;&#160;fs::read_to_string&#160;&#160;takes the&#160;&#160;file_path&#160;, opens that&#160;ﬁle, and<br/>returns a&#160;&#160;std::io::Result&lt;String&gt;&#160;&#160;of the&#160;ﬁle’s contents.<br/>
https://doc.rust-lang.org/book/print.html<br/>
301/627<br/>
<hr/>
<a name=302></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
After that, we again add a temporary&#160;&#160;println!&#160;&#160;statement that prints the value of<br/>
contents&#160;&#160;after the&#160;ﬁle is read, so we can check that the program is working so far.<br/>
Let’s run this code with any string as the&#160;ﬁrst command line argument (because we haven’t<br/>implemented the searching part yet) and the&#160;<i>poem.txt</i>&#160;ﬁle as the second argument:<br/>
$&#160;cargo&#160;run&#160;--&#160;the&#160;poem.txt<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.0s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/minigrep&#160;the&#160;poem.txt`<br/>Searching&#160;for&#160;the<br/>In&#160;file&#160;poem.txt<br/>With&#160;text:<br/>I'm&#160;nobody!&#160;Who&#160;are&#160;you?<br/>Are&#160;you&#160;nobody,&#160;too?<br/>Then&#160;there's&#160;a&#160;pair&#160;of&#160;us&#160;-&#160;don't&#160;tell!<br/>They'd&#160;banish&#160;us,&#160;you&#160;know.<br/>
How&#160;dreary&#160;to&#160;be&#160;somebody!<br/>How&#160;public,&#160;like&#160;a&#160;frog<br/>To&#160;tell&#160;your&#160;name&#160;the&#160;livelong&#160;day<br/>To&#160;an&#160;admiring&#160;bog!<br/>
Great! The code read and then printed the contents of the&#160;ﬁle. But the code has a few&#160;ﬂaws.<br/>At the moment, the&#160;&#160;main&#160;&#160;function has multiple responsibilities: generally, functions are<br/>clearer and easier to maintain if each function is responsible for only one idea. The other<br/>problem is that we’re not handling errors as well as we could. The program is still small, so<br/>these&#160;ﬂaws aren’t a big problem, but as the program grows, it will be harder to&#160;ﬁx them<br/>cleanly. It’s good practice to begin refactoring early on when developing a program, because<br/>it’s much easier to refactor smaller amounts of code. We’ll do that next.<br/>
https://doc.rust-lang.org/book/print.html<br/>
302/627<br/>
<hr/>
<a name=303></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#303"><b>Refactoring to Improve Modularity and Error Handling</b></a><br/>
To improve our program, we’ll&#160;ﬁx four problems that have to do with the program’s<br/>structure and how it’s handling potential errors. First, our&#160;&#160;main&#160;&#160;function now performs two<br/>tasks: it parses arguments and reads&#160;ﬁles. As our program grows, the number of separate<br/>tasks the&#160;&#160;main&#160;&#160;function handles will increase. As a function gains responsibilities, it<br/>becomes more diﬃcult to reason about, harder to test, and harder to change without<br/>breaking one of its parts. It’s best to separate functionality so each function is responsible<br/>for one task.<br/>
This issue also ties into the second problem: although&#160;&#160;query&#160;&#160;and&#160;&#160;file_path&#160;&#160;are<br/>conﬁguration variables to our program, variables like&#160;&#160;contents&#160;&#160;are used to perform the<br/>program’s logic. The longer&#160;&#160;main&#160;&#160;becomes, the more variables we’ll need to bring into<br/>scope; the more variables we have in scope, the harder it will be to keep track of the<br/>purpose of each. It’s best to group the conﬁguration variables into one structure to make<br/>their purpose clear.<br/>
The third problem is that we’ve used&#160;&#160;expect&#160;&#160;to print an error message when reading the<br/>ﬁle fails, but the error message just prints&#160;&#160;Should&#160;have&#160;been&#160;able&#160;to&#160;read&#160;the&#160;file&#160;.<br/>Reading a&#160;ﬁle can fail in a number of ways: for example, the&#160;ﬁle could be missing, or we<br/>might not have permission to open it. Right now, regardless of the situation, we’d print the<br/>same error message for everything, which wouldn’t give the user any information!<br/>
Fourth, we use&#160;&#160;expect&#160;&#160;repeatedly to handle diﬀerent errors, and if the user runs our<br/>program without specifying enough arguments, they’ll get an&#160;&#160;index&#160;out&#160;of&#160;bounds&#160;&#160;error<br/>from Rust that doesn’t clearly explain the problem. It would be best if all the error-handling<br/>code were in one place so future maintainers had only one place to consult the code if the<br/>error-handling logic needed to change. Having all the error-handling code in one place will<br/>also ensure that we’re printing messages that will be meaningful to our end users.<br/>
Let’s address these four problems by refactoring our project.<br/>
<a href="tests.html#303"><b>Separation&#160;of&#160;Concerns&#160;for&#160;Binary&#160;Projects</b></a><br/>
The organizational problem of allocating responsibility for multiple tasks to the&#160;&#160;main<br/>function is common to many binary projects. As a result, the Rust community has developed<br/>guidelines for splitting the separate concerns of a binary program when&#160;&#160;main&#160;&#160;starts getting<br/>large. This process has the following steps:<br/>
Split your program into a&#160;<i>main.rs</i>&#160;and a&#160;<i>lib.rs</i>&#160;and move your program’s logic to&#160;<i>lib.rs</i>.<br/>As long as your command line parsing logic is small, it can remain in&#160;<i>main.rs</i>.<br/>
https://doc.rust-lang.org/book/print.html<br/>
303/627<br/>
<hr/>
<a name=304></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
When the command line parsing logic starts getting complicated, extract it from<br/><i>main.rs</i>&#160;and move it to&#160;<i>lib.rs</i>.<br/>
The responsibilities that remain in the&#160;&#160;main&#160;&#160;function after this process should be limited to<br/>the following:<br/>
Calling the command line parsing logic with the argument values<br/>Setting up any other conﬁguration<br/>Calling a&#160;&#160;run&#160;&#160;function in&#160;<i>lib.rs<br/></i>Handling the error if&#160;&#160;run&#160;&#160;returns an error<br/>
This pattern is about separating concerns:&#160;<i>main.rs</i>&#160;handles running the program, and&#160;<i>lib.rs<br/></i>handles all the logic of the task at hand. Because you can’t test the&#160;&#160;main&#160;&#160;function directly,<br/>this structure lets you test all of your program’s logic by moving it into functions in&#160;<i>lib.rs</i>. The<br/>code that remains in&#160;<i>main.rs</i>&#160;will be small enough to verify its correctness by reading it. Let’s<br/>rework our program by following this process.<br/>
<a href="tests.html#304"><b>Extracting the Argument Parser</b></a><br/>
We’ll extract the functionality for parsing arguments into a function that&#160;&#160;main&#160;&#160;will call to<br/>prepare for moving the command line parsing logic to&#160;<i>src/lib.rs</i>. Listing 12-5 shows the new<br/>start of&#160;&#160;main&#160;&#160;that calls a new function&#160;&#160;parse_config&#160;, which we’ll deﬁne in&#160;<i>src/main.rs</i>&#160;for<br/>the moment.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;args:&#160;Vec&lt;String&gt;&#160;=&#160;env::args().collect();<br/>
&#160;&#160;&#160;&#160;let&#160;(query,&#160;file_path)&#160;=&#160;parse_config(&amp;args);<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
fn&#160;parse_config(args:&#160;&amp;[String])&#160;-&gt;&#160;(&amp;str,&#160;&amp;str)&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;query&#160;=&#160;&amp;args[1];<br/>&#160;&#160;&#160;&#160;let&#160;file_path&#160;=&#160;&amp;args[2];<br/>
&#160;&#160;&#160;&#160;(query,&#160;file_path)<br/>}<br/>
<b>Listing&#160;12-5:&#160;Extracting&#160;a&#160;&#160;</b>parse_config&#160;<b>&#160;function&#160;from&#160;&#160;</b>main<br/>
We’re still collecting the command line arguments into a vector, but instead of assigning the<br/>argument value at index 1 to the variable&#160;&#160;query&#160;&#160;and the argument value at index 2 to the<br/>variable&#160;&#160;file_path&#160;&#160;within the&#160;&#160;main&#160;&#160;function, we pass the whole vector to the<br/>
parse_config&#160;&#160;function. The&#160;&#160;parse_config&#160;&#160;function then holds the logic that determines<br/>
which argument goes in which variable and passes the values back to&#160;&#160;main&#160;. We still create<br/>
https://doc.rust-lang.org/book/print.html<br/>
304/627<br/>
<hr/>
<a name=305></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
the&#160;&#160;query&#160;&#160;and&#160;&#160;file_path&#160;&#160;variables in&#160;&#160;main&#160;, but&#160;&#160;main&#160;&#160;no longer has the responsibility of<br/>determining how the command line arguments and variables correspond.<br/>
This rework may seem like overkill for our small program, but we’re refactoring in small,<br/>incremental steps. After making this change, run the program again to verify that the<br/>argument parsing still works. It’s good to check your progress often, to help identify the<br/>cause of problems when they occur.<br/>
<a href="tests.html#305"><b>Grouping Conﬁguration Values</b></a><br/>
We can take another small step to improve the&#160;&#160;parse_config&#160;&#160;function further. At the<br/>moment, we’re returning a tuple, but then we immediately break that tuple into individual<br/>parts again. This is a sign that perhaps we don’t have the right abstraction yet.<br/>
Another indicator that shows there’s room for improvement is the&#160;&#160;config&#160;&#160;part of<br/>
parse_config&#160;, which implies that the two values we return are related and are both part of<br/>
one conﬁguration value. We’re not currently conveying this meaning in the structure of the<br/>data other than by grouping the two values into a tuple; we’ll instead put the two values into<br/>one struct and give each of the struct&#160;ﬁelds a meaningful name. Doing so will make it easier<br/>for future maintainers of this code to understand how the diﬀerent values relate to each<br/>other and what their purpose is.<br/>
Listing 12-6 shows the improvements to the&#160;&#160;parse_config&#160;&#160;function.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
305/627<br/>
<hr/>
<a name=306></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;args:&#160;Vec&lt;String&gt;&#160;=&#160;env::args().collect();<br/>
&#160;&#160;&#160;&#160;let&#160;config&#160;=&#160;parse_config(&amp;args);<br/>
&#160;&#160;&#160;&#160;println!(&#34;Searching&#160;for&#160;{}&#34;,&#160;config.query);<br/>&#160;&#160;&#160;&#160;println!(&#34;In&#160;file&#160;{}&#34;,&#160;config.file_path);<br/>
&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;fs::read_to_string(config.file_path)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;Should&#160;have&#160;been&#160;able&#160;to&#160;read&#160;the&#160;file&#34;);<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
struct&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;query:&#160;String,<br/>&#160;&#160;&#160;&#160;file_path:&#160;String,<br/>}<br/>
fn&#160;parse_config(args:&#160;&amp;[String])&#160;-&gt;&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;query&#160;=&#160;args[1].clone();<br/>&#160;&#160;&#160;&#160;let&#160;file_path&#160;=&#160;args[2].clone();<br/>
&#160;&#160;&#160;&#160;Config&#160;{&#160;query,&#160;file_path&#160;}<br/>}<br/>
<b>Listing&#160;12-6:&#160;Refactoring&#160;&#160;</b>parse_config&#160;<b>&#160;to&#160;return&#160;an&#160;instance&#160;of&#160;a&#160;&#160;</b>Config&#160;<b>&#160;struct</b><br/>
We’ve added a struct named&#160;&#160;Config&#160;&#160;deﬁned to have&#160;ﬁelds named&#160;&#160;query&#160;&#160;and&#160;&#160;file_path&#160;.<br/>The signature of&#160;&#160;parse_config&#160;&#160;now indicates that it returns a&#160;&#160;Config&#160;&#160;value. In the body of<br/>
parse_config&#160;, where we used to return string slices that reference&#160;&#160;String&#160;&#160;values in&#160;&#160;args&#160;,<br/>
we now deﬁne&#160;&#160;Config&#160;&#160;to contain owned&#160;&#160;String&#160;&#160;values. The&#160;&#160;args&#160;&#160;variable in&#160;&#160;main&#160;&#160;is the<br/>owner of the argument values and is only letting the&#160;&#160;parse_config&#160;&#160;function borrow them,<br/>which means we’d violate Rust’s borrowing rules if&#160;&#160;Config&#160;&#160;tried to take ownership of the<br/>values in&#160;&#160;args&#160;.<br/>
There are a number of ways we could manage the&#160;&#160;String&#160;&#160;data; the easiest, though<br/>somewhat ineﬃcient, route is to call the&#160;&#160;clone&#160;&#160;method on the values. This will make a full<br/>copy of the data for the&#160;&#160;Config&#160;&#160;instance to own, which takes more time and memory than<br/>storing a reference to the string data. However, cloning the data also makes our code very<br/>straightforward because we don’t have to manage the lifetimes of the references; in this<br/>circumstance, giving up a little performance to gain simplicity is a worthwhile trade-oﬀ.<br/>
<a href="tests.html#306"><b>The&#160;Trade-Oﬀs&#160;of&#160;Using&#160;</b>clone</a><br/>
There’s a tendency among many Rustaceans to avoid using&#160;&#160;clone&#160;&#160;to&#160;ﬁx ownership<br/><a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">problems because of its runtime cost. In&#160;Chapter 13, you’ll learn how to use more<br/></a>eﬃcient methods in this type of situation. But for now, it’s okay to copy a few strings to<br/>
https://doc.rust-lang.org/book/print.html<br/>
306/627<br/>
<hr/>
<a name=307></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
continue making progress because you’ll make these copies only once and your&#160;ﬁle<br/>path and query string are very small. It’s better to have a working program that’s a bit<br/>ineﬃcient than to try to hyperoptimize code on your&#160;ﬁrst pass. As you become more<br/>experienced with Rust, it’ll be easier to start with the most eﬃcient solution, but for<br/>now, it’s perfectly acceptable to call&#160;&#160;clone&#160;.<br/>
We’ve updated&#160;&#160;main&#160;&#160;so it places the instance of&#160;&#160;Config&#160;&#160;returned by&#160;&#160;parse_config&#160;&#160;into a<br/>variable named&#160;&#160;config&#160;, and we updated the code that previously used the separate&#160;&#160;query<br/>and&#160;&#160;file_path&#160;&#160;variables so it now uses the&#160;ﬁelds on the&#160;&#160;Config&#160;&#160;struct instead.<br/>
Now our code more clearly conveys that&#160;&#160;query&#160;&#160;and&#160;&#160;file_path&#160;&#160;are related and that their<br/>purpose is to conﬁgure how the program will work. Any code that uses these values knows<br/>to&#160;ﬁnd them in the&#160;&#160;config&#160;&#160;instance in the&#160;ﬁelds named for their purpose.<br/>
<a href="tests.html#307"><b>Creating a Constructor for&#160;</b>Config</a><br/>
So far, we’ve extracted the logic responsible for parsing the command line arguments from<br/>
main&#160;&#160;and placed it in the&#160;&#160;parse_config&#160;&#160;function. Doing so helped us to see that the&#160;&#160;query<br/>
and&#160;&#160;file_path&#160;&#160;values were related and that relationship should be conveyed in our code.<br/>We then added a&#160;&#160;Config&#160;&#160;struct to name the related purpose of&#160;&#160;query&#160;&#160;and&#160;&#160;file_path&#160;&#160;and<br/>to be able to return the values’ names as struct&#160;ﬁeld names from the&#160;&#160;parse_config<br/>function.<br/>
So now that the purpose of the&#160;&#160;parse_config&#160;&#160;function is to create a&#160;&#160;Config&#160;&#160;instance, we<br/>can change&#160;&#160;parse_config&#160;&#160;from a plain function to a function named&#160;&#160;new&#160;&#160;that is associated<br/>with the&#160;&#160;Config&#160;&#160;struct. Making this change will make the code more idiomatic. We can<br/>create instances of types in the standard library, such as&#160;&#160;String&#160;, by calling&#160;&#160;String::new&#160;.<br/>Similarly, by changing&#160;&#160;parse_config&#160;&#160;into a&#160;&#160;new&#160;&#160;function associated with&#160;&#160;Config&#160;, we’ll be<br/>able to create instances of&#160;&#160;Config&#160;&#160;by calling&#160;&#160;Config::new&#160;. Listing 12-7 shows the changes<br/>we need to make.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
307/627<br/>
<hr/>
<a name=308></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;args:&#160;Vec&lt;String&gt;&#160;=&#160;env::args().collect();<br/>
&#160;&#160;&#160;&#160;let&#160;config&#160;=&#160;Config::new(&amp;args);<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
//&#160;--snip--<br/>
impl&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;new(args:&#160;&amp;[String])&#160;-&gt;&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;query&#160;=&#160;args[1].clone();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;file_path&#160;=&#160;args[2].clone();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Config&#160;{&#160;query,&#160;file_path&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;12-7:&#160;Changing&#160;&#160;</b>parse_config&#160;<b>&#160;into&#160;&#160;</b>Config::new<br/>
We’ve updated&#160;&#160;main&#160;&#160;where we were calling&#160;&#160;parse_config&#160;&#160;to instead call&#160;&#160;Config::new&#160;.<br/>We’ve changed the name of&#160;&#160;parse_config&#160;&#160;to&#160;&#160;new&#160;&#160;and moved it within an&#160;&#160;impl&#160;&#160;block,<br/>which associates the&#160;&#160;new&#160;&#160;function with&#160;&#160;Config&#160;. Try compiling this code again to make sure<br/>it works.<br/>
<a href="tests.html#308"><b>Fixing&#160;the&#160;Error&#160;Handling</b></a><br/>
Now we’ll work on&#160;ﬁxing our error handling. Recall that attempting to access the values in<br/>the&#160;&#160;args&#160;&#160;vector at index 1 or index 2 will cause the program to panic if the vector contains<br/>fewer than three items. Try running the program without any arguments; it will look like<br/>this:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.0s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/minigrep`<br/>thread&#160;'main'&#160;panicked&#160;at&#160;'index&#160;out&#160;of&#160;bounds:&#160;the&#160;len&#160;is&#160;1&#160;but&#160;the&#160;index&#160;is&#160;<br/>1',&#160;src/main.rs:27:21<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
The line&#160;&#160;index&#160;out&#160;of&#160;bounds:&#160;the&#160;len&#160;is&#160;1&#160;but&#160;the&#160;index&#160;is&#160;1&#160;&#160;is an error message<br/>intended for programmers. It won’t help our end users understand what they should do<br/>instead. Let’s&#160;ﬁx that now.<br/>
https://doc.rust-lang.org/book/print.html<br/>
308/627<br/>
<hr/>
<a name=309></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#309"><b>Improving the Error Message</b></a><br/>
In Listing 12-8, we add a check in the&#160;&#160;new&#160;&#160;function that will verify that the slice is long<br/>enough before accessing index 1 and 2. If the slice isn’t long enough, the program panics<br/>and displays a better error message.<br/>
Filename: src/main.rs<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;fn&#160;new(args:&#160;&amp;[String])&#160;-&gt;&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;args.len()&#160;&lt;&#160;3&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic!(&#34;not&#160;enough&#160;arguments&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
<b>Listing&#160;12-8:&#160;Adding&#160;a&#160;check&#160;for&#160;the&#160;number&#160;of&#160;arguments</b><br/>
<a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">This code is similar to&#160;the&#160;&#160;Guess::new&#160;&#160;function we wrote in Listing 9-13</a>, where we called<br/>
panic!&#160;&#160;when the&#160;&#160;value&#160;&#160;argument was out of the range of valid values. Instead of checking<br/>
for a range of values here, we’re checking that the length of&#160;&#160;args&#160;&#160;is at least 3 and the rest<br/>of the function can operate under the assumption that this condition has been met. If&#160;&#160;args<br/>has fewer than three items, this condition will be true, and we call the&#160;&#160;panic!&#160;&#160;macro to end<br/>the program immediately.<br/>
With these extra few lines of code in&#160;&#160;new&#160;, let’s run the program without any arguments<br/>again to see what the error looks like now:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.0s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/minigrep`<br/>thread&#160;'main'&#160;panicked&#160;at&#160;'not&#160;enough&#160;arguments',&#160;src/main.rs:26:13<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
This output is better: we now have a reasonable error message. However, we also have<br/>extraneous information we don’t want to give to our users. Perhaps using the technique we<br/>used in Listing 9-13 isn’t the best to use here: a call to&#160;&#160;panic!&#160;&#160;is more appropriate for a<br/>programming problem than a usage problem,&#160;<a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">as discussed in Chapter 9. Instead, we’ll use<br/></a>the other technique you learned about in Chapter 9—<a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html">returning a&#160;&#160;Result&#160;&#160;that indicates<br/></a>either success or an error.<br/>
<a href="tests.html#309"><b>Returning a&#160;</b>Result<b>&#160;Instead of Calling&#160;</b>panic!</a><br/>
We can instead return a&#160;&#160;Result&#160;&#160;value that will contain a&#160;&#160;Config&#160;&#160;instance in the successful<br/>case and will describe the problem in the error case. We’re also going to change the<br/>function name from&#160;&#160;new&#160;&#160;to&#160;&#160;build&#160;&#160;because many programmers expect&#160;&#160;new&#160;&#160;functions to<br/>never fail. When&#160;&#160;Config::build&#160;&#160;is communicating to&#160;&#160;main&#160;, we can use the&#160;&#160;Result&#160;&#160;type to<br/>
https://doc.rust-lang.org/book/print.html<br/>
309/627<br/>
<hr/>
<a name=310></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
signal there was a problem. Then we can change&#160;&#160;main&#160;&#160;to convert an&#160;&#160;Err&#160;&#160;variant into a<br/>more practical error for our users without the surrounding text about&#160;&#160;thread&#160;'main'&#160;&#160;and<br/>
RUST_BACKTRACE&#160;&#160;that a call to&#160;&#160;panic!&#160;&#160;causes.<br/>
Listing 12-9 shows the changes we need to make to the return value of the function we’re<br/>now calling&#160;&#160;Config::build&#160;&#160;and the body of the function needed to return a&#160;&#160;Result&#160;. Note<br/>that this won’t compile until we update&#160;&#160;main&#160;&#160;as well, which we’ll do in the next listing.<br/>
Filename: src/main.rs<br/>
impl&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;build(args:&#160;&amp;[String])&#160;-&gt;&#160;Result&lt;Config,&#160;&amp;'static&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;args.len()&#160;&lt;&#160;3&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;Err(&#34;not&#160;enough&#160;arguments&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;query&#160;=&#160;args[1].clone();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;file_path&#160;=&#160;args[2].clone();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(Config&#160;{&#160;query,&#160;file_path&#160;})<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;12-9:&#160;Returning&#160;a&#160;&#160;</b>Result&#160;<b>&#160;from&#160;&#160;</b>Config::build<br/>
Our&#160;&#160;build&#160;&#160;function returns a&#160;&#160;Result&#160;&#160;with a&#160;&#160;Config&#160;&#160;instance in the success case and a<br/>
&amp;'static&#160;str&#160;&#160;in the error case. Our error values will always be string literals that have the<br/>'static&#160;&#160;lifetime.<br/>
We’ve made two changes in the body of the function: instead of calling&#160;&#160;panic!&#160;&#160;when the<br/>user doesn’t pass enough arguments, we now return an&#160;&#160;Err&#160;&#160;value, and we’ve wrapped the<br/>
Config&#160;&#160;return value in an&#160;&#160;Ok&#160;. These changes make the function conform to its new type<br/>
signature.<br/>
Returning an&#160;&#160;Err&#160;&#160;value from&#160;&#160;Config::build&#160;&#160;allows the&#160;&#160;main&#160;&#160;function to handle the<br/>
Result&#160;&#160;value returned from the&#160;&#160;build&#160;&#160;function and exit the process more cleanly in the<br/>
error case.<br/>
<a href="tests.html#310"><b>Calling&#160;</b>Config::build<b>&#160;and Handling Errors</b></a><br/>
To handle the error case and print a user-friendly message, we need to update&#160;&#160;main&#160;&#160;to<br/>handle the&#160;&#160;Result&#160;&#160;being returned by&#160;&#160;Config::build&#160;, as shown in Listing 12-10. We’ll also<br/>take the responsibility of exiting the command line tool with a nonzero error code away<br/>from&#160;&#160;panic!&#160;&#160;and instead implement it by hand. A nonzero exit status is a convention to<br/>signal to the process that called our program that the program exited with an error state.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
310/627<br/>
<hr/>
<a name=311></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::process;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;args:&#160;Vec&lt;String&gt;&#160;=&#160;env::args().collect();<br/>
&#160;&#160;&#160;&#160;let&#160;config&#160;=&#160;Config::build(&amp;args).unwrap_or_else(|err|&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Problem&#160;parsing&#160;arguments:&#160;{err}&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;process::exit(1);<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
<b>Listing&#160;12-10:&#160;Exiting&#160;with&#160;an&#160;error&#160;code&#160;if&#160;building&#160;a&#160;&#160;</b>Config&#160;<b>&#160;fails</b><br/>
In this listing, we’ve used a method we haven’t covered in detail yet:&#160;&#160;unwrap_or_else&#160;, which<br/>is deﬁned on&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;by the standard library. Using&#160;&#160;unwrap_or_else&#160;&#160;allows us to<br/>deﬁne some custom, non-&#160;panic!&#160;&#160;error handling. If the&#160;&#160;Result&#160;&#160;is an&#160;&#160;Ok&#160;&#160;value, this<br/>method’s behavior is similar to&#160;&#160;unwrap&#160;: it returns the inner value&#160;&#160;Ok&#160;&#160;is wrapping. However,<br/>if the value is an&#160;&#160;Err&#160;&#160;value, this method calls the code in the&#160;<i>closure</i>, which is an<br/>anonymous function we deﬁne and pass as an argument to&#160;&#160;unwrap_or_else&#160;. We’ll cover<br/><a href="https://doc.rust-lang.org/book/ch13-00-functional-features.html">closures in more detail in&#160;Chapter 13. For now, you just need to know that&#160;&#160;</a>unwrap_or_else<br/>will pass the inner value of the&#160;&#160;Err&#160;, which in this case is the static string&#160;&#160;&#34;not&#160;enough&#160;<br/>arguments&#34;&#160;&#160;that we added in Listing 12-9, to our closure in the argument&#160;&#160;err&#160;&#160;that appears<br/>between the vertical pipes. The code in the closure can then use the&#160;&#160;err&#160;&#160;value when it<br/>runs.<br/>
We’ve added a new&#160;&#160;use&#160;&#160;line to bring&#160;&#160;process&#160;&#160;from the standard library into scope. The<br/>code in the closure that will be run in the error case is only two lines: we print the&#160;&#160;err&#160;&#160;value<br/>and then call&#160;&#160;process::exit&#160;. The&#160;&#160;process::exit&#160;&#160;function will stop the program<br/>immediately and return the number that was passed as the exit status code. This is similar<br/>to the&#160;&#160;panic!&#160;-based handling we used in Listing 12-8, but we no longer get all the extra<br/>output. Let’s try it:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.48s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/minigrep`<br/>Problem&#160;parsing&#160;arguments:&#160;not&#160;enough&#160;arguments<br/>
Great! This output is much friendlier for our users.<br/>
<a href="tests.html#311"><b>Extracting&#160;Logic&#160;from&#160;</b>main</a><br/>
Now that we’ve&#160;ﬁnished refactoring the conﬁguration parsing, let’s turn to the program’s<br/><a href="https://doc.rust-lang.org/book/ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">logic. As we stated in&#160;“Separation of Concerns for Binary Projects”</a>, we’ll extract a function<br/>named&#160;&#160;run&#160;&#160;that will hold all the logic currently in the&#160;&#160;main&#160;&#160;function that isn’t involved with<br/>
https://doc.rust-lang.org/book/print.html<br/>
311/627<br/>
<hr/>
<a name=312></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
setting up conﬁguration or handling errors. When we’re done,&#160;&#160;main&#160;&#160;will be concise and<br/>easy to verify by inspection, and we’ll be able to write tests for all the other logic.<br/>
Listing 12-11 shows the extracted&#160;&#160;run&#160;&#160;function. For now, we’re just making the small,<br/>incremental improvement of extracting the function. We’re still deﬁning the function in<br/><i>src/main.rs</i>.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;println!(&#34;Searching&#160;for&#160;{}&#34;,&#160;config.query);<br/>&#160;&#160;&#160;&#160;println!(&#34;In&#160;file&#160;{}&#34;,&#160;config.file_path);<br/>
&#160;&#160;&#160;&#160;run(config);<br/>}<br/>
fn&#160;run(config:&#160;Config)&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;fs::read_to_string(config.file_path)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.expect(&#34;Should&#160;have&#160;been&#160;able&#160;to&#160;read&#160;the&#160;file&#34;);<br/>
&#160;&#160;&#160;&#160;println!(&#34;With&#160;text:\n{contents}&#34;);<br/>}<br/>
//&#160;--snip--<br/>
<b>Listing&#160;12-11:&#160;Extracting&#160;a&#160;&#160;</b>run&#160;<b>&#160;function&#160;containing&#160;the&#160;rest&#160;of&#160;the&#160;program&#160;logic</b><br/>
The&#160;&#160;run&#160;&#160;function now contains all the remaining logic from&#160;&#160;main&#160;, starting from reading the<br/>ﬁle. The&#160;&#160;run&#160;&#160;function takes the&#160;&#160;Config&#160;&#160;instance as an argument.<br/>
<a href="tests.html#312"><b>Returning Errors from the&#160;</b>run<b>&#160;Function</b></a><br/>
With the remaining program logic separated into the&#160;&#160;run&#160;&#160;function, we can improve the<br/>error handling, as we did with&#160;&#160;Config::build&#160;&#160;in Listing 12-9. Instead of allowing the<br/>program to panic by calling&#160;&#160;expect&#160;, the&#160;&#160;run&#160;&#160;function will return a&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;when<br/>something goes wrong. This will let us further consolidate the logic around handling errors<br/>into&#160;&#160;main&#160;&#160;in a user-friendly way. Listing 12-12 shows the changes we need to make to the<br/>signature and body of&#160;&#160;run&#160;.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
312/627<br/>
<hr/>
<a name=313></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::error::Error;<br/>
//&#160;--snip--<br/>
fn&#160;run(config:&#160;Config)&#160;-&gt;&#160;Result&lt;(),&#160;Box&lt;dyn&#160;Error&gt;&gt;&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;fs::read_to_string(config.file_path)?;<br/>
&#160;&#160;&#160;&#160;println!(&#34;With&#160;text:\n{contents}&#34;);<br/>
&#160;&#160;&#160;&#160;Ok(())<br/>}<br/>
<b>Listing&#160;12-12:&#160;Changing&#160;the&#160;&#160;</b>run&#160;<b>&#160;function&#160;to&#160;return&#160;&#160;</b>Result<br/>
We’ve made three signiﬁcant changes here. First, we changed the return type of the&#160;&#160;run<br/>function to&#160;&#160;Result&lt;(),&#160;Box&lt;dyn&#160;Error&gt;&gt;&#160;. This function previously returned the unit type,<br/>
()&#160;, and we keep that as the value returned in the&#160;&#160;Ok&#160;&#160;case.<br/>
For the error type, we used the&#160;<i>trait object</i>&#160;&#160;Box&lt;dyn&#160;Error&gt;&#160;&#160;(and we’ve brought<br/>
std::error::Error&#160;&#160;into scope with a&#160;&#160;use&#160;&#160;statement at the top). We’ll cover trait objects in<br/>
<a href="https://doc.rust-lang.org/book/ch17-00-oop.html">Chapter 17. For now, just know that&#160;&#160;</a>Box&lt;dyn&#160;Error&gt;&#160;&#160;means the function will return a type<br/>that implements the&#160;&#160;Error&#160;&#160;trait, but we don’t have to specify what particular type the<br/>return value will be. This gives us&#160;ﬂexibility to return error values that may be of diﬀerent<br/>types in diﬀerent error cases. The&#160;&#160;dyn&#160;&#160;keyword is short for “dynamic.”<br/>
Second, we’ve removed the call to&#160;&#160;expect&#160;&#160;in favor of the&#160;&#160;?&#160;&#160;operator, as we talked about in<br/><a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">Chapter 9. Rather than&#160;&#160;</a>panic!&#160;&#160;on an error,&#160;&#160;?&#160;&#160;will return the error value from the current<br/>function for the caller to handle.<br/>
Third, the&#160;&#160;run&#160;&#160;function now returns an&#160;&#160;Ok&#160;&#160;value in the success case. We’ve declared the<br/>
run&#160;&#160;function’s success type as&#160;&#160;()&#160;&#160;in the signature, which means we need to wrap the unit<br/>
type value in the&#160;&#160;Ok&#160;&#160;value. This&#160;&#160;Ok(())&#160;&#160;syntax might look a bit strange at&#160;ﬁrst, but using<br/>
()&#160;&#160;like this is the idiomatic way to indicate that we’re calling&#160;&#160;run&#160;&#160;for its side eﬀects only; it<br/>
doesn’t return a value we need.<br/>
When you run this code, it will compile but will display a warning:<br/>
https://doc.rust-lang.org/book/print.html<br/>
313/627<br/>
<hr/>
<a name=314></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run&#160;the&#160;poem.txt<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>warning:&#160;unused&#160;`Result`&#160;that&#160;must&#160;be&#160;used<br/>&#160;&#160;--&gt;&#160;src/main.rs:19:5<br/>&#160;&#160;&#160;|<br/>19&#160;|&#160;&#160;&#160;&#160;&#160;run(config);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^<br/>&#160;&#160;&#160;|<br/>&#160;&#160;&#160;=&#160;note:&#160;this&#160;`Result`&#160;may&#160;be&#160;an&#160;`Err`&#160;variant,&#160;which&#160;should&#160;be&#160;handled<br/>&#160;&#160;&#160;=&#160;note:&#160;`#[warn(unused_must_use)]`&#160;on&#160;by&#160;default<br/>
warning:&#160;`minigrep`&#160;(bin&#160;&#34;minigrep&#34;)&#160;generated&#160;1&#160;warning<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.71s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/minigrep&#160;the&#160;poem.txt`<br/>Searching&#160;for&#160;the<br/>In&#160;file&#160;poem.txt<br/>With&#160;text:<br/>I'm&#160;nobody!&#160;Who&#160;are&#160;you?<br/>Are&#160;you&#160;nobody,&#160;too?<br/>Then&#160;there's&#160;a&#160;pair&#160;of&#160;us&#160;-&#160;don't&#160;tell!<br/>They'd&#160;banish&#160;us,&#160;you&#160;know.<br/>
How&#160;dreary&#160;to&#160;be&#160;somebody!<br/>How&#160;public,&#160;like&#160;a&#160;frog<br/>To&#160;tell&#160;your&#160;name&#160;the&#160;livelong&#160;day<br/>To&#160;an&#160;admiring&#160;bog!<br/>
Rust tells us that our code ignored the&#160;&#160;Result&#160;&#160;value and the&#160;&#160;Result&#160;&#160;value might indicate<br/>that an error occurred. But we’re not checking to see whether or not there was an error, and<br/>the compiler reminds us that we probably meant to have some error-handling code here!<br/>Let’s rectify that problem now.<br/>
<a href="tests.html#314"><b>Handling Errors Returned from&#160;</b>run<b>&#160;in&#160;</b>main</a><br/>
We’ll check for errors and handle them using a technique similar to one we used with<br/>
Config::build&#160;&#160;in Listing 12-10, but with a slight diﬀerence:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;println!(&#34;Searching&#160;for&#160;{}&#34;,&#160;config.query);<br/>&#160;&#160;&#160;&#160;println!(&#34;In&#160;file&#160;{}&#34;,&#160;config.file_path);<br/>
&#160;&#160;&#160;&#160;if&#160;let&#160;Err(e)&#160;=&#160;run(config)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Application&#160;error:&#160;{e}&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;process::exit(1);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
314/627<br/>
<hr/>
<a name=315></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We use&#160;&#160;if&#160;let&#160;&#160;rather than&#160;&#160;unwrap_or_else&#160;&#160;to check whether&#160;&#160;run&#160;&#160;returns an&#160;&#160;Err&#160;&#160;value<br/>and call&#160;&#160;process::exit(1)&#160;&#160;if it does. The&#160;&#160;run&#160;&#160;function doesn’t return a value that we want<br/>to&#160;&#160;unwrap&#160;&#160;in the same way that&#160;&#160;Config::build&#160;&#160;returns the&#160;&#160;Config&#160;&#160;instance. Because&#160;&#160;run<br/>returns&#160;&#160;()&#160;&#160;in the success case, we only care about detecting an error, so we don’t need<br/>
unwrap_or_else&#160;&#160;to return the unwrapped value, which would only be&#160;&#160;()&#160;.<br/>
The bodies of the&#160;&#160;if&#160;let&#160;&#160;and the&#160;&#160;unwrap_or_else&#160;&#160;functions are the same in both cases:<br/>we print the error and exit.<br/>
<a href="tests.html#315"><b>Splitting&#160;Code&#160;into&#160;a&#160;Library&#160;Crate</b></a><br/>
Our&#160;&#160;minigrep&#160;&#160;project is looking good so far! Now we’ll split the&#160;<i>src/main.rs</i>&#160;ﬁle and put<br/>some code into the&#160;<i>src/lib.rs</i>&#160;ﬁle. That way we can test the code and have a&#160;<i>src/main.rs</i>&#160;ﬁle<br/>with fewer responsibilities.<br/>
Let’s move all the code that isn’t the&#160;&#160;main&#160;&#160;function from&#160;<i>src/main.rs</i>&#160;to&#160;<i>src/lib.rs</i>:<br/>
The&#160;&#160;run&#160;&#160;function deﬁnition<br/>The relevant&#160;&#160;use&#160;&#160;statements<br/>The deﬁnition of&#160;&#160;Config<br/>The&#160;&#160;Config::build&#160;&#160;function deﬁnition<br/>
The contents of&#160;<i>src/lib.rs</i>&#160;should have the signatures shown in Listing 12-13 (we’ve omitted<br/>the bodies of the functions for brevity). Note that this won’t compile until we modify<br/><i>src/main.rs</i>&#160;in Listing 12-14.<br/>
Filename: src/lib.rs<br/>
use&#160;std::error::Error;<br/>use&#160;std::fs;<br/>
pub&#160;struct&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;query:&#160;String,<br/>&#160;&#160;&#160;&#160;pub&#160;file_path:&#160;String,<br/>}<br/>
impl&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;build(args:&#160;&amp;[String])&#160;-&gt;&#160;Result&lt;Config,&#160;&amp;'static&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
pub&#160;fn&#160;run(config:&#160;Config)&#160;-&gt;&#160;Result&lt;(),&#160;Box&lt;dyn&#160;Error&gt;&gt;&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
<b>Listing&#160;12-13:&#160;Moving&#160;&#160;</b>Config&#160;<b>&#160;and&#160;&#160;</b>run&#160;<b>&#160;into&#160;<i>src/lib.rs</i></b><br/>
https://doc.rust-lang.org/book/print.html<br/>
315/627<br/>
<hr/>
<a name=316></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We’ve made liberal use of the&#160;&#160;pub&#160;&#160;keyword: on&#160;&#160;Config&#160;, on its&#160;ﬁelds and its&#160;&#160;build&#160;&#160;method,<br/>and on the&#160;&#160;run&#160;&#160;function. We now have a library crate that has a public API we can test!<br/>
Now we need to bring the code we moved to&#160;<i>src/lib.rs</i>&#160;into the scope of the binary crate in<br/><i>src/main.rs</i>, as shown in Listing 12-14.<br/>
Filename: src/main.rs<br/>
use&#160;std::env;<br/>use&#160;std::process;<br/>
use&#160;minigrep::Config;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;if&#160;let&#160;Err(e)&#160;=&#160;minigrep::run(config)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;12-14:&#160;Using&#160;the&#160;&#160;</b>minigrep&#160;<b>&#160;library&#160;crate&#160;in&#160;<i>src/main.rs</i></b><br/>
We add a&#160;&#160;use&#160;minigrep::Config&#160;&#160;line to bring the&#160;&#160;Config&#160;&#160;type from the library crate into<br/>the binary crate’s scope, and we preﬁx the&#160;&#160;run&#160;&#160;function with our crate name. Now all the<br/>functionality should be connected and should work. Run the program with&#160;&#160;cargo&#160;run&#160;&#160;and<br/>make sure everything works correctly.<br/>
Whew! That was a lot of work, but we’ve set ourselves up for success in the future. Now it’s<br/>much easier to handle errors, and we’ve made the code more modular. Almost all of our<br/>work will be done in&#160;<i>src/lib.rs</i>&#160;from here on out.<br/>
Let’s take advantage of this newfound modularity by doing something that would have been<br/>diﬃcult with the old code but is easy with the new code: we’ll write some tests!<br/>
https://doc.rust-lang.org/book/print.html<br/>
316/627<br/>
<hr/>
<a name=317></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#317"><b>Developing the Library’s Functionality with Test-Driven<br/>Development</b></a><br/>
Now that we’ve extracted the logic into&#160;<i>src/lib.rs</i>&#160;and left the argument collecting and error<br/>handling in&#160;<i>src/main.rs</i>, it’s much easier to write tests for the core functionality of our code.<br/>We can call functions directly with various arguments and check return values without<br/>having to call our binary from the command line.<br/>
In this section, we’ll add the searching logic to the&#160;&#160;minigrep&#160;&#160;program using the test-driven<br/>development (TDD) process with the following steps:<br/>
1.&#160;Write a test that fails and run it to make sure it fails for the reason you expect.<br/>2.&#160;Write or modify just enough code to make the new test pass.<br/>3.&#160;Refactor the code you just added or changed and make sure the tests continue to<br/>
pass.<br/>
4.&#160;Repeat from step 1!<br/>
Though it’s just one of many ways to write software, TDD can help drive code design. Writing<br/>the test before you write the code that makes the test pass helps to maintain high test<br/>coverage throughout the process.<br/>
We’ll test drive the implementation of the functionality that will actually do the searching for<br/>the query string in the&#160;ﬁle contents and produce a list of lines that match the query. We’ll<br/>add this functionality in a function called&#160;&#160;search&#160;.<br/>
<a href="tests.html#317"><b>Writing&#160;a&#160;Failing&#160;Test</b></a><br/>
Because we don’t need them anymore, let’s remove the&#160;&#160;println!&#160;&#160;statements from&#160;<i>src/lib.rs<br/></i>and&#160;<i>src/main.rs</i>&#160;that we used to check the program’s behavior. Then, in&#160;<i>src/lib.rs</i>, add a<br/>
tests&#160;<a href="https://doc.rust-lang.org/book/ch11-01-writing-tests.html#the-anatomy-of-a-test-function">&#160;module with a test function, as we did in&#160;Chapter 11</a>. The test function speciﬁes the<br/>
behavior we want the&#160;&#160;search&#160;&#160;function to have: it will take a query and the text to search,<br/>and it will return only the lines from the text that contain the query. Listing 12-15 shows this<br/>test, which won’t compile yet.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
317/627<br/>
<hr/>
<a name=318></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;one_result()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;query&#160;=&#160;&#34;duct&#34;;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;&#34;\<br/>Rust:<br/>safe,&#160;fast,&#160;productive.<br/>Pick&#160;three.&#34;;<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(vec![&#34;safe,&#160;fast,&#160;productive.&#34;],&#160;search(query,&#160;contents));<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;12-15:&#160;Creating&#160;a&#160;failing&#160;test&#160;for&#160;the&#160;&#160;</b>search&#160;<b>&#160;function&#160;we&#160;wish&#160;we&#160;had</b><br/>
This test searches for the string&#160;&#160;&#34;duct&#34;&#160;. The text we’re searching is three lines, only one of<br/>which contains&#160;&#160;&#34;duct&#34;&#160;&#160;(Note that the backslash after the opening double quote tells Rust<br/>not to put a newline character at the beginning of the contents of this string literal). We<br/>assert that the value returned from the&#160;&#160;search&#160;&#160;function contains only the line we expect.<br/>
We aren’t yet able to run this test and watch it fail because the test doesn’t even compile:<br/>the&#160;&#160;search&#160;&#160;function doesn’t exist yet! In accordance with TDD principles, we’ll add just<br/>enough code to get the test to compile and run by adding a deﬁnition of the&#160;&#160;search<br/>function that always returns an empty vector, as shown in Listing 12-16. Then the test<br/>should compile and fail because an empty vector doesn’t match a vector containing the line<br/>
&#34;safe,&#160;fast,&#160;productive.&#34;<br/>
Filename: src/lib.rs<br/>
pub&#160;fn&#160;search&lt;'a&gt;(query:&#160;&amp;str,&#160;contents:&#160;&amp;'a&#160;str)&#160;-&gt;&#160;Vec&lt;&amp;'a&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;vec![]<br/>}<br/>
<b>Listing&#160;12-16:&#160;Deﬁning&#160;just&#160;enough&#160;of&#160;the&#160;&#160;</b>search&#160;<b>&#160;function&#160;so&#160;our&#160;test&#160;will&#160;compile</b><br/>
Notice that we need to deﬁne an explicit lifetime&#160;&#160;'a&#160;&#160;in the signature of&#160;&#160;search&#160;&#160;and use<br/>that lifetime with the&#160;&#160;contents&#160;&#160;argument and the return value. Recall in&#160;<a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">Chapter 10</a>&#160;that<br/>the lifetime parameters specify which argument lifetime is connected to the lifetime of the<br/>return value. In this case, we indicate that the returned vector should contain string slices<br/>that reference slices of the argument&#160;&#160;contents&#160;&#160;(rather than the argument&#160;&#160;query&#160;).<br/>
In other words, we tell Rust that the data returned by the&#160;&#160;search&#160;&#160;function will live as long<br/>as the data passed into the&#160;&#160;search&#160;&#160;function in the&#160;&#160;contents&#160;&#160;argument. This is important!<br/>The data referenced&#160;<i>by</i>&#160;a slice needs to be valid for the reference to be valid; if the compiler<br/>assumes we’re making string slices of&#160;&#160;query&#160;&#160;rather than&#160;&#160;contents&#160;, it will do its safety<br/>checking incorrectly.<br/>
https://doc.rust-lang.org/book/print.html<br/>
318/627<br/>
<hr/>
<a name=319></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
If we forget the lifetime annotations and try to compile this function, we’ll get this error:<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>error[E0106]:&#160;missing&#160;lifetime&#160;specifier<br/>&#160;&#160;--&gt;&#160;src/lib.rs:28:51<br/>&#160;&#160;&#160;|<br/>28&#160;|&#160;pub&#160;fn&#160;search(query:&#160;&amp;str,&#160;contents:&#160;&amp;str)&#160;-&gt;&#160;Vec&lt;&amp;str&gt;&#160;{<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;----&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;----&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^&#160;expected&#160;named&#160;<br/>lifetime&#160;parameter<br/>&#160;&#160;&#160;|<br/>&#160;&#160;&#160;=&#160;help:&#160;this&#160;function's&#160;return&#160;type&#160;contains&#160;a&#160;borrowed&#160;value,&#160;but&#160;the&#160;<br/>signature&#160;does&#160;not&#160;say&#160;whether&#160;it&#160;is&#160;borrowed&#160;from&#160;`query`&#160;or&#160;`contents`<br/>help:&#160;consider&#160;introducing&#160;a&#160;named&#160;lifetime&#160;parameter<br/>&#160;&#160;&#160;|<br/>28&#160;|&#160;pub&#160;fn&#160;search&lt;'a&gt;(query:&#160;&amp;'a&#160;str,&#160;contents:&#160;&amp;'a&#160;str)&#160;-&gt;&#160;Vec&lt;&amp;'a&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++++&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0106`.<br/>error:&#160;could&#160;not&#160;compile&#160;`minigrep`&#160;due&#160;to&#160;previous&#160;error<br/>
Rust can’t possibly know which of the two arguments we need, so we need to tell it<br/>explicitly. Because&#160;&#160;contents&#160;&#160;is the argument that contains all of our text and we want to<br/>return the parts of that text that match, we know&#160;&#160;contents&#160;&#160;is the argument that should be<br/>connected to the return value using the lifetime syntax.<br/>
Other programming languages don’t require you to connect arguments to return values in<br/>the signature, but this practice will get easier over time. You might want to compare this<br/>example with the&#160;<a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“Validating References with Lifetimes”&#160;section in Chapter 10.</a><br/>
Now let’s run the test:<br/>
https://doc.rust-lang.org/book/print.html<br/>
319/627<br/>
<hr/>
<a name=320></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.97s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/minigrep-9cd200e5fac0fc94)<br/>
running&#160;1&#160;test<br/>test&#160;tests::one_result&#160;...&#160;FAILED<br/>
failures:<br/>
----&#160;tests::one_result&#160;stdout&#160;----<br/>thread&#160;'tests::one_result'&#160;panicked&#160;at&#160;'assertion&#160;failed:&#160;`(left&#160;==&#160;right)`<br/>&#160;&#160;left:&#160;`[&#34;safe,&#160;fast,&#160;productive.&#34;]`,<br/>&#160;right:&#160;`[]`',&#160;src/lib.rs:44:9<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
failures:<br/>&#160;&#160;&#160;&#160;tests::one_result<br/>
test&#160;result:&#160;FAILED.&#160;0&#160;passed;&#160;1&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
error:&#160;test&#160;failed,&#160;to&#160;rerun&#160;pass&#160;`--lib`<br/>
Great, the test fails, exactly as we expected. Let’s get the test to pass!<br/>
<a href="tests.html#320"><b>Writing&#160;Code&#160;to&#160;Pass&#160;the&#160;Test</b></a><br/>
Currently, our test is failing because we always return an empty vector. To&#160;ﬁx that and<br/>implement&#160;&#160;search&#160;, our program needs to follow these steps:<br/>
Iterate through each line of the contents.<br/>Check whether the line contains our query string.<br/>If it does, add it to the list of values we’re returning.<br/>If it doesn’t, do nothing.<br/>Return the list of results that match.<br/>
Let’s work through each step, starting with iterating through lines.<br/>
<a href="tests.html#320"><b>Iterating Through Lines with the&#160;</b>lines<b>&#160;Method</b></a><br/>
Rust has a helpful method to handle line-by-line iteration of strings, conveniently named<br/>
lines&#160;, that works as shown in Listing 12-17. Note this won’t compile yet.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
320/627<br/>
<hr/>
<a name=321></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;fn&#160;search&lt;'a&gt;(query:&#160;&amp;str,&#160;contents:&#160;&amp;'a&#160;str)&#160;-&gt;&#160;Vec&lt;&amp;'a&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;for&#160;line&#160;in&#160;contents.lines()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;do&#160;something&#160;with&#160;line<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;12-17:&#160;Iterating&#160;through&#160;each&#160;line&#160;in&#160;&#160;</b>contents<br/>
The&#160;&#160;lines&#160;&#160;method returns an iterator. We’ll talk about iterators in depth in&#160;<a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">Chapter 13, but<br/></a>recall that you saw this way of using an iterator in&#160;<a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html#looping-through-a-collection-with-for">Listing 3-5, where we used a&#160;&#160;</a>for&#160;&#160;loop<br/>with an iterator to run some code on each item in a collection.<br/>
<a href="tests.html#321"><b>Searching Each Line for the Query</b></a><br/>
Next, we’ll check whether the current line contains our query string. Fortunately, strings<br/>have a helpful method named&#160;&#160;contains&#160;&#160;that does this for us! Add a call to the&#160;&#160;contains<br/>method in the&#160;&#160;search&#160;&#160;function, as shown in Listing 12-18. Note this still won’t compile yet.<br/>
Filename: src/lib.rs<br/>
pub&#160;fn&#160;search&lt;'a&gt;(query:&#160;&amp;str,&#160;contents:&#160;&amp;'a&#160;str)&#160;-&gt;&#160;Vec&lt;&amp;'a&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;for&#160;line&#160;in&#160;contents.lines()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;line.contains(query)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;do&#160;something&#160;with&#160;line<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;12-18:&#160;Adding&#160;functionality&#160;to&#160;see&#160;whether&#160;the&#160;line&#160;contains&#160;the&#160;string&#160;in&#160;&#160;</b>query<br/>
At the moment, we’re building up functionality. To get it to compile, we need to return a<br/>value from the body as we indicated we would in the function signature.<br/>
<a href="tests.html#321"><b>Storing Matching Lines</b></a><br/>
To&#160;ﬁnish this function, we need a way to store the matching lines that we want to return. For<br/>that, we can make a mutable vector before the&#160;&#160;for&#160;&#160;loop and call the&#160;&#160;push&#160;&#160;method to store<br/>a&#160;&#160;line&#160;&#160;in the vector. After the&#160;&#160;for&#160;&#160;loop, we return the vector, as shown in Listing 12-19.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
321/627<br/>
<hr/>
<a name=322></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;fn&#160;search&lt;'a&gt;(query:&#160;&amp;str,&#160;contents:&#160;&amp;'a&#160;str)&#160;-&gt;&#160;Vec&lt;&amp;'a&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;results&#160;=&#160;Vec::new();<br/>
&#160;&#160;&#160;&#160;for&#160;line&#160;in&#160;contents.lines()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;line.contains(query)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;results.push(line);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;results<br/>}<br/>
<b>Listing&#160;12-19:&#160;Storing&#160;the&#160;lines&#160;that&#160;match&#160;so&#160;we&#160;can&#160;return&#160;them</b><br/>
Now the&#160;&#160;search&#160;&#160;function should return only the lines that contain&#160;&#160;query&#160;, and our test<br/>should pass. Let’s run the test:<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;1.22s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/minigrep-9cd200e5fac0fc94)<br/>
running&#160;1&#160;test<br/>test&#160;tests::one_result&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/main.rs&#160;(target/debug/deps/minigrep-<br/>9cd200e5fac0fc94)<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;minigrep<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
Our test passed, so we know it works!<br/>
At this point, we could consider opportunities for refactoring the implementation of the<br/>search function while keeping the tests passing to maintain the same functionality. The code<br/>in the search function isn’t too bad, but it doesn’t take advantage of some useful features of<br/><a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">iterators. We’ll return to this example in&#160;Chapter 13</a>, where we’ll explore iterators in detail,<br/>and look at how to improve it.<br/>
https://doc.rust-lang.org/book/print.html<br/>
322/627<br/>
<hr/>
<a name=323></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#323"><b>Using the&#160;</b>search<b>&#160;Function in the&#160;</b>run<b>&#160;Function</b></a><br/>
Now that the&#160;&#160;search&#160;&#160;function is working and tested, we need to call&#160;&#160;search&#160;&#160;from our&#160;&#160;run<br/>function. We need to pass the&#160;&#160;config.query&#160;&#160;value and the&#160;&#160;contents&#160;&#160;that&#160;&#160;run&#160;&#160;reads from<br/>the&#160;ﬁle to the&#160;&#160;search&#160;&#160;function. Then&#160;&#160;run&#160;&#160;will print each line returned from&#160;&#160;search&#160;:<br/>
Filename: src/lib.rs<br/>
pub&#160;fn&#160;run(config:&#160;Config)&#160;-&gt;&#160;Result&lt;(),&#160;Box&lt;dyn&#160;Error&gt;&gt;&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;fs::read_to_string(config.file_path)?;<br/>
&#160;&#160;&#160;&#160;for&#160;line&#160;in&#160;search(&amp;config.query,&#160;&amp;contents)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;{line}&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;Ok(())<br/>}<br/>
We’re still using a&#160;&#160;for&#160;&#160;loop to return each line from&#160;&#160;search&#160;&#160;and print it.<br/>
Now the entire program should work! Let’s try it out,&#160;ﬁrst with a word that should return<br/>exactly one line from the Emily Dickinson poem, “frog”:<br/>
$&#160;cargo&#160;run&#160;--&#160;frog&#160;poem.txt<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.38s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/minigrep&#160;frog&#160;poem.txt`<br/>How&#160;public,&#160;like&#160;a&#160;frog<br/>
Cool! Now let’s try a word that will match multiple lines, like “body”:<br/>
$&#160;cargo&#160;run&#160;--&#160;body&#160;poem.txt<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.0s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/minigrep&#160;body&#160;poem.txt`<br/>I'm&#160;nobody!&#160;Who&#160;are&#160;you?<br/>Are&#160;you&#160;nobody,&#160;too?<br/>How&#160;dreary&#160;to&#160;be&#160;somebody!<br/>
And&#160;ﬁnally, let’s make sure that we don’t get any lines when we search for a word that isn’t<br/>anywhere in the poem, such as “monomorphization”:<br/>
$&#160;cargo&#160;run&#160;--&#160;monomorphization&#160;poem.txt<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.0s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/minigrep&#160;monomorphization&#160;poem.txt`<br/>
Excellent! We’ve built our own mini version of a classic tool and learned a lot about how to<br/>structure applications. We’ve also learned a bit about&#160;ﬁle input and output, lifetimes, testing,<br/>and command line parsing.<br/>
https://doc.rust-lang.org/book/print.html<br/>
323/627<br/>
<hr/>
<a name=324></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
To round out this project, we’ll brieﬂy demonstrate how to work with environment variables<br/>and how to print to standard error, both of which are useful when you’re writing command<br/>line programs.<br/>
https://doc.rust-lang.org/book/print.html<br/>
324/627<br/>
<hr/>
<a name=325></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#325"><b>Working with Environment Variables</b></a><br/>
We’ll improve&#160;&#160;minigrep&#160;&#160;by adding an extra feature: an option for case-insensitive searching<br/>that the user can turn on via an environment variable. We could make this feature a<br/>command line option and require that users enter it each time they want it to apply, but by<br/>instead making it an environment variable, we allow our users to set the environment<br/>variable once and have all their searches be case insensitive in that terminal session.<br/>
<a href="tests.html#325"><b>Writing&#160;a&#160;Failing&#160;Test&#160;for&#160;the&#160;Case-Insensitive&#160;</b>search<b>&#160;Function</b></a><br/>
We&#160;ﬁrst add a new&#160;&#160;search_case_insensitive&#160;&#160;function that will be called when the<br/>environment variable has a value. We’ll continue to follow the TDD process, so the&#160;ﬁrst step<br/>is again to write a failing test. We’ll add a new test for the new&#160;&#160;search_case_insensitive<br/>function and rename our old test from&#160;&#160;one_result&#160;&#160;to&#160;&#160;case_sensitive&#160;&#160;to clarify the<br/>diﬀerences between the two tests, as shown in Listing 12-20.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
325/627<br/>
<hr/>
<a name=326></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;case_sensitive()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;query&#160;=&#160;&#34;duct&#34;;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;&#34;\<br/>Rust:<br/>safe,&#160;fast,&#160;productive.<br/>Pick&#160;three.<br/>Duct&#160;tape.&#34;;<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(vec![&#34;safe,&#160;fast,&#160;productive.&#34;],&#160;search(query,&#160;contents));<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;case_insensitive()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;query&#160;=&#160;&#34;rUsT&#34;;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;&#34;\<br/>Rust:<br/>safe,&#160;fast,&#160;productive.<br/>Pick&#160;three.<br/>Trust&#160;me.&#34;;<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vec![&#34;Rust:&#34;,&#160;&#34;Trust&#160;me.&#34;],<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;search_case_insensitive(query,&#160;contents)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;12-20:&#160;Adding&#160;a&#160;new&#160;failing&#160;test&#160;for&#160;the&#160;case-insensitive&#160;function&#160;we’re&#160;about&#160;to&#160;add</b><br/>
Note that we’ve edited the old test’s&#160;&#160;contents&#160;&#160;too. We’ve added a new line with the text<br/>
&#34;Duct&#160;tape.&#34;&#160;&#160;using a capital D that shouldn’t match the query&#160;&#160;&#34;duct&#34;&#160;&#160;when we’re<br/>
searching in a case-sensitive manner. Changing the old test in this way helps ensure that we<br/>don’t accidentally break the case-sensitive search functionality that we’ve already<br/>implemented. This test should pass now and should continue to pass as we work on the<br/>case-insensitive search.<br/>
The new test for the case-<i>insensitive</i>&#160;search uses&#160;&#160;&#34;rUsT&#34;&#160;&#160;as its query. In the<br/>
search_case_insensitive&#160;&#160;function we’re about to add, the query&#160;&#160;&#34;rUsT&#34;&#160;&#160;should match<br/>
the line containing&#160;&#160;&#34;Rust:&#34;&#160;&#160;with a capital R and match the line&#160;&#160;&#34;Trust&#160;me.&#34;&#160;&#160;even though<br/>both have diﬀerent casing from the query. This is our failing test, and it will fail to compile<br/>because we haven’t yet deﬁned the&#160;&#160;search_case_insensitive&#160;&#160;function. Feel free to add a<br/>skeleton implementation that always returns an empty vector, similar to the way we did for<br/>the&#160;&#160;search&#160;&#160;function in Listing 12-16 to see the test compile and fail.<br/>
https://doc.rust-lang.org/book/print.html<br/>
326/627<br/>
<hr/>
<a name=327></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#327"><b>Implementing&#160;the&#160;</b>search_case_insensitive<b>&#160;Function</b></a><br/>
The&#160;&#160;search_case_insensitive&#160;&#160;function, shown in Listing 12-21, will be almost the same as<br/>the&#160;&#160;search&#160;&#160;function. The only diﬀerence is that we’ll lowercase the&#160;&#160;query&#160;&#160;and each&#160;&#160;line<br/>so whatever the case of the input arguments, they’ll be the same case when we check<br/>whether the line contains the query.<br/>
Filename: src/lib.rs<br/>
pub&#160;fn&#160;search_case_insensitive&lt;'a&gt;(<br/>&#160;&#160;&#160;&#160;query:&#160;&amp;str,<br/>&#160;&#160;&#160;&#160;contents:&#160;&amp;'a&#160;str,<br/>)&#160;-&gt;&#160;Vec&lt;&amp;'a&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;query&#160;=&#160;query.to_lowercase();<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;results&#160;=&#160;Vec::new();<br/>
&#160;&#160;&#160;&#160;for&#160;line&#160;in&#160;contents.lines()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;line.to_lowercase().contains(&amp;query)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;results.push(line);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;results<br/>}<br/>
<b>Listing&#160;12-21:&#160;Deﬁning&#160;the&#160;&#160;</b>search_case_insensitive&#160;<b>&#160;function&#160;to&#160;lowercase&#160;the&#160;query&#160;and&#160;the&#160;line&#160;before<br/>comparing&#160;them</b><br/>
First, we lowercase the&#160;&#160;query&#160;&#160;string and store it in a shadowed variable with the same<br/>name. Calling&#160;&#160;to_lowercase&#160;&#160;on the query is necessary so no matter whether the user’s<br/>query is&#160;&#160;&#34;rust&#34;&#160;,&#160;&#160;&#34;RUST&#34;&#160;,&#160;&#160;&#34;Rust&#34;&#160;, or&#160;&#160;&#34;rUsT&#34;&#160;, we’ll treat the query as if it were&#160;&#160;&#34;rust&#34;&#160;&#160;and<br/>be insensitive to the case. While&#160;&#160;to_lowercase&#160;&#160;will handle basic Unicode, it won’t be 100%<br/>accurate. If we were writing a real application, we’d want to do a bit more work here, but<br/>this section is about environment variables, not Unicode, so we’ll leave it at that here.<br/>
Note that&#160;&#160;query&#160;&#160;is now a&#160;&#160;String&#160;&#160;rather than a string slice, because calling&#160;&#160;to_lowercase<br/>creates new data rather than referencing existing data. Say the query is&#160;&#160;&#34;rUsT&#34;&#160;, as an<br/>example: that string slice doesn’t contain a lowercase&#160;&#160;u&#160;&#160;or&#160;&#160;t&#160;&#160;for us to use, so we have to<br/>allocate a new&#160;&#160;String&#160;&#160;containing&#160;&#160;&#34;rust&#34;&#160;. When we pass&#160;&#160;query&#160;&#160;as an argument to the<br/>
contains&#160;&#160;method now, we need to add an ampersand because the signature of&#160;&#160;contains<br/>
is deﬁned to take a string slice.<br/>
Next, we add a call to&#160;&#160;to_lowercase&#160;&#160;on each&#160;&#160;line&#160;&#160;to lowercase all characters. Now that<br/>we’ve converted&#160;&#160;line&#160;&#160;and&#160;&#160;query&#160;&#160;to lowercase, we’ll&#160;ﬁnd matches no matter what the case<br/>of the query is.<br/>
Let’s see if this implementation passes the tests:<br/>
https://doc.rust-lang.org/book/print.html<br/>
327/627<br/>
<hr/>
<a name=328></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;1.33s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/minigrep-9cd200e5fac0fc94)<br/>
running&#160;2&#160;tests<br/>test&#160;tests::case_insensitive&#160;...&#160;ok<br/>test&#160;tests::case_sensitive&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;2&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/main.rs&#160;(target/debug/deps/minigrep-<br/>9cd200e5fac0fc94)<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;minigrep<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
Great! They passed. Now, let’s call the new&#160;&#160;search_case_insensitive&#160;&#160;function from the<br/>
run&#160;&#160;function. First, we’ll add a conﬁguration option to the&#160;&#160;Config&#160;&#160;struct to switch between<br/>
case-sensitive and case-insensitive search. Adding this&#160;ﬁeld will cause compiler errors<br/>because we aren’t initializing this&#160;ﬁeld anywhere yet:<br/>
Filename: src/lib.rs<br/>
pub&#160;struct&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;query:&#160;String,<br/>&#160;&#160;&#160;&#160;pub&#160;file_path:&#160;String,<br/>&#160;&#160;&#160;&#160;pub&#160;ignore_case:&#160;bool,<br/>}<br/>
We added the&#160;&#160;ignore_case&#160;&#160;ﬁeld that holds a Boolean. Next, we need the&#160;&#160;run&#160;&#160;function to<br/>check the&#160;&#160;ignore_case&#160;&#160;ﬁeld’s value and use that to decide whether to call the&#160;&#160;search<br/>function or the&#160;&#160;search_case_insensitive&#160;&#160;function, as shown in Listing 12-22. This still<br/>won’t compile yet.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
328/627<br/>
<hr/>
<a name=329></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;fn&#160;run(config:&#160;Config)&#160;-&gt;&#160;Result&lt;(),&#160;Box&lt;dyn&#160;Error&gt;&gt;&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;fs::read_to_string(config.file_path)?;<br/>
&#160;&#160;&#160;&#160;let&#160;results&#160;=&#160;if&#160;config.ignore_case&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;search_case_insensitive(&amp;config.query,&#160;&amp;contents)<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;search(&amp;config.query,&#160;&amp;contents)<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;for&#160;line&#160;in&#160;results&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;{line}&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;Ok(())<br/>}<br/>
<b>Listing&#160;12-22:&#160;Calling&#160;either&#160;&#160;</b>search&#160;<b>&#160;or&#160;&#160;</b>search_case_insensitive&#160;<b>&#160;based&#160;on&#160;the&#160;value&#160;in&#160;&#160;</b>config.ignore_case<br/>
Finally, we need to check for the environment variable. The functions for working with<br/>environment variables are in the&#160;&#160;env&#160;&#160;module in the standard library, so we bring that<br/>module into scope at the top of&#160;<i>src/lib.rs</i>. Then we’ll use the&#160;&#160;var&#160;&#160;function from the&#160;&#160;env<br/>module to check to see if any value has been set for an environment variable named<br/>
IGNORE_CASE&#160;, as shown in Listing 12-23.<br/>
Filename: src/lib.rs<br/>
use&#160;std::env;<br/>//&#160;--snip--<br/>
impl&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;build(args:&#160;&amp;[String])&#160;-&gt;&#160;Result&lt;Config,&#160;&amp;'static&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;args.len()&#160;&lt;&#160;3&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;Err(&#34;not&#160;enough&#160;arguments&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;query&#160;=&#160;args[1].clone();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;file_path&#160;=&#160;args[2].clone();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;ignore_case&#160;=&#160;env::var(&#34;IGNORE_CASE&#34;).is_ok();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(Config&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;query,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;file_path,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ignore_case,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;})<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;12-23:&#160;Checking&#160;for&#160;any&#160;value&#160;in&#160;an&#160;environment&#160;variable&#160;named&#160;&#160;</b>IGNORE_CASE<br/>
Here, we create a new variable&#160;&#160;ignore_case&#160;. To set its value, we call the&#160;&#160;env::var&#160;&#160;function<br/>and pass it the name of the&#160;&#160;IGNORE_CASE&#160;&#160;environment variable. The&#160;&#160;env::var&#160;&#160;function<br/>
https://doc.rust-lang.org/book/print.html<br/>
329/627<br/>
<hr/>
<a name=330></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
returns a&#160;&#160;Result&#160;&#160;that will be the successful&#160;&#160;Ok&#160;&#160;variant that contains the value of the<br/>environment variable if the environment variable is set to any value. It will return the&#160;&#160;Err<br/>variant if the environment variable is not set.<br/>
We’re using the&#160;&#160;is_ok&#160;&#160;method on the&#160;&#160;Result&#160;&#160;to check whether the environment variable<br/>is set, which means the program should do a case-insensitive search. If the&#160;&#160;IGNORE_CASE<br/>environment variable isn’t set to anything,&#160;&#160;is_ok&#160;&#160;will return false and the program will<br/>perform a case-sensitive search. We don’t care about the&#160;<i>value</i>&#160;of the environment variable,<br/>just whether it’s set or unset, so we’re checking&#160;&#160;is_ok&#160;&#160;rather than using&#160;&#160;unwrap&#160;,&#160;&#160;expect&#160;,<br/>or any of the other methods we’ve seen on&#160;&#160;Result&#160;.<br/>
We pass the value in the&#160;&#160;ignore_case&#160;&#160;variable to the&#160;&#160;Config&#160;&#160;instance so the&#160;&#160;run&#160;&#160;function<br/>can read that value and decide whether to call&#160;&#160;search_case_insensitive&#160;&#160;or&#160;&#160;search&#160;, as we<br/>implemented in Listing 12-22.<br/>
Let’s give it a try! First, we’ll run our program without the environment variable set and with<br/>the query&#160;&#160;to&#160;, which should match any line that contains the word “to” in all lowercase:<br/>
$&#160;cargo&#160;run&#160;--&#160;to&#160;poem.txt<br/>&#160;&#160;&#160;Compiling&#160;minigrep&#160;v0.1.0&#160;(file:///projects/minigrep)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.0s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/minigrep&#160;to&#160;poem.txt`<br/>Are&#160;you&#160;nobody,&#160;too?<br/>How&#160;dreary&#160;to&#160;be&#160;somebody!<br/>
Looks like that still works! Now, let’s run the program with&#160;&#160;IGNORE_CASE&#160;&#160;set to&#160;&#160;1&#160;&#160;but with<br/>the same query&#160;&#160;to&#160;.<br/>
$&#160;IGNORE_CASE=1&#160;cargo&#160;run&#160;--&#160;to&#160;poem.txt<br/>
If you’re using PowerShell, you will need to set the environment variable and run the<br/>program as separate commands:<br/>
PS&gt;&#160;$Env:IGNORE_CASE=1;&#160;cargo&#160;run&#160;--&#160;to&#160;poem.txt<br/>
This will make&#160;&#160;IGNORE_CASE&#160;&#160;persist for the remainder of your shell session. It can be unset<br/>with the&#160;&#160;Remove-Item&#160;&#160;cmdlet:<br/>
PS&gt;&#160;Remove-Item&#160;Env:IGNORE_CASE<br/>
We should get lines that contain “to” that might have uppercase letters:<br/>
Are&#160;you&#160;nobody,&#160;too?<br/>How&#160;dreary&#160;to&#160;be&#160;somebody!<br/>To&#160;tell&#160;your&#160;name&#160;the&#160;livelong&#160;day<br/>To&#160;an&#160;admiring&#160;bog!<br/>
https://doc.rust-lang.org/book/print.html<br/>
330/627<br/>
<hr/>
<a name=331></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Excellent, we also got lines containing “To”! Our&#160;&#160;minigrep&#160;&#160;program can now do case-<br/>insensitive searching controlled by an environment variable. Now you know how to manage<br/>options set using either command line arguments or environment variables.<br/>
Some programs allow arguments&#160;<i>and</i>&#160;environment variables for the same conﬁguration. In<br/>those cases, the programs decide that one or the other takes precedence. For another<br/>exercise on your own, try controlling case sensitivity through either a command line<br/>argument or an environment variable. Decide whether the command line argument or the<br/>environment variable should take precedence if the program is run with one set to case<br/>sensitive and one set to ignore case.<br/>
The&#160;&#160;std::env&#160;&#160;module contains many more useful features for dealing with environment<br/>variables: check out its documentation to see what is available.<br/>
https://doc.rust-lang.org/book/print.html<br/>
331/627<br/>
<hr/>
<a name=332></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#332"><b>Writing Error Messages to Standard Error Instead of<br/>Standard Output</b></a><br/>
At the moment, we’re writing all of our output to the terminal using the&#160;&#160;println!&#160;&#160;macro. In<br/>most terminals, there are two kinds of output:&#160;<i>standard output</i>&#160;(&#160;stdout&#160;) for general<br/>information and&#160;<i>standard error</i>&#160;(&#160;stderr&#160;) for error messages. This distinction enables users<br/>to choose to direct the successful output of a program to a&#160;ﬁle but still print error messages<br/>to the screen.<br/>
The&#160;&#160;println!&#160;&#160;macro is only capable of printing to standard output, so we have to use<br/>something else to print to standard error.<br/>
<a href="tests.html#332"><b>Checking&#160;Where&#160;Errors&#160;Are&#160;Written</b></a><br/>
First, let’s observe how the content printed by&#160;&#160;minigrep&#160;&#160;is currently being written to<br/>standard output, including any error messages we want to write to standard error instead.<br/>We’ll do that by redirecting the standard output stream to a&#160;ﬁle while intentionally causing<br/>an error. We won’t redirect the standard error stream, so any content sent to standard error<br/>will continue to display on the screen.<br/>
Command line programs are expected to send error messages to the standard error stream<br/>so we can still see error messages on the screen even if we redirect the standard output<br/>stream to a&#160;ﬁle. Our program is not currently well-behaved: we’re about to see that it saves<br/>the error message output to a&#160;ﬁle instead!<br/>
To demonstrate this behavior, we’ll run the program with&#160;&#160;&gt;&#160;&#160;and the&#160;ﬁle path,&#160;<i>output.txt</i>,<br/>that we want to redirect the standard output stream to. We won’t pass any arguments,<br/>which should cause an error:<br/>
$&#160;cargo&#160;run&#160;&gt;&#160;output.txt<br/>
The&#160;&#160;&gt;&#160;&#160;syntax tells the shell to write the contents of standard output to&#160;<i>output.txt</i>&#160;instead of<br/>the screen. We didn’t see the error message we were expecting printed to the screen, so<br/>that means it must have ended up in the&#160;ﬁle. This is what&#160;<i>output.txt</i>&#160;contains:<br/>
Problem&#160;parsing&#160;arguments:&#160;not&#160;enough&#160;arguments<br/>
Yup, our error message is being printed to standard output. It’s much more useful for error<br/>messages like this to be printed to standard error so only data from a successful run ends<br/>up in the&#160;ﬁle. We’ll change that.<br/>
https://doc.rust-lang.org/book/print.html<br/>
332/627<br/>
<hr/>
<a name=333></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#333"><b>Printing&#160;Errors&#160;to&#160;Standard&#160;Error</b></a><br/>
We’ll use the code in Listing 12-24 to change how error messages are printed. Because of<br/>the refactoring we did earlier in this chapter, all the code that prints error messages is in<br/>one function,&#160;&#160;main&#160;. The standard library provides the&#160;&#160;eprintln!&#160;&#160;macro that prints to the<br/>standard error stream, so let’s change the two places we were calling&#160;&#160;println!&#160;&#160;to print<br/>errors to use&#160;&#160;eprintln!&#160;&#160;instead.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;args:&#160;Vec&lt;String&gt;&#160;=&#160;env::args().collect();<br/>
&#160;&#160;&#160;&#160;let&#160;config&#160;=&#160;Config::build(&amp;args).unwrap_or_else(|err|&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;eprintln!(&#34;Problem&#160;parsing&#160;arguments:&#160;{err}&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;process::exit(1);<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;if&#160;let&#160;Err(e)&#160;=&#160;minigrep::run(config)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;eprintln!(&#34;Application&#160;error:&#160;{e}&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;process::exit(1);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;12-24:&#160;Writing&#160;error&#160;messages&#160;to&#160;standard&#160;error&#160;instead&#160;of&#160;standard&#160;output&#160;using&#160;&#160;</b>eprintln!<br/>
Let’s now run the program again in the same way, without any arguments and redirecting<br/>standard output with&#160;&#160;&gt;&#160;:<br/>
$&#160;cargo&#160;run&#160;&gt;&#160;output.txt<br/>Problem&#160;parsing&#160;arguments:&#160;not&#160;enough&#160;arguments<br/>
Now we see the error onscreen and&#160;<i>output.txt</i>&#160;contains nothing, which is the behavior we<br/>expect of command line programs.<br/>
Let’s run the program again with arguments that don’t cause an error but still redirect<br/>standard output to a&#160;ﬁle, like so:<br/>
$&#160;cargo&#160;run&#160;--&#160;to&#160;poem.txt&#160;&gt;&#160;output.txt<br/>
We won’t see any output to the terminal, and&#160;<i>output.txt</i>&#160;will contain our results:<br/>
Filename: output.txt<br/>
Are&#160;you&#160;nobody,&#160;too?<br/>How&#160;dreary&#160;to&#160;be&#160;somebody!<br/>
This demonstrates that we’re now using standard output for successful output and<br/>standard error for error output as appropriate.<br/>
https://doc.rust-lang.org/book/print.html<br/>
333/627<br/>
<hr/>
<a name=334></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#334"><b>Summary</b></a><br/>
This chapter recapped some of the major concepts you’ve learned so far and covered how<br/>to perform common I/O operations in Rust. By using command line arguments,&#160;ﬁles,<br/>environment variables, and the&#160;&#160;eprintln!&#160;&#160;macro for printing errors, you’re now prepared<br/>to write command line applications. Combined with the concepts in previous chapters, your<br/>code will be well organized, store data eﬀectively in the appropriate data structures, handle<br/>errors nicely, and be well tested.<br/>
Next, we’ll explore some Rust features that were inﬂuenced by functional languages:<br/>closures and iterators.<br/>
https://doc.rust-lang.org/book/print.html<br/>
334/627<br/>
<hr/>
<a name=335></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#335"><b>Functional Language Features: Iterators<br/>and Closures</b></a><br/>
Rust’s design has taken inspiration from many existing languages and techniques, and one<br/>signiﬁcant inﬂuence is&#160;<i>functional programming</i>. Programming in a functional style often<br/>includes using functions as values by passing them in arguments, returning them from<br/>other functions, assigning them to variables for later execution, and so forth.<br/>
In this chapter, we won’t debate the issue of what functional programming is or isn’t but will<br/>instead discuss some features of Rust that are similar to features in many languages often<br/>referred to as functional.<br/>
More speciﬁcally, we’ll cover:<br/>
<i>Closures</i>, a function-like construct you can store in a variable<br/><i>Iterators</i>, a way of processing a series of elements<br/>How to use closures and iterators to improve the I/O project in Chapter 12<br/>The performance of closures and iterators (Spoiler alert: they’re faster than you might<br/>think!)<br/>
We’ve already covered some other Rust features, such as pattern matching and enums, that<br/>are also inﬂuenced by the functional style. Because mastering closures and iterators is an<br/>important part of writing idiomatic, fast Rust code, we’ll devote this entire chapter to them.<br/>
https://doc.rust-lang.org/book/print.html<br/>
335/627<br/>
<hr/>
<a name=336></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#336"><b>Closures: Anonymous Functions that Capture Their<br/>Environment</b></a><br/>
Rust’s closures are anonymous functions you can save in a variable or pass as arguments to<br/>other functions. You can create the closure in one place and then call the closure elsewhere<br/>to evaluate it in a diﬀerent context. Unlike functions, closures can capture values from the<br/>scope in which they’re deﬁned. We’ll demonstrate how these closure features allow for code<br/>reuse and behavior customization.<br/>
<a href="tests.html#336"><b>Capturing&#160;the&#160;Environment&#160;with&#160;Closures</b></a><br/>
We’ll&#160;ﬁrst examine how we can use closures to capture values from the environment they’re<br/>deﬁned in for later use. Here’s the scenario: Every so often, our t-shirt company gives away<br/>an exclusive, limited-edition shirt to someone on our mailing list as a promotion. People on<br/>the mailing list can optionally add their favorite color to their proﬁle. If the person chosen<br/>for a free shirt has their favorite color set, they get that color shirt. If the person hasn’t<br/>speciﬁed a favorite color, they get whatever color the company currently has the most of.<br/>
There are many ways to implement this. For this example, we’re going to use an enum<br/>called&#160;&#160;ShirtColor&#160;&#160;that has the variants&#160;&#160;Red&#160;&#160;and&#160;&#160;Blue&#160;&#160;(limiting the number of colors<br/>available for simplicity). We represent the company’s inventory with an&#160;&#160;Inventory&#160;&#160;struct<br/>that has a&#160;ﬁeld named&#160;&#160;shirts&#160;&#160;that contains a&#160;&#160;Vec&lt;ShirtColor&gt;&#160;&#160;representing the shirt<br/>colors currently in stock. The method&#160;&#160;giveaway&#160;&#160;deﬁned on&#160;&#160;Inventory&#160;&#160;gets the optional<br/>shirt color preference of the free shirt winner, and returns the shirt color the person will get.<br/>This setup is shown in Listing 13-1:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
336/627<br/>
<hr/>
<a name=337></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
#[derive(Debug,&#160;PartialEq,&#160;Copy,&#160;Clone)]<br/>enum&#160;ShirtColor&#160;{<br/>&#160;&#160;&#160;&#160;Red,<br/>&#160;&#160;&#160;&#160;Blue,<br/>}<br/>
struct&#160;Inventory&#160;{<br/>&#160;&#160;&#160;&#160;shirts:&#160;Vec&lt;ShirtColor&gt;,<br/>}<br/>
impl&#160;Inventory&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;giveaway(&amp;self,&#160;user_preference:&#160;Option&lt;ShirtColor&gt;)&#160;-&gt;&#160;ShirtColor&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;user_preference.unwrap_or_else(||&#160;self.most_stocked())<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;fn&#160;most_stocked(&amp;self)&#160;-&gt;&#160;ShirtColor&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;num_red&#160;=&#160;0;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;num_blue&#160;=&#160;0;<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;color&#160;in&#160;&amp;self.shirts&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;color&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ShirtColor::Red&#160;=&gt;&#160;num_red&#160;+=&#160;1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ShirtColor::Blue&#160;=&gt;&#160;num_blue&#160;+=&#160;1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;num_red&#160;&gt;&#160;num_blue&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ShirtColor::Red<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ShirtColor::Blue<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;store&#160;=&#160;Inventory&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;shirts:&#160;vec![ShirtColor::Blue,&#160;ShirtColor::Red,&#160;ShirtColor::Blue],<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;let&#160;user_pref1&#160;=&#160;Some(ShirtColor::Red);<br/>&#160;&#160;&#160;&#160;let&#160;giveaway1&#160;=&#160;store.giveaway(user_pref1);<br/>&#160;&#160;&#160;&#160;println!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;The&#160;user&#160;with&#160;preference&#160;{:?}&#160;gets&#160;{:?}&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;user_pref1,&#160;giveaway1<br/>&#160;&#160;&#160;&#160;);<br/>
&#160;&#160;&#160;&#160;let&#160;user_pref2&#160;=&#160;None;<br/>&#160;&#160;&#160;&#160;let&#160;giveaway2&#160;=&#160;store.giveaway(user_pref2);<br/>&#160;&#160;&#160;&#160;println!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;The&#160;user&#160;with&#160;preference&#160;{:?}&#160;gets&#160;{:?}&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;user_pref2,&#160;giveaway2<br/>&#160;&#160;&#160;&#160;);<br/>}<br/>
<b>Listing&#160;13-1:&#160;Shirt&#160;company&#160;giveaway&#160;situation</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
337/627<br/>
<hr/>
<a name=338></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The&#160;&#160;store&#160;&#160;deﬁned in&#160;&#160;main&#160;&#160;has two blue shirts and one red shirt remaining to distribute for<br/>this limited-edition promotion. We call the&#160;&#160;giveaway&#160;&#160;method for a user with a preference<br/>for a red shirt and a user without any preference.<br/>
Again, this code could be implemented in many ways, and here, to focus on closures, we’ve<br/>stuck to concepts you’ve already learned except for the body of the&#160;&#160;giveaway&#160;&#160;method that<br/>uses a closure. In the&#160;&#160;giveaway&#160;&#160;method, we get the user preference as a parameter of type<br/>
Option&lt;ShirtColor&gt;&#160;&#160;and call the&#160;&#160;unwrap_or_else&#160;&#160;method on&#160;&#160;user_preference&#160;. The<br/><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else">unwrap_or_else&#160;&#160;method on&#160;&#160;Option&lt;T&gt;&#160;&#160;is de</a>ﬁned by the standard library. It takes one<br/>
argument: a closure without any arguments that returns a value&#160;&#160;T&#160;&#160;(the same type stored in<br/>the&#160;&#160;Some&#160;&#160;variant of the&#160;&#160;Option&lt;T&gt;&#160;, in this case&#160;&#160;ShirtColor&#160;). If the&#160;&#160;Option&lt;T&gt;&#160;&#160;is the&#160;&#160;Some<br/>variant,&#160;&#160;unwrap_or_else&#160;&#160;returns the value from within the&#160;&#160;Some&#160;. If the&#160;&#160;Option&lt;T&gt;&#160;&#160;is the<br/>
None&#160;&#160;variant,&#160;&#160;unwrap_or_else&#160;&#160;calls the closure and returns the value returned by the<br/>
closure.<br/>
We specify the closure expression&#160;&#160;||&#160;self.most_stocked()&#160;&#160;as the argument to<br/>
unwrap_or_else&#160;. This is a closure that takes no parameters itself (if the closure had<br/>
parameters, they would appear between the two vertical bars). The body of the closure calls<br/>
self.most_stocked()&#160;. We’re deﬁning the closure here, and the implementation of<br/>unwrap_or_else&#160;&#160;will evaluate the closure later if the result is needed.<br/>
Running this code prints:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;shirt-company&#160;v0.1.0&#160;(file:///projects/shirt-company)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.27s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/shirt-company`<br/>The&#160;user&#160;with&#160;preference&#160;Some(Red)&#160;gets&#160;Red<br/>The&#160;user&#160;with&#160;preference&#160;None&#160;gets&#160;Blue<br/>
One interesting aspect here is that we’ve passed a closure that calls&#160;&#160;self.most_stocked()<br/>on the current&#160;&#160;Inventory&#160;&#160;instance. The standard library didn’t need to know anything<br/>about the&#160;&#160;Inventory&#160;&#160;or&#160;&#160;ShirtColor&#160;&#160;types we deﬁned, or the logic we want to use in this<br/>scenario. The closure captures an immutable reference to the&#160;&#160;self&#160;&#160;&#160;Inventory&#160;&#160;instance<br/>and passes it with the code we specify to the&#160;&#160;unwrap_or_else&#160;&#160;method. Functions, on the<br/>other hand, are not able to capture their environment in this way.<br/>
<a href="tests.html#338"><b>Closure&#160;Type&#160;Inference&#160;and&#160;Annotation</b></a><br/>
There are more diﬀerences between functions and closures. Closures don’t usually require<br/>you to annotate the types of the parameters or the return value like&#160;&#160;fn&#160;&#160;functions do. Type<br/>annotations are required on functions because the types are part of an explicit interface<br/>exposed to your users. Deﬁning this interface rigidly is important for ensuring that everyone<br/>agrees on what types of values a function uses and returns. Closures, on the other hand,<br/>
https://doc.rust-lang.org/book/print.html<br/>
338/627<br/>
<hr/>
<a name=339></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
aren’t used in an exposed interface like this: they’re stored in variables and used without<br/>naming them and exposing them to users of our library.<br/>
Closures are typically short and relevant only within a narrow context rather than in any<br/>arbitrary scenario. Within these limited contexts, the compiler can infer the types of the<br/>parameters and the return type, similar to how it’s able to infer the types of most variables<br/>(there are rare cases where the compiler needs closure type annotations too).<br/>
As with variables, we can add type annotations if we want to increase explicitness and clarity<br/>at the cost of being more verbose than is strictly necessary. Annotating the types for a<br/>closure would look like the deﬁnition shown in Listing 13-2. In this example, we’re deﬁning a<br/>closure and storing it in a variable rather than deﬁning the closure in the spot we pass it as<br/>an argument as we did in Listing 13-1.<br/>
Filename: src/main.rs<br/>
&#160;&#160;&#160;&#160;let&#160;expensive_closure&#160;=&#160;|num:&#160;u32|&#160;-&gt;&#160;u32&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;calculating&#160;slowly...&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::sleep(Duration::from_secs(2));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;num<br/>&#160;&#160;&#160;&#160;};<br/>
<b>Listing&#160;13-2:&#160;Adding&#160;optional&#160;type&#160;annotations&#160;of&#160;the&#160;parameter&#160;and&#160;return&#160;value&#160;types&#160;in&#160;the&#160;closure</b><br/>
With type annotations added, the syntax of closures looks more similar to the syntax of<br/>functions. Here we deﬁne a function that adds 1 to its parameter and a closure that has the<br/>same behavior, for comparison. We’ve added some spaces to line up the relevant parts. This<br/>illustrates how closure syntax is similar to function syntax except for the use of pipes and<br/>the amount of syntax that is optional:<br/>
fn&#160;&#160;add_one_v1&#160;&#160;&#160;(x:&#160;u32)&#160;-&gt;&#160;u32&#160;{&#160;x&#160;+&#160;1&#160;}<br/>let&#160;add_one_v2&#160;=&#160;|x:&#160;u32|&#160;-&gt;&#160;u32&#160;{&#160;x&#160;+&#160;1&#160;};<br/>let&#160;add_one_v3&#160;=&#160;|x|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{&#160;x&#160;+&#160;1&#160;};<br/>let&#160;add_one_v4&#160;=&#160;|x|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x&#160;+&#160;1&#160;&#160;;<br/>
The&#160;ﬁrst line shows a function deﬁnition, and the second line shows a fully annotated<br/>closure deﬁnition. In the third line, we remove the type annotations from the closure<br/>deﬁnition. In the fourth line, we remove the brackets, which are optional because the<br/>closure body has only one expression. These are all valid deﬁnitions that will produce the<br/>same behavior when they’re called. The&#160;&#160;add_one_v3&#160;&#160;and&#160;&#160;add_one_v4&#160;&#160;lines require the<br/>closures to be evaluated to be able to compile because the types will be inferred from their<br/>usage. This is similar to&#160;&#160;let&#160;v&#160;=&#160;Vec::new();&#160;&#160;needing either type annotations or values of<br/>some type to be inserted into the&#160;&#160;Vec&#160;&#160;for Rust to be able to infer the type.<br/>
For closure deﬁnitions, the compiler will infer one concrete type for each of their<br/>parameters and for their return value. For instance, Listing 13-3 shows the deﬁnition of a<br/>short closure that just returns the value it receives as a parameter. This closure isn’t very<br/>useful except for the purposes of this example. Note that we haven’t added any type<br/>
https://doc.rust-lang.org/book/print.html<br/>
339/627<br/>
<hr/>
<a name=340></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
annotations to the deﬁnition. Because there are no type annotations, we can call the closure<br/>with any type, which we’ve done here with&#160;&#160;String&#160;&#160;the&#160;ﬁrst time. If we then try to call<br/>
example_closure&#160;&#160;with an integer, we’ll get an error.<br/>
Filename: src/main.rs<br/>
&#160;&#160;&#160;&#160;let&#160;example_closure&#160;=&#160;|x|&#160;x;<br/>
&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;example_closure(String::from(&#34;hello&#34;));<br/>&#160;&#160;&#160;&#160;let&#160;n&#160;=&#160;example_closure(5);<br/>
<b>Listing&#160;13-3:&#160;Attempting&#160;to&#160;call&#160;a&#160;closure&#160;whose&#160;types&#160;are&#160;inferred&#160;with&#160;two&#160;diﬀerent&#160;types</b><br/>
The compiler gives us this error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;closure-example&#160;v0.1.0&#160;(file:///projects/closure-example)<br/>error[E0308]:&#160;mismatched&#160;types<br/>&#160;--&gt;&#160;src/main.rs:5:29<br/>&#160;&#160;|<br/>5&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;n&#160;=&#160;example_closure(5);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;---------------&#160;^-&#160;help:&#160;try&#160;using&#160;a&#160;conversion&#160;method:&#160;<br/>`.to_string()`<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;expected&#160;struct&#160;`String`,&#160;found&#160;integer<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;arguments&#160;to&#160;this&#160;function&#160;are&#160;incorrect<br/>&#160;&#160;|<br/>note:&#160;closure&#160;parameter&#160;defined&#160;here<br/>&#160;--&gt;&#160;src/main.rs:2:28<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;example_closure&#160;=&#160;|x|&#160;x;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0308`.<br/>error:&#160;could&#160;not&#160;compile&#160;`closure-example`&#160;due&#160;to&#160;previous&#160;error<br/>
The&#160;ﬁrst time we call&#160;&#160;example_closure&#160;&#160;with the&#160;&#160;String&#160;&#160;value, the compiler infers the type<br/>of&#160;&#160;x&#160;&#160;and the return type of the closure to be&#160;&#160;String&#160;. Those types are then locked into the<br/>closure in&#160;&#160;example_closure&#160;, and we get a type error when we next try to use a diﬀerent<br/>type with the same closure.<br/>
<a href="tests.html#340"><b>Capturing&#160;References&#160;or&#160;Moving&#160;Ownership</b></a><br/>
Closures can capture values from their environment in three ways, which directly map to<br/>the three ways a function can take a parameter: borrowing immutably, borrowing mutably,<br/>and taking ownership. The closure will decide which of these to use based on what the body<br/>of the function does with the captured values.<br/>
https://doc.rust-lang.org/book/print.html<br/>
340/627<br/>
<hr/>
<a name=341></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
In Listing 13-4, we deﬁne a closure that captures an immutable reference to the vector<br/>named&#160;&#160;list&#160;&#160;because it only needs an immutable reference to print the value:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;list&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>&#160;&#160;&#160;&#160;println!(&#34;Before&#160;defining&#160;closure:&#160;{:?}&#34;,&#160;list);<br/>
&#160;&#160;&#160;&#160;let&#160;only_borrows&#160;=&#160;||&#160;println!(&#34;From&#160;closure:&#160;{:?}&#34;,&#160;list);<br/>
&#160;&#160;&#160;&#160;println!(&#34;Before&#160;calling&#160;closure:&#160;{:?}&#34;,&#160;list);<br/>&#160;&#160;&#160;&#160;only_borrows();<br/>&#160;&#160;&#160;&#160;println!(&#34;After&#160;calling&#160;closure:&#160;{:?}&#34;,&#160;list);<br/>}<br/>
<b>Listing&#160;13-4:&#160;Deﬁning&#160;and&#160;calling&#160;a&#160;closure&#160;that&#160;captures&#160;an&#160;immutable&#160;reference</b><br/>
This example also illustrates that a variable can bind to a closure deﬁnition, and we can later<br/>call the closure by using the variable name and parentheses as if the variable name were a<br/>function name.<br/>
Because we can have multiple immutable references to&#160;&#160;list&#160;&#160;at the same time,&#160;&#160;list&#160;&#160;is still<br/>accessible from the code before the closure deﬁnition, after the closure deﬁnition but<br/>before the closure is called, and after the closure is called. This code compiles, runs, and<br/>prints:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;closure-example&#160;v0.1.0&#160;(file:///projects/closure-example)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.43s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/closure-example`<br/>Before&#160;defining&#160;closure:&#160;[1,&#160;2,&#160;3]<br/>Before&#160;calling&#160;closure:&#160;[1,&#160;2,&#160;3]<br/>From&#160;closure:&#160;[1,&#160;2,&#160;3]<br/>After&#160;calling&#160;closure:&#160;[1,&#160;2,&#160;3]<br/>
Next, in Listing 13-5, we change the closure body so that it adds an element to the&#160;&#160;list<br/>vector. The closure now captures a mutable reference:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;list&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>&#160;&#160;&#160;&#160;println!(&#34;Before&#160;defining&#160;closure:&#160;{:?}&#34;,&#160;list);<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;borrows_mutably&#160;=&#160;||&#160;list.push(7);<br/>
&#160;&#160;&#160;&#160;borrows_mutably();<br/>&#160;&#160;&#160;&#160;println!(&#34;After&#160;calling&#160;closure:&#160;{:?}&#34;,&#160;list);<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
341/627<br/>
<hr/>
<a name=342></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Listing&#160;13-5:&#160;Deﬁning&#160;and&#160;calling&#160;a&#160;closure&#160;that&#160;captures&#160;a&#160;mutable&#160;reference</b><br/>
This code compiles, runs, and prints:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;closure-example&#160;v0.1.0&#160;(file:///projects/closure-example)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.43s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/closure-example`<br/>Before&#160;defining&#160;closure:&#160;[1,&#160;2,&#160;3]<br/>After&#160;calling&#160;closure:&#160;[1,&#160;2,&#160;3,&#160;7]<br/>
Note that there’s no longer a&#160;&#160;println!&#160;&#160;between the deﬁnition and the call of the<br/>
borrows_mutably&#160;&#160;closure: when&#160;&#160;borrows_mutably&#160;&#160;is deﬁned, it captures a mutable<br/>
reference to&#160;&#160;list&#160;. We don’t use the closure again after the closure is called, so the mutable<br/>borrow ends. Between the closure deﬁnition and the closure call, an immutable borrow to<br/>print isn’t allowed because no other borrows are allowed when there’s a mutable borrow.<br/>Try adding a&#160;&#160;println!&#160;&#160;there to see what error message you get!<br/>
If you want to force the closure to take ownership of the values it uses in the environment<br/>even though the body of the closure doesn’t strictly need ownership, you can use the&#160;&#160;move<br/>keyword before the parameter list.<br/>
This technique is mostly useful when passing a closure to a new thread to move the data so<br/>that it’s owned by the new thread. We’ll discuss threads and why you would want to use<br/>them in detail in Chapter 16 when we talk about concurrency, but for now, let’s brieﬂy<br/>explore spawning a new thread using a closure that needs the&#160;&#160;move&#160;&#160;keyword. Listing 13-6<br/>shows Listing 13-4 modiﬁed to print the vector in a new thread rather than in the main<br/>thread:<br/>
Filename: src/main.rs<br/>
use&#160;std::thread;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;list&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>&#160;&#160;&#160;&#160;println!(&#34;Before&#160;defining&#160;closure:&#160;{:?}&#34;,&#160;list);<br/>
&#160;&#160;&#160;&#160;thread::spawn(move&#160;||&#160;println!(&#34;From&#160;thread:&#160;{:?}&#34;,&#160;list))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.join()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.unwrap();<br/>}<br/>
<b>Listing&#160;13-6:&#160;Using&#160;&#160;</b>move&#160;<b>&#160;to&#160;force&#160;the&#160;closure&#160;for&#160;the&#160;thread&#160;to&#160;take&#160;ownership&#160;of&#160;&#160;</b>list<br/>
We spawn a new thread, giving the thread a closure to run as an argument. The closure<br/>body prints out the list. In Listing 13-4, the closure only captured&#160;&#160;list&#160;&#160;using an immutable<br/>reference because that's the least amount of access to&#160;&#160;list&#160;&#160;needed to print it. In this<br/>example, even though the closure body still only needs an immutable reference, we need to<br/>specify that&#160;&#160;list&#160;&#160;should be moved into the closure by putting the&#160;&#160;move&#160;&#160;keyword at the<br/>
https://doc.rust-lang.org/book/print.html<br/>
342/627<br/>
<hr/>
<a name=343></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
beginning of the closure deﬁnition. The new thread might&#160;ﬁnish before the rest of the main<br/>thread&#160;ﬁnishes, or the main thread might&#160;ﬁnish&#160;ﬁrst. If the main thread maintained<br/>ownership of&#160;&#160;list&#160;&#160;but ended before the new thread did and dropped&#160;&#160;list&#160;, the<br/>immutable reference in the thread would be invalid. Therefore, the compiler requires that<br/>
list&#160;&#160;be moved into the closure given to the new thread so the reference will be valid. Try<br/>
removing the&#160;&#160;move&#160;&#160;keyword or using&#160;&#160;list&#160;&#160;in the main thread after the closure is deﬁned<br/>to see what compiler errors you get!<br/>
<a href="tests.html#343"><b>Moving&#160;Captured&#160;Values&#160;Out&#160;of&#160;Closures&#160;and&#160;the&#160;</b>Fn<b>&#160;Traits</b></a><br/>
Once a closure has captured a reference or captured ownership of a value from the<br/>environment where the closure is deﬁned (thus aﬀecting what, if anything, is moved&#160;<i>into</i>&#160;the<br/>closure), the code in the body of the closure deﬁnes what happens to the references or<br/>values when the closure is evaluated later (thus aﬀecting what, if anything, is moved&#160;<i>out of<br/></i>the closure). A closure body can do any of the following: move a captured value out of the<br/>closure, mutate the captured value, neither move nor mutate the value, or capture nothing<br/>from the environment to begin with.<br/>
The way a closure captures and handles values from the environment aﬀects which traits<br/>the closure implements, and traits are how functions and structs can specify what kinds of<br/>closures they can use. Closures will automatically implement one, two, or all three of these<br/>
Fn&#160;&#160;traits, in an additive fashion, depending on how the closure’s body handles the values:<br/>
1.&#160;&#160;FnOnce&#160;&#160;applies to closures that can be called once. All closures implement at least this<br/>
trait, because all closures can be called. A closure that moves captured values out of its<br/>body will only implement&#160;&#160;FnOnce&#160;&#160;and none of the other&#160;&#160;Fn&#160;&#160;traits, because it can only<br/>be called once.<br/>
2.&#160;&#160;FnMut&#160;&#160;applies to closures that don’t move captured values out of their body, but that<br/>
might mutate the captured values. These closures can be called more than once.<br/>
3.&#160;&#160;Fn&#160;&#160;applies to closures that don’t move captured values out of their body and that<br/>
don’t mutate captured values, as well as closures that capture nothing from their<br/>environment. These closures can be called more than once without mutating their<br/>environment, which is important in cases such as calling a closure multiple times<br/>concurrently.<br/>
Let’s look at the deﬁnition of the&#160;&#160;unwrap_or_else&#160;&#160;method on&#160;&#160;Option&lt;T&gt;&#160;&#160;that we used in<br/>Listing 13-1:<br/>
https://doc.rust-lang.org/book/print.html<br/>
343/627<br/>
<hr/>
<a name=344></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
impl&lt;T&gt;&#160;Option&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;unwrap_or_else&lt;F&gt;(self,&#160;f:&#160;F)&#160;-&gt;&#160;T<br/>&#160;&#160;&#160;&#160;where<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F:&#160;FnOnce()&#160;-&gt;&#160;T<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;self&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(x)&#160;=&gt;&#160;x,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;None&#160;=&gt;&#160;f(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
Recall that&#160;&#160;T&#160;&#160;is the generic type representing the type of the value in the&#160;&#160;Some&#160;&#160;variant of an<br/>
Option&#160;. That type&#160;&#160;T&#160;&#160;is also the return type of the&#160;&#160;unwrap_or_else&#160;&#160;function: code that calls<br/>unwrap_or_else&#160;&#160;on an&#160;&#160;Option&lt;String&gt;&#160;, for example, will get a&#160;&#160;String&#160;.<br/>
Next, notice that the&#160;&#160;unwrap_or_else&#160;&#160;function has the additional generic type parameter<br/>
F&#160;. The&#160;&#160;F&#160;&#160;type is the type of the parameter named&#160;&#160;f&#160;, which is the closure we provide when<br/>
calling&#160;&#160;unwrap_or_else&#160;.<br/>
The trait bound speciﬁed on the generic type&#160;&#160;F&#160;&#160;is&#160;&#160;FnOnce()&#160;-&gt;&#160;T&#160;, which means&#160;&#160;F&#160;&#160;must be<br/>able to be called once, take no arguments, and return a&#160;&#160;T&#160;. Using&#160;&#160;FnOnce&#160;&#160;in the trait bound<br/>expresses the constraint that&#160;&#160;unwrap_or_else&#160;&#160;is only going to call&#160;&#160;f&#160;&#160;at most one time. In<br/>the body of&#160;&#160;unwrap_or_else&#160;, we can see that if the&#160;&#160;Option&#160;&#160;is&#160;&#160;Some&#160;,&#160;&#160;f&#160;&#160;won’t be called. If<br/>the&#160;&#160;Option&#160;&#160;is&#160;&#160;None&#160;,&#160;&#160;f&#160;&#160;will be called once. Because all closures implement&#160;&#160;FnOnce&#160;,<br/>
unwrap_or_else&#160;&#160;accepts the most diﬀerent kinds of closures and is as&#160;ﬂexible as it can be.<br/>
Note: Functions can implement all three of the&#160;&#160;Fn&#160;&#160;traits too. If what we want to do<br/>doesn’t require capturing a value from the environment, we can use the name of a<br/>function rather than a closure where we need something that implements one of the<br/>
Fn&#160;&#160;traits. For example, on an&#160;&#160;Option&lt;Vec&lt;T&gt;&gt;&#160;&#160;value, we could call<br/>unwrap_or_else(Vec::new)&#160;&#160;to get a new, empty vector if the value is&#160;&#160;None&#160;.<br/>
Now let’s look at the standard library method&#160;&#160;sort_by_key&#160;&#160;deﬁned on slices, to see how<br/>that diﬀers from&#160;&#160;unwrap_or_else&#160;&#160;and why&#160;&#160;sort_by_key&#160;&#160;uses&#160;&#160;FnMut&#160;&#160;instead of&#160;&#160;FnOnce&#160;&#160;for<br/>the trait bound. The closure gets one argument in the form of a reference to the current<br/>item in the slice being considered, and returns a value of type&#160;&#160;K&#160;&#160;that can be ordered. This<br/>function is useful when you want to sort a slice by a particular attribute of each item. In<br/>Listing 13-7, we have a list of&#160;&#160;Rectangle&#160;&#160;instances and we use&#160;&#160;sort_by_key&#160;&#160;to order them<br/>by their&#160;&#160;width&#160;&#160;attribute from low to high:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
344/627<br/>
<hr/>
<a name=345></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
#[derive(Debug)]<br/>struct&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;width:&#160;u32,<br/>&#160;&#160;&#160;&#160;height:&#160;u32,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;list&#160;=&#160;[<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rectangle&#160;{&#160;width:&#160;10,&#160;height:&#160;1&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rectangle&#160;{&#160;width:&#160;3,&#160;height:&#160;5&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rectangle&#160;{&#160;width:&#160;7,&#160;height:&#160;12&#160;},<br/>&#160;&#160;&#160;&#160;];<br/>
&#160;&#160;&#160;&#160;list.sort_by_key(|r|&#160;r.width);<br/>&#160;&#160;&#160;&#160;println!(&#34;{:#?}&#34;,&#160;list);<br/>}<br/>
<b>Listing&#160;13-7:&#160;Using&#160;&#160;</b>sort_by_key&#160;<b>&#160;to&#160;order&#160;rectangles&#160;by&#160;width</b><br/>
This code prints:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;rectangles&#160;v0.1.0&#160;(file:///projects/rectangles)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.41s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/rectangles`<br/>[<br/>&#160;&#160;&#160;&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;3,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;5,<br/>&#160;&#160;&#160;&#160;},<br/>&#160;&#160;&#160;&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;7,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;12,<br/>&#160;&#160;&#160;&#160;},<br/>&#160;&#160;&#160;&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;10,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;1,<br/>&#160;&#160;&#160;&#160;},<br/>]<br/>
The reason&#160;&#160;sort_by_key&#160;&#160;is deﬁned to take an&#160;&#160;FnMut&#160;&#160;closure is that it calls the closure<br/>multiple times: once for each item in the slice. The closure&#160;&#160;|r|&#160;r.width&#160;&#160;doesn’t capture,<br/>mutate, or move out anything from its environment, so it meets the trait bound<br/>requirements.<br/>
In contrast, Listing 13-8 shows an example of a closure that implements just the&#160;&#160;FnOnce<br/>trait, because it moves a value out of the environment. The compiler won’t let us use this<br/>closure with&#160;&#160;sort_by_key&#160;:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
345/627<br/>
<hr/>
<a name=346></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
#[derive(Debug)]<br/>struct&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;width:&#160;u32,<br/>&#160;&#160;&#160;&#160;height:&#160;u32,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;list&#160;=&#160;[<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rectangle&#160;{&#160;width:&#160;10,&#160;height:&#160;1&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rectangle&#160;{&#160;width:&#160;3,&#160;height:&#160;5&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rectangle&#160;{&#160;width:&#160;7,&#160;height:&#160;12&#160;},<br/>&#160;&#160;&#160;&#160;];<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;sort_operations&#160;=&#160;vec![];<br/>&#160;&#160;&#160;&#160;let&#160;value&#160;=&#160;String::from(&#34;by&#160;key&#160;called&#34;);<br/>
&#160;&#160;&#160;&#160;list.sort_by_key(|r|&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sort_operations.push(value);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;r.width<br/>&#160;&#160;&#160;&#160;});<br/>&#160;&#160;&#160;&#160;println!(&#34;{:#?}&#34;,&#160;list);<br/>}<br/>
<b>Listing&#160;13-8:&#160;Attempting&#160;to&#160;use&#160;an&#160;&#160;</b>FnOnce&#160;<b>&#160;closure&#160;with&#160;&#160;</b>sort_by_key<br/>
This is a contrived, convoluted way (that doesn’t work) to try and count the number of times<br/>
sort_by_key&#160;&#160;gets called when sorting&#160;&#160;list&#160;. This code attempts to do this counting by<br/>
pushing&#160;&#160;value&#160;—a&#160;&#160;String&#160;&#160;from the closure’s environment—into the&#160;&#160;sort_operations<br/>vector. The closure captures&#160;&#160;value&#160;&#160;then moves&#160;&#160;value&#160;&#160;out of the closure by transferring<br/>ownership of&#160;&#160;value&#160;&#160;to the&#160;&#160;sort_operations&#160;&#160;vector. This closure can be called once; trying<br/>to call it a second time wouldn’t work because&#160;&#160;value&#160;&#160;would no longer be in the<br/>environment to be pushed into&#160;&#160;sort_operations&#160;&#160;again! Therefore, this closure only<br/>implements&#160;&#160;FnOnce&#160;. When we try to compile this code, we get this error that&#160;&#160;value&#160;&#160;can’t<br/>be moved out of the closure because the closure must implement&#160;&#160;FnMut&#160;:<br/>
https://doc.rust-lang.org/book/print.html<br/>
346/627<br/>
<hr/>
<a name=347></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;rectangles&#160;v0.1.0&#160;(file:///projects/rectangles)<br/>error[E0507]:&#160;cannot&#160;move&#160;out&#160;of&#160;`value`,&#160;a&#160;captured&#160;variable&#160;in&#160;an&#160;`FnMut`&#160;<br/>closure<br/>&#160;&#160;--&gt;&#160;src/main.rs:18:30<br/>&#160;&#160;&#160;|<br/>15&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;value&#160;=&#160;String::from(&#34;by&#160;key&#160;called&#34;);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-----&#160;captured&#160;outer&#160;variable<br/>16&#160;|<br/>17&#160;|&#160;&#160;&#160;&#160;&#160;list.sort_by_key(|r|&#160;{<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;---&#160;captured&#160;by&#160;this&#160;`FnMut`&#160;closure<br/>18&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sort_operations.push(value);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^&#160;move&#160;occurs&#160;because&#160;`value`&#160;has&#160;type&#160;<br/>`String`,&#160;which&#160;does&#160;not&#160;implement&#160;the&#160;`Copy`&#160;trait<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0507`.<br/>error:&#160;could&#160;not&#160;compile&#160;`rectangles`&#160;due&#160;to&#160;previous&#160;error<br/>
The error points to the line in the closure body that moves&#160;&#160;value&#160;&#160;out of the environment.<br/>To&#160;ﬁx this, we need to change the closure body so that it doesn’t move values out of the<br/>environment. To count the number of times&#160;&#160;sort_by_key&#160;&#160;is called, keeping a counter in the<br/>environment and incrementing its value in the closure body is a more straightforward way<br/>to calculate that. The closure in Listing 13-9 works with&#160;&#160;sort_by_key&#160;&#160;because it is only<br/>capturing a mutable reference to the&#160;&#160;num_sort_operations&#160;&#160;counter and can therefore be<br/>called more than once:<br/>
Filename: src/main.rs<br/>
#[derive(Debug)]<br/>struct&#160;Rectangle&#160;{<br/>&#160;&#160;&#160;&#160;width:&#160;u32,<br/>&#160;&#160;&#160;&#160;height:&#160;u32,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;list&#160;=&#160;[<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rectangle&#160;{&#160;width:&#160;10,&#160;height:&#160;1&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rectangle&#160;{&#160;width:&#160;3,&#160;height:&#160;5&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rectangle&#160;{&#160;width:&#160;7,&#160;height:&#160;12&#160;},<br/>&#160;&#160;&#160;&#160;];<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;num_sort_operations&#160;=&#160;0;<br/>&#160;&#160;&#160;&#160;list.sort_by_key(|r|&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;num_sort_operations&#160;+=&#160;1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;r.width<br/>&#160;&#160;&#160;&#160;});<br/>&#160;&#160;&#160;&#160;println!(&#34;{:#?},&#160;sorted&#160;in&#160;{num_sort_operations}&#160;operations&#34;,&#160;list);<br/>}<br/>
<b>Listing&#160;13-9:&#160;Using&#160;an&#160;&#160;</b>FnMut&#160;<b>&#160;closure&#160;with&#160;&#160;</b>sort_by_key&#160;<b>&#160;is&#160;allowed</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
347/627<br/>
<hr/>
<a name=348></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The&#160;&#160;Fn&#160;&#160;traits are important when deﬁning or using functions or types that make use of<br/>closures. In the next section, we’ll discuss iterators. Many iterator methods take closure<br/>arguments, so keep these closure details in mind as we continue!<br/>
https://doc.rust-lang.org/book/print.html<br/>
348/627<br/>
<hr/>
<a name=349></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#349"><b>Processing a Series of Items with Iterators</b></a><br/>
The iterator pattern allows you to perform some task on a sequence of items in turn. An<br/>iterator is responsible for the logic of iterating over each item and determining when the<br/>sequence has&#160;ﬁnished. When you use iterators, you don’t have to reimplement that logic<br/>yourself.<br/>
In Rust, iterators are&#160;<i>lazy</i>, meaning they have no eﬀect until you call methods that consume<br/>the iterator to use it up. For example, the code in Listing 13-10 creates an iterator over the<br/>items in the vector&#160;&#160;v1&#160;&#160;by calling the&#160;&#160;iter&#160;&#160;method deﬁned on&#160;&#160;Vec&lt;T&gt;&#160;. This code by itself<br/>doesn’t do anything useful.<br/>
&#160;&#160;&#160;&#160;let&#160;v1&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>
&#160;&#160;&#160;&#160;let&#160;v1_iter&#160;=&#160;v1.iter();<br/>
<b>Listing&#160;13-10:&#160;Creating&#160;an&#160;iterator</b><br/>
The iterator is stored in the&#160;&#160;v1_iter&#160;&#160;variable. Once we’ve created an iterator, we can use it<br/>in a variety of ways. In Listing 3-5 in Chapter 3, we iterated over an array using a&#160;&#160;for&#160;&#160;loop to<br/>execute some code on each of its items. Under the hood this implicitly created and then<br/>consumed an iterator, but we glossed over how exactly that works until now.<br/>
In the example in Listing 13-11, we separate the creation of the iterator from the use of the<br/>iterator in the&#160;&#160;for&#160;&#160;loop. When the&#160;&#160;for&#160;&#160;loop is called using the iterator in&#160;&#160;v1_iter&#160;, each<br/>element in the iterator is used in one iteration of the loop, which prints out each value.<br/>
&#160;&#160;&#160;&#160;let&#160;v1&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>
&#160;&#160;&#160;&#160;let&#160;v1_iter&#160;=&#160;v1.iter();<br/>
&#160;&#160;&#160;&#160;for&#160;val&#160;in&#160;v1_iter&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Got:&#160;{}&#34;,&#160;val);<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;13-11:&#160;Using&#160;an&#160;iterator&#160;in&#160;a&#160;&#160;</b>for&#160;<b>&#160;loop</b><br/>
In languages that don’t have iterators provided by their standard libraries, you would likely<br/>write this same functionality by starting a variable at index 0, using that variable to index<br/>into the vector to get a value, and incrementing the variable value in a loop until it reached<br/>the total number of items in the vector.<br/>
Iterators handle all that logic for you, cutting down on repetitive code you could potentially<br/>mess up. Iterators give you more&#160;ﬂexibility to use the same logic with many diﬀerent kinds<br/>
https://doc.rust-lang.org/book/print.html<br/>
349/627<br/>
<hr/>
<a name=350></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
of sequences, not just data structures you can index into, like vectors. Let’s examine how<br/>iterators do that.<br/>
<a href="tests.html#350"><b>The&#160;</b>Iterator<b>&#160;Trait&#160;and&#160;the&#160;</b>next<b>&#160;Method</b></a><br/>
All iterators implement a trait named&#160;&#160;Iterator&#160;&#160;that is deﬁned in the standard library. The<br/>deﬁnition of the trait looks like this:<br/>
pub&#160;trait&#160;Iterator&#160;{<br/>&#160;&#160;&#160;&#160;type&#160;Item;<br/>
&#160;&#160;&#160;&#160;fn&#160;next(&amp;mut&#160;self)&#160;-&gt;&#160;Option&lt;Self::Item&gt;;<br/>
&#160;&#160;&#160;&#160;//&#160;methods&#160;with&#160;default&#160;implementations&#160;elided<br/>}<br/>
Notice this deﬁnition uses some new syntax:&#160;&#160;type&#160;Item&#160;&#160;and&#160;&#160;Self::Item&#160;, which are<br/>deﬁning an&#160;<i>associated type</i>&#160;with this trait. We’ll talk about associated types in depth in<br/>Chapter 19. For now, all you need to know is that this code says implementing the<br/>
Iterator&#160;&#160;trait requires that you also deﬁne an&#160;&#160;Item&#160;&#160;type, and this&#160;&#160;Item&#160;&#160;type is used in<br/>
the return type of the&#160;&#160;next&#160;&#160;method. In other words, the&#160;&#160;Item&#160;&#160;type will be the type<br/>returned from the iterator.<br/>
The&#160;&#160;Iterator&#160;&#160;trait only requires implementors to deﬁne one method: the&#160;&#160;next&#160;&#160;method,<br/>which returns one item of the iterator at a time wrapped in&#160;&#160;Some&#160;&#160;and, when iteration is<br/>over, returns&#160;&#160;None&#160;.<br/>
We can call the&#160;&#160;next&#160;&#160;method on iterators directly; Listing 13-12 demonstrates what values<br/>are returned from repeated calls to&#160;&#160;next&#160;&#160;on the iterator created from the vector.<br/>
Filename: src/lib.rs<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;iterator_demonstration()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;v1&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;v1_iter&#160;=&#160;v1.iter();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(v1_iter.next(),&#160;Some(&amp;1));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(v1_iter.next(),&#160;Some(&amp;2));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(v1_iter.next(),&#160;Some(&amp;3));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(v1_iter.next(),&#160;None);<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;13-12:&#160;Calling&#160;the&#160;&#160;</b>next&#160;<b>&#160;method&#160;on&#160;an&#160;iterator</b><br/>
Note that we needed to make&#160;&#160;v1_iter&#160;&#160;mutable: calling the&#160;&#160;next&#160;&#160;method on an iterator<br/>changes internal state that the iterator uses to keep track of where it is in the sequence. In<br/>
https://doc.rust-lang.org/book/print.html<br/>
350/627<br/>
<hr/>
<a name=351></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
other words, this code&#160;<i>consumes</i>, or uses up, the iterator. Each call to&#160;&#160;next&#160;&#160;eats up an item<br/>from the iterator. We didn’t need to make&#160;&#160;v1_iter&#160;&#160;mutable when we used a&#160;&#160;for&#160;&#160;loop<br/>because the loop took ownership of&#160;&#160;v1_iter&#160;&#160;and made it mutable behind the scenes.<br/>
Also note that the values we get from the calls to&#160;&#160;next&#160;&#160;are immutable references to the<br/>values in the vector. The&#160;&#160;iter&#160;&#160;method produces an iterator over immutable references. If<br/>we want to create an iterator that takes ownership of&#160;&#160;v1&#160;&#160;and returns owned values, we can<br/>call&#160;&#160;into_iter&#160;&#160;instead of&#160;&#160;iter&#160;. Similarly, if we want to iterate over mutable references, we<br/>can call&#160;&#160;iter_mut&#160;&#160;instead of&#160;&#160;iter&#160;.<br/>
<a href="tests.html#351"><b>Methods&#160;that&#160;Consume&#160;the&#160;Iterator</b></a><br/>
The&#160;&#160;Iterator&#160;&#160;trait has a number of diﬀerent methods with default implementations<br/>provided by the standard library; you can&#160;ﬁnd out about these methods by looking in the<br/>standard library API documentation for the&#160;&#160;Iterator&#160;&#160;trait. Some of these methods call the<br/>
next&#160;&#160;method in their deﬁnition, which is why you’re required to implement the&#160;&#160;next<br/>
method when implementing the&#160;&#160;Iterator&#160;&#160;trait.<br/>
Methods that call&#160;&#160;next&#160;&#160;are called&#160;<i>consuming adaptors</i>, because calling them uses up the<br/>iterator. One example is the&#160;&#160;sum&#160;&#160;method, which takes ownership of the iterator and<br/>iterates through the items by repeatedly calling&#160;&#160;next&#160;, thus consuming the iterator. As it<br/>iterates through, it adds each item to a running total and returns the total when iteration is<br/>complete. Listing 13-13 has a test illustrating a use of the&#160;&#160;sum&#160;&#160;method:<br/>
Filename: src/lib.rs<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;iterator_sum()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;v1&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;v1_iter&#160;=&#160;v1.iter();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;total:&#160;i32&#160;=&#160;v1_iter.sum();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(total,&#160;6);<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;13-13:&#160;Calling&#160;the&#160;&#160;</b>sum&#160;<b>&#160;method&#160;to&#160;get&#160;the&#160;total&#160;of&#160;all&#160;items&#160;in&#160;the&#160;iterator</b><br/>
We aren’t allowed to use&#160;&#160;v1_iter&#160;&#160;after the call to&#160;&#160;sum&#160;&#160;because&#160;&#160;sum&#160;&#160;takes ownership of the<br/>iterator we call it on.<br/>
https://doc.rust-lang.org/book/print.html<br/>
351/627<br/>
<hr/>
<a name=352></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#352"><b>Methods&#160;that&#160;Produce&#160;Other&#160;Iterators</b></a><br/>
<i>Iterator adaptors</i>&#160;are methods deﬁned on the&#160;&#160;Iterator&#160;&#160;trait that don’t consume the<br/>iterator. Instead, they produce diﬀerent iterators by changing some aspect of the original<br/>iterator.<br/>
Listing 13-14 shows an example of calling the iterator adaptor method&#160;&#160;map&#160;, which takes a<br/>closure to call on each item as the items are iterated through. The&#160;&#160;map&#160;&#160;method returns a<br/>new iterator that produces the modiﬁed items. The closure here creates a new iterator in<br/>which each item from the vector will be incremented by 1:<br/>
Filename: src/main.rs<br/>
&#160;&#160;&#160;&#160;let&#160;v1:&#160;Vec&lt;i32&gt;&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>
&#160;&#160;&#160;&#160;v1.iter().map(|x|&#160;x&#160;+&#160;1);<br/>
<b>Listing&#160;13-14:&#160;Calling&#160;the&#160;iterator&#160;adaptor&#160;&#160;</b>map&#160;<b>&#160;to&#160;create&#160;a&#160;new&#160;iterator</b><br/>
However, this code produces a warning:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;iterators&#160;v0.1.0&#160;(file:///projects/iterators)<br/>warning:&#160;unused&#160;`Map`&#160;that&#160;must&#160;be&#160;used<br/>&#160;--&gt;&#160;src/main.rs:4:5<br/>&#160;&#160;|<br/>4&#160;|&#160;&#160;&#160;&#160;&#160;v1.iter().map(|x|&#160;x&#160;+&#160;1);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^^^^^^^^^<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;iterators&#160;are&#160;lazy&#160;and&#160;do&#160;nothing&#160;unless&#160;consumed<br/>&#160;&#160;=&#160;note:&#160;`#[warn(unused_must_use)]`&#160;on&#160;by&#160;default<br/>
warning:&#160;`iterators`&#160;(bin&#160;&#34;iterators&#34;)&#160;generated&#160;1&#160;warning<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.47s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/iterators`<br/>
The code in Listing 13-14 doesn’t do anything; the closure we’ve speciﬁed never gets called.<br/>The warning reminds us why: iterator adaptors are lazy, and we need to consume the<br/>iterator here.<br/>
To&#160;ﬁx this warning and consume the iterator, we’ll use the&#160;&#160;collect&#160;&#160;method, which we used<br/>in Chapter 12 with&#160;&#160;env::args&#160;&#160;in Listing 12-1. This method consumes the iterator and<br/>collects the resulting values into a collection data type.<br/>
In Listing 13-15, we collect the results of iterating over the iterator that’s returned from the<br/>call to&#160;&#160;map&#160;&#160;into a vector. This vector will end up containing each item from the original<br/>vector incremented by 1.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
352/627<br/>
<hr/>
<a name=353></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;let&#160;v1:&#160;Vec&lt;i32&gt;&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>
&#160;&#160;&#160;&#160;let&#160;v2:&#160;Vec&lt;_&gt;&#160;=&#160;v1.iter().map(|x|&#160;x&#160;+&#160;1).collect();<br/>
&#160;&#160;&#160;&#160;assert_eq!(v2,&#160;vec![2,&#160;3,&#160;4]);<br/>
<b>Listing&#160;13-15:&#160;Calling&#160;the&#160;&#160;</b>map&#160;<b>&#160;method&#160;to&#160;create&#160;a&#160;new&#160;iterator&#160;and&#160;then&#160;calling&#160;the&#160;&#160;</b>collect&#160;<b>&#160;method&#160;to<br/>consume&#160;the&#160;new&#160;iterator&#160;and&#160;create&#160;a&#160;vector</b><br/>
Because&#160;&#160;map&#160;&#160;takes a closure, we can specify any operation we want to perform on each<br/>item. This is a great example of how closures let you customize some behavior while reusing<br/>the iteration behavior that the&#160;&#160;Iterator&#160;&#160;trait provides.<br/>
You can chain multiple calls to iterator adaptors to perform complex actions in a readable<br/>way. But because all iterators are lazy, you have to call one of the consuming adaptor<br/>methods to get results from calls to iterator adaptors.<br/>
<a href="tests.html#353"><b>Using&#160;Closures&#160;that&#160;Capture&#160;Their&#160;Environment</b></a><br/>
Many iterator adapters take closures as arguments, and commonly the closures we’ll specify<br/>as arguments to iterator adapters will be closures that capture their environment.<br/>
For this example, we’ll use the&#160;&#160;filter&#160;&#160;method that takes a closure. The closure gets an<br/>item from the iterator and returns a&#160;&#160;bool&#160;. If the closure returns&#160;&#160;true&#160;, the value will be<br/>included in the iteration produced by&#160;&#160;filter&#160;. If the closure returns&#160;&#160;false&#160;, the value won’t<br/>be included.<br/>
In Listing 13-16, we use&#160;&#160;filter&#160;&#160;with a closure that captures the&#160;&#160;shoe_size&#160;&#160;variable from<br/>its environment to iterate over a collection of&#160;&#160;Shoe&#160;&#160;struct instances. It will return only shoes<br/>that are the speciﬁed size.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
353/627<br/>
<hr/>
<a name=354></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
#[derive(PartialEq,&#160;Debug)]<br/>struct&#160;Shoe&#160;{<br/>&#160;&#160;&#160;&#160;size:&#160;u32,<br/>&#160;&#160;&#160;&#160;style:&#160;String,<br/>}<br/>
fn&#160;shoes_in_size(shoes:&#160;Vec&lt;Shoe&gt;,&#160;shoe_size:&#160;u32)&#160;-&gt;&#160;Vec&lt;Shoe&gt;&#160;{<br/>&#160;&#160;&#160;&#160;shoes.into_iter().filter(|s|&#160;s.size&#160;==&#160;shoe_size).collect()<br/>}<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;filters_by_size()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;shoes&#160;=&#160;vec![<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Shoe&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size:&#160;10,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;style:&#160;String::from(&#34;sneaker&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Shoe&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size:&#160;13,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;style:&#160;String::from(&#34;sandal&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Shoe&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size:&#160;10,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;style:&#160;String::from(&#34;boot&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;];<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;in_my_size&#160;=&#160;shoes_in_size(shoes,&#160;10);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in_my_size,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vec![<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Shoe&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size:&#160;10,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;style:&#160;String::from(&#34;sneaker&#34;)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Shoe&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;size:&#160;10,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;style:&#160;String::from(&#34;boot&#34;)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;]<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;13-16:&#160;Using&#160;the&#160;&#160;</b>filter&#160;<b>&#160;method&#160;with&#160;a&#160;closure&#160;that&#160;captures&#160;&#160;</b>shoe_size<br/>
The&#160;&#160;shoes_in_size&#160;&#160;function takes ownership of a vector of shoes and a shoe size as<br/>parameters. It returns a vector containing only shoes of the speciﬁed size.<br/>
https://doc.rust-lang.org/book/print.html<br/>
354/627<br/>
<hr/>
<a name=355></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
In the body of&#160;&#160;shoes_in_size&#160;, we call&#160;&#160;into_iter&#160;&#160;to create an iterator that takes ownership<br/>of the vector. Then we call&#160;&#160;filter&#160;&#160;to adapt that iterator into a new iterator that only<br/>contains elements for which the closure returns&#160;&#160;true&#160;.<br/>
The closure captures the&#160;&#160;shoe_size&#160;&#160;parameter from the environment and compares the<br/>value with each shoe’s size, keeping only shoes of the size speciﬁed. Finally, calling&#160;&#160;collect<br/>gathers the values returned by the adapted iterator into a vector that’s returned by the<br/>function.<br/>
The test shows that when we call&#160;&#160;shoes_in_size&#160;, we get back only shoes that have the<br/>same size as the value we speciﬁed.<br/>
https://doc.rust-lang.org/book/print.html<br/>
355/627<br/>
<hr/>
<a name=356></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#356"><b>Improving Our I/O Project</b></a><br/>
With this new knowledge about iterators, we can improve the I/O project in Chapter 12 by<br/>using iterators to make places in the code clearer and more concise. Let’s look at how<br/>iterators can improve our implementation of the&#160;&#160;Config::build&#160;&#160;function and the&#160;&#160;search<br/>function.<br/>
<a href="tests.html#356"><b>Removing&#160;a&#160;</b>clone<b>&#160;Using&#160;an&#160;Iterator</b></a><br/>
In Listing 12-6, we added code that took a slice of&#160;&#160;String&#160;&#160;values and created an instance of<br/>the&#160;&#160;Config&#160;&#160;struct by indexing into the slice and cloning the values, allowing the&#160;&#160;Config<br/>struct to own those values. In Listing 13-17, we’ve reproduced the implementation of the<br/>
Config::build&#160;&#160;function as it was in Listing 12-23:<br/>
Filename: src/lib.rs<br/>
impl&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;build(args:&#160;&amp;[String])&#160;-&gt;&#160;Result&lt;Config,&#160;&amp;'static&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;args.len()&#160;&lt;&#160;3&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;Err(&#34;not&#160;enough&#160;arguments&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;query&#160;=&#160;args[1].clone();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;file_path&#160;=&#160;args[2].clone();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;ignore_case&#160;=&#160;env::var(&#34;IGNORE_CASE&#34;).is_ok();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(Config&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;query,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;file_path,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ignore_case,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;})<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;13-17:&#160;Reproduction&#160;of&#160;the&#160;&#160;</b>Config::build&#160;<b>&#160;function&#160;from&#160;Listing&#160;12-23</b><br/>
At the time, we said not to worry about the ineﬃcient&#160;&#160;clone&#160;&#160;calls because we would<br/>remove them in the future. Well, that time is now!<br/>
We needed&#160;&#160;clone&#160;&#160;here because we have a slice with&#160;&#160;String&#160;&#160;elements in the parameter<br/>
args&#160;, but the&#160;&#160;build&#160;&#160;function doesn’t own&#160;&#160;args&#160;. To return ownership of a&#160;&#160;Config<br/>
instance, we had to clone the values from the&#160;&#160;query&#160;&#160;and&#160;&#160;file_path&#160;&#160;ﬁelds of&#160;&#160;Config&#160;&#160;so<br/>the&#160;&#160;Config&#160;&#160;instance can own its values.<br/>
https://doc.rust-lang.org/book/print.html<br/>
356/627<br/>
<hr/>
<a name=357></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
With our new knowledge about iterators, we can change the&#160;&#160;build&#160;&#160;function to take<br/>ownership of an iterator as its argument instead of borrowing a slice. We’ll use the iterator<br/>functionality instead of the code that checks the length of the slice and indexes into speciﬁc<br/>locations. This will clarify what the&#160;&#160;Config::build&#160;&#160;function is doing because the iterator will<br/>access the values.<br/>
Once&#160;&#160;Config::build&#160;&#160;takes ownership of the iterator and stops using indexing operations<br/>that borrow, we can move the&#160;&#160;String&#160;&#160;values from the iterator into&#160;&#160;Config&#160;&#160;rather than<br/>calling&#160;&#160;clone&#160;&#160;and making a new allocation.<br/>
<a href="tests.html#357"><b>Using the Returned Iterator Directly</b></a><br/>
Open your I/O project’s&#160;<i>src/main.rs</i>&#160;ﬁle, which should look like this:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;args:&#160;Vec&lt;String&gt;&#160;=&#160;env::args().collect();<br/>
&#160;&#160;&#160;&#160;let&#160;config&#160;=&#160;Config::build(&amp;args).unwrap_or_else(|err|&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;eprintln!(&#34;Problem&#160;parsing&#160;arguments:&#160;{err}&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;process::exit(1);<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
We’ll&#160;ﬁrst change the start of the&#160;&#160;main&#160;&#160;function that we had in Listing 12-24 to the code in<br/>Listing 13-18, which this time uses an iterator. This won’t compile until we update<br/>
Config::build&#160;&#160;as well.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;config&#160;=&#160;Config::build(env::args()).unwrap_or_else(|err|&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;eprintln!(&#34;Problem&#160;parsing&#160;arguments:&#160;{err}&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;process::exit(1);<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
<b>Listing&#160;13-18:&#160;Passing&#160;the&#160;return&#160;value&#160;of&#160;&#160;</b>env::args&#160;<b>&#160;to&#160;&#160;</b>Config::build<br/>
The&#160;&#160;env::args&#160;&#160;function returns an iterator! Rather than collecting the iterator values into a<br/>vector and then passing a slice to&#160;&#160;Config::build&#160;, now we’re passing ownership of the<br/>iterator returned from&#160;&#160;env::args&#160;&#160;to&#160;&#160;Config::build&#160;&#160;directly.<br/>
https://doc.rust-lang.org/book/print.html<br/>
357/627<br/>
<hr/>
<a name=358></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Next, we need to update the deﬁnition of&#160;&#160;Config::build&#160;. In your I/O project’s&#160;<i>src/lib.rs</i>&#160;ﬁle,<br/>let’s change the signature of&#160;&#160;Config::build&#160;&#160;to look like Listing 13-19. This still won’t<br/>compile because we need to update the function body.<br/>
Filename: src/lib.rs<br/>
impl&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;build(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mut&#160;args:&#160;impl&#160;Iterator&lt;Item&#160;=&#160;String&gt;,<br/>&#160;&#160;&#160;&#160;)&#160;-&gt;&#160;Result&lt;Config,&#160;&amp;'static&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
<b>Listing&#160;13-19:&#160;Updating&#160;the&#160;signature&#160;of&#160;&#160;</b>Config::build&#160;<b>&#160;to&#160;expect&#160;an&#160;iterator</b><br/>
The standard library documentation for the&#160;&#160;env::args&#160;&#160;function shows that the type of the<br/>iterator it returns is&#160;&#160;std::env::Args&#160;, and that type implements the&#160;&#160;Iterator&#160;&#160;trait and<br/>returns&#160;&#160;String&#160;&#160;values.<br/>
We’ve updated the signature of the&#160;&#160;Config::build&#160;&#160;function so the parameter&#160;&#160;args&#160;&#160;has a<br/>generic type with the trait bounds&#160;&#160;impl&#160;Iterator&lt;Item&#160;=&#160;String&gt;&#160;&#160;instead of&#160;&#160;&amp;[String]&#160;.<br/>This usage of the&#160;&#160;impl&#160;Trait&#160;<a href="https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters">&#160;syntax we discussed in the&#160;“Traits as Parameters”</a>&#160;section of<br/>Chapter 10 means that&#160;&#160;args&#160;&#160;can be any type that implements the&#160;&#160;Iterator&#160;&#160;type and<br/>returns&#160;&#160;String&#160;&#160;items.<br/>
Because we’re taking ownership of&#160;&#160;args&#160;&#160;and we’ll be mutating&#160;&#160;args&#160;&#160;by iterating over it, we<br/>can add the&#160;&#160;mut&#160;&#160;keyword into the speciﬁcation of the&#160;&#160;args&#160;&#160;parameter to make it mutable.<br/>
<a href="tests.html#358"><b>Using&#160;</b>Iterator<b>&#160;Trait Methods Instead of Indexing</b></a><br/>
Next, we’ll&#160;ﬁx the body of&#160;&#160;Config::build&#160;. Because&#160;&#160;args&#160;&#160;implements the&#160;&#160;Iterator&#160;&#160;trait,<br/>we know we can call the&#160;&#160;next&#160;&#160;method on it! Listing 13-20 updates the code from Listing 12-<br/>23 to use the&#160;&#160;next&#160;&#160;method:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
358/627<br/>
<hr/>
<a name=359></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
impl&#160;Config&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;build(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mut&#160;args:&#160;impl&#160;Iterator&lt;Item&#160;=&#160;String&gt;,<br/>&#160;&#160;&#160;&#160;)&#160;-&gt;&#160;Result&lt;Config,&#160;&amp;'static&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;args.next();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;query&#160;=&#160;match&#160;args.next()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(arg)&#160;=&gt;&#160;arg,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;None&#160;=&gt;&#160;return&#160;Err(&#34;Didn't&#160;get&#160;a&#160;query&#160;string&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;file_path&#160;=&#160;match&#160;args.next()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(arg)&#160;=&gt;&#160;arg,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;None&#160;=&gt;&#160;return&#160;Err(&#34;Didn't&#160;get&#160;a&#160;file&#160;path&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;ignore_case&#160;=&#160;env::var(&#34;IGNORE_CASE&#34;).is_ok();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(Config&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;query,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;file_path,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ignore_case,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;})<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;13-20:&#160;Changing&#160;the&#160;body&#160;of&#160;&#160;</b>Config::build&#160;<b>&#160;to&#160;use&#160;iterator&#160;methods</b><br/>
Remember that the&#160;ﬁrst value in the return value of&#160;&#160;env::args&#160;&#160;is the name of the program.<br/>We want to ignore that and get to the next value, so&#160;ﬁrst we call&#160;&#160;next&#160;&#160;and do nothing with<br/>the return value. Second, we call&#160;&#160;next&#160;&#160;to get the value we want to put in the&#160;&#160;query&#160;&#160;ﬁeld of<br/>
Config&#160;. If&#160;&#160;next&#160;&#160;returns a&#160;&#160;Some&#160;, we use a&#160;&#160;match&#160;&#160;to extract the value. If it returns&#160;&#160;None&#160;, it<br/>
means not enough arguments were given and we return early with an&#160;&#160;Err&#160;&#160;value. We do the<br/>same thing for the&#160;&#160;file_path&#160;&#160;value.<br/>
<a href="tests.html#359"><b>Making&#160;Code&#160;Clearer&#160;with&#160;Iterator&#160;Adaptors</b></a><br/>
We can also take advantage of iterators in the&#160;&#160;search&#160;&#160;function in our I/O project, which is<br/>reproduced here in Listing 13-21 as it was in Listing 12-19:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
359/627<br/>
<hr/>
<a name=360></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;fn&#160;search&lt;'a&gt;(query:&#160;&amp;str,&#160;contents:&#160;&amp;'a&#160;str)&#160;-&gt;&#160;Vec&lt;&amp;'a&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;results&#160;=&#160;Vec::new();<br/>
&#160;&#160;&#160;&#160;for&#160;line&#160;in&#160;contents.lines()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;line.contains(query)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;results.push(line);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;results<br/>}<br/>
<b>Listing&#160;13-21:&#160;The&#160;implementation&#160;of&#160;the&#160;&#160;</b>search&#160;<b>&#160;function&#160;from&#160;Listing&#160;12-19</b><br/>
We can write this code in a more concise way using iterator adaptor methods. Doing so also<br/>lets us avoid having a mutable intermediate&#160;&#160;results&#160;&#160;vector. The functional programming<br/>style prefers to minimize the amount of mutable state to make code clearer. Removing the<br/>mutable state might enable a future enhancement to make searching happen in parallel,<br/>because we wouldn’t have to manage concurrent access to the&#160;&#160;results&#160;&#160;vector. Listing 13-<br/>22 shows this change:<br/>
Filename: src/lib.rs<br/>
pub&#160;fn&#160;search&lt;'a&gt;(query:&#160;&amp;str,&#160;contents:&#160;&amp;'a&#160;str)&#160;-&gt;&#160;Vec&lt;&amp;'a&#160;str&gt;&#160;{<br/>&#160;&#160;&#160;&#160;contents<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.lines()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.filter(|line|&#160;line.contains(query))<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.collect()<br/>}<br/>
<b>Listing&#160;13-22:&#160;Using&#160;iterator&#160;adaptor&#160;methods&#160;in&#160;the&#160;implementation&#160;of&#160;the&#160;&#160;</b>search&#160;<b>&#160;function</b><br/>
Recall that the purpose of the&#160;&#160;search&#160;&#160;function is to return all lines in&#160;&#160;contents&#160;&#160;that<br/>contain the&#160;&#160;query&#160;. Similar to the&#160;&#160;filter&#160;&#160;example in Listing 13-16, this code uses the<br/>
filter&#160;&#160;adaptor to keep only the lines that&#160;&#160;line.contains(query)&#160;&#160;returns&#160;&#160;true&#160;&#160;for. We<br/>
then collect the matching lines into another vector with&#160;&#160;collect&#160;. Much simpler! Feel free to<br/>make the same change to use iterator methods in the&#160;&#160;search_case_insensitive&#160;&#160;function<br/>as well.<br/>
<a href="tests.html#360"><b>Choosing&#160;Between&#160;Loops&#160;or&#160;Iterators</b></a><br/>
The next logical question is which style you should choose in your own code and why: the<br/>original implementation in Listing 13-21 or the version using iterators in Listing 13-22. Most<br/>Rust programmers prefer to use the iterator style. It’s a bit tougher to get the hang of at<br/>ﬁrst, but once you get a feel for the various iterator adaptors and what they do, iterators<br/>can be easier to understand. Instead of&#160;ﬁddling with the various bits of looping and building<br/>new vectors, the code focuses on the high-level objective of the loop. This abstracts away<br/>
https://doc.rust-lang.org/book/print.html<br/>
360/627<br/>
<hr/>
<a name=361></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
some of the commonplace code so it’s easier to see the concepts that are unique to this<br/>code, such as the&#160;ﬁltering condition each element in the iterator must pass.<br/>
But are the two implementations truly equivalent? The intuitive assumption might be that<br/>the more low-level loop will be faster. Let’s talk about performance.<br/>
https://doc.rust-lang.org/book/print.html<br/>
361/627<br/>
<hr/>
<a name=362></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#362"><b>Comparing Performance: Loops vs. Iterators</b></a><br/>
To determine whether to use loops or iterators, you need to know which implementation is<br/>faster: the version of the&#160;&#160;search&#160;&#160;function with an explicit&#160;&#160;for&#160;&#160;loop or the version with<br/>iterators.<br/>
We ran a benchmark by loading the entire contents of&#160;<i>The Adventures of Sherlock Holmes</i>&#160;by<br/>Sir Arthur Conan Doyle into a&#160;&#160;String&#160;&#160;and looking for the word&#160;<i>the</i>&#160;in the contents. Here are<br/>the results of the benchmark on the version of&#160;&#160;search&#160;&#160;using the&#160;&#160;for&#160;&#160;loop and the version<br/>using iterators:<br/>
test&#160;bench_search_for&#160;&#160;...&#160;bench:&#160;&#160;19,620,300&#160;ns/iter&#160;(+/-&#160;915,700)<br/>test&#160;bench_search_iter&#160;...&#160;bench:&#160;&#160;19,234,900&#160;ns/iter&#160;(+/-&#160;657,200)<br/>
The iterator version was slightly faster! We won’t explain the benchmark code here, because<br/>the point is not to prove that the two versions are equivalent but to get a general sense of<br/>how these two implementations compare performance-wise.<br/>
For a more comprehensive benchmark, you should check using various texts of various<br/>sizes as the&#160;&#160;contents&#160;, diﬀerent words and words of diﬀerent lengths as the&#160;&#160;query&#160;, and all<br/>kinds of other variations. The point is this: iterators, although a high-level abstraction, get<br/>compiled down to roughly the same code as if you’d written the lower-level code yourself.<br/>Iterators are one of Rust’s&#160;<i>zero-cost abstractions</i>, by which we mean using the abstraction<br/>imposes no additional runtime overhead. This is analogous to how Bjarne Stroustrup, the<br/>original designer and implementor of C++, deﬁnes&#160;<i>zero-overhead</i>&#160;in “Foundations of C++”<br/>(2012):<br/>
In general, C++ implementations obey the zero-overhead principle: What you don’t<br/>use, you don’t pay for. And further: What you do use, you couldn’t hand code any<br/>better.<br/>
As another example, the following code is taken from an audio decoder. The decoding<br/>algorithm uses the linear prediction mathematical operation to estimate future values<br/>based on a linear function of the previous samples. This code uses an iterator chain to do<br/>some math on three variables in scope: a&#160;&#160;buffer&#160;&#160;slice of data, an array of 12<br/>
coefficients&#160;, and an amount by which to shift data in&#160;&#160;qlp_shift&#160;. We’ve declared the<br/>
variables within this example but not given them any values; although this code doesn’t<br/>have much meaning outside of its context, it’s still a concise, real-world example of how Rust<br/>translates high-level ideas to low-level code.<br/>
https://doc.rust-lang.org/book/print.html<br/>
362/627<br/>
<hr/>
<a name=363></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
let&#160;buffer:&#160;&amp;mut&#160;[i32];<br/>let&#160;coefficients:&#160;[i64;&#160;12];<br/>let&#160;qlp_shift:&#160;i16;<br/>
for&#160;i&#160;in&#160;12..buffer.len()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;prediction&#160;=&#160;coefficients.iter()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.zip(&amp;buffer[i&#160;-&#160;12..i])<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.map(|(&amp;c,&#160;&amp;s)|&#160;c&#160;*&#160;s&#160;as&#160;i64)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.sum::&lt;i64&gt;()&#160;&gt;&gt;&#160;qlp_shift;<br/>&#160;&#160;&#160;&#160;let&#160;delta&#160;=&#160;buffer[i];<br/>&#160;&#160;&#160;&#160;buffer[i]&#160;=&#160;prediction&#160;as&#160;i32&#160;+&#160;delta;<br/>}<br/>
To calculate the value of&#160;&#160;prediction&#160;, this code iterates through each of the 12 values in<br/>
coefficients&#160;&#160;and uses the&#160;&#160;zip&#160;&#160;method to pair the coeﬃcient values with the previous 12<br/>
values in&#160;&#160;buffer&#160;. Then, for each pair, we multiply the values together, sum all the results,<br/>and shift the bits in the sum&#160;&#160;qlp_shift&#160;&#160;bits to the right.<br/>
Calculations in applications like audio decoders often prioritize performance most highly.<br/>Here, we’re creating an iterator, using two adaptors, and then consuming the value. What<br/>assembly code would this Rust code compile to? Well, as of this writing, it compiles down to<br/>the same assembly you’d write by hand. There’s no loop at all corresponding to the iteration<br/>over the values in&#160;&#160;coefficients&#160;: Rust knows that there are 12 iterations, so it “unrolls” the<br/>loop.&#160;<i>Unrolling</i>&#160;is an optimization that removes the overhead of the loop controlling code<br/>and instead generates repetitive code for each iteration of the loop.<br/>
All of the coeﬃcients get stored in registers, which means accessing the values is very fast.<br/>There are no bounds checks on the array access at runtime. All these optimizations that<br/>Rust is able to apply make the resulting code extremely eﬃcient. Now that you know this,<br/>you can use iterators and closures without fear! They make code seem like it’s higher level<br/>but don’t impose a runtime performance penalty for doing so.<br/>
<a href="tests.html#363"><b>Summary</b></a><br/>
Closures and iterators are Rust features inspired by functional programming language<br/>ideas. They contribute to Rust’s capability to clearly express high-level ideas at low-level<br/>performance. The implementations of closures and iterators are such that runtime<br/>performance is not aﬀected. This is part of Rust’s goal to strive to provide zero-cost<br/>abstractions.<br/>
Now that we’ve improved the expressiveness of our I/O project, let’s look at some more<br/>features of&#160;&#160;cargo&#160;&#160;that will help us share the project with the world.<br/>
https://doc.rust-lang.org/book/print.html<br/>
363/627<br/>
<hr/>
<a name=364></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#364"><b>More About Cargo and Crates.io</b></a><br/>
So far we’ve used only the most basic features of Cargo to build, run, and test our code, but<br/>it can do a lot more. In this chapter, we’ll discuss some of its other, more advanced features<br/>to show you how to do the following:<br/>
Customize your build through release proﬁles<br/><a href="https://crates.io/">Publish libraries on&#160;crates.io<br/></a>Organize large projects with workspaces<br/>Install binaries from&#160;<a href="https://crates.io/">crates.io<br/></a>Extend Cargo using custom commands<br/>
Cargo can do even more than the functionality we cover in this chapter, so for a full<br/><a href="https://doc.rust-lang.org/cargo/">explanation of all its features, see&#160;its documentation.</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
364/627<br/>
<hr/>
<a name=365></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#365"><b>Customizing Builds with Release Proﬁles</b></a><br/>
In Rust,&#160;<i>release proﬁles</i>&#160;are predeﬁned and customizable proﬁles with diﬀerent<br/>conﬁgurations that allow a programmer to have more control over various options for<br/>compiling code. Each proﬁle is conﬁgured independently of the others.<br/>
Cargo has two main proﬁles: the&#160;&#160;dev&#160;&#160;proﬁle Cargo uses when you run&#160;&#160;cargo&#160;build&#160;&#160;and<br/>the&#160;&#160;release&#160;&#160;proﬁle Cargo uses when you run&#160;&#160;cargo&#160;build&#160;--release&#160;. The&#160;&#160;dev&#160;&#160;proﬁle is<br/>deﬁned with good defaults for development, and the&#160;&#160;release&#160;&#160;proﬁle has good defaults for<br/>release builds.<br/>
These proﬁle names might be familiar from the output of your builds:<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.0s<br/>$&#160;cargo&#160;build&#160;--release<br/>&#160;&#160;&#160;&#160;Finished&#160;release&#160;[optimized]&#160;target(s)&#160;in&#160;0.0s<br/>
The&#160;&#160;dev&#160;&#160;and&#160;&#160;release&#160;&#160;are these diﬀerent proﬁles used by the compiler.<br/>
Cargo has default settings for each of the proﬁles that apply when you haven't explicitly<br/>added any&#160;&#160;[profile.*]&#160;&#160;sections in the project’s&#160;<i>Cargo.toml</i>&#160;ﬁle. By adding&#160;&#160;[profile.*]<br/>sections for any proﬁle you want to customize, you override any subset of the default<br/>settings. For example, here are the default values for the&#160;&#160;opt-level&#160;&#160;setting for the&#160;&#160;dev<br/>and&#160;&#160;release&#160;&#160;proﬁles:<br/>
Filename: Cargo.toml<br/>
[profile.dev]<br/>opt-level&#160;=&#160;0<br/>
[profile.release]<br/>opt-level&#160;=&#160;3<br/>
The&#160;&#160;opt-level&#160;&#160;setting controls the number of optimizations Rust will apply to your code,<br/>with a range of 0 to 3. Applying more optimizations extends compiling time, so if you’re in<br/>development and compiling your code often, you’ll want fewer optimizations to compile<br/>faster even if the resulting code runs slower. The default&#160;&#160;opt-level&#160;&#160;for&#160;&#160;dev&#160;&#160;is therefore&#160;&#160;0&#160;.<br/>When you’re ready to release your code, it’s best to spend more time compiling. You’ll only<br/>compile in release mode once, but you’ll run the compiled program many times, so release<br/>mode trades longer compile time for code that runs faster. That is why the default&#160;&#160;opt-<br/>level&#160;&#160;for the&#160;&#160;release&#160;&#160;proﬁle is&#160;&#160;3&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
365/627<br/>
<hr/>
<a name=366></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
You can override a default setting by adding a diﬀerent value for it in&#160;<i>Cargo.toml</i>. For<br/>example, if we want to use optimization level 1 in the development proﬁle, we can add<br/>these two lines to our project’s&#160;<i>Cargo.toml</i>&#160;ﬁle:<br/>
Filename: Cargo.toml<br/>
[profile.dev]<br/>opt-level&#160;=&#160;1<br/>
This code overrides the default setting of&#160;&#160;0&#160;. Now when we run&#160;&#160;cargo&#160;build&#160;, Cargo will use<br/>the defaults for the&#160;&#160;dev&#160;&#160;proﬁle plus our customization to&#160;&#160;opt-level&#160;. Because we set&#160;&#160;opt-<br/>level&#160;&#160;to&#160;&#160;1&#160;, Cargo will apply more optimizations than the default, but not as many as in a<br/>release build.<br/>
<a href="https://doc.rust-lang.org/cargo/reference/profiles.html">For the full list of conﬁguration options and defaults for each proﬁle, see&#160;Cargo’s<br/>documentation.</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
366/627<br/>
<hr/>
<a name=367></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#367"><b>Publishing a Crate to Crates.io</b></a><br/>
We’ve used packages from&#160;<a href="https://crates.io/">crates.io&#160;as dependencies of our project, but you can also share<br/></a>your code with other people by publishing your own packages. The crate registry at&#160;<a href="https://crates.io/">crates.io<br/></a>distributes the source code of your packages, so it primarily hosts code that is open source.<br/>
Rust and Cargo have features that make your published package easier for people to&#160;ﬁnd<br/>and use. We’ll talk about some of these features next and then explain how to publish a<br/>package.<br/>
<a href="tests.html#367"><b>Making&#160;Useful&#160;Documentation&#160;Comments</b></a><br/>
Accurately documenting your packages will help other users know how and when to use<br/>them, so it’s worth investing the time to write documentation. In Chapter 3, we discussed<br/>how to comment Rust code using two slashes,&#160;&#160;//&#160;. Rust also has a particular kind of<br/>comment for documentation, known conveniently as a&#160;<i>documentation comment</i>, that will<br/>generate HTML documentation. The HTML displays the contents of documentation<br/>comments for public API items intended for programmers interested in knowing how to&#160;<i>use<br/></i>your crate as opposed to how your crate is&#160;<i>implemented</i>.<br/>
Documentation comments use three slashes,&#160;&#160;///&#160;, instead of two and support Markdown<br/>notation for formatting the text. Place documentation comments just before the item<br/>they’re documenting. Listing 14-1 shows documentation comments for an&#160;&#160;add_one&#160;&#160;function<br/>in a crate named&#160;&#160;my_crate&#160;.<br/>
Filename: src/lib.rs<br/>
///&#160;Adds&#160;one&#160;to&#160;the&#160;number&#160;given.<br/>///<br/>///&#160;#&#160;Examples<br/>///<br/>///&#160;```<br/>///&#160;let&#160;arg&#160;=&#160;5;<br/>///&#160;let&#160;answer&#160;=&#160;my_crate::add_one(arg);<br/>///<br/>///&#160;assert_eq!(6,&#160;answer);<br/>///&#160;```<br/>pub&#160;fn&#160;add_one(x:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;x&#160;+&#160;1<br/>}<br/>
<b>Listing&#160;14-1:&#160;A&#160;documentation&#160;comment&#160;for&#160;a&#160;function</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
367/627<br/>
<hr/>
<a name=368></a><img src="test-368_1.png"/><br/>
14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Here, we give a description of what the&#160;&#160;add_one&#160;&#160;function does, start a section with the<br/>heading&#160;&#160;Examples&#160;, and then provide code that demonstrates how to use the&#160;&#160;add_one<br/>function. We can generate the HTML documentation from this documentation comment by<br/>running&#160;&#160;cargo&#160;doc&#160;. This command runs the&#160;&#160;rustdoc&#160;&#160;tool distributed with Rust and puts<br/>the generated HTML documentation in the&#160;<i>target/doc</i>&#160;directory.<br/>
For convenience, running&#160;&#160;cargo&#160;doc&#160;--open&#160;&#160;will build the HTML for your current crate’s<br/>documentation (as well as the documentation for all of your crate’s dependencies) and open<br/>the result in a web browser. Navigate to the&#160;&#160;add_one&#160;&#160;function and you’ll see how the text in<br/>the documentation comments is rendered, as shown in Figure 14-1:<br/>
<b>Figure&#160;14-1:&#160;HTML&#160;documentation&#160;for&#160;the&#160;&#160;</b>add_one&#160;<b>&#160;function</b><br/>
<a href="tests.html#368"><b>Commonly Used Sections</b></a><br/>
We used the&#160;&#160;#&#160;Examples&#160;&#160;Markdown heading in Listing 14-1 to create a section in the HTML<br/>with the title “Examples.” Here are some other sections that crate authors commonly use in<br/>their documentation:<br/>
<b>Panics</b>: The scenarios in which the function being documented could panic. Callers of<br/>the function who don’t want their programs to panic should make sure they don’t call<br/>the function in these situations.<br/><b>Errors</b>: If the function returns a&#160;&#160;Result&#160;, describing the kinds of errors that might<br/>occur and what conditions might cause those errors to be returned can be helpful to<br/>callers so they can write code to handle the diﬀerent kinds of errors in diﬀerent ways.<br/><b>Safety</b>: If the function is&#160;&#160;unsafe&#160;&#160;to call (we discuss unsafety in Chapter 19), there<br/>should be a section explaining why the function is unsafe and covering the invariants<br/>
https://doc.rust-lang.org/book/print.html<br/>
368/627<br/>
<hr/>
<a name=369></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
that the function expects callers to uphold.<br/>
Most documentation comments don’t need all of these sections, but this is a good checklist<br/>to remind you of the aspects of your code users will be interested in knowing about.<br/>
<a href="tests.html#369"><b>Documentation Comments as Tests</b></a><br/>
Adding example code blocks in your documentation comments can help demonstrate how<br/>to use your library, and doing so has an additional bonus: running&#160;&#160;cargo&#160;test&#160;&#160;will run the<br/>code examples in your documentation as tests! Nothing is better than documentation with<br/>examples. But nothing is worse than examples that don’t work because the code has<br/>changed since the documentation was written. If we run&#160;&#160;cargo&#160;test&#160;&#160;with the<br/>documentation for the&#160;&#160;add_one&#160;&#160;function from Listing 14-1, we will see a section in the test<br/>results like this:<br/>
&#160;&#160;&#160;Doc-tests&#160;my_crate<br/>
running&#160;1&#160;test<br/>test&#160;src/lib.rs&#160;-&#160;add_one&#160;(line&#160;5)&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.27s<br/>
Now if we change either the function or the example so the&#160;&#160;assert_eq!&#160;&#160;in the example<br/>panics and run&#160;&#160;cargo&#160;test&#160;&#160;again, we’ll see that the doc tests catch that the example and<br/>the code are out of sync with each other!<br/>
<a href="tests.html#369"><b>Commenting Contained Items</b></a><br/>
The style of doc comment&#160;&#160;//!&#160;&#160;adds documentation to the item that contains the<br/>comments rather than to the items following the comments. We typically use these doc<br/>comments inside the crate root&#160;ﬁle (<i>src/lib.rs</i>&#160;by convention) or inside a module to document<br/>the crate or the module as a whole.<br/>
For example, to add documentation that describes the purpose of the&#160;&#160;my_crate&#160;&#160;crate that<br/>contains the&#160;&#160;add_one&#160;&#160;function, we add documentation comments that start with&#160;&#160;//!&#160;&#160;to<br/>the beginning of the&#160;<i>src/lib.rs</i>&#160;ﬁle, as shown in Listing 14-2:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
369/627<br/>
<hr/>
<a name=370></a><img src="test-370_1.png"/><br/>
14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
//!&#160;#&#160;My&#160;Crate<br/>//!<br/>//!&#160;`my_crate`&#160;is&#160;a&#160;collection&#160;of&#160;utilities&#160;to&#160;make&#160;performing&#160;certain<br/>//!&#160;calculations&#160;more&#160;convenient.<br/>
///&#160;Adds&#160;one&#160;to&#160;the&#160;number&#160;given.<br/>//&#160;--snip--<br/>
<b>Listing&#160;14-2:&#160;Documentation&#160;for&#160;the&#160;&#160;</b>my_crate&#160;<b>&#160;crate&#160;as&#160;a&#160;whole</b><br/>
Notice there isn’t any code after the last line that begins with&#160;&#160;//!&#160;. Because we started the<br/>comments with&#160;&#160;//!&#160;&#160;instead of&#160;&#160;///&#160;, we’re documenting the item that contains this<br/>comment rather than an item that follows this comment. In this case, that item is the<br/><i>src/lib.rs</i>&#160;ﬁle, which is the crate root. These comments describe the entire crate.<br/>
When we run&#160;&#160;cargo&#160;doc&#160;--open&#160;, these comments will display on the front page of the<br/>documentation for&#160;&#160;my_crate&#160;&#160;above the list of public items in the crate, as shown in Figure<br/>14-2:<br/>
<b>Figure&#160;14-2:&#160;Rendered&#160;documentation&#160;for&#160;&#160;</b>my_crate&#160;<b>,&#160;including&#160;the&#160;comment&#160;describing&#160;the&#160;crate&#160;as&#160;a&#160;whole</b><br/>
Documentation comments within items are useful for describing crates and modules<br/>especially. Use them to explain the overall purpose of the container to help your users<br/>understand the crate’s organization.<br/>
<a href="tests.html#370"><b>Exporting&#160;a&#160;Convenient&#160;Public&#160;API&#160;with&#160;</b>pub&#160;use</a><br/>
The structure of your public API is a major consideration when publishing a crate. People<br/>who use your crate are less familiar with the structure than you are and might have<br/>diﬃculty&#160;ﬁnding the pieces they want to use if your crate has a large module hierarchy.<br/>
https://doc.rust-lang.org/book/print.html<br/>
370/627<br/>
<hr/>
<a name=371></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
In Chapter 7, we covered how to make items public using the&#160;&#160;pub&#160;&#160;keyword, and bring items<br/>into a scope with the&#160;&#160;use&#160;&#160;keyword. However, the structure that makes sense to you while<br/>you’re developing a crate might not be very convenient for your users. You might want to<br/>organize your structs in a hierarchy containing multiple levels, but then people who want to<br/>use a type you’ve deﬁned deep in the hierarchy might have trouble&#160;ﬁnding out that type<br/>exists. They might also be annoyed at having to enter&#160;&#160;use<br/>
my_crate::some_module::another_module::UsefulType;&#160;&#160;rather than&#160;&#160;use<br/>my_crate::UsefulType;&#160;.<br/>
The good news is that if the structure&#160;<i>isn’t</i>&#160;convenient for others to use from another library,<br/>you don’t have to rearrange your internal organization: instead, you can re-export items to<br/>make a public structure that’s diﬀerent from your private structure by using&#160;&#160;pub&#160;use&#160;. Re-<br/>exporting takes a public item in one location and makes it public in another location, as if it<br/>were deﬁned in the other location instead.<br/>
For example, say we made a library named&#160;&#160;art&#160;&#160;for modeling artistic concepts. Within this<br/>library are two modules: a&#160;&#160;kinds&#160;&#160;module containing two enums named&#160;&#160;PrimaryColor&#160;&#160;and<br/>
SecondaryColor&#160;&#160;and a&#160;&#160;utils&#160;&#160;module containing a function named&#160;&#160;mix&#160;, as shown in<br/>
Listing 14-3:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
371/627<br/>
<hr/>
<a name=372></a><img src="test-372_1.png"/><br/>
14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
//!&#160;#&#160;Art<br/>//!<br/>//!&#160;A&#160;library&#160;for&#160;modeling&#160;artistic&#160;concepts.<br/>
pub&#160;mod&#160;kinds&#160;{<br/>&#160;&#160;&#160;&#160;///&#160;The&#160;primary&#160;colors&#160;according&#160;to&#160;the&#160;RYB&#160;color&#160;model.<br/>&#160;&#160;&#160;&#160;pub&#160;enum&#160;PrimaryColor&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Red,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Yellow,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Blue,<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;///&#160;The&#160;secondary&#160;colors&#160;according&#160;to&#160;the&#160;RYB&#160;color&#160;model.<br/>&#160;&#160;&#160;&#160;pub&#160;enum&#160;SecondaryColor&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Orange,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Green,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Purple,<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
pub&#160;mod&#160;utils&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;crate::kinds::*;<br/>
&#160;&#160;&#160;&#160;///&#160;Combines&#160;two&#160;primary&#160;colors&#160;in&#160;equal&#160;amounts&#160;to&#160;create<br/>&#160;&#160;&#160;&#160;///&#160;a&#160;secondary&#160;color.<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;mix(c1:&#160;PrimaryColor,&#160;c2:&#160;PrimaryColor)&#160;-&gt;&#160;SecondaryColor&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;14-3:&#160;An&#160;&#160;</b>art&#160;<b>&#160;library&#160;with&#160;items&#160;organized&#160;into&#160;&#160;</b>kinds&#160;<b>&#160;and&#160;&#160;</b>utils&#160;<b>&#160;modules</b><br/>
Figure 14-3 shows what the front page of the documentation for this crate generated by<br/>
cargo&#160;doc&#160;&#160;would look like:<br/>
https://doc.rust-lang.org/book/print.html<br/>
372/627<br/>
<hr/>
<a name=373></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Figure&#160;14-3:&#160;Front&#160;page&#160;of&#160;the&#160;documentation&#160;for&#160;&#160;</b>art&#160;<b>&#160;that&#160;lists&#160;the&#160;&#160;</b>kinds&#160;<b>&#160;and&#160;&#160;</b>utils&#160;<b>&#160;modules</b><br/>
Note that the&#160;&#160;PrimaryColor&#160;&#160;and&#160;&#160;SecondaryColor&#160;&#160;types aren’t listed on the front page, nor<br/>is the&#160;&#160;mix&#160;&#160;function. We have to click&#160;&#160;kinds&#160;&#160;and&#160;&#160;utils&#160;&#160;to see them.<br/>
Another crate that depends on this library would need&#160;&#160;use&#160;&#160;statements that bring the items<br/>from&#160;&#160;art&#160;&#160;into scope, specifying the module structure that’s currently deﬁned. Listing 14-4<br/>shows an example of a crate that uses the&#160;&#160;PrimaryColor&#160;&#160;and&#160;&#160;mix&#160;&#160;items from the&#160;&#160;art<br/>crate:<br/>
Filename: src/main.rs<br/>
use&#160;art::kinds::PrimaryColor;<br/>use&#160;art::utils::mix;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;red&#160;=&#160;PrimaryColor::Red;<br/>&#160;&#160;&#160;&#160;let&#160;yellow&#160;=&#160;PrimaryColor::Yellow;<br/>&#160;&#160;&#160;&#160;mix(red,&#160;yellow);<br/>}<br/>
<b>Listing&#160;14-4:&#160;A&#160;crate&#160;using&#160;the&#160;&#160;</b>art&#160;<b>&#160;crate’s&#160;items&#160;with&#160;its&#160;internal&#160;structure&#160;exported</b><br/>
The author of the code in Listing 14-4, which uses the&#160;&#160;art&#160;&#160;crate, had to&#160;ﬁgure out that<br/>
PrimaryColor&#160;&#160;is in the&#160;&#160;kinds&#160;&#160;module and&#160;&#160;mix&#160;&#160;is in the&#160;&#160;utils&#160;&#160;module. The module<br/>
structure of the&#160;&#160;art&#160;&#160;crate is more relevant to developers working on the&#160;&#160;art&#160;&#160;crate than to<br/>those using it. The internal structure doesn’t contain any useful information for someone<br/>trying to understand how to use the&#160;&#160;art&#160;&#160;crate, but rather causes confusion because<br/>developers who use it have to&#160;ﬁgure out where to look, and must specify the module names<br/>in the&#160;&#160;use&#160;&#160;statements.<br/>
To remove the internal organization from the public API, we can modify the&#160;&#160;art&#160;&#160;crate code<br/>in Listing 14-3 to add&#160;&#160;pub&#160;use&#160;&#160;statements to re-export the items at the top level, as shown<br/>in Listing 14-5:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
373/627<br/>
<hr/>
<a name=374></a><img src="test-374_1.png"/><br/>
14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
//!&#160;#&#160;Art<br/>//!<br/>//!&#160;A&#160;library&#160;for&#160;modeling&#160;artistic&#160;concepts.<br/>
pub&#160;use&#160;self::kinds::PrimaryColor;<br/>pub&#160;use&#160;self::kinds::SecondaryColor;<br/>pub&#160;use&#160;self::utils::mix;<br/>
pub&#160;mod&#160;kinds&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
pub&#160;mod&#160;utils&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
<b>Listing&#160;14-5:&#160;Adding&#160;&#160;</b>pub&#160;use&#160;<b>&#160;statements&#160;to&#160;re-export&#160;items</b><br/>
The API documentation that&#160;&#160;cargo&#160;doc&#160;&#160;generates for this crate will now list and link re-<br/>exports on the front page, as shown in Figure 14-4, making the&#160;&#160;PrimaryColor&#160;&#160;and<br/>
SecondaryColor&#160;&#160;types and the&#160;&#160;mix&#160;&#160;function easier to&#160;ﬁnd.<br/>
<b>Figure&#160;14-4:&#160;The&#160;front&#160;page&#160;of&#160;the&#160;documentation&#160;for&#160;&#160;</b>art&#160;<b>&#160;that&#160;lists&#160;the&#160;re-exports</b><br/>
The&#160;&#160;art&#160;&#160;crate users can still see and use the internal structure from Listing 14-3 as<br/>demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5,<br/>
https://doc.rust-lang.org/book/print.html<br/>
374/627<br/>
<hr/>
<a name=375></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
as shown in Listing 14-6:<br/>
Filename: src/main.rs<br/>
use&#160;art::mix;<br/>use&#160;art::PrimaryColor;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
<b>Listing&#160;14-6:&#160;A&#160;program&#160;using&#160;the&#160;re-exported&#160;items&#160;from&#160;the&#160;&#160;</b>art&#160;<b>&#160;crate</b><br/>
In cases where there are many nested modules, re-exporting the types at the top level with<br/>
pub&#160;use&#160;&#160;can make a signiﬁcant diﬀerence in the experience of people who use the crate.<br/>
Another common use of&#160;&#160;pub&#160;use&#160;&#160;is to re-export deﬁnitions of a dependency in the current<br/>crate to make that crate's deﬁnitions part of your crate’s public API.<br/>
Creating a useful public API structure is more of an art than a science, and you can iterate to<br/>ﬁnd the API that works best for your users. Choosing&#160;&#160;pub&#160;use&#160;&#160;gives you&#160;ﬂexibility in how<br/>you structure your crate internally and decouples that internal structure from what you<br/>present to your users. Look at some of the code of crates you’ve installed to see if their<br/>internal structure diﬀers from their public API.<br/>
<a href="tests.html#375"><b>Setting&#160;Up&#160;a&#160;Crates.io&#160;Account</b></a><br/>
<a href="https://crates.io/">Before you can publish any crates, you need to create an account on&#160;crates.io&#160;and get an<br/></a>API token. To do so, visit the home page at&#160;<a href="https://crates.io/">crates.io</a>&#160;and log in via a GitHub account. (The<br/>GitHub account is currently a requirement, but the site might support other ways of creating<br/>an account in the future.) Once you’re logged in, visit your account settings at<br/><a href="https://crates.io/me/">https://crates.io/me/</a>&#160;and retrieve your API key. Then run the&#160;&#160;cargo&#160;login&#160;&#160;command with<br/>your API key, like this:<br/>
$&#160;cargo&#160;login&#160;abcdefghijklmnopqrstuvwxyz012345<br/>
This command will inform Cargo of your API token and store it locally in&#160;<i>~/.cargo/credentials</i>.<br/>Note that this token is a&#160;<i>secret</i>: do not share it with anyone else. If you do share it with<br/>anyone for any reason, you should revoke it and generate a new token on&#160;<a href="https://crates.io/">crates.io</a>.<br/>
<a href="tests.html#375"><b>Adding&#160;Metadata&#160;to&#160;a&#160;New&#160;Crate</b></a><br/>
Let’s say you have a crate you want to publish. Before publishing, you’ll need to add some<br/>metadata in the&#160;&#160;[package]&#160;&#160;section of the crate’s&#160;<i>Cargo.toml</i>&#160;ﬁle.<br/>
https://doc.rust-lang.org/book/print.html<br/>
375/627<br/>
<hr/>
<a name=376></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Your crate will need a unique name. While you’re working on a crate locally, you can name a<br/>crate whatever you’d like. However, crate names on&#160;<a href="https://crates.io/">crates.io</a>&#160;are allocated on a&#160;ﬁrst-come,<br/>ﬁrst-served basis. Once a crate name is taken, no one else can publish a crate with that<br/>name. Before attempting to publish a crate, search for the name you want to use. If the<br/>name has been used, you will need to&#160;ﬁnd another name and edit the&#160;&#160;name&#160;&#160;ﬁeld in the<br/><i>Cargo.toml</i>&#160;ﬁle under the&#160;&#160;[package]&#160;&#160;section to use the new name for publishing, like so:<br/>
Filename: Cargo.toml<br/>
[package]<br/>name&#160;=&#160;&#34;guessing_game&#34;<br/>
Even if you’ve chosen a unique name, when you run&#160;&#160;cargo&#160;publish&#160;&#160;to publish the crate at<br/>this point, you’ll get a warning and then an error:<br/>
$&#160;cargo&#160;publish<br/>&#160;&#160;&#160;&#160;Updating&#160;crates.io&#160;index<br/>warning:&#160;manifest&#160;has&#160;no&#160;description,&#160;license,&#160;license-file,&#160;documentation,&#160;<br/>homepage&#160;or&#160;repository.<br/>See&#160;https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata&#160;<br/>for&#160;more&#160;info.<br/>--snip--<br/>error:&#160;failed&#160;to&#160;publish&#160;to&#160;registry&#160;at&#160;https://crates.io<br/>
Caused&#160;by:<br/>&#160;&#160;the&#160;remote&#160;server&#160;responded&#160;with&#160;an&#160;error:&#160;missing&#160;or&#160;empty&#160;metadata&#160;fields:&#160;<br/>description,&#160;license.&#160;Please&#160;see&#160;https://doc.rust-<br/>lang.org/cargo/reference/manifest.html&#160;for&#160;how&#160;to&#160;upload&#160;metadata<br/>
This errors because you’re missing some crucial information: a description and license are<br/>required so people will know what your crate does and under what terms they can use it. In<br/><i>Cargo.toml</i>, add a description that's just a sentence or two, because it will appear with your<br/>crate in search results. For the&#160;&#160;license&#160;&#160;ﬁeld, you need to give a&#160;<i>license identiﬁer value</i>. The<br/><a href="http://spdx.org/licenses/">Linux Foundation’s Software Package Data Exchange (SPDX)&#160;lists the identi</a>ﬁers you can use<br/>for this value. For example, to specify that you’ve licensed your crate using the MIT License,<br/>add the&#160;&#160;MIT&#160;&#160;identiﬁer:<br/>
Filename: Cargo.toml<br/>
[package]<br/>name&#160;=&#160;&#34;guessing_game&#34;<br/>license&#160;=&#160;&#34;MIT&#34;<br/>
If you want to use a license that doesn’t appear in the SPDX, you need to place the text of<br/>that license in a&#160;ﬁle, include the&#160;ﬁle in your project, and then use&#160;&#160;license-file&#160;&#160;to specify<br/>the name of that&#160;ﬁle instead of using the&#160;&#160;license&#160;&#160;key.<br/>
Guidance on which license is appropriate for your project is beyond the scope of this book.<br/>Many people in the Rust community license their projects in the same way as Rust by using<br/>
https://doc.rust-lang.org/book/print.html<br/>
376/627<br/>
<hr/>
<a name=377></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
a dual license of&#160;&#160;MIT&#160;OR&#160;Apache-2.0&#160;. This practice demonstrates that you can also specify<br/>multiple license identiﬁers separated by&#160;&#160;OR&#160;&#160;to have multiple licenses for your project.<br/>
With a unique name, the version, your description, and a license added, the&#160;<i>Cargo.toml</i>&#160;ﬁle<br/>for a project that is ready to publish might look like this:<br/>
Filename: Cargo.toml<br/>
[package]<br/>name&#160;=&#160;&#34;guessing_game&#34;<br/>version&#160;=&#160;&#34;0.1.0&#34;<br/>edition&#160;=&#160;&#34;2021&#34;<br/>description&#160;=&#160;&#34;A&#160;fun&#160;game&#160;where&#160;you&#160;guess&#160;what&#160;number&#160;the&#160;computer&#160;has&#160;chosen.&#34;<br/>license&#160;=&#160;&#34;MIT&#160;OR&#160;Apache-2.0&#34;<br/>
[dependencies]<br/>
<a href="https://doc.rust-lang.org/cargo/">Cargo’s documentation&#160;describes other metadata you can specify to ensure others can<br/></a>discover and use your crate more easily.<br/>
<a href="tests.html#377"><b>Publishing&#160;to&#160;Crates.io</b></a><br/>
Now that you’ve created an account, saved your API token, chosen a name for your crate,<br/>and speciﬁed the required metadata, you’re ready to publish! Publishing a crate uploads a<br/>speciﬁc version to&#160;<a href="https://crates.io/">crates.io&#160;for others to use.</a><br/>
Be careful, because a publish is&#160;<i>permanent</i>. The version can never be overwritten, and the<br/>code cannot be deleted. One major goal of&#160;<a href="https://crates.io/">crates.io&#160;is to act as a permanent archive of code<br/></a>so that builds of all projects that depend on crates from&#160;<a href="https://crates.io/">crates.io&#160;will continue to work.<br/></a>Allowing version deletions would make fulﬁlling that goal impossible. However, there is no<br/>limit to the number of crate versions you can publish.<br/>
Run the&#160;&#160;cargo&#160;publish&#160;&#160;command again. It should succeed now:<br/>
$&#160;cargo&#160;publish<br/>&#160;&#160;&#160;&#160;Updating&#160;crates.io&#160;index<br/>&#160;&#160;&#160;Packaging&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;Verifying&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>&#160;&#160;&#160;Compiling&#160;guessing_game&#160;v0.1.0<br/>(file:///projects/guessing_game/target/package/guessing_game-0.1.0)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.19s<br/>&#160;&#160;&#160;Uploading&#160;guessing_game&#160;v0.1.0&#160;(file:///projects/guessing_game)<br/>
Congratulations! You’ve now shared your code with the Rust community, and anyone can<br/>easily add your crate as a dependency of their project.<br/>
https://doc.rust-lang.org/book/print.html<br/>
377/627<br/>
<hr/>
<a name=378></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#378"><b>Publishing&#160;a&#160;New&#160;Version&#160;of&#160;an&#160;Existing&#160;Crate</b></a><br/>
When you’ve made changes to your crate and are ready to release a new version, you<br/><a href="http://semver.org/">change the&#160;&#160;version&#160;&#160;value speciﬁed in your&#160;<i>Cargo.toml</i>&#160;ﬁle and republish. Use the&#160;Semantic<br/>Versioning rules&#160;to decide what an appropriate next version number is based on the kinds<br/></a>of changes you’ve made. Then run&#160;&#160;cargo&#160;publish&#160;&#160;to upload the new version.<br/>
<a href="tests.html#378"><b>Deprecating&#160;Versions&#160;from&#160;Crates.io&#160;with&#160;</b>cargo&#160;yank</a><br/>
Although you can’t remove previous versions of a crate, you can prevent any future projects<br/>from adding them as a new dependency. This is useful when a crate version is broken for<br/>one reason or another. In such situations, Cargo supports&#160;<i>yanking</i>&#160;a crate version.<br/>
Yanking a version prevents new projects from depending on that version while allowing all<br/>existing projects that depend on it to continue. Essentially, a yank means that all projects<br/>with a&#160;<i>Cargo.lock</i>&#160;will not break, and any future&#160;<i>Cargo.lock</i>&#160;ﬁles generated will not use the<br/>yanked version.<br/>
To yank a version of a crate, in the directory of the crate that you’ve previously published,<br/>run&#160;&#160;cargo&#160;yank&#160;&#160;and specify which version you want to yank. For example, if we've<br/>published a crate named&#160;&#160;guessing_game&#160;&#160;version 1.0.1 and we want to yank it, in the project<br/>directory for&#160;&#160;guessing_game&#160;&#160;we'd run:<br/>
$&#160;cargo&#160;yank&#160;--vers&#160;1.0.1<br/>&#160;&#160;&#160;&#160;Updating&#160;crates.io&#160;index<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Yank&#160;guessing_game@1.0.1<br/>
By adding&#160;&#160;--undo&#160;&#160;to the command, you can also undo a yank and allow projects to start<br/>depending on a version again:<br/>
$&#160;cargo&#160;yank&#160;--vers&#160;1.0.1&#160;--undo<br/>&#160;&#160;&#160;&#160;Updating&#160;crates.io&#160;index<br/>&#160;&#160;&#160;&#160;&#160;&#160;Unyank&#160;guessing_game@1.0.1<br/>
A yank&#160;<i>does not</i>&#160;delete any code. It cannot, for example, delete accidentally uploaded<br/>secrets. If that happens, you must reset those secrets immediately.<br/>
https://doc.rust-lang.org/book/print.html<br/>
378/627<br/>
<hr/>
<a name=379></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#379"><b>Cargo Workspaces</b></a><br/>
In Chapter 12, we built a package that included a binary crate and a library crate. As your<br/>project develops, you might&#160;ﬁnd that the library crate continues to get bigger and you want<br/>to split your package further into multiple library crates. Cargo oﬀers a feature called<br/><i>workspaces</i>&#160;that can help manage multiple related packages that are developed in tandem.<br/>
<a href="tests.html#379"><b>Creating&#160;a&#160;Workspace</b></a><br/>
A&#160;<i>workspace</i>&#160;is a set of packages that share the same&#160;<i>Cargo.lock</i>&#160;and output directory. Let’s<br/>make a project using a workspace—we’ll use trivial code so we can concentrate on the<br/>structure of the workspace. There are multiple ways to structure a workspace, so we'll just<br/>show one common way. We’ll have a workspace containing a binary and two libraries. The<br/>binary, which will provide the main functionality, will depend on the two libraries. One<br/>library will provide an&#160;&#160;add_one&#160;&#160;function, and a second library an&#160;&#160;add_two&#160;&#160;function. These<br/>three crates will be part of the same workspace. We’ll start by creating a new directory for<br/>the workspace:<br/>
$&#160;mkdir&#160;add<br/>$&#160;cd&#160;add<br/>
Next, in the&#160;<i>add</i>&#160;directory, we create the&#160;<i>Cargo.toml</i>&#160;ﬁle that will conﬁgure the entire<br/>workspace. This&#160;ﬁle won’t have a&#160;&#160;[package]&#160;&#160;section. Instead, it will start with a<br/>
[workspace]&#160;&#160;section that will allow us to add members to the workspace by specifying the<br/>
path to the package with our binary crate; in this case, that path is&#160;<i>adder</i>:<br/>
Filename: Cargo.toml<br/>
[workspace]<br/>
members&#160;=&#160;[<br/>&#160;&#160;&#160;&#160;&#34;adder&#34;,<br/>]<br/>
Next, we’ll create the&#160;&#160;adder&#160;&#160;binary crate by running&#160;&#160;cargo&#160;new&#160;&#160;within the&#160;<i>add</i>&#160;directory:<br/>
$&#160;cargo&#160;new&#160;adder<br/>&#160;&#160;&#160;&#160;&#160;Created&#160;binary&#160;(application)&#160;`adder`&#160;package<br/>
At this point, we can build the workspace by running&#160;&#160;cargo&#160;build&#160;. The&#160;ﬁles in your&#160;<i>add<br/></i>directory should look like this:<br/>
https://doc.rust-lang.org/book/print.html<br/>
379/627<br/>
<hr/>
<a name=380></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
├──&#160;Cargo.lock<br/>├──&#160;Cargo.toml<br/>├──&#160;adder<br/>│&#160;&#160;&#160;├──&#160;Cargo.toml<br/>│&#160;&#160;&#160;└──&#160;src<br/>│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──&#160;main.rs<br/>└──&#160;target<br/>
The workspace has one&#160;<i>target</i>&#160;directory at the top level that the compiled artifacts will be<br/>placed into; the&#160;&#160;adder&#160;&#160;package doesn’t have its own&#160;<i>target</i>&#160;directory. Even if we were to run<br/>
cargo&#160;build&#160;&#160;from inside the&#160;<i>adder</i>&#160;directory, the compiled artifacts would still end up in<br/>
<i>add/target</i>&#160;rather than&#160;<i>add/adder/target</i>. Cargo structures the&#160;<i>target</i>&#160;directory in a workspace<br/>like this because the crates in a workspace are meant to depend on each other. If each crate<br/>had its own&#160;<i>target</i>&#160;directory, each crate would have to recompile each of the other crates in<br/>the workspace to place the artifacts in its own&#160;<i>target</i>&#160;directory. By sharing one&#160;<i>target<br/></i>directory, the crates can avoid unnecessary rebuilding.<br/>
<a href="tests.html#380"><b>Creating&#160;the&#160;Second&#160;Package&#160;in&#160;the&#160;Workspace</b></a><br/>
Next, let’s create another member package in the workspace and call it&#160;&#160;add_one&#160;. Change<br/>the top-level&#160;<i>Cargo.toml</i>&#160;to specify the&#160;<i>add_one</i>&#160;path in the&#160;&#160;members&#160;&#160;list:<br/>
Filename: Cargo.toml<br/>
[workspace]<br/>
members&#160;=&#160;[<br/>&#160;&#160;&#160;&#160;&#34;adder&#34;,<br/>&#160;&#160;&#160;&#160;&#34;add_one&#34;,<br/>]<br/>
Then generate a new library crate named&#160;&#160;add_one&#160;:<br/>
$&#160;cargo&#160;new&#160;add_one&#160;--lib<br/>&#160;&#160;&#160;&#160;&#160;Created&#160;library&#160;`add_one`&#160;package<br/>
Your&#160;<i>add</i>&#160;directory should now have these directories and&#160;ﬁles:<br/>
https://doc.rust-lang.org/book/print.html<br/>
380/627<br/>
<hr/>
<a name=381></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
├──&#160;Cargo.lock<br/>├──&#160;Cargo.toml<br/>├──&#160;add_one<br/>│&#160;&#160;&#160;├──&#160;Cargo.toml<br/>│&#160;&#160;&#160;└──&#160;src<br/>│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──&#160;lib.rs<br/>├──&#160;adder<br/>│&#160;&#160;&#160;├──&#160;Cargo.toml<br/>│&#160;&#160;&#160;└──&#160;src<br/>│&#160;&#160;&#160;&#160;&#160;&#160;&#160;└──&#160;main.rs<br/>└──&#160;target<br/>
In the&#160;<i>add_one/src/lib.rs</i>&#160;ﬁle, let’s add an&#160;&#160;add_one&#160;&#160;function:<br/>
Filename: add_one/src/lib.rs<br/>
pub&#160;fn&#160;add_one(x:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;x&#160;+&#160;1<br/>}<br/>
Now we can have the&#160;&#160;adder&#160;&#160;package with our binary depend on the&#160;&#160;add_one&#160;&#160;package that<br/>has our library. First, we’ll need to add a path dependency on&#160;&#160;add_one&#160;&#160;to&#160;<i>adder/Cargo.toml</i>.<br/>
Filename: adder/Cargo.toml<br/>
[dependencies]<br/>add_one&#160;=&#160;{&#160;path&#160;=&#160;&#34;../add_one&#34;&#160;}<br/>
Cargo doesn’t assume that crates in a workspace will depend on each other, so we need to<br/>be explicit about the dependency relationships.<br/>
Next, let’s use the&#160;&#160;add_one&#160;&#160;function (from the&#160;&#160;add_one&#160;&#160;crate) in the&#160;&#160;adder&#160;&#160;crate. Open the<br/><i>adder/src/main.rs</i>&#160;ﬁle and add a&#160;&#160;use&#160;&#160;line at the top to bring the new&#160;&#160;add_one&#160;&#160;library crate<br/>into scope. Then change the&#160;&#160;main&#160;&#160;function to call the&#160;&#160;add_one&#160;&#160;function, as in Listing 14-7.<br/>
Filename: adder/src/main.rs<br/>
use&#160;add_one;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;num&#160;=&#160;10;<br/>&#160;&#160;&#160;&#160;println!(&#34;Hello,&#160;world!&#160;{num}&#160;plus&#160;one&#160;is&#160;{}!&#34;,&#160;add_one::add_one(num));<br/>}<br/>
<b>Listing&#160;14-7:&#160;Using&#160;the&#160;&#160;</b>add_one&#160;<b>&#160;library&#160;crate&#160;from&#160;the&#160;&#160;</b>adder&#160;<b>&#160;crate</b><br/>
Let’s build the workspace by running&#160;&#160;cargo&#160;build&#160;&#160;in the top-level&#160;<i>add</i>&#160;directory!<br/>
https://doc.rust-lang.org/book/print.html<br/>
381/627<br/>
<hr/>
<a name=382></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;Compiling&#160;add_one&#160;v0.1.0&#160;(file:///projects/add/add_one)<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/add/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.68s<br/>
To run the binary crate from the&#160;<i>add</i>&#160;directory, we can specify which package in the<br/>workspace we want to run by using the&#160;&#160;-p&#160;&#160;argument and the package name with&#160;&#160;cargo&#160;<br/>run&#160;:<br/>
$&#160;cargo&#160;run&#160;-p&#160;adder<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.0s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/adder`<br/>Hello,&#160;world!&#160;10&#160;plus&#160;one&#160;is&#160;11!<br/>
This runs the code in&#160;<i>adder/src/main.rs</i>, which depends on the&#160;&#160;add_one&#160;&#160;crate.<br/>
<a href="tests.html#382"><b>Depending on an External Package in a Workspace</b></a><br/>
Notice that the workspace has only one&#160;<i>Cargo.lock</i>&#160;ﬁle at the top level, rather than having a<br/><i>Cargo.lock</i>&#160;in each crate’s directory. This ensures that all crates are using the same version of<br/>all dependencies. If we add the&#160;&#160;rand&#160;&#160;package to the&#160;<i>adder/Cargo.toml</i>&#160;and<br/><i>add_one/Cargo.toml</i>&#160;ﬁles, Cargo will resolve both of those to one version of&#160;&#160;rand&#160;&#160;and record<br/>that in the one&#160;<i>Cargo.lock</i>. Making all crates in the workspace use the same dependencies<br/>means the crates will always be compatible with each other. Let’s add the&#160;&#160;rand&#160;&#160;crate to the<br/>
[dependencies]&#160;&#160;section in the&#160;<i>add_one/Cargo.toml</i>&#160;ﬁle so we can use the&#160;&#160;rand&#160;&#160;crate in the<br/>add_one&#160;&#160;crate:<br/>
Filename: add_one/Cargo.toml<br/>
[dependencies]<br/>rand&#160;=&#160;&#34;0.8.5&#34;<br/>
We can now add&#160;&#160;use&#160;rand;&#160;&#160;to the&#160;<i>add_one/src/lib.rs</i>&#160;ﬁle, and building the whole workspace<br/>by running&#160;&#160;cargo&#160;build&#160;&#160;in the&#160;<i>add</i>&#160;directory will bring in and compile the&#160;&#160;rand&#160;&#160;crate. We<br/>will get one warning because we aren’t referring to the&#160;&#160;rand&#160;&#160;we brought into scope:<br/>
https://doc.rust-lang.org/book/print.html<br/>
382/627<br/>
<hr/>
<a name=383></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;&#160;Updating&#160;crates.io&#160;index<br/>&#160;&#160;Downloaded&#160;rand&#160;v0.8.5<br/>&#160;&#160;&#160;--snip--<br/>&#160;&#160;&#160;Compiling&#160;rand&#160;v0.8.5<br/>&#160;&#160;&#160;Compiling&#160;add_one&#160;v0.1.0&#160;(file:///projects/add/add_one)<br/>warning:&#160;unused&#160;import:&#160;`rand`<br/>&#160;--&gt;&#160;add_one/src/lib.rs:1:5<br/>&#160;&#160;|<br/>1&#160;|&#160;use&#160;rand;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;`#[warn(unused_imports)]`&#160;on&#160;by&#160;default<br/>
warning:&#160;`add_one`&#160;(lib)&#160;generated&#160;1&#160;warning<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/add/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;10.18s<br/>
The top-level&#160;<i>Cargo.lock</i>&#160;now contains information about the dependency of&#160;&#160;add_one&#160;&#160;on<br/>
rand&#160;. However, even though&#160;&#160;rand&#160;&#160;is used somewhere in the workspace, we can’t use it in<br/>
other crates in the workspace unless we add&#160;&#160;rand&#160;&#160;to their&#160;<i>Cargo.toml</i>&#160;ﬁles as well. For<br/>example, if we add&#160;&#160;use&#160;rand;&#160;&#160;to the&#160;<i>adder/src/main.rs</i>&#160;ﬁle for the&#160;&#160;adder&#160;&#160;package, we’ll get<br/>an error:<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;--snip--<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/add/adder)<br/>error[E0432]:&#160;unresolved&#160;import&#160;`rand`<br/>&#160;--&gt;&#160;adder/src/main.rs:2:5<br/>&#160;&#160;|<br/>2&#160;|&#160;use&#160;rand;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^&#160;no&#160;external&#160;crate&#160;`rand`<br/>
To&#160;ﬁx this, edit the&#160;<i>Cargo.toml</i>&#160;ﬁle for the&#160;&#160;adder&#160;&#160;package and indicate that&#160;&#160;rand&#160;&#160;is a<br/>dependency for it as well. Building the&#160;&#160;adder&#160;&#160;package will add&#160;&#160;rand&#160;&#160;to the list of<br/>dependencies for&#160;&#160;adder&#160;&#160;in&#160;<i>Cargo.lock</i>, but no additional copies of&#160;&#160;rand&#160;&#160;will be downloaded.<br/>Cargo has ensured that every crate in every package in the workspace using the&#160;&#160;rand<br/>package will be using the same version, saving us space and ensuring that the crates in the<br/>workspace will be compatible with each other.<br/>
<a href="tests.html#383"><b>Adding a Test to a Workspace</b></a><br/>
For another enhancement, let’s add a test of the&#160;&#160;add_one::add_one&#160;&#160;function within the<br/>
add_one&#160;&#160;crate:<br/>
Filename: add_one/src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
383/627<br/>
<hr/>
<a name=384></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;fn&#160;add_one(x:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;x&#160;+&#160;1<br/>}<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;it_works()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(3,&#160;add_one(2));<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
Now run&#160;&#160;cargo&#160;test&#160;&#160;in the top-level&#160;<i>add</i>&#160;directory. Running&#160;&#160;cargo&#160;test&#160;&#160;in a workspace<br/>structured like this one will run the tests for all the crates in the workspace:<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;add_one&#160;v0.1.0&#160;(file:///projects/add/add_one)<br/>&#160;&#160;&#160;Compiling&#160;adder&#160;v0.1.0&#160;(file:///projects/add/adder)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.27s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/add_one-f0253159197f7841)<br/>
running&#160;1&#160;test<br/>test&#160;tests::it_works&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/main.rs&#160;(target/debug/deps/adder-49979ff40686fa8e)<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;add_one<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
The&#160;ﬁrst section of the output shows that the&#160;&#160;it_works&#160;&#160;test in the&#160;&#160;add_one&#160;&#160;crate passed.<br/>The next section shows that zero tests were found in the&#160;&#160;adder&#160;&#160;crate, and then the last<br/>section shows zero documentation tests were found in the&#160;&#160;add_one&#160;&#160;crate.<br/>
We can also run tests for one particular crate in a workspace from the top-level directory by<br/>using the&#160;&#160;-p&#160;&#160;ﬂag and specifying the name of the crate we want to test:<br/>
https://doc.rust-lang.org/book/print.html<br/>
384/627<br/>
<hr/>
<a name=385></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test&#160;-p&#160;add_one<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.00s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/add_one-b3235fea9a156f74)<br/>
running&#160;1&#160;test<br/>test&#160;tests::it_works&#160;...&#160;ok<br/>
test&#160;result:&#160;ok.&#160;1&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
&#160;&#160;&#160;Doc-tests&#160;add_one<br/>
running&#160;0&#160;tests<br/>
test&#160;result:&#160;ok.&#160;0&#160;passed;&#160;0&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
This output shows&#160;&#160;cargo&#160;test&#160;&#160;only ran the tests for the&#160;&#160;add_one&#160;&#160;crate and didn’t run the<br/>
adder&#160;&#160;crate tests.<br/>
<a href="https://crates.io/">If you publish the crates in the workspace to&#160;crates.io</a>, each crate in the workspace will need<br/>to be published separately. Like&#160;&#160;cargo&#160;test&#160;, we can publish a particular crate in our<br/>workspace by using the&#160;&#160;-p&#160;&#160;ﬂag and specifying the name of the crate we want to publish.<br/>
For additional practice, add an&#160;&#160;add_two&#160;&#160;crate to this workspace in a similar way as the<br/>
add_one&#160;&#160;crate!<br/>
As your project grows, consider using a workspace: it’s easier to understand smaller,<br/>individual components than one big blob of code. Furthermore, keeping the crates in a<br/>workspace can make coordination between crates easier if they are often changed at the<br/>same time.<br/>
https://doc.rust-lang.org/book/print.html<br/>
385/627<br/>
<hr/>
<a name=386></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#386"><b>Installing Binaries with&#160;</b>cargo&#160;install</a><br/>
The&#160;&#160;cargo&#160;install&#160;&#160;command allows you to install and use binary crates locally. This isn’t<br/>intended to replace system packages; it’s meant to be a convenient way for Rust developers<br/>to install tools that others have shared on&#160;<a href="https://crates.io/">crates.io. Note that you can only install packages<br/></a>that have binary targets. A&#160;<i>binary target</i>&#160;is the runnable program that is created if the crate<br/>has a&#160;<i>src/main.rs</i>&#160;ﬁle or another&#160;ﬁle speciﬁed as a binary, as opposed to a library target that<br/>isn’t runnable on its own but is suitable for including within other programs. Usually, crates<br/>have information in the&#160;<i>README</i>&#160;ﬁle about whether a crate is a library, has a binary target, or<br/>both.<br/>
All binaries installed with&#160;&#160;cargo&#160;install&#160;&#160;are stored in the installation root’s&#160;<i>bin</i>&#160;folder. If<br/>you installed Rust using&#160;<i>rustup.rs</i>&#160;and don’t have any custom conﬁgurations, this directory<br/>will be&#160;<i>$HOME/.cargo/bin</i>. Ensure that directory is in your&#160;&#160;$PATH&#160;&#160;to be able to run programs<br/>you’ve installed with&#160;&#160;cargo&#160;install&#160;.<br/>
For example, in Chapter 12 we mentioned that there’s a Rust implementation of the&#160;&#160;grep<br/>tool called&#160;&#160;ripgrep&#160;&#160;for searching&#160;ﬁles. To install&#160;&#160;ripgrep&#160;, we can run the following:<br/>
$&#160;cargo&#160;install&#160;ripgrep<br/>&#160;&#160;&#160;&#160;Updating&#160;crates.io&#160;index<br/>&#160;&#160;Downloaded&#160;ripgrep&#160;v13.0.0<br/>&#160;&#160;Downloaded&#160;1&#160;crate&#160;(243.3&#160;KB)&#160;in&#160;0.88s<br/>&#160;&#160;Installing&#160;ripgrep&#160;v13.0.0<br/>--snip--<br/>&#160;&#160;&#160;Compiling&#160;ripgrep&#160;v13.0.0<br/>&#160;&#160;&#160;&#160;Finished&#160;release&#160;[optimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;3m&#160;10s<br/>&#160;&#160;Installing&#160;~/.cargo/bin/rg<br/>&#160;&#160;&#160;Installed&#160;package&#160;`ripgrep&#160;v13.0.0`&#160;(executable&#160;`rg`)<br/>
The second-to-last line of the output shows the location and the name of the installed<br/>binary, which in the case of&#160;&#160;ripgrep&#160;&#160;is&#160;&#160;rg&#160;. As long as the installation directory is in your<br/>
$PATH&#160;, as mentioned previously, you can then run&#160;&#160;rg&#160;--help&#160;&#160;and start using a faster,<br/>
rustier tool for searching&#160;ﬁles!<br/>
https://doc.rust-lang.org/book/print.html<br/>
386/627<br/>
<hr/>
<a name=387></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#387"><b>Extending Cargo with Custom Commands</b></a><br/>
Cargo is designed so you can extend it with new subcommands without having to modify<br/>Cargo. If a binary in your&#160;&#160;$PATH&#160;&#160;is named&#160;&#160;cargo-something&#160;, you can run it as if it was a<br/>Cargo subcommand by running&#160;&#160;cargo&#160;something&#160;. Custom commands like this are also<br/>listed when you run&#160;&#160;cargo&#160;--list&#160;. Being able to use&#160;&#160;cargo&#160;install&#160;&#160;to install extensions<br/>and then run them just like the built-in Cargo tools is a super convenient beneﬁt of Cargo’s<br/>design!<br/>
<a href="tests.html#387"><b>Summary</b></a><br/>
Sharing code with Cargo and&#160;<a href="https://crates.io/">crates.io&#160;is part of what makes the Rust ecosystem useful for<br/></a>many diﬀerent tasks. Rust’s standard library is small and stable, but crates are easy to<br/>share, use, and improve on a timeline diﬀerent from that of the language. Don’t be shy<br/><a href="https://crates.io/">about sharing code that’s useful to you on&#160;crates.io</a>; it’s likely that it will be useful to<br/>someone else as well!<br/>
https://doc.rust-lang.org/book/print.html<br/>
387/627<br/>
<hr/>
<a name=388></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#388"><b>Smart Pointers</b></a><br/>
A&#160;<i>pointer</i>&#160;is a general concept for a variable that contains an address in memory. This<br/>address refers to, or “points at,” some other data. The most common kind of pointer in Rust<br/>is a reference, which you learned about in Chapter 4. References are indicated by the&#160;&#160;&amp;<br/>symbol and borrow the value they point to. They don’t have any special capabilities other<br/>than referring to data, and have no overhead.<br/>
<i>Smart pointers</i>, on the other hand, are data structures that act like a pointer but also have<br/>additional metadata and capabilities. The concept of smart pointers isn’t unique to Rust:<br/>smart pointers originated in C++ and exist in other languages as well. Rust has a variety of<br/>smart pointers deﬁned in the standard library that provide functionality beyond that<br/>provided by references. To explore the general concept, we’ll look at a couple of diﬀerent<br/>examples of smart pointers, including a&#160;<i>reference counting</i>&#160;smart pointer type. This pointer<br/>enables you to allow data to have multiple owners by keeping track of the number of<br/>owners and, when no owners remain, cleaning up the data.<br/>
Rust, with its concept of ownership and borrowing, has an additional diﬀerence between<br/>references and smart pointers: while references only borrow data, in many cases, smart<br/>pointers&#160;<i>own</i>&#160;the data they point to.<br/>
Though we didn’t call them as such at the time, we’ve already encountered a few smart<br/>pointers in this book, including&#160;&#160;String&#160;&#160;and&#160;&#160;Vec&lt;T&gt;&#160;&#160;in Chapter 8. Both these types count as<br/>smart pointers because they own some memory and allow you to manipulate it. They also<br/>have metadata and extra capabilities or guarantees.&#160;&#160;String&#160;, for example, stores its<br/>capacity as metadata and has the extra ability to ensure its data will always be valid UTF-8.<br/>
Smart pointers are usually implemented using structs. Unlike an ordinary struct, smart<br/>pointers implement the&#160;&#160;Deref&#160;&#160;and&#160;&#160;Drop&#160;&#160;traits. The&#160;&#160;Deref&#160;&#160;trait allows an instance of the<br/>smart pointer struct to behave like a reference so you can write your code to work with<br/>either references or smart pointers. The&#160;&#160;Drop&#160;&#160;trait allows you to customize the code that’s<br/>run when an instance of the smart pointer goes out of scope. In this chapter, we’ll discuss<br/>both traits and demonstrate why they’re important to smart pointers.<br/>
Given that the smart pointer pattern is a general design pattern used frequently in Rust, this<br/>chapter won’t cover every existing smart pointer. Many libraries have their own smart<br/>pointers, and you can even write your own. We’ll cover the most common smart pointers in<br/>the standard library:<br/>
Box&lt;T&gt;&#160;&#160;for allocating values on the heap<br/>Rc&lt;T&gt;&#160;, a reference counting type that enables multiple ownership<br/>Ref&lt;T&gt;&#160;&#160;and&#160;&#160;RefMut&lt;T&gt;&#160;, accessed through&#160;&#160;RefCell&lt;T&gt;&#160;, a type that enforces the<br/>
borrowing rules at runtime instead of compile time<br/>
https://doc.rust-lang.org/book/print.html<br/>
388/627<br/>
<hr/>
<a name=389></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
In addition, we’ll cover the&#160;<i>interior mutability</i>&#160;pattern where an immutable type exposes an<br/>API for mutating an interior value. We’ll also discuss&#160;<i>reference cycles</i>: how they can leak<br/>memory and how to prevent them.<br/>
Let’s dive in!<br/>
https://doc.rust-lang.org/book/print.html<br/>
389/627<br/>
<hr/>
<a name=390></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#390"><b>Using&#160;</b>Box&lt;T&gt;<b>&#160;to Point to Data on the Heap</b></a><br/>
The most straightforward smart pointer is a&#160;<i>box</i>, whose type is written&#160;&#160;Box&lt;T&gt;&#160;. Boxes allow<br/>you to store data on the heap rather than the stack. What remains on the stack is the<br/>pointer to the heap data. Refer to Chapter 4 to review the diﬀerence between the stack and<br/>the heap.<br/>
Boxes don’t have performance overhead, other than storing their data on the heap instead<br/>of on the stack. But they don’t have many extra capabilities either. You’ll use them most<br/>often in these situations:<br/>
When you have a type whose size can’t be known at compile time and you want to use<br/>a value of that type in a context that requires an exact size<br/>When you have a large amount of data and you want to transfer ownership but ensure<br/>the data won’t be copied when you do so<br/>When you want to own a value and you care only that it’s a type that implements a<br/>particular trait rather than being of a speciﬁc type<br/>
We’ll demonstrate the&#160;ﬁ<a href="https://doc.rust-lang.org/book/ch15-01-box.html#enabling-recursive-types-with-boxes">rst situation in the&#160;“Enabling Recursive Types with Boxes”</a>&#160;section. In<br/>the second case, transferring ownership of a large amount of data can take a long time<br/>because the data is copied around on the stack. To improve performance in this situation,<br/>we can store the large amount of data on the heap in a box. Then, only the small amount of<br/>pointer data is copied around on the stack, while the data it references stays in one place on<br/>the heap. The third case is known as a&#160;<i>trait object</i>, and Chapter 17 devotes an entire section,<br/><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Using Trait Objects That Allow for Values of Diﬀerent Types,”&#160;just to that topic. So what you<br/></a>learn here you’ll apply again in Chapter 17!<br/>
<a href="tests.html#390"><b>Using&#160;a&#160;</b>Box&lt;T&gt;<b>&#160;to&#160;Store&#160;Data&#160;on&#160;the&#160;Heap</b></a><br/>
Before we discuss the heap storage use case for&#160;&#160;Box&lt;T&gt;&#160;, we’ll cover the syntax and how to<br/>interact with values stored within a&#160;&#160;Box&lt;T&gt;&#160;.<br/>
Listing 15-1 shows how to use a box to store an&#160;&#160;i32&#160;&#160;value on the heap:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;b&#160;=&#160;Box::new(5);<br/>&#160;&#160;&#160;&#160;println!(&#34;b&#160;=&#160;{}&#34;,&#160;b);<br/>}<br/>
<b>Listing&#160;15-1:&#160;Storing&#160;an&#160;&#160;</b>i32&#160;<b>&#160;value&#160;on&#160;the&#160;heap&#160;using&#160;a&#160;box</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
390/627<br/>
<hr/>
<a name=391></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We deﬁne the variable&#160;&#160;b&#160;&#160;to have the value of a&#160;&#160;Box&#160;&#160;that points to the value&#160;&#160;5&#160;, which is<br/>allocated on the heap. This program will print&#160;&#160;b&#160;=&#160;5&#160;; in this case, we can access the data in<br/>the box similar to how we would if this data were on the stack. Just like any owned value,<br/>when a box goes out of scope, as&#160;&#160;b&#160;&#160;does at the end of&#160;&#160;main&#160;, it will be deallocated. The<br/>deallocation happens both for the box (stored on the stack) and the data it points to (stored<br/>on the heap).<br/>
Putting a single value on the heap isn’t very useful, so you won’t use boxes by themselves in<br/>this way very often. Having values like a single&#160;&#160;i32&#160;&#160;on the stack, where they’re stored by<br/>default, is more appropriate in the majority of situations. Let’s look at a case where boxes<br/>allow us to deﬁne types that we wouldn’t be allowed to if we didn’t have boxes.<br/>
<a href="tests.html#391"><b>Enabling&#160;Recursive&#160;Types&#160;with&#160;Boxes</b></a><br/>
A value of&#160;<i>recursive type</i>&#160;can have another value of the same type as part of itself. Recursive<br/>types pose an issue because at compile time Rust needs to know how much space a type<br/>takes up. However, the nesting of values of recursive types could theoretically continue<br/>inﬁnitely, so Rust can’t know how much space the value needs. Because boxes have a<br/>known size, we can enable recursive types by inserting a box in the recursive type deﬁnition.<br/>
As an example of a recursive type, let’s explore the&#160;<i>cons list</i>. This is a data type commonly<br/>found in functional programming languages. The cons list type we’ll deﬁne is<br/>straightforward except for the recursion; therefore, the concepts in the example we’ll work<br/>with will be useful any time you get into more complex situations involving recursive types.<br/>
<a href="tests.html#391"><b>More Information About the Cons List</b></a><br/>
A&#160;<i>cons list</i>&#160;is a data structure that comes from the Lisp programming language and its<br/>dialects and is made up of nested pairs, and is the Lisp version of a linked list. Its name<br/>comes from the&#160;&#160;cons&#160;&#160;function (short for “construct function”) in Lisp that constructs a new<br/>pair from its two arguments. By calling&#160;&#160;cons&#160;&#160;on a pair consisting of a value and another<br/>pair, we can construct cons lists made up of recursive pairs.<br/>
For example, here’s a pseudocode representation of a cons list containing the list 1, 2, 3 with<br/>each pair in parentheses:<br/>
(1,&#160;(2,&#160;(3,&#160;Nil)))<br/>
Each item in a cons list contains two elements: the value of the current item and the next<br/>item. The last item in the list contains only a value called&#160;&#160;Nil&#160;&#160;without a next item. A cons<br/>list is produced by recursively calling the&#160;&#160;cons&#160;&#160;function. The canonical name to denote the<br/>base case of the recursion is&#160;&#160;Nil&#160;. Note that this is not the same as the “null” or “nil” concept<br/>in Chapter 6, which is an invalid or absent value.<br/>
https://doc.rust-lang.org/book/print.html<br/>
391/627<br/>
<hr/>
<a name=392></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The cons list isn’t a commonly used data structure in Rust. Most of the time when you have<br/>a list of items in Rust,&#160;&#160;Vec&lt;T&gt;&#160;&#160;is a better choice to use. Other, more complex recursive data<br/>types&#160;<i>are</i>&#160;useful in various situations, but by starting with the cons list in this chapter, we<br/>can explore how boxes let us deﬁne a recursive data type without much distraction.<br/>
Listing 15-2 contains an enum deﬁnition for a cons list. Note that this code won’t compile yet<br/>because the&#160;&#160;List&#160;&#160;type doesn’t have a known size, which we’ll demonstrate.<br/>
Filename: src/main.rs<br/>
enum&#160;List&#160;{<br/>&#160;&#160;&#160;&#160;Cons(i32,&#160;List),<br/>&#160;&#160;&#160;&#160;Nil,<br/>}<br/>
<b>Listing&#160;15-2:&#160;The&#160;ﬁrst&#160;attempt&#160;at&#160;deﬁning&#160;an&#160;enum&#160;to&#160;represent&#160;a&#160;cons&#160;list&#160;data&#160;structure&#160;of&#160;&#160;</b>i32&#160;<b>&#160;values</b><br/>
Note: We’re implementing a cons list that holds only&#160;&#160;i32&#160;&#160;values for the purposes of<br/>this example. We could have implemented it using generics, as we discussed in<br/>Chapter 10, to deﬁne a cons list type that could store values of any type.<br/>
Using the&#160;&#160;List&#160;&#160;type to store the list&#160;&#160;1,&#160;2,&#160;3&#160;&#160;would look like the code in Listing 15-3:<br/>
Filename: src/main.rs<br/>
use&#160;crate::List::{Cons,&#160;Nil};<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;list&#160;=&#160;Cons(1,&#160;Cons(2,&#160;Cons(3,&#160;Nil)));<br/>}<br/>
<b>Listing&#160;15-3:&#160;Using&#160;the&#160;&#160;</b>List&#160;<b>&#160;enum&#160;to&#160;store&#160;the&#160;list&#160;&#160;</b>1,&#160;2,&#160;3<br/>
The&#160;ﬁrst&#160;&#160;Cons&#160;&#160;value holds&#160;&#160;1&#160;&#160;and another&#160;&#160;List&#160;&#160;value. This&#160;&#160;List&#160;&#160;value is another&#160;&#160;Cons<br/>value that holds&#160;&#160;2&#160;&#160;and another&#160;&#160;List&#160;&#160;value. This&#160;&#160;List&#160;&#160;value is one more&#160;&#160;Cons&#160;&#160;value that<br/>holds&#160;&#160;3&#160;&#160;and a&#160;&#160;List&#160;&#160;value, which is&#160;ﬁnally&#160;&#160;Nil&#160;, the non-recursive variant that signals the<br/>end of the list.<br/>
If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:<br/>
https://doc.rust-lang.org/book/print.html<br/>
392/627<br/>
<hr/>
<a name=393></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;cons-list&#160;v0.1.0&#160;(file:///projects/cons-list)<br/>error[E0072]:&#160;recursive&#160;type&#160;`List`&#160;has&#160;infinite&#160;size<br/>&#160;--&gt;&#160;src/main.rs:1:1<br/>&#160;&#160;|<br/>1&#160;|&#160;enum&#160;List&#160;{<br/>&#160;&#160;|&#160;^^^^^^^^^<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;Cons(i32,&#160;List),<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;----&#160;recursive&#160;without&#160;indirection<br/>&#160;&#160;|<br/>help:&#160;insert&#160;some&#160;indirection&#160;(e.g.,&#160;a&#160;`Box`,&#160;`Rc`,&#160;or&#160;`&amp;`)&#160;to&#160;break&#160;the&#160;cycle<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;Cons(i32,&#160;Box&lt;List&gt;),<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++++&#160;&#160;&#160;&#160;+<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0072`.<br/>error:&#160;could&#160;not&#160;compile&#160;`cons-list`&#160;due&#160;to&#160;previous&#160;error<br/>
<b>Listing&#160;15-4:&#160;The&#160;error&#160;we&#160;get&#160;when&#160;attempting&#160;to&#160;deﬁne&#160;a&#160;recursive&#160;enum</b><br/>
The error shows this type “has inﬁnite size.” The reason is that we’ve deﬁned&#160;&#160;List&#160;&#160;with a<br/>variant that is recursive: it holds another value of itself directly. As a result, Rust can’t&#160;ﬁgure<br/>out how much space it needs to store a&#160;&#160;List&#160;&#160;value. Let’s break down why we get this error.<br/>First, we’ll look at how Rust decides how much space it needs to store a value of a non-<br/>recursive type.<br/>
<a href="tests.html#393"><b>Computing the Size of a Non-Recursive Type</b></a><br/>
Recall the&#160;&#160;Message&#160;&#160;enum we deﬁned in Listing 6-2 when we discussed enum deﬁnitions in<br/>Chapter 6:<br/>
enum&#160;Message&#160;{<br/>&#160;&#160;&#160;&#160;Quit,<br/>&#160;&#160;&#160;&#160;Move&#160;{&#160;x:&#160;i32,&#160;y:&#160;i32&#160;},<br/>&#160;&#160;&#160;&#160;Write(String),<br/>&#160;&#160;&#160;&#160;ChangeColor(i32,&#160;i32,&#160;i32),<br/>}<br/>
To determine how much space to allocate for a&#160;&#160;Message&#160;&#160;value, Rust goes through each of<br/>the variants to see which variant needs the most space. Rust sees that&#160;&#160;Message::Quit<br/>doesn’t need any space,&#160;&#160;Message::Move&#160;&#160;needs enough space to store two&#160;&#160;i32&#160;&#160;values, and<br/>so forth. Because only one variant will be used, the most space a&#160;&#160;Message&#160;&#160;value will need is<br/>the space it would take to store the largest of its variants.<br/>
Contrast this with what happens when Rust tries to determine how much space a recursive<br/>type like the&#160;&#160;List&#160;&#160;enum in Listing 15-2 needs. The compiler starts by looking at the&#160;&#160;Cons<br/>variant, which holds a value of type&#160;&#160;i32&#160;&#160;and a value of type&#160;&#160;List&#160;. Therefore,&#160;&#160;Cons&#160;&#160;needs<br/>an amount of space equal to the size of an&#160;&#160;i32&#160;&#160;plus the size of a&#160;&#160;List&#160;. To&#160;ﬁgure out how<br/>much memory the&#160;&#160;List&#160;&#160;type needs, the compiler looks at the variants, starting with the<br/>
https://doc.rust-lang.org/book/print.html<br/>
393/627<br/>
<hr/>
<a name=394></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Cons&#160;&#160;variant. The&#160;&#160;Cons&#160;&#160;variant holds a value of type&#160;&#160;i32&#160;&#160;and a value of type&#160;&#160;List&#160;, and<br/>
this process continues inﬁnitely, as shown in Figure 15-1.<br/>
Cons<br/>
Cons<br/>
Cons<br/>
i32<br/>
Cons<br/>
i32&#160;i32<br/>
Cons<br/>
i32&#160;i32&#160;∞<br/>
<b>Figure&#160;15-1:&#160;An&#160;inﬁnite&#160;&#160;</b>List&#160;<b>&#160;consisting&#160;of&#160;inﬁnite&#160;&#160;</b>Cons&#160;<b>&#160;variants</b><br/>
<a href="tests.html#394"><b>Using&#160;</b>Box&lt;T&gt;<b>&#160;to Get a Recursive Type with a Known Size</b></a><br/>
Because Rust can’t&#160;ﬁgure out how much space to allocate for recursively deﬁned types, the<br/>compiler gives an error with this helpful suggestion:<br/>
help:&#160;insert&#160;some&#160;indirection&#160;(e.g.,&#160;a&#160;`Box`,&#160;`Rc`,&#160;or&#160;`&amp;`)&#160;to&#160;make&#160;`List`&#160;<br/>representable<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;Cons(i32,&#160;Box&lt;List&gt;),<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++++&#160;&#160;&#160;&#160;+<br/>
In this suggestion, “indirection” means that instead of storing a value directly, we should<br/>change the data structure to store the value indirectly by storing a pointer to the value<br/>instead.<br/>
Because a&#160;&#160;Box&lt;T&gt;&#160;&#160;is a pointer, Rust always knows how much space a&#160;&#160;Box&lt;T&gt;&#160;&#160;needs: a<br/>pointer’s size doesn’t change based on the amount of data it’s pointing to. This means we<br/>can put a&#160;&#160;Box&lt;T&gt;&#160;&#160;inside the&#160;&#160;Cons&#160;&#160;variant instead of another&#160;&#160;List&#160;&#160;value directly. The<br/>
Box&lt;T&gt;&#160;&#160;will point to the next&#160;&#160;List&#160;&#160;value that will be on the heap rather than inside the<br/>Cons&#160;&#160;variant. Conceptually, we still have a list, created with lists holding other lists, but this<br/>
implementation is now more like placing the items next to one another rather than inside<br/>one another.<br/>
We can change the deﬁnition of the&#160;&#160;List&#160;&#160;enum in Listing 15-2 and the usage of the&#160;&#160;List&#160;&#160;in<br/>Listing 15-3 to the code in Listing 15-5, which will compile:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
394/627<br/>
<hr/>
<a name=395></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
enum&#160;List&#160;{<br/>&#160;&#160;&#160;&#160;Cons(i32,&#160;Box&lt;List&gt;),<br/>&#160;&#160;&#160;&#160;Nil,<br/>}<br/>
use&#160;crate::List::{Cons,&#160;Nil};<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;list&#160;=&#160;Cons(1,&#160;Box::new(Cons(2,&#160;Box::new(Cons(3,&#160;Box::new(Nil))))));<br/>}<br/>
<b>Listing&#160;15-5:&#160;Deﬁnition&#160;of&#160;&#160;</b>List&#160;<b>&#160;that&#160;uses&#160;&#160;</b>Box&lt;T&gt;&#160;<b>&#160;in&#160;order&#160;to&#160;have&#160;a&#160;known&#160;size</b><br/>
The&#160;&#160;Cons&#160;&#160;variant needs the size of an&#160;&#160;i32&#160;&#160;plus the space to store the box’s pointer data.<br/>The&#160;&#160;Nil&#160;&#160;variant stores no values, so it needs less space than the&#160;&#160;Cons&#160;&#160;variant. We now<br/>know that any&#160;&#160;List&#160;&#160;value will take up the size of an&#160;&#160;i32&#160;&#160;plus the size of a box’s pointer<br/>data. By using a box, we’ve broken the inﬁnite, recursive chain, so the compiler can&#160;ﬁgure<br/>out the size it needs to store a&#160;&#160;List&#160;&#160;value. Figure 15-2 shows what the&#160;&#160;Cons&#160;&#160;variant looks<br/>like now.<br/>
Cons<br/>
Box<br/>
i32&#160;usize<br/>
<b>Figure&#160;15-2:&#160;A&#160;&#160;</b>List&#160;<b>&#160;that&#160;is&#160;not&#160;inﬁnitely&#160;sized&#160;because&#160;&#160;</b>Cons&#160;<b>&#160;holds&#160;a&#160;&#160;</b>Box<br/>
Boxes provide only the indirection and heap allocation; they don’t have any other special<br/>capabilities, like those we’ll see with the other smart pointer types. They also don’t have the<br/>performance overhead that these special capabilities incur, so they can be useful in cases<br/>like the cons list where the indirection is the only feature we need. We’ll look at more use<br/>cases for boxes in Chapter 17, too.<br/>
The&#160;&#160;Box&lt;T&gt;&#160;&#160;type is a smart pointer because it implements the&#160;&#160;Deref&#160;&#160;trait, which allows<br/>
Box&lt;T&gt;&#160;&#160;values to be treated like references. When a&#160;&#160;Box&lt;T&gt;&#160;&#160;value goes out of scope, the<br/>
heap data that the box is pointing to is cleaned up as well because of the&#160;&#160;Drop&#160;&#160;trait<br/>implementation. These two traits will be even more important to the functionality provided<br/>
https://doc.rust-lang.org/book/print.html<br/>
395/627<br/>
<hr/>
<a name=396></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
by the other smart pointer types we’ll discuss in the rest of this chapter. Let’s explore these<br/>two traits in more detail.<br/>
https://doc.rust-lang.org/book/print.html<br/>
396/627<br/>
<hr/>
<a name=397></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#397"><b>Treating Smart Pointers Like Regular References with the<br/></b>Deref<b>&#160;Trait</b></a><br/>
Implementing the&#160;&#160;Deref&#160;&#160;trait allows you to customize the behavior of the&#160;<i>dereference<br/>operator</i>&#160;&#160;*&#160;&#160;(not to be confused with the multiplication or glob operator). By implementing<br/>
Deref&#160;&#160;in such a way that a smart pointer can be treated like a regular reference, you can<br/>
write code that operates on references and use that code with smart pointers too.<br/>
Let’s&#160;ﬁrst look at how the dereference operator works with regular references. Then we’ll try<br/>to deﬁne a custom type that behaves like&#160;&#160;Box&lt;T&gt;&#160;, and see why the dereference operator<br/>doesn’t work like a reference on our newly deﬁned type. We’ll explore how implementing<br/>the&#160;&#160;Deref&#160;&#160;trait makes it possible for smart pointers to work in ways similar to references.<br/>Then we’ll look at Rust’s&#160;<i>deref coercion</i>&#160;feature and how it lets us work with either references<br/>or smart pointers.<br/>
Note: there’s one big diﬀerence between the&#160;&#160;MyBox&lt;T&gt;&#160;&#160;type we’re about to build and<br/>the real&#160;&#160;Box&lt;T&gt;&#160;: our version will not store its data on the heap. We are focusing this<br/>example on&#160;&#160;Deref&#160;, so where the data is actually stored is less important than the<br/>pointer-like behavior.<br/>
<a href="tests.html#397"><b>Following&#160;the&#160;Pointer&#160;to&#160;the&#160;Value</b></a><br/>
A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a<br/>value stored somewhere else. In Listing 15-6, we create a reference to an&#160;&#160;i32&#160;&#160;value and<br/>then use the dereference operator to follow the reference to the value:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;<br/>&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;&amp;x;<br/>
&#160;&#160;&#160;&#160;assert_eq!(5,&#160;x);<br/>&#160;&#160;&#160;&#160;assert_eq!(5,&#160;*y);<br/>}<br/>
<b>Listing&#160;15-6:&#160;Using&#160;the&#160;dereference&#160;operator&#160;to&#160;follow&#160;a&#160;reference&#160;to&#160;an&#160;&#160;</b>i32&#160;<b>&#160;value</b><br/>
The variable&#160;&#160;x&#160;&#160;holds an&#160;&#160;i32&#160;&#160;value&#160;&#160;5&#160;. We set&#160;&#160;y&#160;&#160;equal to a reference to&#160;&#160;x&#160;. We can assert<br/>that&#160;&#160;x&#160;&#160;is equal to&#160;&#160;5&#160;. However, if we want to make an assertion about the value in&#160;&#160;y&#160;, we<br/>have to use&#160;&#160;*y&#160;&#160;to follow the reference to the value it’s pointing to (hence&#160;<i>dereference</i>) so the<br/>
https://doc.rust-lang.org/book/print.html<br/>
397/627<br/>
<hr/>
<a name=398></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
compiler can compare the actual value. Once we dereference&#160;&#160;y&#160;, we have access to the<br/>integer value&#160;&#160;y&#160;&#160;is pointing to that we can compare with&#160;&#160;5&#160;.<br/>
If we tried to write&#160;&#160;assert_eq!(5,&#160;y);&#160;&#160;instead, we would get this compilation error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;deref-example&#160;v0.1.0&#160;(file:///projects/deref-example)<br/>error[E0277]:&#160;can't&#160;compare&#160;`{integer}`&#160;with&#160;`&amp;{integer}`<br/>&#160;--&gt;&#160;src/main.rs:6:5<br/>&#160;&#160;|<br/>6&#160;|&#160;&#160;&#160;&#160;&#160;assert_eq!(5,&#160;y);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^&#160;no&#160;implementation&#160;for&#160;`{integer}&#160;==&#160;&amp;{integer}`<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;help:&#160;the&#160;trait&#160;`PartialEq&lt;&amp;{integer}&gt;`&#160;is&#160;not&#160;implemented&#160;for&#160;`{integer}`<br/>&#160;&#160;=&#160;help:&#160;the&#160;following&#160;other&#160;types&#160;implement&#160;trait&#160;`PartialEq&lt;Rhs&gt;`:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;f32<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;f64<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i128<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i16<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i32<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i64<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;i8<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;isize<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;and&#160;6&#160;others<br/>&#160;&#160;=&#160;note:&#160;this&#160;error&#160;originates&#160;in&#160;the&#160;macro&#160;`assert_eq`&#160;(in&#160;Nightly&#160;builds,&#160;<br/>run&#160;with&#160;-Z&#160;macro-backtrace&#160;for&#160;more&#160;info)<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0277`.<br/>error:&#160;could&#160;not&#160;compile&#160;`deref-example`&#160;due&#160;to&#160;previous&#160;error<br/>
Comparing a number and a reference to a number isn’t allowed because they’re diﬀerent<br/>types. We must use the dereference operator to follow the reference to the value it’s<br/>pointing to.<br/>
<a href="tests.html#398"><b>Using&#160;</b>Box&lt;T&gt;<b>&#160;Like&#160;a&#160;Reference</b></a><br/>
We can rewrite the code in Listing 15-6 to use a&#160;&#160;Box&lt;T&gt;&#160;&#160;instead of a reference; the<br/>dereference operator used on the&#160;&#160;Box&lt;T&gt;&#160;&#160;in Listing 15-7 functions in the same way as the<br/>dereference operator used on the reference in Listing 15-6:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;<br/>&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;Box::new(x);<br/>
&#160;&#160;&#160;&#160;assert_eq!(5,&#160;x);<br/>&#160;&#160;&#160;&#160;assert_eq!(5,&#160;*y);<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
398/627<br/>
<hr/>
<a name=399></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Listing&#160;15-7:&#160;Using&#160;the&#160;dereference&#160;operator&#160;on&#160;a&#160;&#160;</b>Box&lt;i32&gt;<br/>
The main diﬀerence between Listing 15-7 and Listing 15-6 is that here we set&#160;&#160;y&#160;&#160;to be an<br/>instance of a&#160;&#160;Box&lt;T&gt;&#160;&#160;pointing to a copied value of&#160;&#160;x&#160;&#160;rather than a reference pointing to the<br/>value of&#160;&#160;x&#160;. In the last assertion, we can use the dereference operator to follow the pointer<br/>of the&#160;&#160;Box&lt;T&gt;&#160;&#160;in the same way that we did when&#160;&#160;y&#160;&#160;was a reference. Next, we’ll explore<br/>what is special about&#160;&#160;Box&lt;T&gt;&#160;&#160;that enables us to use the dereference operator by deﬁning<br/>our own type.<br/>
<a href="tests.html#399"><b>Deﬁning&#160;Our&#160;Own&#160;Smart&#160;Pointer</b></a><br/>
Let’s build a smart pointer similar to the&#160;&#160;Box&lt;T&gt;&#160;&#160;type provided by the standard library to<br/>experience how smart pointers behave diﬀerently from references by default. Then we’ll<br/>look at how to add the ability to use the dereference operator.<br/>
The&#160;&#160;Box&lt;T&gt;&#160;&#160;type is ultimately deﬁned as a tuple struct with one element, so Listing 15-8<br/>deﬁnes a&#160;&#160;MyBox&lt;T&gt;&#160;&#160;type in the same way. We’ll also deﬁne a&#160;&#160;new&#160;&#160;function to match the<br/>
new&#160;&#160;function deﬁned on&#160;&#160;Box&lt;T&gt;&#160;.<br/>
Filename: src/main.rs<br/>
struct&#160;MyBox&lt;T&gt;(T);<br/>
impl&lt;T&gt;&#160;MyBox&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;new(x:&#160;T)&#160;-&gt;&#160;MyBox&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MyBox(x)<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;15-8:&#160;Deﬁning&#160;a&#160;&#160;</b>MyBox&lt;T&gt;&#160;<b>&#160;type</b><br/>
We deﬁne a struct named&#160;&#160;MyBox&#160;&#160;and declare a generic parameter&#160;&#160;T&#160;, because we want our<br/>type to hold values of any type. The&#160;&#160;MyBox&#160;&#160;type is a tuple struct with one element of type<br/>
T&#160;. The&#160;&#160;MyBox::new&#160;&#160;function takes one parameter of type&#160;&#160;T&#160;&#160;and returns a&#160;&#160;MyBox&#160;&#160;instance<br/>
that holds the value passed in.<br/>
Let’s try adding the&#160;&#160;main&#160;&#160;function in Listing 15-7 to Listing 15-8 and changing it to use the<br/>
MyBox&lt;T&gt;&#160;&#160;type we’ve deﬁned instead of&#160;&#160;Box&lt;T&gt;&#160;. The code in Listing 15-9 won’t compile<br/>
because Rust doesn’t know how to dereference&#160;&#160;MyBox&#160;.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
399/627<br/>
<hr/>
<a name=400></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;<br/>&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;MyBox::new(x);<br/>
&#160;&#160;&#160;&#160;assert_eq!(5,&#160;x);<br/>&#160;&#160;&#160;&#160;assert_eq!(5,&#160;*y);<br/>}<br/>
<b>Listing&#160;15-9:&#160;Attempting&#160;to&#160;use&#160;&#160;</b>MyBox&lt;T&gt;&#160;<b>&#160;in&#160;the&#160;same&#160;way&#160;we&#160;used&#160;references&#160;and&#160;&#160;</b>Box&lt;T&gt;<br/>
Here’s the resulting compilation error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;deref-example&#160;v0.1.0&#160;(file:///projects/deref-example)<br/>error[E0614]:&#160;type&#160;`MyBox&lt;{integer}&gt;`&#160;cannot&#160;be&#160;dereferenced<br/>&#160;&#160;--&gt;&#160;src/main.rs:14:19<br/>&#160;&#160;&#160;|<br/>14&#160;|&#160;&#160;&#160;&#160;&#160;assert_eq!(5,&#160;*y);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0614`.<br/>error:&#160;could&#160;not&#160;compile&#160;`deref-example`&#160;due&#160;to&#160;previous&#160;error<br/>
Our&#160;&#160;MyBox&lt;T&gt;&#160;&#160;type can’t be dereferenced because we haven’t implemented that ability on<br/>our type. To enable dereferencing with the&#160;&#160;*&#160;&#160;operator, we implement the&#160;&#160;Deref&#160;&#160;trait.<br/>
<a href="tests.html#400"><b>Treating&#160;a&#160;Type&#160;Like&#160;a&#160;Reference&#160;by&#160;Implementing&#160;the&#160;</b>Deref<b>&#160;Trait</b></a><br/>
As discussed in the&#160;<a href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type">“Implementing a Trait on a Type”&#160;section of Chapter 10, to implement a<br/></a>trait, we need to provide implementations for the trait’s required methods. The&#160;&#160;Deref&#160;&#160;trait,<br/>provided by the standard library, requires us to implement one method named&#160;&#160;deref&#160;&#160;that<br/>borrows&#160;&#160;self&#160;&#160;and returns a reference to the inner data. Listing 15-10 contains an<br/>implementation of&#160;&#160;Deref&#160;&#160;to add to the deﬁnition of&#160;&#160;MyBox&#160;:<br/>
Filename: src/main.rs<br/>
use&#160;std::ops::Deref;<br/>
impl&lt;T&gt;&#160;Deref&#160;for&#160;MyBox&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;type&#160;Target&#160;=&#160;T;<br/>
&#160;&#160;&#160;&#160;fn&#160;deref(&amp;self)&#160;-&gt;&#160;&amp;Self::Target&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&amp;self.0<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;15-10:&#160;Implementing&#160;&#160;</b>Deref&#160;<b>&#160;on&#160;&#160;</b>MyBox&lt;T&gt;<br/>
https://doc.rust-lang.org/book/print.html<br/>
400/627<br/>
<hr/>
<a name=401></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The&#160;&#160;type&#160;Target&#160;=&#160;T;&#160;&#160;syntax deﬁnes an associated type for the&#160;&#160;Deref&#160;&#160;trait to use.<br/>Associated types are a slightly diﬀerent way of declaring a generic parameter, but you don’t<br/>need to worry about them for now; we’ll cover them in more detail in Chapter 19.<br/>
We&#160;ﬁll in the body of the&#160;&#160;deref&#160;&#160;method with&#160;&#160;&amp;self.0&#160;&#160;so&#160;&#160;deref&#160;&#160;returns a reference to the<br/><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">value we want to access with the&#160;&#160;*&#160;&#160;operator; recall from the&#160;“Using Tuple Structs without<br/>Named Fields to Create Diﬀerent Types”&#160;section of Chapter 5 that&#160;&#160;.0&#160;&#160;accesses the&#160;ﬁrst<br/></a>value in a tuple struct. The&#160;&#160;main&#160;&#160;function in Listing 15-9 that calls&#160;&#160;*&#160;&#160;on the&#160;&#160;MyBox&lt;T&gt;&#160;&#160;value<br/>now compiles, and the assertions pass!<br/>
Without the&#160;&#160;Deref&#160;&#160;trait, the compiler can only dereference&#160;&#160;&amp;&#160;&#160;references. The&#160;&#160;deref<br/>method gives the compiler the ability to take a value of any type that implements&#160;&#160;Deref<br/>and call the&#160;&#160;deref&#160;&#160;method to get a&#160;&#160;&amp;&#160;&#160;reference that it knows how to dereference.<br/>
When we entered&#160;&#160;*y&#160;&#160;in Listing 15-9, behind the scenes Rust actually ran this code:<br/>
*(y.deref())<br/>
Rust substitutes the&#160;&#160;*&#160;&#160;operator with a call to the&#160;&#160;deref&#160;&#160;method and then a plain<br/>dereference so we don’t have to think about whether or not we need to call the&#160;&#160;deref<br/>method. This Rust feature lets us write code that functions identically whether we have a<br/>regular reference or a type that implements&#160;&#160;Deref&#160;.<br/>
The reason the&#160;&#160;deref&#160;&#160;method returns a reference to a value, and that the plain<br/>dereference outside the parentheses in&#160;&#160;*(y.deref())&#160;&#160;is still necessary, is to do with the<br/>ownership system. If the&#160;&#160;deref&#160;&#160;method returned the value directly instead of a reference<br/>to the value, the value would be moved out of&#160;&#160;self&#160;. We don’t want to take ownership of<br/>the inner value inside&#160;&#160;MyBox&lt;T&gt;&#160;&#160;in this case or in most cases where we use the dereference<br/>operator.<br/>
Note that the&#160;&#160;*&#160;&#160;operator is replaced with a call to the&#160;&#160;deref&#160;&#160;method and then a call to the<br/>
*&#160;&#160;operator just once, each time we use a&#160;&#160;*&#160;&#160;in our code. Because the substitution of the&#160;&#160;*<br/>
operator does not recurse inﬁnitely, we end up with data of type&#160;&#160;i32&#160;, which matches the&#160;&#160;5<br/>in&#160;&#160;assert_eq!&#160;&#160;in Listing 15-9.<br/>
<a href="tests.html#401"><b>Implicit&#160;Deref&#160;Coercions&#160;with&#160;Functions&#160;and&#160;Methods</b></a><br/>
<i>Deref coercion</i>&#160;converts a reference to a type that implements the&#160;&#160;Deref&#160;&#160;trait into a<br/>reference to another type. For example, deref coercion can convert&#160;&#160;&amp;String&#160;&#160;to&#160;&#160;&amp;str<br/>because&#160;&#160;String&#160;&#160;implements the&#160;&#160;Deref&#160;&#160;trait such that it returns&#160;&#160;&amp;str&#160;. Deref coercion is a<br/>convenience Rust performs on arguments to functions and methods, and works only on<br/>types that implement the&#160;&#160;Deref&#160;&#160;trait. It happens automatically when we pass a reference to<br/>a particular type’s value as an argument to a function or method that doesn’t match the<br/>
https://doc.rust-lang.org/book/print.html<br/>
401/627<br/>
<hr/>
<a name=402></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
parameter type in the function or method deﬁnition. A sequence of calls to the&#160;&#160;deref<br/>method converts the type we provided into the type the parameter needs.<br/>
Deref coercion was added to Rust so that programmers writing function and method calls<br/>don’t need to add as many explicit references and dereferences with&#160;&#160;&amp;&#160;&#160;and&#160;&#160;*&#160;. The deref<br/>coercion feature also lets us write more code that can work for either references or smart<br/>pointers.<br/>
To see deref coercion in action, let’s use the&#160;&#160;MyBox&lt;T&gt;&#160;&#160;type we deﬁned in Listing 15-8 as<br/>well as the implementation of&#160;&#160;Deref&#160;&#160;that we added in Listing 15-10. Listing 15-11 shows the<br/>deﬁnition of a function that has a string slice parameter:<br/>
Filename: src/main.rs<br/>
fn&#160;hello(name:&#160;&amp;str)&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Hello,&#160;{name}!&#34;);<br/>}<br/>
<b>Listing&#160;15-11:&#160;A&#160;&#160;</b>hello&#160;<b>&#160;function&#160;that&#160;has&#160;the&#160;parameter&#160;&#160;</b>name&#160;<b>&#160;of&#160;type&#160;&#160;</b>&amp;str<br/>
We can call the&#160;&#160;hello&#160;&#160;function with a string slice as an argument, such as&#160;&#160;hello(&#34;Rust&#34;);<br/>for example. Deref coercion makes it possible to call&#160;&#160;hello&#160;&#160;with a reference to a value of<br/>type&#160;&#160;MyBox&lt;String&gt;&#160;, as shown in Listing 15-12:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;m&#160;=&#160;MyBox::new(String::from(&#34;Rust&#34;));<br/>&#160;&#160;&#160;&#160;hello(&amp;m);<br/>}<br/>
<b>Listing&#160;15-12:&#160;Calling&#160;&#160;</b>hello&#160;<b>&#160;with&#160;a&#160;reference&#160;to&#160;a&#160;&#160;</b>MyBox&lt;String&gt;&#160;<b>&#160;value,&#160;which&#160;works&#160;because&#160;of&#160;deref&#160;coercion</b><br/>
Here we’re calling the&#160;&#160;hello&#160;&#160;function with the argument&#160;&#160;&amp;m&#160;, which is a reference to a<br/>
MyBox&lt;String&gt;&#160;&#160;value. Because we implemented the&#160;&#160;Deref&#160;&#160;trait on&#160;&#160;MyBox&lt;T&gt;&#160;&#160;in Listing 15-<br/>
10, Rust can turn&#160;&#160;&amp;MyBox&lt;String&gt;&#160;&#160;into&#160;&#160;&amp;String&#160;&#160;by calling&#160;&#160;deref&#160;. The standard library<br/>provides an implementation of&#160;&#160;Deref&#160;&#160;on&#160;&#160;String&#160;&#160;that returns a string slice, and this is in<br/>the API documentation for&#160;&#160;Deref&#160;. Rust calls&#160;&#160;deref&#160;&#160;again to turn the&#160;&#160;&amp;String&#160;&#160;into&#160;&#160;&amp;str&#160;,<br/>which matches the&#160;&#160;hello&#160;&#160;function’s deﬁnition.<br/>
If Rust didn’t implement deref coercion, we would have to write the code in Listing 15-13<br/>instead of the code in Listing 15-12 to call&#160;&#160;hello&#160;&#160;with a value of type&#160;&#160;&amp;MyBox&lt;String&gt;&#160;.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
402/627<br/>
<hr/>
<a name=403></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;m&#160;=&#160;MyBox::new(String::from(&#34;Rust&#34;));<br/>&#160;&#160;&#160;&#160;hello(&amp;(*m)[..]);<br/>}<br/>
<b>Listing&#160;15-13:&#160;The&#160;code&#160;we&#160;would&#160;have&#160;to&#160;write&#160;if&#160;Rust&#160;didn’t&#160;have&#160;deref&#160;coercion</b><br/>
The&#160;&#160;(*m)&#160;&#160;dereferences the&#160;&#160;MyBox&lt;String&gt;&#160;&#160;into a&#160;&#160;String&#160;. Then the&#160;&#160;&amp;&#160;&#160;and&#160;&#160;[..]&#160;&#160;take a<br/>string slice of the&#160;&#160;String&#160;&#160;that is equal to the whole string to match the signature of&#160;&#160;hello&#160;.<br/>This code without deref coercions is harder to read, write, and understand with all of these<br/>symbols involved. Deref coercion allows Rust to handle these conversions for us<br/>automatically.<br/>
When the&#160;&#160;Deref&#160;&#160;trait is deﬁned for the types involved, Rust will analyze the types and use<br/>
Deref::deref&#160;&#160;as many times as necessary to get a reference to match the parameter’s<br/>
type. The number of times that&#160;&#160;Deref::deref&#160;&#160;needs to be inserted is resolved at compile<br/>time, so there is no runtime penalty for taking advantage of deref coercion!<br/>
<a href="tests.html#403"><b>How&#160;Deref&#160;Coercion&#160;Interacts&#160;with&#160;Mutability</b></a><br/>
Similar to how you use the&#160;&#160;Deref&#160;&#160;trait to override the&#160;&#160;*&#160;&#160;operator on immutable<br/>references, you can use the&#160;&#160;DerefMut&#160;&#160;trait to override the&#160;&#160;*&#160;&#160;operator on mutable<br/>references.<br/>
Rust does deref coercion when it&#160;ﬁnds types and trait implementations in three cases:<br/>
From&#160;&#160;&amp;T&#160;&#160;to&#160;&#160;&amp;U&#160;&#160;when&#160;&#160;T:&#160;Deref&lt;Target=U&gt;<br/>From&#160;&#160;&amp;mut&#160;T&#160;&#160;to&#160;&#160;&amp;mut&#160;U&#160;&#160;when&#160;&#160;T:&#160;DerefMut&lt;Target=U&gt;<br/>From&#160;&#160;&amp;mut&#160;T&#160;&#160;to&#160;&#160;&amp;U&#160;&#160;when&#160;&#160;T:&#160;Deref&lt;Target=U&gt;<br/>
The&#160;ﬁrst two cases are the same as each other except that the second implements<br/>mutability. The&#160;ﬁrst case states that if you have a&#160;&#160;&amp;T&#160;, and&#160;&#160;T&#160;&#160;implements&#160;&#160;Deref&#160;&#160;to some<br/>type&#160;&#160;U&#160;, you can get a&#160;&#160;&amp;U&#160;&#160;transparently. The second case states that the same deref<br/>coercion happens for mutable references.<br/>
The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But<br/>the reverse is&#160;<i>not</i>&#160;possible: immutable references will never coerce to mutable references.<br/>Because of the borrowing rules, if you have a mutable reference, that mutable reference<br/>must be the only reference to that data (otherwise, the program wouldn’t compile).<br/>Converting one mutable reference to one immutable reference will never break the<br/>borrowing rules. Converting an immutable reference to a mutable reference would require<br/>that the initial immutable reference is the only immutable reference to that data, but the<br/>borrowing rules don’t guarantee that. Therefore, Rust can’t make the assumption that<br/>converting an immutable reference to a mutable reference is possible.<br/>
https://doc.rust-lang.org/book/print.html<br/>
403/627<br/>
<hr/>
<a name=404></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#404"><b>Running Code on Cleanup with the&#160;</b>Drop<b>&#160;Trait</b></a><br/>
The second trait important to the smart pointer pattern is&#160;&#160;Drop&#160;, which lets you customize<br/>what happens when a value is about to go out of scope. You can provide an implementation<br/>for the&#160;&#160;Drop&#160;&#160;trait on any type, and that code can be used to release resources like&#160;ﬁles or<br/>network connections.<br/>
We’re introducing&#160;&#160;Drop&#160;&#160;in the context of smart pointers because the functionality of the<br/>
Drop&#160;&#160;trait is almost always used when implementing a smart pointer. For example, when a<br/>Box&lt;T&gt;&#160;&#160;is dropped it will deallocate the space on the heap that the box points to.<br/>
In some languages, for some types, the programmer must call code to free memory or<br/>resources every time they&#160;ﬁnish using an instance of those types. Examples include&#160;ﬁle<br/>handles, sockets, or locks. If they forget, the system might become overloaded and crash. In<br/>Rust, you can specify that a particular bit of code be run whenever a value goes out of<br/>scope, and the compiler will insert this code automatically. As a result, you don’t need to be<br/>careful about placing cleanup code everywhere in a program that an instance of a particular<br/>type is&#160;ﬁnished with—you still won’t leak resources!<br/>
You specify the code to run when a value goes out of scope by implementing the&#160;&#160;Drop&#160;&#160;trait.<br/>The&#160;&#160;Drop&#160;&#160;trait requires you to implement one method named&#160;&#160;drop&#160;&#160;that takes a mutable<br/>reference to&#160;&#160;self&#160;. To see when Rust calls&#160;&#160;drop&#160;, let’s implement&#160;&#160;drop&#160;&#160;with&#160;&#160;println!<br/>statements for now.<br/>
Listing 15-14 shows a&#160;&#160;CustomSmartPointer&#160;&#160;struct whose only custom functionality is that it<br/>will print&#160;&#160;Dropping&#160;CustomSmartPointer!&#160;&#160;when the instance goes out of scope, to show<br/>when Rust runs the&#160;&#160;drop&#160;&#160;function.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
404/627<br/>
<hr/>
<a name=405></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
struct&#160;CustomSmartPointer&#160;{<br/>&#160;&#160;&#160;&#160;data:&#160;String,<br/>}<br/>
impl&#160;Drop&#160;for&#160;CustomSmartPointer&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;drop(&amp;mut&#160;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Dropping&#160;CustomSmartPointer&#160;with&#160;data&#160;`{}`!&#34;,&#160;self.data);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;c&#160;=&#160;CustomSmartPointer&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;data:&#160;String::from(&#34;my&#160;stuff&#34;),<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;let&#160;d&#160;=&#160;CustomSmartPointer&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;data:&#160;String::from(&#34;other&#160;stuff&#34;),<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;println!(&#34;CustomSmartPointers&#160;created.&#34;);<br/>}<br/>
<b>Listing&#160;15-14:&#160;A&#160;&#160;</b>CustomSmartPointer&#160;<b>&#160;struct&#160;that&#160;implements&#160;the&#160;&#160;</b>Drop&#160;<b>&#160;trait&#160;where&#160;we&#160;would&#160;put&#160;our&#160;cleanup<br/>code</b><br/>
The&#160;&#160;Drop&#160;&#160;trait is included in the prelude, so we don’t need to bring it into scope. We<br/>implement the&#160;&#160;Drop&#160;&#160;trait on&#160;&#160;CustomSmartPointer&#160;&#160;and provide an implementation for the<br/>
drop&#160;&#160;method that calls&#160;&#160;println!&#160;. The body of the&#160;&#160;drop&#160;&#160;function is where you would place<br/>
any logic that you wanted to run when an instance of your type goes out of scope. We’re<br/>printing some text here to demonstrate visually when Rust will call&#160;&#160;drop&#160;.<br/>
In&#160;&#160;main&#160;, we create two instances of&#160;&#160;CustomSmartPointer&#160;&#160;and then print<br/>
CustomSmartPointers&#160;created&#160;. At the end of&#160;&#160;main&#160;, our instances of&#160;&#160;CustomSmartPointer<br/>
will go out of scope, and Rust will call the code we put in the&#160;&#160;drop&#160;&#160;method, printing our<br/>ﬁnal message. Note that we didn’t need to call the&#160;&#160;drop&#160;&#160;method explicitly.<br/>
When we run this program, we’ll see the following output:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;drop-example&#160;v0.1.0&#160;(file:///projects/drop-example)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.60s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/drop-example`<br/>CustomSmartPointers&#160;created.<br/>Dropping&#160;CustomSmartPointer&#160;with&#160;data&#160;`other&#160;stuff`!<br/>Dropping&#160;CustomSmartPointer&#160;with&#160;data&#160;`my&#160;stuff`!<br/>
Rust automatically called&#160;&#160;drop&#160;&#160;for us when our instances went out of scope, calling the<br/>code we speciﬁed. Variables are dropped in the reverse order of their creation, so&#160;&#160;d&#160;&#160;was<br/>dropped before&#160;&#160;c&#160;. This example’s purpose is to give you a visual guide to how the&#160;&#160;drop<br/>method works; usually you would specify the cleanup code that your type needs to run<br/>rather than a print message.<br/>
https://doc.rust-lang.org/book/print.html<br/>
405/627<br/>
<hr/>
<a name=406></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#406"><b>Dropping&#160;a&#160;Value&#160;Early&#160;with&#160;</b>std::mem::drop</a><br/>
Unfortunately, it’s not straightforward to disable the automatic&#160;&#160;drop&#160;&#160;functionality. Disabling<br/>
drop&#160;&#160;isn’t usually necessary; the whole point of the&#160;&#160;Drop&#160;&#160;trait is that it’s taken care of<br/>
automatically. Occasionally, however, you might want to clean up a value early. One<br/>example is when using smart pointers that manage locks: you might want to force the&#160;&#160;drop<br/>method that releases the lock so that other code in the same scope can acquire the lock.<br/>Rust doesn’t let you call the&#160;&#160;Drop&#160;&#160;trait’s&#160;&#160;drop&#160;&#160;method manually; instead you have to call<br/>the&#160;&#160;std::mem::drop&#160;&#160;function provided by the standard library if you want to force a value<br/>to be dropped before the end of its scope.<br/>
If we try to call the&#160;&#160;Drop&#160;&#160;trait’s&#160;&#160;drop&#160;&#160;method manually by modifying the&#160;&#160;main&#160;&#160;function<br/>from Listing 15-14, as shown in Listing 15-15, we’ll get a compiler error:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;c&#160;=&#160;CustomSmartPointer&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;data:&#160;String::from(&#34;some&#160;data&#34;),<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;println!(&#34;CustomSmartPointer&#160;created.&#34;);<br/>&#160;&#160;&#160;&#160;c.drop();<br/>&#160;&#160;&#160;&#160;println!(&#34;CustomSmartPointer&#160;dropped&#160;before&#160;the&#160;end&#160;of&#160;main.&#34;);<br/>}<br/>
<b>Listing&#160;15-15:&#160;Attempting&#160;to&#160;call&#160;the&#160;&#160;</b>drop&#160;<b>&#160;method&#160;from&#160;the&#160;&#160;</b>Drop&#160;<b>&#160;trait&#160;manually&#160;to&#160;clean&#160;up&#160;early</b><br/>
When we try to compile this code, we’ll get this error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;drop-example&#160;v0.1.0&#160;(file:///projects/drop-example)<br/>error[E0040]:&#160;explicit&#160;use&#160;of&#160;destructor&#160;method<br/>&#160;&#160;--&gt;&#160;src/main.rs:16:7<br/>&#160;&#160;&#160;|<br/>16&#160;|&#160;&#160;&#160;&#160;&#160;c.drop();<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;--^^^^--<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;|&#160;|<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;|&#160;explicit&#160;destructor&#160;calls&#160;not&#160;allowed<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;help:&#160;consider&#160;using&#160;`drop`&#160;function:&#160;`drop(c)`<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0040`.<br/>error:&#160;could&#160;not&#160;compile&#160;`drop-example`&#160;due&#160;to&#160;previous&#160;error<br/>
This error message states that we’re not allowed to explicitly call&#160;&#160;drop&#160;. The error message<br/>uses the term&#160;<i>destructor</i>, which is the general programming term for a function that cleans<br/>up an instance. A&#160;<i>destructor</i>&#160;is analogous to a&#160;<i>constructor</i>, which creates an instance. The<br/>
drop&#160;&#160;function in Rust is one particular destructor.<br/>
Rust doesn’t let us call&#160;&#160;drop&#160;&#160;explicitly because Rust would still automatically call&#160;&#160;drop&#160;&#160;on<br/>the value at the end of&#160;&#160;main&#160;. This would cause a&#160;<i>double free</i>&#160;error because Rust would be<br/>
https://doc.rust-lang.org/book/print.html<br/>
406/627<br/>
<hr/>
<a name=407></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
trying to clean up the same value twice.<br/>
We can’t disable the automatic insertion of&#160;&#160;drop&#160;&#160;when a value goes out of scope, and we<br/>can’t call the&#160;&#160;drop&#160;&#160;method explicitly. So, if we need to force a value to be cleaned up early,<br/>we use the&#160;&#160;std::mem::drop&#160;&#160;function.<br/>
The&#160;&#160;std::mem::drop&#160;&#160;function is diﬀerent from the&#160;&#160;drop&#160;&#160;method in the&#160;&#160;Drop&#160;&#160;trait. We call<br/>it by passing as an argument the value we want to force drop. The function is in the prelude,<br/>so we can modify&#160;&#160;main&#160;&#160;in Listing 15-15 to call the&#160;&#160;drop&#160;&#160;function, as shown in Listing 15-16:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;c&#160;=&#160;CustomSmartPointer&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;data:&#160;String::from(&#34;some&#160;data&#34;),<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;println!(&#34;CustomSmartPointer&#160;created.&#34;);<br/>&#160;&#160;&#160;&#160;drop(c);<br/>&#160;&#160;&#160;&#160;println!(&#34;CustomSmartPointer&#160;dropped&#160;before&#160;the&#160;end&#160;of&#160;main.&#34;);<br/>}<br/>
<b>Listing&#160;15-16:&#160;Calling&#160;&#160;</b>std::mem::drop&#160;<b>&#160;to&#160;explicitly&#160;drop&#160;a&#160;value&#160;before&#160;it&#160;goes&#160;out&#160;of&#160;scope</b><br/>
Running this code will print the following:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;drop-example&#160;v0.1.0&#160;(file:///projects/drop-example)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.73s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/drop-example`<br/>CustomSmartPointer&#160;created.<br/>Dropping&#160;CustomSmartPointer&#160;with&#160;data&#160;`some&#160;data`!<br/>CustomSmartPointer&#160;dropped&#160;before&#160;the&#160;end&#160;of&#160;main.<br/>
The text&#160;&#160;Dropping&#160;CustomSmartPointer&#160;with&#160;data&#160;`some&#160;data`!&#160;&#160;is printed between the<br/>
CustomSmartPointer&#160;created.&#160;&#160;and&#160;&#160;CustomSmartPointer&#160;dropped&#160;before&#160;the&#160;end&#160;of&#160;<br/>
main.&#160;&#160;text, showing that the&#160;&#160;drop&#160;&#160;method code is called to drop&#160;&#160;c&#160;&#160;at that point.<br/>
You can use code speciﬁed in a&#160;&#160;Drop&#160;&#160;trait implementation in many ways to make cleanup<br/>convenient and safe: for instance, you could use it to create your own memory allocator!<br/>With the&#160;&#160;Drop&#160;&#160;trait and Rust’s ownership system, you don’t have to remember to clean up<br/>because Rust does it automatically.<br/>
You also don’t have to worry about problems resulting from accidentally cleaning up values<br/>still in use: the ownership system that makes sure references are always valid also ensures<br/>that&#160;&#160;drop&#160;&#160;gets called only once when the value is no longer being used.<br/>
Now that we’ve examined&#160;&#160;Box&lt;T&gt;&#160;&#160;and some of the characteristics of smart pointers, let’s<br/>look at a few other smart pointers deﬁned in the standard library.<br/>
https://doc.rust-lang.org/book/print.html<br/>
407/627<br/>
<hr/>
<a name=408></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#408">Rc&lt;T&gt;<b>, the Reference Counted Smart Pointer</b></a><br/>
In the majority of cases, ownership is clear: you know exactly which variable owns a given<br/>value. However, there are cases when a single value might have multiple owners. For<br/>example, in graph data structures, multiple edges might point to the same node, and that<br/>node is conceptually owned by all of the edges that point to it. A node shouldn’t be cleaned<br/>up unless it doesn’t have any edges pointing to it and so has no owners.<br/>
You have to enable multiple ownership explicitly by using the Rust type&#160;&#160;Rc&lt;T&gt;&#160;, which is an<br/>abbreviation for&#160;<i>reference counting</i>. The&#160;&#160;Rc&lt;T&gt;&#160;&#160;type keeps track of the number of references<br/>to a value to determine whether or not the value is still in use. If there are zero references to<br/>a value, the value can be cleaned up without any references becoming invalid.<br/>
Imagine&#160;&#160;Rc&lt;T&gt;&#160;&#160;as a TV in a family room. When one person enters to watch TV, they turn it<br/>on. Others can come into the room and watch the TV. When the last person leaves the<br/>room, they turn oﬀ&#160;the TV because it’s no longer being used. If someone turns oﬀ&#160;the TV<br/>while others are still watching it, there would be uproar from the remaining TV watchers!<br/>
We use the&#160;&#160;Rc&lt;T&gt;&#160;&#160;type when we want to allocate some data on the heap for multiple parts<br/>of our program to read and we can’t determine at compile time which part will&#160;ﬁnish using<br/>the data last. If we knew which part would&#160;ﬁnish last, we could just make that part the data’s<br/>owner, and the normal ownership rules enforced at compile time would take eﬀect.<br/>
Note that&#160;&#160;Rc&lt;T&gt;&#160;&#160;is only for use in single-threaded scenarios. When we discuss concurrency<br/>in Chapter 16, we’ll cover how to do reference counting in multithreaded programs.<br/>
<a href="tests.html#408"><b>Using&#160;</b>Rc&lt;T&gt;<b>&#160;to&#160;Share&#160;Data</b></a><br/>
Let’s return to our cons list example in Listing 15-5. Recall that we deﬁned it using&#160;&#160;Box&lt;T&gt;&#160;.<br/>This time, we’ll create two lists that both share ownership of a third list. Conceptually, this<br/>looks similar to Figure 15-3:<br/>
b<br/>
3&#160; <br/>
a<br/>
5&#160; <br/>
10&#160; <br/>
Nil<br/>
c<br/>
4&#160; <br/>
<b>Figure&#160;15-3:&#160;Two&#160;lists,&#160;&#160;</b>b&#160;<b>&#160;and&#160;&#160;</b>c&#160;<b>,&#160;sharing&#160;ownership&#160;of&#160;a&#160;third&#160;list,&#160;&#160;</b>a<br/>
https://doc.rust-lang.org/book/print.html<br/>
408/627<br/>
<hr/>
<a name=409></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We’ll create list&#160;&#160;a&#160;&#160;that contains 5 and then 10. Then we’ll make two more lists:&#160;&#160;b&#160;&#160;that starts<br/>with 3 and&#160;&#160;c&#160;&#160;that starts with 4. Both&#160;&#160;b&#160;&#160;and&#160;&#160;c&#160;&#160;lists will then continue on to the&#160;ﬁrst&#160;&#160;a&#160;&#160;list<br/>containing 5 and 10. In other words, both lists will share the&#160;ﬁrst list containing 5 and 10.<br/>
Trying to implement this scenario using our deﬁnition of&#160;&#160;List&#160;&#160;with&#160;&#160;Box&lt;T&gt;&#160;&#160;won’t work, as<br/>shown in Listing 15-17:<br/>
Filename: src/main.rs<br/>
enum&#160;List&#160;{<br/>&#160;&#160;&#160;&#160;Cons(i32,&#160;Box&lt;List&gt;),<br/>&#160;&#160;&#160;&#160;Nil,<br/>}<br/>
use&#160;crate::List::{Cons,&#160;Nil};<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;a&#160;=&#160;Cons(5,&#160;Box::new(Cons(10,&#160;Box::new(Nil))));<br/>&#160;&#160;&#160;&#160;let&#160;b&#160;=&#160;Cons(3,&#160;Box::new(a));<br/>&#160;&#160;&#160;&#160;let&#160;c&#160;=&#160;Cons(4,&#160;Box::new(a));<br/>}<br/>
<b>Listing&#160;15-17:&#160;Demonstrating&#160;we’re&#160;not&#160;allowed&#160;to&#160;have&#160;two&#160;lists&#160;using&#160;&#160;</b>Box&lt;T&gt;&#160;<b>&#160;that&#160;try&#160;to&#160;share&#160;ownership&#160;of&#160;a<br/>third&#160;list</b><br/>
When we compile this code, we get this error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;cons-list&#160;v0.1.0&#160;(file:///projects/cons-list)<br/>error[E0382]:&#160;use&#160;of&#160;moved&#160;value:&#160;`a`<br/>&#160;&#160;--&gt;&#160;src/main.rs:11:30<br/>&#160;&#160;&#160;|<br/>9&#160;&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;a&#160;=&#160;Cons(5,&#160;Box::new(Cons(10,&#160;Box::new(Nil))));<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&#160;move&#160;occurs&#160;because&#160;`a`&#160;has&#160;type&#160;`List`,&#160;which&#160;does&#160;not&#160;<br/>implement&#160;the&#160;`Copy`&#160;trait<br/>10&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;b&#160;=&#160;Cons(3,&#160;Box::new(a));<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&#160;value&#160;moved&#160;here<br/>11&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;c&#160;=&#160;Cons(4,&#160;Box::new(a));<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^&#160;value&#160;used&#160;here&#160;after&#160;move<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0382`.<br/>error:&#160;could&#160;not&#160;compile&#160;`cons-list`&#160;due&#160;to&#160;previous&#160;error<br/>
The&#160;&#160;Cons&#160;&#160;variants own the data they hold, so when we create the&#160;&#160;b&#160;&#160;list,&#160;&#160;a&#160;&#160;is moved into&#160;&#160;b<br/>and&#160;&#160;b&#160;&#160;owns&#160;&#160;a&#160;. Then, when we try to use&#160;&#160;a&#160;&#160;again when creating&#160;&#160;c&#160;, we’re not allowed to<br/>because&#160;&#160;a&#160;&#160;has been moved.<br/>
We could change the deﬁnition of&#160;&#160;Cons&#160;&#160;to hold references instead, but then we would have<br/>to specify lifetime parameters. By specifying lifetime parameters, we would be specifying<br/>that every element in the list will live at least as long as the entire list. This is the case for the<br/>elements and lists in Listing 15-17, but not in every scenario.<br/>
https://doc.rust-lang.org/book/print.html<br/>
409/627<br/>
<hr/>
<a name=410></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Instead, we’ll change our deﬁnition of&#160;&#160;List&#160;&#160;to use&#160;&#160;Rc&lt;T&gt;&#160;&#160;in place of&#160;&#160;Box&lt;T&gt;&#160;, as shown in<br/>Listing 15-18. Each&#160;&#160;Cons&#160;&#160;variant will now hold a value and an&#160;&#160;Rc&lt;T&gt;&#160;&#160;pointing to a&#160;&#160;List&#160;.<br/>When we create&#160;&#160;b&#160;, instead of taking ownership of&#160;&#160;a&#160;, we’ll clone the&#160;&#160;Rc&lt;List&gt;&#160;&#160;that&#160;&#160;a&#160;&#160;is<br/>holding, thereby increasing the number of references from one to two and letting&#160;&#160;a&#160;&#160;and&#160;&#160;b<br/>share ownership of the data in that&#160;&#160;Rc&lt;List&gt;&#160;. We’ll also clone&#160;&#160;a&#160;&#160;when creating&#160;&#160;c&#160;,<br/>increasing the number of references from two to three. Every time we call&#160;&#160;Rc::clone&#160;, the<br/>reference count to the data within the&#160;&#160;Rc&lt;List&gt;&#160;&#160;will increase, and the data won’t be<br/>cleaned up unless there are zero references to it.<br/>
Filename: src/main.rs<br/>
enum&#160;List&#160;{<br/>&#160;&#160;&#160;&#160;Cons(i32,&#160;Rc&lt;List&gt;),<br/>&#160;&#160;&#160;&#160;Nil,<br/>}<br/>
use&#160;crate::List::{Cons,&#160;Nil};<br/>use&#160;std::rc::Rc;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;a&#160;=&#160;Rc::new(Cons(5,&#160;Rc::new(Cons(10,&#160;Rc::new(Nil)))));<br/>&#160;&#160;&#160;&#160;let&#160;b&#160;=&#160;Cons(3,&#160;Rc::clone(&amp;a));<br/>&#160;&#160;&#160;&#160;let&#160;c&#160;=&#160;Cons(4,&#160;Rc::clone(&amp;a));<br/>}<br/>
<b>Listing&#160;15-18:&#160;A&#160;deﬁnition&#160;of&#160;&#160;</b>List&#160;<b>&#160;that&#160;uses&#160;&#160;</b>Rc&lt;T&gt;<br/>
We need to add a&#160;&#160;use&#160;&#160;statement to bring&#160;&#160;Rc&lt;T&gt;&#160;&#160;into scope because it’s not in the prelude.<br/>In&#160;&#160;main&#160;, we create the list holding 5 and 10 and store it in a new&#160;&#160;Rc&lt;List&gt;&#160;&#160;in&#160;&#160;a&#160;. Then<br/>when we create&#160;&#160;b&#160;&#160;and&#160;&#160;c&#160;, we call the&#160;&#160;Rc::clone&#160;&#160;function and pass a reference to the<br/>
Rc&lt;List&gt;&#160;&#160;in&#160;&#160;a&#160;&#160;as an argument.<br/>
We could have called&#160;&#160;a.clone()&#160;&#160;rather than&#160;&#160;Rc::clone(&amp;a)&#160;, but Rust’s convention is to<br/>use&#160;&#160;Rc::clone&#160;&#160;in this case. The implementation of&#160;&#160;Rc::clone&#160;&#160;doesn’t make a deep copy of<br/>all the data like most types’ implementations of&#160;&#160;clone&#160;&#160;do. The call to&#160;&#160;Rc::clone&#160;&#160;only<br/>increments the reference count, which doesn’t take much time. Deep copies of data can<br/>take a lot of time. By using&#160;&#160;Rc::clone&#160;&#160;for reference counting, we can visually distinguish<br/>between the deep-copy kinds of clones and the kinds of clones that increase the reference<br/>count. When looking for performance problems in the code, we only need to consider the<br/>deep-copy clones and can disregard calls to&#160;&#160;Rc::clone&#160;.<br/>
<a href="tests.html#410"><b>Cloning&#160;an&#160;</b>Rc&lt;T&gt;<b>&#160;Increases&#160;the&#160;Reference&#160;Count</b></a><br/>
Let’s change our working example in Listing 15-18 so we can see the reference counts<br/>changing as we create and drop references to the&#160;&#160;Rc&lt;List&gt;&#160;&#160;in&#160;&#160;a&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
410/627<br/>
<hr/>
<a name=411></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
In Listing 15-19, we’ll change&#160;&#160;main&#160;&#160;so it has an inner scope around list&#160;&#160;c&#160;; then we can see<br/>how the reference count changes when&#160;&#160;c&#160;&#160;goes out of scope.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;a&#160;=&#160;Rc::new(Cons(5,&#160;Rc::new(Cons(10,&#160;Rc::new(Nil)))));<br/>&#160;&#160;&#160;&#160;println!(&#34;count&#160;after&#160;creating&#160;a&#160;=&#160;{}&#34;,&#160;Rc::strong_count(&amp;a));<br/>&#160;&#160;&#160;&#160;let&#160;b&#160;=&#160;Cons(3,&#160;Rc::clone(&amp;a));<br/>&#160;&#160;&#160;&#160;println!(&#34;count&#160;after&#160;creating&#160;b&#160;=&#160;{}&#34;,&#160;Rc::strong_count(&amp;a));<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;c&#160;=&#160;Cons(4,&#160;Rc::clone(&amp;a));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;count&#160;after&#160;creating&#160;c&#160;=&#160;{}&#34;,&#160;Rc::strong_count(&amp;a));<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;println!(&#34;count&#160;after&#160;c&#160;goes&#160;out&#160;of&#160;scope&#160;=&#160;{}&#34;,&#160;Rc::strong_count(&amp;a));<br/>}<br/>
<b>Listing&#160;15-19:&#160;Printing&#160;the&#160;reference&#160;count</b><br/>
At each point in the program where the reference count changes, we print the reference<br/>count, which we get by calling the&#160;&#160;Rc::strong_count&#160;&#160;function. This function is named<br/>
strong_count&#160;&#160;rather than&#160;&#160;count&#160;&#160;because the&#160;&#160;Rc&lt;T&gt;&#160;&#160;type also has a&#160;&#160;weak_count&#160;; we’ll see<br/>
<a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">what&#160;&#160;weak_count&#160;&#160;is used for in the&#160;“Preventing Reference Cycles: Turning an&#160;&#160;Rc&lt;T&gt;&#160;&#160;into a</a><br/>
<a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">Weak&lt;T&gt;&#160;”&#160;section.</a><br/>
This code prints the following:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;cons-list&#160;v0.1.0&#160;(file:///projects/cons-list)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.45s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/cons-list`<br/>count&#160;after&#160;creating&#160;a&#160;=&#160;1<br/>count&#160;after&#160;creating&#160;b&#160;=&#160;2<br/>count&#160;after&#160;creating&#160;c&#160;=&#160;3<br/>count&#160;after&#160;c&#160;goes&#160;out&#160;of&#160;scope&#160;=&#160;2<br/>
We can see that the&#160;&#160;Rc&lt;List&gt;&#160;&#160;in&#160;&#160;a&#160;&#160;has an initial reference count of 1; then each time we<br/>call&#160;&#160;clone&#160;, the count goes up by 1. When&#160;&#160;c&#160;&#160;goes out of scope, the count goes down by 1.<br/>We don’t have to call a function to decrease the reference count like we have to call<br/>
Rc::clone&#160;&#160;to increase the reference count: the implementation of the&#160;&#160;Drop&#160;&#160;trait decreases<br/>
the reference count automatically when an&#160;&#160;Rc&lt;T&gt;&#160;&#160;value goes out of scope.<br/>
What we can’t see in this example is that when&#160;&#160;b&#160;&#160;and then&#160;&#160;a&#160;&#160;go out of scope at the end of<br/>
main&#160;, the count is then 0, and the&#160;&#160;Rc&lt;List&gt;&#160;&#160;is cleaned up completely. Using&#160;&#160;Rc&lt;T&gt;&#160;&#160;allows<br/>
a single value to have multiple owners, and the count ensures that the value remains valid<br/>as long as any of the owners still exist.<br/>
Via immutable references,&#160;&#160;Rc&lt;T&gt;&#160;&#160;allows you to share data between multiple parts of your<br/>program for reading only. If&#160;&#160;Rc&lt;T&gt;&#160;&#160;allowed you to have multiple mutable references too,<br/>
https://doc.rust-lang.org/book/print.html<br/>
411/627<br/>
<hr/>
<a name=412></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable<br/>borrows to the same place can cause data races and inconsistencies. But being able to<br/>mutate data is very useful! In the next section, we’ll discuss the interior mutability pattern<br/>and the&#160;&#160;RefCell&lt;T&gt;&#160;&#160;type that you can use in conjunction with an&#160;&#160;Rc&lt;T&gt;&#160;&#160;to work with this<br/>immutability restriction.<br/>
https://doc.rust-lang.org/book/print.html<br/>
412/627<br/>
<hr/>
<a name=413></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#413">RefCell&lt;T&gt;<b>&#160;and the Interior Mutability Pattern</b></a><br/>
<i>Interior mutability</i>&#160;is a design pattern in Rust that allows you to mutate data even when there<br/>are immutable references to that data; normally, this action is disallowed by the borrowing<br/>rules. To mutate data, the pattern uses&#160;&#160;unsafe&#160;&#160;code inside a data structure to bend Rust’s<br/>usual rules that govern mutation and borrowing. Unsafe code indicates to the compiler that<br/>we’re checking the rules manually instead of relying on the compiler to check them for us;<br/>we will discuss unsafe code more in Chapter 19.<br/>
We can use types that use the interior mutability pattern only when we can ensure that the<br/>borrowing rules will be followed at runtime, even though the compiler can’t guarantee that.<br/>The&#160;&#160;unsafe&#160;&#160;code involved is then wrapped in a safe API, and the outer type is still<br/>immutable.<br/>
Let’s explore this concept by looking at the&#160;&#160;RefCell&lt;T&gt;&#160;&#160;type that follows the interior<br/>mutability pattern.<br/>
<a href="tests.html#413"><b>Enforcing&#160;Borrowing&#160;Rules&#160;at&#160;Runtime&#160;with&#160;</b>RefCell&lt;T&gt;</a><br/>
Unlike&#160;&#160;Rc&lt;T&gt;&#160;, the&#160;&#160;RefCell&lt;T&gt;&#160;&#160;type represents single ownership over the data it holds. So,<br/>what makes&#160;&#160;RefCell&lt;T&gt;&#160;&#160;diﬀerent from a type like&#160;&#160;Box&lt;T&gt;&#160;? Recall the borrowing rules you<br/>learned in Chapter 4:<br/>
At any given time, you can have&#160;<i>either</i>&#160;(but not both) one mutable reference or any<br/>number of immutable references.<br/>References must always be valid.<br/>
With references and&#160;&#160;Box&lt;T&gt;&#160;, the borrowing rules’ invariants are enforced at compile time.<br/>With&#160;&#160;RefCell&lt;T&gt;&#160;, these invariants are enforced&#160;<i>at runtime</i>. With references, if you break<br/>these rules, you’ll get a compiler error. With&#160;&#160;RefCell&lt;T&gt;&#160;, if you break these rules, your<br/>program will panic and exit.<br/>
The advantages of checking the borrowing rules at compile time are that errors will be<br/>caught sooner in the development process, and there is no impact on runtime performance<br/>because all the analysis is completed beforehand. For those reasons, checking the<br/>borrowing rules at compile time is the best choice in the majority of cases, which is why this<br/>is Rust’s default.<br/>
The advantage of checking the borrowing rules at runtime instead is that certain memory-<br/>safe scenarios are then allowed, where they would’ve been disallowed by the compile-time<br/>checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of<br/>code are impossible to detect by analyzing the code: the most famous example is the<br/>
https://doc.rust-lang.org/book/print.html<br/>
413/627<br/>
<hr/>
<a name=414></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Halting Problem, which is beyond the scope of this book but is an interesting topic to<br/>research.<br/>
Because some analysis is impossible, if the Rust compiler can’t be sure the code complies<br/>with the ownership rules, it might reject a correct program; in this way, it’s conservative. If<br/>Rust accepted an incorrect program, users wouldn’t be able to trust in the guarantees Rust<br/>makes. However, if Rust rejects a correct program, the programmer will be inconvenienced,<br/>but nothing catastrophic can occur. The&#160;&#160;RefCell&lt;T&gt;&#160;&#160;type is useful when you’re sure your<br/>code follows the borrowing rules but the compiler is unable to understand and guarantee<br/>that.<br/>
Similar to&#160;&#160;Rc&lt;T&gt;&#160;,&#160;&#160;RefCell&lt;T&gt;&#160;&#160;is only for use in single-threaded scenarios and will give you<br/>a compile-time error if you try using it in a multithreaded context. We’ll talk about how to<br/>get the functionality of&#160;&#160;RefCell&lt;T&gt;&#160;&#160;in a multithreaded program in Chapter 16.<br/>
Here is a recap of the reasons to choose&#160;&#160;Box&lt;T&gt;&#160;,&#160;&#160;Rc&lt;T&gt;&#160;, or&#160;&#160;RefCell&lt;T&gt;&#160;:<br/>
Rc&lt;T&gt;&#160;&#160;enables multiple owners of the same data;&#160;&#160;Box&lt;T&gt;&#160;&#160;and&#160;&#160;RefCell&lt;T&gt;&#160;&#160;have<br/>
single owners.<br/>
Box&lt;T&gt;&#160;&#160;allows immutable or mutable borrows checked at compile time;&#160;&#160;Rc&lt;T&gt;&#160;&#160;allows<br/>
only immutable borrows checked at compile time;&#160;&#160;RefCell&lt;T&gt;&#160;&#160;allows immutable or<br/>mutable borrows checked at runtime.<br/>Because&#160;&#160;RefCell&lt;T&gt;&#160;&#160;allows mutable borrows checked at runtime, you can mutate the<br/>value inside the&#160;&#160;RefCell&lt;T&gt;&#160;&#160;even when the&#160;&#160;RefCell&lt;T&gt;&#160;&#160;is immutable.<br/>
Mutating the value inside an immutable value is the&#160;<i>interior mutability</i>&#160;pattern. Let’s look at a<br/>situation in which interior mutability is useful and examine how it’s possible.<br/>
<a href="tests.html#414"><b>Interior&#160;Mutability:&#160;A&#160;Mutable&#160;Borrow&#160;to&#160;an&#160;Immutable&#160;Value</b></a><br/>
A consequence of the borrowing rules is that when you have an immutable value, you can’t<br/>borrow it mutably. For example, this code won’t compile:<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;<br/>&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;&amp;mut&#160;x;<br/>}<br/>
If you tried to compile this code, you’d get the following error:<br/>
https://doc.rust-lang.org/book/print.html<br/>
414/627<br/>
<hr/>
<a name=415></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;borrowing&#160;v0.1.0&#160;(file:///projects/borrowing)<br/>error[E0596]:&#160;cannot&#160;borrow&#160;`x`&#160;as&#160;mutable,&#160;as&#160;it&#160;is&#160;not&#160;declared&#160;as&#160;mutable<br/>&#160;--&gt;&#160;src/main.rs:3:13<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&#160;help:&#160;consider&#160;changing&#160;this&#160;to&#160;be&#160;mutable:&#160;`mut&#160;x`<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;&amp;mut&#160;x;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^&#160;cannot&#160;borrow&#160;as&#160;mutable<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0596`.<br/>error:&#160;could&#160;not&#160;compile&#160;`borrowing`&#160;due&#160;to&#160;previous&#160;error<br/>
However, there are situations in which it would be useful for a value to mutate itself in its<br/>methods but appear immutable to other code. Code outside the value’s methods would not<br/>be able to mutate the value. Using&#160;&#160;RefCell&lt;T&gt;&#160;&#160;is one way to get the ability to have interior<br/>mutability, but&#160;&#160;RefCell&lt;T&gt;&#160;&#160;doesn’t get around the borrowing rules completely: the borrow<br/>checker in the compiler allows this interior mutability, and the borrowing rules are checked<br/>at runtime instead. If you violate the rules, you’ll get a&#160;&#160;panic!&#160;&#160;instead of a compiler error.<br/>
Let’s work through a practical example where we can use&#160;&#160;RefCell&lt;T&gt;&#160;&#160;to mutate an<br/>immutable value and see why that is useful.<br/>
<a href="tests.html#415"><b>A Use Case for Interior Mutability: Mock Objects</b></a><br/>
Sometimes during testing a programmer will use a type in place of another type, in order to<br/>observe particular behavior and assert it’s implemented correctly. This placeholder type is<br/>called a&#160;<i>test double</i>. Think of it in the sense of a “stunt double” in&#160;ﬁlmmaking, where a<br/>person steps in and substitutes for an actor to do a particular tricky scene. Test doubles<br/>stand in for other types when we’re running tests.&#160;<i>Mock objects</i>&#160;are speciﬁc types of test<br/>doubles that record what happens during a test so you can assert that the correct actions<br/>took place.<br/>
Rust doesn’t have objects in the same sense as other languages have objects, and Rust<br/>doesn’t have mock object functionality built into the standard library as some other<br/>languages do. However, you can deﬁnitely create a struct that will serve the same purposes<br/>as a mock object.<br/>
Here’s the scenario we’ll test: we’ll create a library that tracks a value against a maximum<br/>value and sends messages based on how close to the maximum value the current value is.<br/>This library could be used to keep track of a user’s quota for the number of API calls they’re<br/>allowed to make, for example.<br/>
Our library will only provide the functionality of tracking how close to the maximum a value<br/>is and what the messages should be at what times. Applications that use our library will be<br/>expected to provide the mechanism for sending the messages: the application could put a<br/>message in the application, send an email, send a text message, or something else. The<br/>
https://doc.rust-lang.org/book/print.html<br/>
415/627<br/>
<hr/>
<a name=416></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
library doesn’t need to know that detail. All it needs is something that implements a trait<br/>we’ll provide called&#160;&#160;Messenger&#160;. Listing 15-20 shows the library code:<br/>
Filename: src/lib.rs<br/>
pub&#160;trait&#160;Messenger&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;send(&amp;self,&#160;msg:&#160;&amp;str);<br/>}<br/>
pub&#160;struct&#160;LimitTracker&lt;'a,&#160;T:&#160;Messenger&gt;&#160;{<br/>&#160;&#160;&#160;&#160;messenger:&#160;&amp;'a&#160;T,<br/>&#160;&#160;&#160;&#160;value:&#160;usize,<br/>&#160;&#160;&#160;&#160;max:&#160;usize,<br/>}<br/>
impl&lt;'a,&#160;T&gt;&#160;LimitTracker&lt;'a,&#160;T&gt;<br/>where<br/>&#160;&#160;&#160;&#160;T:&#160;Messenger,<br/>{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(messenger:&#160;&amp;'a&#160;T,&#160;max:&#160;usize)&#160;-&gt;&#160;LimitTracker&lt;'a,&#160;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;LimitTracker&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;messenger,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value:&#160;0,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;max,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;pub&#160;fn&#160;set_value(&amp;mut&#160;self,&#160;value:&#160;usize)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.value&#160;=&#160;value;<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;percentage_of_max&#160;=&#160;self.value&#160;as&#160;f64&#160;/&#160;self.max&#160;as&#160;f64;<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;percentage_of_max&#160;&gt;=&#160;1.0&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.messenger.send(&#34;Error:&#160;You&#160;are&#160;over&#160;your&#160;quota!&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;else&#160;if&#160;percentage_of_max&#160;&gt;=&#160;0.9&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.messenger<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.send(&#34;Urgent&#160;warning:&#160;You've&#160;used&#160;up&#160;over&#160;90%&#160;of&#160;your&#160;<br/>quota!&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;else&#160;if&#160;percentage_of_max&#160;&gt;=&#160;0.75&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.messenger<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.send(&#34;Warning:&#160;You've&#160;used&#160;up&#160;over&#160;75%&#160;of&#160;your&#160;quota!&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;15-20:&#160;A&#160;library&#160;to&#160;keep&#160;track&#160;of&#160;how&#160;close&#160;a&#160;value&#160;is&#160;to&#160;a&#160;maximum&#160;value&#160;and&#160;warn&#160;when&#160;the&#160;value&#160;is&#160;at<br/>certain&#160;levels</b><br/>
One important part of this code is that the&#160;&#160;Messenger&#160;&#160;trait has one method called&#160;&#160;send<br/>that takes an immutable reference to&#160;&#160;self&#160;&#160;and the text of the message. This trait is the<br/>interface our mock object needs to implement so that the mock can be used in the same<br/>way a real object is. The other important part is that we want to test the behavior of the<br/>
set_value&#160;&#160;method on the&#160;&#160;LimitTracker&#160;. We can change what we pass in for the&#160;&#160;value<br/>
https://doc.rust-lang.org/book/print.html<br/>
416/627<br/>
<hr/>
<a name=417></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
parameter, but&#160;&#160;set_value&#160;&#160;doesn’t return anything for us to make assertions on. We want<br/>to be able to say that if we create a&#160;&#160;LimitTracker&#160;&#160;with something that implements the<br/>
Messenger&#160;&#160;trait and a particular value for&#160;&#160;max&#160;, when we pass diﬀerent numbers for&#160;&#160;value&#160;,<br/>
the messenger is told to send the appropriate messages.<br/>
We need a mock object that, instead of sending an email or text message when we call<br/>
send&#160;, will only keep track of the messages it’s told to send. We can create a new instance of<br/>
the mock object, create a&#160;&#160;LimitTracker&#160;&#160;that uses the mock object, call the&#160;&#160;set_value<br/>method on&#160;&#160;LimitTracker&#160;, and then check that the mock object has the messages we<br/>expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the<br/>borrow checker won’t allow it:<br/>
Filename: src/lib.rs<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>
&#160;&#160;&#160;&#160;struct&#160;MockMessenger&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sent_messages:&#160;Vec&lt;String&gt;,<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;impl&#160;MockMessenger&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;new()&#160;-&gt;&#160;MockMessenger&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MockMessenger&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sent_messages:&#160;vec![],<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;impl&#160;Messenger&#160;for&#160;MockMessenger&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;send(&amp;self,&#160;message:&#160;&amp;str)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.sent_messages.push(String::from(message));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;it_sends_an_over_75_percent_warning_message()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mock_messenger&#160;=&#160;MockMessenger::new();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;limit_tracker&#160;=&#160;LimitTracker::new(&amp;mock_messenger,&#160;100);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;limit_tracker.set_value(80);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(mock_messenger.sent_messages.len(),&#160;1);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;15-21:&#160;An&#160;attempt&#160;to&#160;implement&#160;a&#160;&#160;</b>MockMessenger&#160;<b>&#160;that&#160;isn’t&#160;allowed&#160;by&#160;the&#160;borrow&#160;checker</b><br/>
This test code deﬁnes a&#160;&#160;MockMessenger&#160;&#160;struct that has a&#160;&#160;sent_messages&#160;&#160;ﬁeld with a&#160;&#160;Vec&#160;&#160;of<br/>
String&#160;&#160;values to keep track of the messages it’s told to send. We also deﬁne an associated<br/>
function&#160;&#160;new&#160;&#160;to make it convenient to create new&#160;&#160;MockMessenger&#160;&#160;values that start with an<br/>
https://doc.rust-lang.org/book/print.html<br/>
417/627<br/>
<hr/>
<a name=418></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
empty list of messages. We then implement the&#160;&#160;Messenger&#160;&#160;trait for&#160;&#160;MockMessenger&#160;&#160;so we<br/>can give a&#160;&#160;MockMessenger&#160;&#160;to a&#160;&#160;LimitTracker&#160;. In the deﬁnition of the&#160;&#160;send&#160;&#160;method, we<br/>take the message passed in as a parameter and store it in the&#160;&#160;MockMessenger&#160;&#160;list of<br/>
sent_messages&#160;.<br/>
In the test, we’re testing what happens when the&#160;&#160;LimitTracker&#160;&#160;is told to set&#160;&#160;value&#160;&#160;to<br/>something that is more than 75 percent of the&#160;&#160;max&#160;&#160;value. First, we create a new<br/>
MockMessenger&#160;, which will start with an empty list of messages. Then we create a new<br/>LimitTracker&#160;&#160;and give it a reference to the new&#160;&#160;MockMessenger&#160;&#160;and a&#160;&#160;max&#160;&#160;value of 100.<br/>
We call the&#160;&#160;set_value&#160;&#160;method on the&#160;&#160;LimitTracker&#160;&#160;with a value of 80, which is more than<br/>75 percent of 100. Then we assert that the list of messages that the&#160;&#160;MockMessenger&#160;&#160;is<br/>keeping track of should now have one message in it.<br/>
However, there’s one problem with this test, as shown here:<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;limit-tracker&#160;v0.1.0&#160;(file:///projects/limit-tracker)<br/>error[E0596]:&#160;cannot&#160;borrow&#160;`self.sent_messages`&#160;as&#160;mutable,&#160;as&#160;it&#160;is&#160;behind&#160;a&#160;<br/>`&amp;`&#160;reference<br/>&#160;&#160;--&gt;&#160;src/lib.rs:58:13<br/>&#160;&#160;&#160;|<br/>2&#160;&#160;|&#160;&#160;&#160;&#160;&#160;fn&#160;send(&amp;self,&#160;msg:&#160;&amp;str);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-----&#160;help:&#160;consider&#160;changing&#160;that&#160;to&#160;be&#160;a&#160;mutable&#160;reference:&#160;<br/>`&amp;mut&#160;self`<br/>...<br/>58&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.sent_messages.push(String::from(message));<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#160;`self`&#160;is&#160;a&#160;`&amp;`&#160;<br/>reference,&#160;so&#160;the&#160;data&#160;it&#160;refers&#160;to&#160;cannot&#160;be&#160;borrowed&#160;as&#160;mutable<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0596`.<br/>error:&#160;could&#160;not&#160;compile&#160;`limit-tracker`&#160;due&#160;to&#160;previous&#160;error<br/>warning:&#160;build&#160;failed,&#160;waiting&#160;for&#160;other&#160;jobs&#160;to&#160;finish...<br/>
We can’t modify the&#160;&#160;MockMessenger&#160;&#160;to keep track of the messages, because the&#160;&#160;send<br/>method takes an immutable reference to&#160;&#160;self&#160;. We also can’t take the suggestion from the<br/>error text to use&#160;&#160;&amp;mut&#160;self&#160;&#160;instead, because then the signature of&#160;&#160;send&#160;&#160;wouldn’t match<br/>the signature in the&#160;&#160;Messenger&#160;&#160;trait deﬁnition (feel free to try and see what error message<br/>you get).<br/>
This is a situation in which interior mutability can help! We’ll store the&#160;&#160;sent_messages&#160;&#160;within<br/>a&#160;&#160;RefCell&lt;T&gt;&#160;, and then the&#160;&#160;send&#160;&#160;method will be able to modify&#160;&#160;sent_messages&#160;&#160;to store<br/>the messages we’ve seen. Listing 15-22 shows what that looks like:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
418/627<br/>
<hr/>
<a name=419></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
#[cfg(test)]<br/>mod&#160;tests&#160;{<br/>&#160;&#160;&#160;&#160;use&#160;super::*;<br/>&#160;&#160;&#160;&#160;use&#160;std::cell::RefCell;<br/>
&#160;&#160;&#160;&#160;struct&#160;MockMessenger&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sent_messages:&#160;RefCell&lt;Vec&lt;String&gt;&gt;,<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;impl&#160;MockMessenger&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;new()&#160;-&gt;&#160;MockMessenger&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;MockMessenger&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sent_messages:&#160;RefCell::new(vec![]),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;impl&#160;Messenger&#160;for&#160;MockMessenger&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;send(&amp;self,&#160;message:&#160;&amp;str)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.sent_messages.borrow_mut().push(String::from(message));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;#[test]<br/>&#160;&#160;&#160;&#160;fn&#160;it_sends_an_over_75_percent_warning_message()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert_eq!(mock_messenger.sent_messages.borrow().len(),&#160;1);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;15-22:&#160;Using&#160;&#160;</b>RefCell&lt;T&gt;&#160;<b>&#160;to&#160;mutate&#160;an&#160;inner&#160;value&#160;while&#160;the&#160;outer&#160;value&#160;is&#160;considered&#160;immutable</b><br/>
The&#160;&#160;sent_messages&#160;&#160;ﬁeld is now of type&#160;&#160;RefCell&lt;Vec&lt;String&gt;&gt;&#160;&#160;instead of&#160;&#160;Vec&lt;String&gt;&#160;. In<br/>the&#160;&#160;new&#160;&#160;function, we create a new&#160;&#160;RefCell&lt;Vec&lt;String&gt;&gt;&#160;&#160;instance around the empty<br/>vector.<br/>
For the implementation of the&#160;&#160;send&#160;&#160;method, the&#160;ﬁrst parameter is still an immutable<br/>borrow of&#160;&#160;self&#160;, which matches the trait deﬁnition. We call&#160;&#160;borrow_mut&#160;&#160;on the<br/>
RefCell&lt;Vec&lt;String&gt;&gt;&#160;&#160;in&#160;&#160;self.sent_messages&#160;&#160;to get a mutable reference to the value<br/>
inside the&#160;&#160;RefCell&lt;Vec&lt;String&gt;&gt;&#160;, which is the vector. Then we can call&#160;&#160;push&#160;&#160;on the<br/>mutable reference to the vector to keep track of the messages sent during the test.<br/>
The last change we have to make is in the assertion: to see how many items are in the inner<br/>vector, we call&#160;&#160;borrow&#160;&#160;on the&#160;&#160;RefCell&lt;Vec&lt;String&gt;&gt;&#160;&#160;to get an immutable reference to the<br/>vector.<br/>
Now that you’ve seen how to use&#160;&#160;RefCell&lt;T&gt;&#160;, let’s dig into how it works!<br/>
https://doc.rust-lang.org/book/print.html<br/>
419/627<br/>
<hr/>
<a name=420></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#420"><b>Keeping Track of Borrows at Runtime with&#160;</b>RefCell&lt;T&gt;</a><br/>
When creating immutable and mutable references, we use the&#160;&#160;&amp;&#160;&#160;and&#160;&#160;&amp;mut&#160;&#160;syntax,<br/>respectively. With&#160;&#160;RefCell&lt;T&gt;&#160;, we use the&#160;&#160;borrow&#160;&#160;and&#160;&#160;borrow_mut&#160;&#160;methods, which are<br/>part of the safe API that belongs to&#160;&#160;RefCell&lt;T&gt;&#160;. The&#160;&#160;borrow&#160;&#160;method returns the smart<br/>pointer type&#160;&#160;Ref&lt;T&gt;&#160;, and&#160;&#160;borrow_mut&#160;&#160;returns the smart pointer type&#160;&#160;RefMut&lt;T&gt;&#160;. Both<br/>types implement&#160;&#160;Deref&#160;, so we can treat them like regular references.<br/>
The&#160;&#160;RefCell&lt;T&gt;&#160;&#160;keeps track of how many&#160;&#160;Ref&lt;T&gt;&#160;&#160;and&#160;&#160;RefMut&lt;T&gt;&#160;&#160;smart pointers are<br/>currently active. Every time we call&#160;&#160;borrow&#160;, the&#160;&#160;RefCell&lt;T&gt;&#160;&#160;increases its count of how<br/>many immutable borrows are active. When a&#160;&#160;Ref&lt;T&gt;&#160;&#160;value goes out of scope, the count of<br/>immutable borrows goes down by one. Just like the compile-time borrowing rules,<br/>
RefCell&lt;T&gt;&#160;&#160;lets us have many immutable borrows or one mutable borrow at any point in<br/>
time.<br/>
If we try to violate these rules, rather than getting a compiler error as we would with<br/>references, the implementation of&#160;&#160;RefCell&lt;T&gt;&#160;&#160;will panic at runtime. Listing 15-23 shows a<br/>modiﬁcation of the implementation of&#160;&#160;send&#160;&#160;in Listing 15-22. We’re deliberately trying to<br/>create two mutable borrows active for the same scope to illustrate that&#160;&#160;RefCell&lt;T&gt;<br/>prevents us from doing this at runtime.<br/>
Filename: src/lib.rs<br/>
&#160;&#160;&#160;&#160;impl&#160;Messenger&#160;for&#160;MockMessenger&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;send(&amp;self,&#160;message:&#160;&amp;str)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;one_borrow&#160;=&#160;self.sent_messages.borrow_mut();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;two_borrow&#160;=&#160;self.sent_messages.borrow_mut();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;one_borrow.push(String::from(message));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;two_borrow.push(String::from(message));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;15-23:&#160;Creating&#160;two&#160;mutable&#160;references&#160;in&#160;the&#160;same&#160;scope&#160;to&#160;see&#160;that&#160;&#160;</b>RefCell&lt;T&gt;&#160;<b>&#160;will&#160;panic</b><br/>
We create a variable&#160;&#160;one_borrow&#160;&#160;for the&#160;&#160;RefMut&lt;T&gt;&#160;&#160;smart pointer returned from<br/>
borrow_mut&#160;. Then we create another mutable borrow in the same way in the variable<br/>two_borrow&#160;. This makes two mutable references in the same scope, which isn’t allowed.<br/>
When we run the tests for our library, the code in Listing 15-23 will compile without any<br/>errors, but the test will fail:<br/>
https://doc.rust-lang.org/book/print.html<br/>
420/627<br/>
<hr/>
<a name=421></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;test<br/>&#160;&#160;&#160;Compiling&#160;limit-tracker&#160;v0.1.0&#160;(file:///projects/limit-tracker)<br/>&#160;&#160;&#160;&#160;Finished&#160;test&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.91s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;unittests&#160;src/lib.rs&#160;(target/debug/deps/limit_tracker-<br/>e599811fa246dbde)<br/>
running&#160;1&#160;test<br/>test&#160;tests::it_sends_an_over_75_percent_warning_message&#160;...&#160;FAILED<br/>
failures:<br/>
----&#160;tests::it_sends_an_over_75_percent_warning_message&#160;stdout&#160;----<br/>thread&#160;'tests::it_sends_an_over_75_percent_warning_message'&#160;panicked&#160;at&#160;<br/>'already&#160;borrowed:&#160;BorrowMutError',&#160;src/lib.rs:60:53<br/>note:&#160;run&#160;with&#160;`RUST_BACKTRACE=1`&#160;environment&#160;variable&#160;to&#160;display&#160;a&#160;backtrace<br/>
failures:<br/>&#160;&#160;&#160;&#160;tests::it_sends_an_over_75_percent_warning_message<br/>
test&#160;result:&#160;FAILED.&#160;0&#160;passed;&#160;1&#160;failed;&#160;0&#160;ignored;&#160;0&#160;measured;&#160;0&#160;filtered&#160;out;&#160;<br/>finished&#160;in&#160;0.00s<br/>
error:&#160;test&#160;failed,&#160;to&#160;rerun&#160;pass&#160;`--lib`<br/>
Notice that the code panicked with the message&#160;&#160;already&#160;borrowed:&#160;BorrowMutError&#160;. This<br/>is how&#160;&#160;RefCell&lt;T&gt;&#160;&#160;handles violations of the borrowing rules at runtime.<br/>
Choosing to catch borrowing errors at runtime rather than compile time, as we’ve done<br/>here, means you’d potentially be&#160;ﬁnding mistakes in your code later in the development<br/>process: possibly not until your code was deployed to production. Also, your code would<br/>incur a small runtime performance penalty as a result of keeping track of the borrows at<br/>runtime rather than compile time. However, using&#160;&#160;RefCell&lt;T&gt;&#160;&#160;makes it possible to write a<br/>mock object that can modify itself to keep track of the messages it has seen while you’re<br/>using it in a context where only immutable values are allowed. You can use&#160;&#160;RefCell&lt;T&gt;<br/>despite its trade-oﬀs to get more functionality than regular references provide.<br/>
<a href="tests.html#421"><b>Having&#160;Multiple&#160;Owners&#160;of&#160;Mutable&#160;Data&#160;by&#160;Combining&#160;</b>Rc&lt;T&gt;<b>&#160;and<br/></b>RefCell&lt;T&gt;</a><br/>
A common way to use&#160;&#160;RefCell&lt;T&gt;&#160;&#160;is in combination with&#160;&#160;Rc&lt;T&gt;&#160;. Recall that&#160;&#160;Rc&lt;T&gt;&#160;&#160;lets you<br/>have multiple owners of some data, but it only gives immutable access to that data. If you<br/>have an&#160;&#160;Rc&lt;T&gt;&#160;&#160;that holds a&#160;&#160;RefCell&lt;T&gt;&#160;, you can get a value that can have multiple owners<br/><i>and</i>&#160;that you can mutate!<br/>
For example, recall the cons list example in Listing 15-18 where we used&#160;&#160;Rc&lt;T&gt;&#160;&#160;to allow<br/>multiple lists to share ownership of another list. Because&#160;&#160;Rc&lt;T&gt;&#160;&#160;holds only immutable<br/>values, we can’t change any of the values in the list once we’ve created them. Let’s add in<br/>
https://doc.rust-lang.org/book/print.html<br/>
421/627<br/>
<hr/>
<a name=422></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
RefCell&lt;T&gt;&#160;&#160;to gain the ability to change the values in the lists. Listing 15-24 shows that by<br/>
using a&#160;&#160;RefCell&lt;T&gt;&#160;&#160;in the&#160;&#160;Cons&#160;&#160;deﬁnition, we can modify the value stored in all the lists:<br/>
Filename: src/main.rs<br/>
#[derive(Debug)]<br/>enum&#160;List&#160;{<br/>&#160;&#160;&#160;&#160;Cons(Rc&lt;RefCell&lt;i32&gt;&gt;,&#160;Rc&lt;List&gt;),<br/>&#160;&#160;&#160;&#160;Nil,<br/>}<br/>
use&#160;crate::List::{Cons,&#160;Nil};<br/>use&#160;std::cell::RefCell;<br/>use&#160;std::rc::Rc;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;value&#160;=&#160;Rc::new(RefCell::new(5));<br/>
&#160;&#160;&#160;&#160;let&#160;a&#160;=&#160;Rc::new(Cons(Rc::clone(&amp;value),&#160;Rc::new(Nil)));<br/>
&#160;&#160;&#160;&#160;let&#160;b&#160;=&#160;Cons(Rc::new(RefCell::new(3)),&#160;Rc::clone(&amp;a));<br/>&#160;&#160;&#160;&#160;let&#160;c&#160;=&#160;Cons(Rc::new(RefCell::new(4)),&#160;Rc::clone(&amp;a));<br/>
&#160;&#160;&#160;&#160;*value.borrow_mut()&#160;+=&#160;10;<br/>
&#160;&#160;&#160;&#160;println!(&#34;a&#160;after&#160;=&#160;{:?}&#34;,&#160;a);<br/>&#160;&#160;&#160;&#160;println!(&#34;b&#160;after&#160;=&#160;{:?}&#34;,&#160;b);<br/>&#160;&#160;&#160;&#160;println!(&#34;c&#160;after&#160;=&#160;{:?}&#34;,&#160;c);<br/>}<br/>
<b>Listing&#160;15-24:&#160;Using&#160;&#160;</b>Rc&lt;RefCell&lt;i32&gt;&gt;&#160;<b>&#160;to&#160;create&#160;a&#160;&#160;</b>List&#160;<b>&#160;that&#160;we&#160;can&#160;mutate</b><br/>
We create a value that is an instance of&#160;&#160;Rc&lt;RefCell&lt;i32&gt;&gt;&#160;&#160;and store it in a variable named<br/>
value&#160;&#160;so we can access it directly later. Then we create a&#160;&#160;List&#160;&#160;in&#160;&#160;a&#160;&#160;with a&#160;&#160;Cons&#160;&#160;variant<br/>
that holds&#160;&#160;value&#160;. We need to clone&#160;&#160;value&#160;&#160;so both&#160;&#160;a&#160;&#160;and&#160;&#160;value&#160;&#160;have ownership of the<br/>inner&#160;&#160;5&#160;&#160;value rather than transferring ownership from&#160;&#160;value&#160;&#160;to&#160;&#160;a&#160;&#160;or having&#160;&#160;a&#160;&#160;borrow<br/>from&#160;&#160;value&#160;.<br/>
We wrap the list&#160;&#160;a&#160;&#160;in an&#160;&#160;Rc&lt;T&gt;&#160;&#160;so when we create lists&#160;&#160;b&#160;&#160;and&#160;&#160;c&#160;, they can both refer to&#160;&#160;a&#160;,<br/>which is what we did in Listing 15-18.<br/>
After we’ve created the lists in&#160;&#160;a&#160;,&#160;&#160;b&#160;, and&#160;&#160;c&#160;, we want to add 10 to the value in&#160;&#160;value&#160;. We<br/>do this by calling&#160;&#160;borrow_mut&#160;&#160;on&#160;&#160;value&#160;, which uses the automatic dereferencing feature<br/>we discussed in Chapter 5 (see the section&#160;<a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#wheres-the---operator">“Where’s the&#160;&#160;-&gt;&#160;&#160;Operator?”) to dereference the</a><br/>
Rc&lt;T&gt;&#160;&#160;to the inner&#160;&#160;RefCell&lt;T&gt;&#160;&#160;value. The&#160;&#160;borrow_mut&#160;&#160;method returns a&#160;&#160;RefMut&lt;T&gt;&#160;&#160;smart<br/>
pointer, and we use the dereference operator on it and change the inner value.<br/>
When we print&#160;&#160;a&#160;,&#160;&#160;b&#160;, and&#160;&#160;c&#160;, we can see that they all have the modiﬁed value of 15 rather<br/>than 5:<br/>
https://doc.rust-lang.org/book/print.html<br/>
422/627<br/>
<hr/>
<a name=423></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;cons-list&#160;v0.1.0&#160;(file:///projects/cons-list)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.63s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/cons-list`<br/>a&#160;after&#160;=&#160;Cons(RefCell&#160;{&#160;value:&#160;15&#160;},&#160;Nil)<br/>b&#160;after&#160;=&#160;Cons(RefCell&#160;{&#160;value:&#160;3&#160;},&#160;Cons(RefCell&#160;{&#160;value:&#160;15&#160;},&#160;Nil))<br/>c&#160;after&#160;=&#160;Cons(RefCell&#160;{&#160;value:&#160;4&#160;},&#160;Cons(RefCell&#160;{&#160;value:&#160;15&#160;},&#160;Nil))<br/>
This technique is pretty neat! By using&#160;&#160;RefCell&lt;T&gt;&#160;, we have an outwardly immutable&#160;&#160;List<br/>value. But we can use the methods on&#160;&#160;RefCell&lt;T&gt;&#160;&#160;that provide access to its interior<br/>mutability so we can modify our data when we need to. The runtime checks of the<br/>borrowing rules protect us from data races, and it’s sometimes worth trading a bit of speed<br/>for this&#160;ﬂexibility in our data structures. Note that&#160;&#160;RefCell&lt;T&gt;&#160;&#160;does not work for<br/>multithreaded code!&#160;&#160;Mutex&lt;T&gt;&#160;&#160;is the thread-safe version of&#160;&#160;RefCell&lt;T&gt;&#160;&#160;and we’ll discuss<br/>
Mutex&lt;T&gt;&#160;&#160;in Chapter 16.<br/>
https://doc.rust-lang.org/book/print.html<br/>
423/627<br/>
<hr/>
<a name=424></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#424"><b>Reference Cycles Can Leak Memory</b></a><br/>
Rust’s memory safety guarantees make it diﬃcult, but not impossible, to accidentally create<br/>memory that is never cleaned up (known as a&#160;<i>memory leak</i>). Preventing memory leaks<br/>entirely is not one of Rust’s guarantees, meaning memory leaks are memory safe in Rust.<br/>We can see that Rust allows memory leaks by using&#160;&#160;Rc&lt;T&gt;&#160;&#160;and&#160;&#160;RefCell&lt;T&gt;&#160;: it’s possible to<br/>create references where items refer to each other in a cycle. This creates memory leaks<br/>because the reference count of each item in the cycle will never reach 0, and the values will<br/>never be dropped.<br/>
<a href="tests.html#424"><b>Creating&#160;a&#160;Reference&#160;Cycle</b></a><br/>
Let’s look at how a reference cycle might happen and how to prevent it, starting with the<br/>deﬁnition of the&#160;&#160;List&#160;&#160;enum and a&#160;&#160;tail&#160;&#160;method in Listing 15-25:<br/>
Filename: src/main.rs<br/>
use&#160;crate::List::{Cons,&#160;Nil};<br/>use&#160;std::cell::RefCell;<br/>use&#160;std::rc::Rc;<br/>
#[derive(Debug)]<br/>enum&#160;List&#160;{<br/>&#160;&#160;&#160;&#160;Cons(i32,&#160;RefCell&lt;Rc&lt;List&gt;&gt;),<br/>&#160;&#160;&#160;&#160;Nil,<br/>}<br/>
impl&#160;List&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;tail(&amp;self)&#160;-&gt;&#160;Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;self&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Cons(_,&#160;item)&#160;=&gt;&#160;Some(item),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Nil&#160;=&gt;&#160;None,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;main()&#160;{}<br/>
<b>Listing&#160;15-25:&#160;A&#160;cons&#160;list&#160;deﬁnition&#160;that&#160;holds&#160;a&#160;&#160;</b>RefCell&lt;T&gt;&#160;<b>&#160;so&#160;we&#160;can&#160;modify&#160;what&#160;a&#160;&#160;</b>Cons&#160;<b>&#160;variant&#160;is&#160;referring<br/>to</b><br/>
We’re using another variation of the&#160;&#160;List&#160;&#160;deﬁnition from Listing 15-5. The second element<br/>in the&#160;&#160;Cons&#160;&#160;variant is now&#160;&#160;RefCell&lt;Rc&lt;List&gt;&gt;&#160;, meaning that instead of having the ability<br/>to modify the&#160;&#160;i32&#160;&#160;value as we did in Listing 15-24, we want to modify the&#160;&#160;List&#160;&#160;value a<br/>
https://doc.rust-lang.org/book/print.html<br/>
424/627<br/>
<hr/>
<a name=425></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Cons&#160;&#160;variant is pointing to. We’re also adding a&#160;&#160;tail&#160;&#160;method to make it convenient for us<br/>
to access the second item if we have a&#160;&#160;Cons&#160;&#160;variant.<br/>
In Listing 15-26, we’re adding a&#160;&#160;main&#160;&#160;function that uses the deﬁnitions in Listing 15-25. This<br/>code creates a list in&#160;&#160;a&#160;&#160;and a list in&#160;&#160;b&#160;&#160;that points to the list in&#160;&#160;a&#160;. Then it modiﬁes the list in<br/>
a&#160;&#160;to point to&#160;&#160;b&#160;, creating a reference cycle. There are&#160;&#160;println!&#160;&#160;statements along the way<br/>
to show what the reference counts are at various points in this process.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;a&#160;=&#160;Rc::new(Cons(5,&#160;RefCell::new(Rc::new(Nil))));<br/>
&#160;&#160;&#160;&#160;println!(&#34;a&#160;initial&#160;rc&#160;count&#160;=&#160;{}&#34;,&#160;Rc::strong_count(&amp;a));<br/>&#160;&#160;&#160;&#160;println!(&#34;a&#160;next&#160;item&#160;=&#160;{:?}&#34;,&#160;a.tail());<br/>
&#160;&#160;&#160;&#160;let&#160;b&#160;=&#160;Rc::new(Cons(10,&#160;RefCell::new(Rc::clone(&amp;a))));<br/>
&#160;&#160;&#160;&#160;println!(&#34;a&#160;rc&#160;count&#160;after&#160;b&#160;creation&#160;=&#160;{}&#34;,&#160;Rc::strong_count(&amp;a));<br/>&#160;&#160;&#160;&#160;println!(&#34;b&#160;initial&#160;rc&#160;count&#160;=&#160;{}&#34;,&#160;Rc::strong_count(&amp;b));<br/>&#160;&#160;&#160;&#160;println!(&#34;b&#160;next&#160;item&#160;=&#160;{:?}&#34;,&#160;b.tail());<br/>
&#160;&#160;&#160;&#160;if&#160;let&#160;Some(link)&#160;=&#160;a.tail()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*link.borrow_mut()&#160;=&#160;Rc::clone(&amp;b);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;b&#160;rc&#160;count&#160;after&#160;changing&#160;a&#160;=&#160;{}&#34;,&#160;Rc::strong_count(&amp;b));<br/>&#160;&#160;&#160;&#160;println!(&#34;a&#160;rc&#160;count&#160;after&#160;changing&#160;a&#160;=&#160;{}&#34;,&#160;Rc::strong_count(&amp;a));<br/>
&#160;&#160;&#160;&#160;//&#160;Uncomment&#160;the&#160;next&#160;line&#160;to&#160;see&#160;that&#160;we&#160;have&#160;a&#160;cycle;<br/>&#160;&#160;&#160;&#160;//&#160;it&#160;will&#160;overflow&#160;the&#160;stack<br/>&#160;&#160;&#160;&#160;//&#160;println!(&#34;a&#160;next&#160;item&#160;=&#160;{:?}&#34;,&#160;a.tail());<br/>}<br/>
<b>Listing&#160;15-26:&#160;Creating&#160;a&#160;reference&#160;cycle&#160;of&#160;two&#160;&#160;</b>List&#160;<b>&#160;values&#160;pointing&#160;to&#160;each&#160;other</b><br/>
We create an&#160;&#160;Rc&lt;List&gt;&#160;&#160;instance holding a&#160;&#160;List&#160;&#160;value in the variable&#160;&#160;a&#160;&#160;with an initial list of<br/>
5,&#160;Nil&#160;. We then create an&#160;&#160;Rc&lt;List&gt;&#160;&#160;instance holding another&#160;&#160;List&#160;&#160;value in the variable<br/>b&#160;&#160;that contains the value 10 and points to the list in&#160;&#160;a&#160;.<br/>
We modify&#160;&#160;a&#160;&#160;so it points to&#160;&#160;b&#160;&#160;instead of&#160;&#160;Nil&#160;, creating a cycle. We do that by using the<br/>
tail&#160;&#160;method to get a reference to the&#160;&#160;RefCell&lt;Rc&lt;List&gt;&gt;&#160;&#160;in&#160;&#160;a&#160;, which we put in the<br/>
variable&#160;&#160;link&#160;. Then we use the&#160;&#160;borrow_mut&#160;&#160;method on the&#160;&#160;RefCell&lt;Rc&lt;List&gt;&gt;&#160;&#160;to change<br/>the value inside from an&#160;&#160;Rc&lt;List&gt;&#160;&#160;that holds a&#160;&#160;Nil&#160;&#160;value to the&#160;&#160;Rc&lt;List&gt;&#160;&#160;in&#160;&#160;b&#160;.<br/>
When we run this code, keeping the last&#160;&#160;println!&#160;&#160;commented out for the moment, we’ll<br/>get this output:<br/>
https://doc.rust-lang.org/book/print.html<br/>
425/627<br/>
<hr/>
<a name=426></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;cons-list&#160;v0.1.0&#160;(file:///projects/cons-list)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.53s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/cons-list`<br/>a&#160;initial&#160;rc&#160;count&#160;=&#160;1<br/>a&#160;next&#160;item&#160;=&#160;Some(RefCell&#160;{&#160;value:&#160;Nil&#160;})<br/>a&#160;rc&#160;count&#160;after&#160;b&#160;creation&#160;=&#160;2<br/>b&#160;initial&#160;rc&#160;count&#160;=&#160;1<br/>b&#160;next&#160;item&#160;=&#160;Some(RefCell&#160;{&#160;value:&#160;Cons(5,&#160;RefCell&#160;{&#160;value:&#160;Nil&#160;})&#160;})<br/>b&#160;rc&#160;count&#160;after&#160;changing&#160;a&#160;=&#160;2<br/>a&#160;rc&#160;count&#160;after&#160;changing&#160;a&#160;=&#160;2<br/>
The reference count of the&#160;&#160;Rc&lt;List&gt;&#160;&#160;instances in both&#160;&#160;a&#160;&#160;and&#160;&#160;b&#160;&#160;are 2 after we change the<br/>list in&#160;&#160;a&#160;&#160;to point to&#160;&#160;b&#160;. At the end of&#160;&#160;main&#160;, Rust drops the variable&#160;&#160;b&#160;, which decreases the<br/>reference count of the&#160;&#160;b&#160;&#160;&#160;Rc&lt;List&gt;&#160;&#160;instance from 2 to 1. The memory that&#160;&#160;Rc&lt;List&gt;&#160;&#160;has<br/>on the heap won’t be dropped at this point, because its reference count is 1, not 0. Then<br/>Rust drops&#160;&#160;a&#160;, which decreases the reference count of the&#160;&#160;a&#160;&#160;&#160;Rc&lt;List&gt;&#160;&#160;instance from 2 to 1<br/>as well. This instance’s memory can’t be dropped either, because the other&#160;&#160;Rc&lt;List&gt;<br/>instance still refers to it. The memory allocated to the list will remain uncollected forever. To<br/>visualize this reference cycle, we’ve created a diagram in Figure 15-4.<br/>
b<br/>
a<br/>
5<br/>
10<br/>
<b>Figure&#160;15-4:&#160;A&#160;reference&#160;cycle&#160;of&#160;lists&#160;&#160;</b>a&#160;<b>&#160;and&#160;&#160;</b>b&#160;<b>&#160;pointing&#160;to&#160;each&#160;other</b><br/>
If you uncomment the last&#160;&#160;println!&#160;&#160;and run the program, Rust will try to print this cycle<br/>with&#160;&#160;a&#160;&#160;pointing to&#160;&#160;b&#160;&#160;pointing to&#160;&#160;a&#160;&#160;and so forth until it overﬂows the stack.<br/>
Compared to a real-world program, the consequences of creating a reference cycle in this<br/>example aren’t very dire: right after we create the reference cycle, the program ends.<br/>However, if a more complex program allocated lots of memory in a cycle and held onto it for<br/>
https://doc.rust-lang.org/book/print.html<br/>
426/627<br/>
<hr/>
<a name=427></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
a long time, the program would use more memory than it needed and might overwhelm the<br/>system, causing it to run out of available memory.<br/>
Creating reference cycles is not easily done, but it’s not impossible either. If you have<br/>
RefCell&lt;T&gt;&#160;&#160;values that contain&#160;&#160;Rc&lt;T&gt;&#160;&#160;values or similar nested combinations of types with<br/>
interior mutability and reference counting, you must ensure that you don’t create cycles;<br/>you can’t rely on Rust to catch them. Creating a reference cycle would be a logic bug in your<br/>program that you should use automated tests, code reviews, and other software<br/>development practices to minimize.<br/>
Another solution for avoiding reference cycles is reorganizing your data structures so that<br/>some references express ownership and some references don’t. As a result, you can have<br/>cycles made up of some ownership relationships and some non-ownership relationships,<br/>and only the ownership relationships aﬀect whether or not a value can be dropped. In<br/>Listing 15-25, we always want&#160;&#160;Cons&#160;&#160;variants to own their list, so reorganizing the data<br/>structure isn’t possible. Let’s look at an example using graphs made up of parent nodes and<br/>child nodes to see when non-ownership relationships are an appropriate way to prevent<br/>reference cycles.<br/>
<a href="tests.html#427"><b>Preventing&#160;Reference&#160;Cycles:&#160;Turning&#160;an&#160;</b>Rc&lt;T&gt;<b>&#160;into&#160;a&#160;</b>Weak&lt;T&gt;</a><br/>
So far, we’ve demonstrated that calling&#160;&#160;Rc::clone&#160;&#160;increases the&#160;&#160;strong_count&#160;&#160;of an<br/>
Rc&lt;T&gt;&#160;&#160;instance, and an&#160;&#160;Rc&lt;T&gt;&#160;&#160;instance is only cleaned up if its&#160;&#160;strong_count&#160;&#160;is 0. You can<br/>
also create a&#160;<i>weak reference</i>&#160;to the value within an&#160;&#160;Rc&lt;T&gt;&#160;&#160;instance by calling&#160;&#160;Rc::downgrade<br/>and passing a reference to the&#160;&#160;Rc&lt;T&gt;&#160;. Strong references are how you can share ownership<br/>of an&#160;&#160;Rc&lt;T&gt;&#160;&#160;instance. Weak references don’t express an ownership relationship, and their<br/>count doesn’t aﬀect when an&#160;&#160;Rc&lt;T&gt;&#160;&#160;instance is cleaned up. They won’t cause a reference<br/>cycle because any cycle involving some weak references will be broken once the strong<br/>reference count of values involved is 0.<br/>
When you call&#160;&#160;Rc::downgrade&#160;, you get a smart pointer of type&#160;&#160;Weak&lt;T&gt;&#160;. Instead of<br/>increasing the&#160;&#160;strong_count&#160;&#160;in the&#160;&#160;Rc&lt;T&gt;&#160;&#160;instance by 1, calling&#160;&#160;Rc::downgrade&#160;&#160;increases<br/>the&#160;&#160;weak_count&#160;&#160;by 1. The&#160;&#160;Rc&lt;T&gt;&#160;&#160;type uses&#160;&#160;weak_count&#160;&#160;to keep track of how many<br/>
Weak&lt;T&gt;&#160;&#160;references exist, similar to&#160;&#160;strong_count&#160;. The diﬀerence is the&#160;&#160;weak_count<br/>
doesn’t need to be 0 for the&#160;&#160;Rc&lt;T&gt;&#160;&#160;instance to be cleaned up.<br/>
Because the value that&#160;&#160;Weak&lt;T&gt;&#160;&#160;references might have been dropped, to do anything with<br/>the value that a&#160;&#160;Weak&lt;T&gt;&#160;&#160;is pointing to, you must make sure the value still exists. Do this by<br/>calling the&#160;&#160;upgrade&#160;&#160;method on a&#160;&#160;Weak&lt;T&gt;&#160;&#160;instance, which will return an&#160;&#160;Option&lt;Rc&lt;T&gt;&gt;&#160;.<br/>You’ll get a result of&#160;&#160;Some&#160;&#160;if the&#160;&#160;Rc&lt;T&gt;&#160;&#160;value has not been dropped yet and a result of<br/>
None&#160;&#160;if the&#160;&#160;Rc&lt;T&gt;&#160;&#160;value has been dropped. Because&#160;&#160;upgrade&#160;&#160;returns an&#160;&#160;Option&lt;Rc&lt;T&gt;&gt;&#160;,<br/>
Rust will ensure that the&#160;&#160;Some&#160;&#160;case and the&#160;&#160;None&#160;&#160;case are handled, and there won’t be an<br/>invalid pointer.<br/>
https://doc.rust-lang.org/book/print.html<br/>
427/627<br/>
<hr/>
<a name=428></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
As an example, rather than using a list whose items know only about the next item, we’ll<br/>create a tree whose items know about their children items&#160;<i>and</i>&#160;their parent items.<br/>
<a href="tests.html#428"><b>Creating a Tree Data Structure: a&#160;</b>Node<b>&#160;with Child Nodes</b></a><br/>
To start, we’ll build a tree with nodes that know about their child nodes. We’ll create a struct<br/>named&#160;&#160;Node&#160;&#160;that holds its own&#160;&#160;i32&#160;&#160;value as well as references to its children&#160;&#160;Node&#160;&#160;values:<br/>
Filename: src/main.rs<br/>
use&#160;std::cell::RefCell;<br/>use&#160;std::rc::Rc;<br/>
#[derive(Debug)]<br/>struct&#160;Node&#160;{<br/>&#160;&#160;&#160;&#160;value:&#160;i32,<br/>&#160;&#160;&#160;&#160;children:&#160;RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,<br/>}<br/>
We want a&#160;&#160;Node&#160;&#160;to own its children, and we want to share that ownership with variables so<br/>we can access each&#160;&#160;Node&#160;&#160;in the tree directly. To do this, we deﬁne the&#160;&#160;Vec&lt;T&gt;&#160;&#160;items to be<br/>values of type&#160;&#160;Rc&lt;Node&gt;&#160;. We also want to modify which nodes are children of another node,<br/>so we have a&#160;&#160;RefCell&lt;T&gt;&#160;&#160;in&#160;&#160;children&#160;&#160;around the&#160;&#160;Vec&lt;Rc&lt;Node&gt;&gt;&#160;.<br/>
Next, we’ll use our struct deﬁnition and create one&#160;&#160;Node&#160;&#160;instance named&#160;&#160;leaf&#160;&#160;with the<br/>value 3 and no children, and another instance named&#160;&#160;branch&#160;&#160;with the value 5 and&#160;&#160;leaf&#160;&#160;as<br/>one of its children, as shown in Listing 15-27:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;leaf&#160;=&#160;Rc::new(Node&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value:&#160;3,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;children:&#160;RefCell::new(vec![]),<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;let&#160;branch&#160;=&#160;Rc::new(Node&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value:&#160;5,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;children:&#160;RefCell::new(vec![Rc::clone(&amp;leaf)]),<br/>&#160;&#160;&#160;&#160;});<br/>}<br/>
<b>Listing&#160;15-27:&#160;Creating&#160;a&#160;&#160;</b>leaf&#160;<b>&#160;node&#160;with&#160;no&#160;children&#160;and&#160;a&#160;&#160;</b>branch&#160;<b>&#160;node&#160;with&#160;&#160;</b>leaf&#160;<b>&#160;as&#160;one&#160;of&#160;its&#160;children</b><br/>
We clone the&#160;&#160;Rc&lt;Node&gt;&#160;&#160;in&#160;&#160;leaf&#160;&#160;and store that in&#160;&#160;branch&#160;, meaning the&#160;&#160;Node&#160;&#160;in&#160;&#160;leaf&#160;&#160;now<br/>has two owners:&#160;&#160;leaf&#160;&#160;and&#160;&#160;branch&#160;. We can get from&#160;&#160;branch&#160;&#160;to&#160;&#160;leaf&#160;&#160;through<br/>
branch.children&#160;, but there’s no way to get from&#160;&#160;leaf&#160;&#160;to&#160;&#160;branch&#160;. The reason is that&#160;&#160;leaf<br/>
has no reference to&#160;&#160;branch&#160;&#160;and doesn’t know they’re related. We want&#160;&#160;leaf&#160;&#160;to know that<br/>
branch&#160;&#160;is its parent. We’ll do that next.<br/>
https://doc.rust-lang.org/book/print.html<br/>
428/627<br/>
<hr/>
<a name=429></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#429"><b>Adding a Reference from a Child to Its Parent</b></a><br/>
To make the child node aware of its parent, we need to add a&#160;&#160;parent&#160;&#160;ﬁeld to our&#160;&#160;Node<br/>struct deﬁnition. The trouble is in deciding what the type of&#160;&#160;parent&#160;&#160;should be. We know it<br/>can’t contain an&#160;&#160;Rc&lt;T&gt;&#160;, because that would create a reference cycle with&#160;&#160;leaf.parent<br/>pointing to&#160;&#160;branch&#160;&#160;and&#160;&#160;branch.children&#160;&#160;pointing to&#160;&#160;leaf&#160;, which would cause their<br/>
strong_count&#160;&#160;values to never be 0.<br/>
Thinking about the relationships another way, a parent node should own its children: if a<br/>parent node is dropped, its child nodes should be dropped as well. However, a child should<br/>not own its parent: if we drop a child node, the parent should still exist. This is a case for<br/>weak references!<br/>
So instead of&#160;&#160;Rc&lt;T&gt;&#160;, we’ll make the type of&#160;&#160;parent&#160;&#160;use&#160;&#160;Weak&lt;T&gt;&#160;, speciﬁcally a<br/>
RefCell&lt;Weak&lt;Node&gt;&gt;&#160;. Now our&#160;&#160;Node&#160;&#160;struct deﬁnition looks like this:<br/>
Filename: src/main.rs<br/>
use&#160;std::cell::RefCell;<br/>use&#160;std::rc::{Rc,&#160;Weak};<br/>
#[derive(Debug)]<br/>struct&#160;Node&#160;{<br/>&#160;&#160;&#160;&#160;value:&#160;i32,<br/>&#160;&#160;&#160;&#160;parent:&#160;RefCell&lt;Weak&lt;Node&gt;&gt;,<br/>&#160;&#160;&#160;&#160;children:&#160;RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,<br/>}<br/>
A node will be able to refer to its parent node but doesn’t own its parent. In Listing 15-28,<br/>we update&#160;&#160;main&#160;&#160;to use this new deﬁnition so the&#160;&#160;leaf&#160;&#160;node will have a way to refer to its<br/>parent,&#160;&#160;branch&#160;:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
429/627<br/>
<hr/>
<a name=430></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;leaf&#160;=&#160;Rc::new(Node&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value:&#160;3,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;parent:&#160;RefCell::new(Weak::new()),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;children:&#160;RefCell::new(vec![]),<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;println!(&#34;leaf&#160;parent&#160;=&#160;{:?}&#34;,&#160;leaf.parent.borrow().upgrade());<br/>
&#160;&#160;&#160;&#160;let&#160;branch&#160;=&#160;Rc::new(Node&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value:&#160;5,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;parent:&#160;RefCell::new(Weak::new()),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;children:&#160;RefCell::new(vec![Rc::clone(&amp;leaf)]),<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;*leaf.parent.borrow_mut()&#160;=&#160;Rc::downgrade(&amp;branch);<br/>
&#160;&#160;&#160;&#160;println!(&#34;leaf&#160;parent&#160;=&#160;{:?}&#34;,&#160;leaf.parent.borrow().upgrade());<br/>}<br/>
<b>Listing&#160;15-28:&#160;A&#160;&#160;</b>leaf&#160;<b>&#160;node&#160;with&#160;a&#160;weak&#160;reference&#160;to&#160;its&#160;parent&#160;node&#160;&#160;</b>branch<br/>
Creating the&#160;&#160;leaf&#160;&#160;node looks similar to Listing 15-27 with the exception of the&#160;&#160;parent<br/>ﬁeld:&#160;&#160;leaf&#160;&#160;starts out without a parent, so we create a new, empty&#160;&#160;Weak&lt;Node&gt;&#160;&#160;reference<br/>instance.<br/>
At this point, when we try to get a reference to the parent of&#160;&#160;leaf&#160;&#160;by using the&#160;&#160;upgrade<br/>method, we get a&#160;&#160;None&#160;&#160;value. We see this in the output from the&#160;ﬁrst&#160;&#160;println!&#160;&#160;statement:<br/>
leaf&#160;parent&#160;=&#160;None<br/>
When we create the&#160;&#160;branch&#160;&#160;node, it will also have a new&#160;&#160;Weak&lt;Node&gt;&#160;&#160;reference in the<br/>
parent&#160;&#160;ﬁeld, because&#160;&#160;branch&#160;&#160;doesn’t have a parent node. We still have&#160;&#160;leaf&#160;&#160;as one of the<br/>
children of&#160;&#160;branch&#160;. Once we have the&#160;&#160;Node&#160;&#160;instance in&#160;&#160;branch&#160;, we can modify&#160;&#160;leaf&#160;&#160;to<br/>give it a&#160;&#160;Weak&lt;Node&gt;&#160;&#160;reference to its parent. We use the&#160;&#160;borrow_mut&#160;&#160;method on the<br/>
RefCell&lt;Weak&lt;Node&gt;&gt;&#160;&#160;in the&#160;&#160;parent&#160;&#160;ﬁeld of&#160;&#160;leaf&#160;, and then we use the&#160;&#160;Rc::downgrade<br/>
function to create a&#160;&#160;Weak&lt;Node&gt;&#160;&#160;reference to&#160;&#160;branch&#160;&#160;from the&#160;&#160;Rc&lt;Node&gt;&#160;&#160;in&#160;&#160;branch.<br/>
When we print the parent of&#160;&#160;leaf&#160;&#160;again, this time we’ll get a&#160;&#160;Some&#160;&#160;variant holding&#160;&#160;branch&#160;:<br/>now&#160;&#160;leaf&#160;&#160;can access its parent! When we print&#160;&#160;leaf&#160;, we also avoid the cycle that<br/>eventually ended in a stack overﬂow like we had in Listing 15-26; the&#160;&#160;Weak&lt;Node&gt;<br/>references are printed as&#160;&#160;(Weak)&#160;:<br/>
leaf&#160;parent&#160;=&#160;Some(Node&#160;{&#160;value:&#160;5,&#160;parent:&#160;RefCell&#160;{&#160;value:&#160;(Weak)&#160;},<br/>children:&#160;RefCell&#160;{&#160;value:&#160;[Node&#160;{&#160;value:&#160;3,&#160;parent:&#160;RefCell&#160;{&#160;value:&#160;(Weak)&#160;},<br/>children:&#160;RefCell&#160;{&#160;value:&#160;[]&#160;}&#160;}]&#160;}&#160;})<br/>
The lack of inﬁnite output indicates that this code didn’t create a reference cycle. We can<br/>also tell this by looking at the values we get from calling&#160;&#160;Rc::strong_count&#160;&#160;and<br/>
https://doc.rust-lang.org/book/print.html<br/>
430/627<br/>
<hr/>
<a name=431></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Rc::weak_count&#160;.<br/>
<a href="tests.html#431"><b>Visualizing Changes to&#160;</b>strong_count<b>&#160;and&#160;</b>weak_count</a><br/>
Let’s look at how the&#160;&#160;strong_count&#160;&#160;and&#160;&#160;weak_count&#160;&#160;values of the&#160;&#160;Rc&lt;Node&gt;&#160;&#160;instances<br/>change by creating a new inner scope and moving the creation of&#160;&#160;branch&#160;&#160;into that scope.<br/>By doing so, we can see what happens when&#160;&#160;branch&#160;&#160;is created and then dropped when it<br/>goes out of scope. The modiﬁcations are shown in Listing 15-29:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;leaf&#160;=&#160;Rc::new(Node&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value:&#160;3,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;parent:&#160;RefCell::new(Weak::new()),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;children:&#160;RefCell::new(vec![]),<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;println!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;leaf&#160;strong&#160;=&#160;{},&#160;weak&#160;=&#160;{}&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rc::strong_count(&amp;leaf),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rc::weak_count(&amp;leaf),<br/>&#160;&#160;&#160;&#160;);<br/>
&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;branch&#160;=&#160;Rc::new(Node&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value:&#160;5,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;parent:&#160;RefCell::new(Weak::new()),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;children:&#160;RefCell::new(vec![Rc::clone(&amp;leaf)]),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*leaf.parent.borrow_mut()&#160;=&#160;Rc::downgrade(&amp;branch);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;branch&#160;strong&#160;=&#160;{},&#160;weak&#160;=&#160;{}&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rc::strong_count(&amp;branch),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rc::weak_count(&amp;branch),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;leaf&#160;strong&#160;=&#160;{},&#160;weak&#160;=&#160;{}&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rc::strong_count(&amp;leaf),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rc::weak_count(&amp;leaf),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;leaf&#160;parent&#160;=&#160;{:?}&#34;,&#160;leaf.parent.borrow().upgrade());<br/>&#160;&#160;&#160;&#160;println!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;leaf&#160;strong&#160;=&#160;{},&#160;weak&#160;=&#160;{}&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rc::strong_count(&amp;leaf),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Rc::weak_count(&amp;leaf),<br/>&#160;&#160;&#160;&#160;);<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
431/627<br/>
<hr/>
<a name=432></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Listing&#160;15-29:&#160;Creating&#160;&#160;</b>branch&#160;<b>&#160;in&#160;an&#160;inner&#160;scope&#160;and&#160;examining&#160;strong&#160;and&#160;weak&#160;reference&#160;counts</b><br/>
After&#160;&#160;leaf&#160;&#160;is created, its&#160;&#160;Rc&lt;Node&gt;&#160;&#160;has a strong count of 1 and a weak count of 0. In the<br/>inner scope, we create&#160;&#160;branch&#160;&#160;and associate it with&#160;&#160;leaf&#160;, at which point when we print the<br/>counts, the&#160;&#160;Rc&lt;Node&gt;&#160;&#160;in&#160;&#160;branch&#160;&#160;will have a strong count of 1 and a weak count of 1 (for<br/>
leaf.parent&#160;&#160;pointing to&#160;&#160;branch&#160;&#160;with a&#160;&#160;Weak&lt;Node&gt;&#160;). When we print the counts in&#160;&#160;leaf&#160;,<br/>
we’ll see it will have a strong count of 2, because&#160;&#160;branch&#160;&#160;now has a clone of the&#160;&#160;Rc&lt;Node&gt;<br/>of&#160;&#160;leaf&#160;&#160;stored in&#160;&#160;branch.children&#160;, but will still have a weak count of 0.<br/>
When the inner scope ends,&#160;&#160;branch&#160;&#160;goes out of scope and the strong count of the<br/>
Rc&lt;Node&gt;&#160;&#160;decreases to 0, so its&#160;&#160;Node&#160;&#160;is dropped. The weak count of 1 from&#160;&#160;leaf.parent<br/>
has no bearing on whether or not&#160;&#160;Node&#160;&#160;is dropped, so we don’t get any memory leaks!<br/>
If we try to access the parent of&#160;&#160;leaf&#160;&#160;after the end of the scope, we’ll get&#160;&#160;None&#160;&#160;again. At<br/>the end of the program, the&#160;&#160;Rc&lt;Node&gt;&#160;&#160;in&#160;&#160;leaf&#160;&#160;has a strong count of 1 and a weak count of<br/>0, because the variable&#160;&#160;leaf&#160;&#160;is now the only reference to the&#160;&#160;Rc&lt;Node&gt;&#160;&#160;again.<br/>
All of the logic that manages the counts and value dropping is built into&#160;&#160;Rc&lt;T&gt;&#160;&#160;and<br/>
Weak&lt;T&gt;&#160;&#160;and their implementations of the&#160;&#160;Drop&#160;&#160;trait. By specifying that the relationship<br/>
from a child to its parent should be a&#160;&#160;Weak&lt;T&gt;&#160;&#160;reference in the deﬁnition of&#160;&#160;Node&#160;, you’re<br/>able to have parent nodes point to child nodes and vice versa without creating a reference<br/>cycle and memory leaks.<br/>
<a href="tests.html#432"><b>Summary</b></a><br/>
This chapter covered how to use smart pointers to make diﬀerent guarantees and trade-<br/>oﬀs from those Rust makes by default with regular references. The&#160;&#160;Box&lt;T&gt;&#160;&#160;type has a<br/>known size and points to data allocated on the heap. The&#160;&#160;Rc&lt;T&gt;&#160;&#160;type keeps track of the<br/>number of references to data on the heap so that data can have multiple owners. The<br/>
RefCell&lt;T&gt;&#160;&#160;type with its interior mutability gives us a type that we can use when we need<br/>
an immutable type but need to change an inner value of that type; it also enforces the<br/>borrowing rules at runtime instead of at compile time.<br/>
Also discussed were the&#160;&#160;Deref&#160;&#160;and&#160;&#160;Drop&#160;&#160;traits, which enable a lot of the functionality of<br/>smart pointers. We explored reference cycles that can cause memory leaks and how to<br/>prevent them using&#160;&#160;Weak&lt;T&gt;&#160;.<br/>
If this chapter has piqued your interest and you want to implement your own smart<br/>pointers, check out&#160;<a href="https://doc.rust-lang.org/nomicon/index.html">“The Rustonomicon”&#160;for more useful information.</a><br/>
Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new smart pointers.<br/>
https://doc.rust-lang.org/book/print.html<br/>
432/627<br/>
<hr/>
<a name=433></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#433"><b>Fearless Concurrency</b></a><br/>
Handling concurrent programming safely and eﬃciently is another of Rust’s major goals.<br/><i>Concurrent programming</i>, where diﬀerent parts of a program execute independently, and<br/><i>parallel programming</i>, where diﬀerent parts of a program execute at the same time, are<br/>becoming increasingly important as more computers take advantage of their multiple<br/>processors. Historically, programming in these contexts has been diﬃcult and error prone:<br/>Rust hopes to change that.<br/>
Initially, the Rust team thought that ensuring memory safety and preventing concurrency<br/>problems were two separate challenges to be solved with diﬀerent methods. Over time, the<br/>team discovered that the ownership and type systems are a powerful set of tools to help<br/>manage memory safety&#160;<i>and</i>&#160;concurrency problems! By leveraging ownership and type<br/>checking, many concurrency errors are compile-time errors in Rust rather than runtime<br/>errors. Therefore, rather than making you spend lots of time trying to reproduce the exact<br/>circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to<br/>compile and present an error explaining the problem. As a result, you can&#160;ﬁx your code<br/>while you’re working on it rather than potentially after it has been shipped to production.<br/>We’ve nicknamed this aspect of Rust&#160;<i>fearless</i>&#160;<i>concurrency</i>. Fearless concurrency allows you to<br/>write code that is free of subtle bugs and is easy to refactor without introducing new bugs.<br/>
Note: For simplicity’s sake, we’ll refer to many of the problems as&#160;<i>concurrent</i>&#160;rather<br/>than being more precise by saying&#160;<i>concurrent and/or parallel</i>. If this book were about<br/>concurrency and/or parallelism, we’d be more speciﬁc. For this chapter, please<br/>mentally substitute&#160;<i>concurrent and/or parallel</i>&#160;whenever we use&#160;<i>concurrent</i>.<br/>
Many languages are dogmatic about the solutions they oﬀer for handling concurrent<br/>problems. For example, Erlang has elegant functionality for message-passing concurrency<br/>but has only obscure ways to share state between threads. Supporting only a subset of<br/>possible solutions is a reasonable strategy for higher-level languages, because a higher-level<br/>language promises beneﬁts from giving up some control to gain abstractions. However,<br/>lower-level languages are expected to provide the solution with the best performance in any<br/>given situation and have fewer abstractions over the hardware. Therefore, Rust oﬀers a<br/>variety of tools for modeling problems in whatever way is appropriate for your situation and<br/>requirements.<br/>
Here are the topics we’ll cover in this chapter:<br/>
How to create threads to run multiple pieces of code at the same time<br/><i>Message-passing</i>&#160;concurrency, where channels send messages between threads<br/><i>Shared-state</i>&#160;concurrency, where multiple threads have access to some piece of data<br/>The&#160;&#160;Sync&#160;&#160;and&#160;&#160;Send&#160;&#160;traits, which extend Rust’s concurrency guarantees to user-<br/>deﬁned types as well as types provided by the standard library<br/>
https://doc.rust-lang.org/book/print.html<br/>
433/627<br/>
<hr/>
<a name=434></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#434"><b>Using Threads to Run Code Simultaneously</b></a><br/>
In most current operating systems, an executed program’s code is run in a&#160;<i>process</i>, and the<br/>operating system will manage multiple processes at once. Within a program, you can also<br/>have independent parts that run simultaneously. The features that run these independent<br/>parts are called&#160;<i>threads</i>. For example, a web server could have multiple threads so that it<br/>could respond to more than one request at the same time.<br/>
Splitting the computation in your program into multiple threads to run multiple tasks at the<br/>same time can improve performance, but it also adds complexity. Because threads can run<br/>simultaneously, there’s no inherent guarantee about the order in which parts of your code<br/>on diﬀerent threads will run. This can lead to problems, such as:<br/>
Race conditions, where threads are accessing data or resources in an inconsistent<br/>order<br/>Deadlocks, where two threads are waiting for each other, preventing both threads<br/>from continuing<br/>Bugs that happen only in certain situations and are hard to reproduce and&#160;ﬁx reliably<br/>
Rust attempts to mitigate the negative eﬀects of using threads, but programming in a<br/>multithreaded context still takes careful thought and requires a code structure that is<br/>diﬀerent from that in programs running in a single thread.<br/>
Programming languages implement threads in a few diﬀerent ways, and many operating<br/>systems provide an API the language can call for creating new threads. The Rust standard<br/>library uses a&#160;<i>1:1</i>&#160;model of thread implementation, whereby a program uses one operating<br/>system thread per one language thread. There are crates that implement other models of<br/>threading that make diﬀerent tradeoﬀs to the 1:1 model.<br/>
<a href="tests.html#434"><b>Creating&#160;a&#160;New&#160;Thread&#160;with&#160;</b>spawn</a><br/>
To create a new thread, we call the&#160;&#160;thread::spawn&#160;&#160;function and pass it a closure (we talked<br/>about closures in Chapter 13) containing the code we want to run in the new thread. The<br/>example in Listing 16-1 prints some text from a main thread and other text from a new<br/>thread:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
434/627<br/>
<hr/>
<a name=435></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::thread;<br/>use&#160;std::time::Duration;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;thread::spawn(||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;i&#160;in&#160;1..10&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;hi&#160;number&#160;{}&#160;from&#160;the&#160;spawned&#160;thread!&#34;,&#160;i);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::sleep(Duration::from_millis(1));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;for&#160;i&#160;in&#160;1..5&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;hi&#160;number&#160;{}&#160;from&#160;the&#160;main&#160;thread!&#34;,&#160;i);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::sleep(Duration::from_millis(1));<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;16-1:&#160;Creating&#160;a&#160;new&#160;thread&#160;to&#160;print&#160;one&#160;thing&#160;while&#160;the&#160;main&#160;thread&#160;prints&#160;something&#160;else</b><br/>
Note that when the main thread of a Rust program completes, all spawned threads are shut<br/>down, whether or not they have&#160;ﬁnished running. The output from this program might be a<br/>little diﬀerent every time, but it will look similar to the following:<br/>
hi&#160;number&#160;1&#160;from&#160;the&#160;main&#160;thread!<br/>hi&#160;number&#160;1&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;2&#160;from&#160;the&#160;main&#160;thread!<br/>hi&#160;number&#160;2&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;3&#160;from&#160;the&#160;main&#160;thread!<br/>hi&#160;number&#160;3&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;4&#160;from&#160;the&#160;main&#160;thread!<br/>hi&#160;number&#160;4&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;5&#160;from&#160;the&#160;spawned&#160;thread!<br/>
The calls to&#160;&#160;thread::sleep&#160;&#160;force a thread to stop its execution for a short duration,<br/>allowing a diﬀerent thread to run. The threads will probably take turns, but that isn’t<br/>guaranteed: it depends on how your operating system schedules the threads. In this run,<br/>the main thread printed&#160;ﬁrst, even though the print statement from the spawned thread<br/>appears&#160;ﬁrst in the code. And even though we told the spawned thread to print until&#160;&#160;i&#160;&#160;is 9,<br/>it only got to 5 before the main thread shut down.<br/>
If you run this code and only see output from the main thread, or don’t see any overlap, try<br/>increasing the numbers in the ranges to create more opportunities for the operating system<br/>to switch between the threads.<br/>
<a href="tests.html#435"><b>Waiting&#160;for&#160;All&#160;Threads&#160;to&#160;Finish&#160;Using&#160;</b>join<b>&#160;Handles</b></a><br/>
The code in Listing 16-1 not only stops the spawned thread prematurely most of the time<br/>due to the main thread ending, but because there is no guarantee on the order in which<br/>threads run, we also can’t guarantee that the spawned thread will get to run at all!<br/>
https://doc.rust-lang.org/book/print.html<br/>
435/627<br/>
<hr/>
<a name=436></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We can&#160;ﬁx the problem of the spawned thread not running or ending prematurely by saving<br/>the return value of&#160;&#160;thread::spawn&#160;&#160;in a variable. The return type of&#160;&#160;thread::spawn&#160;&#160;is<br/>
JoinHandle&#160;. A&#160;&#160;JoinHandle&#160;&#160;is an owned value that, when we call the&#160;&#160;join&#160;&#160;method on it,<br/>
will wait for its thread to&#160;ﬁnish. Listing 16-2 shows how to use the&#160;&#160;JoinHandle&#160;&#160;of the thread<br/>we created in Listing 16-1 and call&#160;&#160;join&#160;&#160;to make sure the spawned thread&#160;ﬁnishes before<br/>
main&#160;&#160;exits:<br/>
Filename: src/main.rs<br/>
use&#160;std::thread;<br/>use&#160;std::time::Duration;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;i&#160;in&#160;1..10&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;hi&#160;number&#160;{}&#160;from&#160;the&#160;spawned&#160;thread!&#34;,&#160;i);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::sleep(Duration::from_millis(1));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;for&#160;i&#160;in&#160;1..5&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;hi&#160;number&#160;{}&#160;from&#160;the&#160;main&#160;thread!&#34;,&#160;i);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::sleep(Duration::from_millis(1));<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;handle.join().unwrap();<br/>}<br/>
<b>Listing&#160;16-2:&#160;Saving&#160;a&#160;&#160;</b>JoinHandle&#160;<b>&#160;from&#160;&#160;</b>thread::spawn&#160;<b>&#160;to&#160;guarantee&#160;the&#160;thread&#160;is&#160;run&#160;to&#160;completion</b><br/>
Calling&#160;&#160;join&#160;&#160;on the handle blocks the thread currently running until the thread<br/>represented by the handle terminates.&#160;<i>Blocking</i>&#160;a thread means that thread is prevented<br/>from performing work or exiting. Because we’ve put the call to&#160;&#160;join&#160;&#160;after the main thread’s<br/>
for&#160;&#160;loop, running Listing 16-2 should produce output similar to this:<br/>
hi&#160;number&#160;1&#160;from&#160;the&#160;main&#160;thread!<br/>hi&#160;number&#160;2&#160;from&#160;the&#160;main&#160;thread!<br/>hi&#160;number&#160;1&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;3&#160;from&#160;the&#160;main&#160;thread!<br/>hi&#160;number&#160;2&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;4&#160;from&#160;the&#160;main&#160;thread!<br/>hi&#160;number&#160;3&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;4&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;5&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;6&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;7&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;8&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;9&#160;from&#160;the&#160;spawned&#160;thread!<br/>
The two threads continue alternating, but the main thread waits because of the call to<br/>
handle.join()&#160;&#160;and does not end until the spawned thread is&#160;ﬁnished.<br/>
https://doc.rust-lang.org/book/print.html<br/>
436/627<br/>
<hr/>
<a name=437></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
But let’s see what happens when we instead move&#160;&#160;handle.join()&#160;&#160;before the&#160;&#160;for&#160;&#160;loop in<br/>
main&#160;, like this:<br/>
Filename: src/main.rs<br/>
use&#160;std::thread;<br/>use&#160;std::time::Duration;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;i&#160;in&#160;1..10&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;hi&#160;number&#160;{}&#160;from&#160;the&#160;spawned&#160;thread!&#34;,&#160;i);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::sleep(Duration::from_millis(1));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;handle.join().unwrap();<br/>
&#160;&#160;&#160;&#160;for&#160;i&#160;in&#160;1..5&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;hi&#160;number&#160;{}&#160;from&#160;the&#160;main&#160;thread!&#34;,&#160;i);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::sleep(Duration::from_millis(1));<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
The main thread will wait for the spawned thread to&#160;ﬁnish and then run its&#160;&#160;for&#160;&#160;loop, so the<br/>output won’t be interleaved anymore, as shown here:<br/>
hi&#160;number&#160;1&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;2&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;3&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;4&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;5&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;6&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;7&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;8&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;9&#160;from&#160;the&#160;spawned&#160;thread!<br/>hi&#160;number&#160;1&#160;from&#160;the&#160;main&#160;thread!<br/>hi&#160;number&#160;2&#160;from&#160;the&#160;main&#160;thread!<br/>hi&#160;number&#160;3&#160;from&#160;the&#160;main&#160;thread!<br/>hi&#160;number&#160;4&#160;from&#160;the&#160;main&#160;thread!<br/>
Small details, such as where&#160;&#160;join&#160;&#160;is called, can aﬀect whether or not your threads run at<br/>the same time.<br/>
<a href="tests.html#437"><b>Using&#160;</b>move<b>&#160;Closures&#160;with&#160;Threads</b></a><br/>
We'll often use the&#160;&#160;move&#160;&#160;keyword with closures passed to&#160;&#160;thread::spawn&#160;&#160;because the<br/>closure will then take ownership of the values it uses from the environment, thus<br/><a href="https://doc.rust-lang.org/book/ch13-01-closures.html#capturing-references-or-moving-ownership">transferring ownership of those values from one thread to another. In the&#160;“Capturing<br/>References or Moving Ownership”&#160;section of Chapter 13, we discussed&#160;&#160;move&#160;&#160;in the context</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
437/627<br/>
<hr/>
<a name=438></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
of closures. Now, we’ll concentrate more on the interaction between&#160;&#160;move&#160;&#160;and<br/>
thread::spawn&#160;.<br/>
Notice in Listing 16-1 that the closure we pass to&#160;&#160;thread::spawn&#160;&#160;takes no arguments: we’re<br/>not using any data from the main thread in the spawned thread’s code. To use data from<br/>the main thread in the spawned thread, the spawned thread’s closure must capture the<br/>values it needs. Listing 16-3 shows an attempt to create a vector in the main thread and use<br/>it in the spawned thread. However, this won’t yet work, as you’ll see in a moment.<br/>
Filename: src/main.rs<br/>
use&#160;std::thread;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;v&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>
&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Here's&#160;a&#160;vector:&#160;{:?}&#34;,&#160;v);<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;handle.join().unwrap();<br/>}<br/>
<b>Listing&#160;16-3:&#160;Attempting&#160;to&#160;use&#160;a&#160;vector&#160;created&#160;by&#160;the&#160;main&#160;thread&#160;in&#160;another&#160;thread</b><br/>
The closure uses&#160;&#160;v&#160;, so it will capture&#160;&#160;v&#160;&#160;and make it part of the closure’s environment.<br/>Because&#160;&#160;thread::spawn&#160;&#160;runs this closure in a new thread, we should be able to access&#160;&#160;v<br/>inside that new thread. But when we compile this example, we get the following error:<br/>
https://doc.rust-lang.org/book/print.html<br/>
438/627<br/>
<hr/>
<a name=439></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;threads&#160;v0.1.0&#160;(file:///projects/threads)<br/>error[E0373]:&#160;closure&#160;may&#160;outlive&#160;the&#160;current&#160;function,&#160;but&#160;it&#160;borrows&#160;`v`,&#160;<br/>which&#160;is&#160;owned&#160;by&#160;the&#160;current&#160;function<br/>&#160;--&gt;&#160;src/main.rs:6:32<br/>&#160;&#160;|<br/>6&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(||&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^&#160;may&#160;outlive&#160;borrowed&#160;value&#160;`v`<br/>7&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Here's&#160;a&#160;vector:&#160;{:?}&#34;,&#160;v);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&#160;`v`&#160;is&#160;borrowed&#160;here<br/>&#160;&#160;|<br/>note:&#160;function&#160;requires&#160;argument&#160;type&#160;to&#160;outlive&#160;`'static`<br/>&#160;--&gt;&#160;src/main.rs:6:18<br/>&#160;&#160;|<br/>6&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(||&#160;{<br/>&#160;&#160;|&#160;&#160;__________________^<br/>7&#160;|&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Here's&#160;a&#160;vector:&#160;{:?}&#34;,&#160;v);<br/>8&#160;|&#160;|&#160;&#160;&#160;&#160;&#160;});<br/>&#160;&#160;|&#160;|______^<br/>help:&#160;to&#160;force&#160;the&#160;closure&#160;to&#160;take&#160;ownership&#160;of&#160;`v`&#160;(and&#160;any&#160;other&#160;referenced&#160;<br/>variables),&#160;use&#160;the&#160;`move`&#160;keyword<br/>&#160;&#160;|<br/>6&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++++<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0373`.<br/>error:&#160;could&#160;not&#160;compile&#160;`threads`&#160;due&#160;to&#160;previous&#160;error<br/>
Rust&#160;<i>infers</i>&#160;how to capture&#160;&#160;v&#160;, and because&#160;&#160;println!&#160;&#160;only needs a reference to&#160;&#160;v&#160;, the<br/>closure tries to borrow&#160;&#160;v&#160;. However, there’s a problem: Rust can’t tell how long the spawned<br/>thread will run, so it doesn’t know if the reference to&#160;&#160;v&#160;&#160;will always be valid.<br/>
Listing 16-4 provides a scenario that’s more likely to have a reference to&#160;&#160;v&#160;&#160;that won’t be<br/>valid:<br/>
Filename: src/main.rs<br/>
use&#160;std::thread;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;v&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>
&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Here's&#160;a&#160;vector:&#160;{:?}&#34;,&#160;v);<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;drop(v);&#160;//&#160;oh&#160;no!<br/>
&#160;&#160;&#160;&#160;handle.join().unwrap();<br/>}<br/>
<b>Listing&#160;16-4:&#160;A&#160;thread&#160;with&#160;a&#160;closure&#160;that&#160;attempts&#160;to&#160;capture&#160;a&#160;reference&#160;to&#160;&#160;</b>v&#160;<b>&#160;from&#160;a&#160;main&#160;thread&#160;that&#160;drops</b><br/>
v<br/>
https://doc.rust-lang.org/book/print.html<br/>
439/627<br/>
<hr/>
<a name=440></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
If Rust allowed us to run this code, there’s a possibility the spawned thread would be<br/>immediately put in the background without running at all. The spawned thread has a<br/>reference to&#160;&#160;v&#160;&#160;inside, but the main thread immediately drops&#160;&#160;v&#160;, using the&#160;&#160;drop&#160;&#160;function<br/>we discussed in Chapter 15. Then, when the spawned thread starts to execute,&#160;&#160;v&#160;&#160;is no<br/>longer valid, so a reference to it is also invalid. Oh no!<br/>
To&#160;ﬁx the compiler error in Listing 16-3, we can use the error message’s advice:<br/>
help:&#160;to&#160;force&#160;the&#160;closure&#160;to&#160;take&#160;ownership&#160;of&#160;`v`&#160;(and&#160;any&#160;other&#160;referenced&#160;<br/>variables),&#160;use&#160;the&#160;`move`&#160;keyword<br/>&#160;&#160;|<br/>6&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++++<br/>
By adding the&#160;&#160;move&#160;&#160;keyword before the closure, we force the closure to take ownership of<br/>the values it’s using rather than allowing Rust to infer that it should borrow the values. The<br/>modiﬁcation to Listing 16-3 shown in Listing 16-5 will compile and run as we intend:<br/>
Filename: src/main.rs<br/>
use&#160;std::thread;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;v&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>
&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Here's&#160;a&#160;vector:&#160;{:?}&#34;,&#160;v);<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;handle.join().unwrap();<br/>}<br/>
<b>Listing&#160;16-5:&#160;Using&#160;the&#160;&#160;</b>move&#160;<b>&#160;keyword&#160;to&#160;force&#160;a&#160;closure&#160;to&#160;take&#160;ownership&#160;of&#160;the&#160;values&#160;it&#160;uses</b><br/>
We might be tempted to try the same thing to&#160;ﬁx the code in Listing 16-4 where the main<br/>thread called&#160;&#160;drop&#160;&#160;by using a&#160;&#160;move&#160;&#160;closure. However, this&#160;ﬁx will not work because what<br/>Listing 16-4 is trying to do is disallowed for a diﬀerent reason. If we added&#160;&#160;move&#160;&#160;to the<br/>closure, we would move&#160;&#160;v&#160;&#160;into the closure’s environment, and we could no longer call<br/>
drop&#160;&#160;on it in the main thread. We would get this compiler error instead:<br/>
https://doc.rust-lang.org/book/print.html<br/>
440/627<br/>
<hr/>
<a name=441></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;threads&#160;v0.1.0&#160;(file:///projects/threads)<br/>error[E0382]:&#160;use&#160;of&#160;moved&#160;value:&#160;`v`<br/>&#160;&#160;--&gt;&#160;src/main.rs:10:10<br/>&#160;&#160;&#160;|<br/>4&#160;&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;v&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&#160;move&#160;occurs&#160;because&#160;`v`&#160;has&#160;type&#160;`Vec&lt;i32&gt;`,&#160;which&#160;does&#160;not&#160;<br/>implement&#160;the&#160;`Copy`&#160;trait<br/>5&#160;&#160;|<br/>6&#160;&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-------&#160;value&#160;moved&#160;into&#160;closure&#160;here<br/>7&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Here's&#160;a&#160;vector:&#160;{:?}&#34;,&#160;v);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&#160;variable&#160;moved&#160;due&#160;to&#160;use&#160;in&#160;<br/>closure<br/>...<br/>10&#160;|&#160;&#160;&#160;&#160;&#160;drop(v);&#160;//&#160;oh&#160;no!<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^&#160;value&#160;used&#160;here&#160;after&#160;move<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0382`.<br/>error:&#160;could&#160;not&#160;compile&#160;`threads`&#160;due&#160;to&#160;previous&#160;error<br/>
Rust’s ownership rules have saved us again! We got an error from the code in Listing 16-3<br/>because Rust was being conservative and only borrowing&#160;&#160;v&#160;&#160;for the thread, which meant<br/>the main thread could theoretically invalidate the spawned thread’s reference. By telling<br/>Rust to move ownership of&#160;&#160;v&#160;&#160;to the spawned thread, we’re guaranteeing Rust that the<br/>main thread won’t use&#160;&#160;v&#160;&#160;anymore. If we change Listing 16-4 in the same way, we’re then<br/>violating the ownership rules when we try to use&#160;&#160;v&#160;&#160;in the main thread. The&#160;&#160;move&#160;&#160;keyword<br/>overrides Rust’s conservative default of borrowing; it doesn’t let us violate the ownership<br/>rules.<br/>
With a basic understanding of threads and the thread API, let’s look at what we can&#160;<i>do</i>&#160;with<br/>threads.<br/>
https://doc.rust-lang.org/book/print.html<br/>
441/627<br/>
<hr/>
<a name=442></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#442"><b>Using Message Passing to Transfer Data Between<br/>Threads</b></a><br/>
One increasingly popular approach to ensuring safe concurrency is&#160;<i>message passing</i>, where<br/>threads or actors communicate by sending each other messages containing data. Here’s the<br/>idea in a slogan from&#160;<a href="https://golang.org/doc/effective_go.html#concurrency">the Go language documentation: “Do not communicate by sharing<br/></a>memory; instead, share memory by communicating.”<br/>
To accomplish message-sending concurrency, Rust's standard library provides an<br/>implementation of&#160;<i>channels</i>. A channel is a general programming concept by which data is<br/>sent from one thread to another.<br/>
You can imagine a channel in programming as being like a directional channel of water,<br/>such as a stream or a river. If you put something like a rubber duck into a river, it will travel<br/>downstream to the end of the waterway.<br/>
A channel has two halves: a transmitter and a receiver. The transmitter half is the upstream<br/>location where you put rubber ducks into the river, and the receiver half is where the<br/>rubber duck ends up downstream. One part of your code calls methods on the transmitter<br/>with the data you want to send, and another part checks the receiving end for arriving<br/>messages. A channel is said to be&#160;<i>closed</i>&#160;if either the transmitter or receiver half is dropped.<br/>
Here, we’ll work up to a program that has one thread to generate values and send them<br/>down a channel, and another thread that will receive the values and print them out. We’ll be<br/>sending simple values between threads using a channel to illustrate the feature. Once<br/>you’re familiar with the technique, you could use channels for any threads that need to<br/>communicate between each other, such as a chat system or a system where many threads<br/>perform parts of a calculation and send the parts to one thread that aggregates the results.<br/>
First, in Listing 16-6, we’ll create a channel but not do anything with it. Note that this won’t<br/>compile yet because Rust can’t tell what type of values we want to send over the channel.<br/>
Filename: src/main.rs<br/>
use&#160;std::sync::mpsc;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;(tx,&#160;rx)&#160;=&#160;mpsc::channel();<br/>}<br/>
<b>Listing&#160;16-6:&#160;Creating&#160;a&#160;channel&#160;and&#160;assigning&#160;the&#160;two&#160;halves&#160;to&#160;&#160;</b>tx&#160;<b>&#160;and&#160;&#160;</b>rx<br/>
We create a new channel using the&#160;&#160;mpsc::channel&#160;&#160;function;&#160;&#160;mpsc&#160;&#160;stands for&#160;<i>multiple<br/>producer, single consumer</i>. In short, the way Rust’s standard library implements channels<br/>
https://doc.rust-lang.org/book/print.html<br/>
442/627<br/>
<hr/>
<a name=443></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
means a channel can have multiple&#160;<i>sending</i>&#160;ends that produce values but only one&#160;<i>receiving<br/></i>end that consumes those values. Imagine multiple streams&#160;ﬂowing together into one big<br/>river: everything sent down any of the streams will end up in one river at the end. We’ll start<br/>with a single producer for now, but we’ll add multiple producers when we get this example<br/>working.<br/>
The&#160;&#160;mpsc::channel&#160;&#160;function returns a tuple, the&#160;ﬁrst element of which is the sending end--<br/>the transmitter--and the second element is the receiving end--the receiver. The<br/>abbreviations&#160;&#160;tx&#160;&#160;and&#160;&#160;rx&#160;&#160;are traditionally used in many&#160;ﬁelds for&#160;<i>transmitter</i>&#160;and&#160;<i>receiver<br/></i>respectively, so we name our variables as such to indicate each end. We’re using a&#160;&#160;let<br/>statement with a pattern that destructures the tuples; we’ll discuss the use of patterns in<br/>
let&#160;&#160;statements and destructuring in Chapter 18. For now, know that using a&#160;&#160;let<br/>
statement this way is a convenient approach to extract the pieces of the tuple returned by<br/>
mpsc::channel&#160;.<br/>
Let’s move the transmitting end into a spawned thread and have it send one string so the<br/>spawned thread is communicating with the main thread, as shown in Listing 16-7. This is like<br/>putting a rubber duck in the river upstream or sending a chat message from one thread to<br/>another.<br/>
Filename: src/main.rs<br/>
use&#160;std::sync::mpsc;<br/>use&#160;std::thread;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;(tx,&#160;rx)&#160;=&#160;mpsc::channel();<br/>
&#160;&#160;&#160;&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;val&#160;=&#160;String::from(&#34;hi&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tx.send(val).unwrap();<br/>&#160;&#160;&#160;&#160;});<br/>}<br/>
<b>Listing&#160;16-7:&#160;Moving&#160;&#160;</b>tx&#160;<b>&#160;to&#160;a&#160;spawned&#160;thread&#160;and&#160;sending&#160;“hi”</b><br/>
Again, we’re using&#160;&#160;thread::spawn&#160;&#160;to create a new thread and then using&#160;&#160;move&#160;&#160;to move&#160;&#160;tx<br/>into the closure so the spawned thread owns&#160;&#160;tx&#160;. The spawned thread needs to own the<br/>transmitter to be able to send messages through the channel. The transmitter has a&#160;&#160;send<br/>method that takes the value we want to send. The&#160;&#160;send&#160;&#160;method returns a&#160;&#160;Result&lt;T,&#160;E&gt;<br/>type, so if the receiver has already been dropped and there’s nowhere to send a value, the<br/>send operation will return an error. In this example, we’re calling&#160;&#160;unwrap&#160;&#160;to panic in case of<br/>an error. But in a real application, we would handle it properly: return to Chapter 9 to review<br/>strategies for proper error handling.<br/>
In Listing 16-8, we’ll get the value from the receiver in the main thread. This is like retrieving<br/>the rubber duck from the water at the end of the river or receiving a chat message.<br/>
https://doc.rust-lang.org/book/print.html<br/>
443/627<br/>
<hr/>
<a name=444></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Filename: src/main.rs<br/>
use&#160;std::sync::mpsc;<br/>use&#160;std::thread;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;(tx,&#160;rx)&#160;=&#160;mpsc::channel();<br/>
&#160;&#160;&#160;&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;val&#160;=&#160;String::from(&#34;hi&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tx.send(val).unwrap();<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;let&#160;received&#160;=&#160;rx.recv().unwrap();<br/>&#160;&#160;&#160;&#160;println!(&#34;Got:&#160;{}&#34;,&#160;received);<br/>}<br/>
<b>Listing&#160;16-8:&#160;Receiving&#160;the&#160;value&#160;“hi”&#160;in&#160;the&#160;main&#160;thread&#160;and&#160;printing&#160;it</b><br/>
The receiver has two useful methods:&#160;&#160;recv&#160;&#160;and&#160;&#160;try_recv&#160;. We’re using&#160;&#160;recv&#160;, short for<br/><i>receive</i>, which will block the main thread’s execution and wait until a value is sent down the<br/>channel. Once a value is sent,&#160;&#160;recv&#160;&#160;will return it in a&#160;&#160;Result&lt;T,&#160;E&gt;&#160;. When the transmitter<br/>closes,&#160;&#160;recv&#160;&#160;will return an error to signal that no more values will be coming.<br/>
The&#160;&#160;try_recv&#160;&#160;method doesn’t block, but will instead return a&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;immediately:<br/>an&#160;&#160;Ok&#160;&#160;value holding a message if one is available and an&#160;&#160;Err&#160;&#160;value if there aren’t any<br/>messages this time. Using&#160;&#160;try_recv&#160;&#160;is useful if this thread has other work to do while<br/>waiting for messages: we could write a loop that calls&#160;&#160;try_recv&#160;&#160;every so often, handles a<br/>message if one is available, and otherwise does other work for a little while until checking<br/>again.<br/>
We’ve used&#160;&#160;recv&#160;&#160;in this example for simplicity; we don’t have any other work for the main<br/>thread to do other than wait for messages, so blocking the main thread is appropriate.<br/>
When we run the code in Listing 16-8, we’ll see the value printed from the main thread:<br/>
Got:&#160;hi<br/>
Perfect!<br/>
<a href="tests.html#444"><b>Channels&#160;and&#160;Ownership&#160;Transference</b></a><br/>
The ownership rules play a vital role in message sending because they help you write safe,<br/>concurrent code. Preventing errors in concurrent programming is the advantage of thinking<br/>about ownership throughout your Rust programs. Let’s do an experiment to show how<br/>channels and ownership work together to prevent problems: we’ll try to use a&#160;&#160;val&#160;&#160;value in<br/>
https://doc.rust-lang.org/book/print.html<br/>
444/627<br/>
<hr/>
<a name=445></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
the spawned thread&#160;<i>after</i>&#160;we’ve sent it down the channel. Try compiling the code in Listing<br/>16-9 to see why this code isn’t allowed:<br/>
Filename: src/main.rs<br/>
use&#160;std::sync::mpsc;<br/>use&#160;std::thread;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;(tx,&#160;rx)&#160;=&#160;mpsc::channel();<br/>
&#160;&#160;&#160;&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;val&#160;=&#160;String::from(&#34;hi&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tx.send(val).unwrap();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;val&#160;is&#160;{}&#34;,&#160;val);<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;let&#160;received&#160;=&#160;rx.recv().unwrap();<br/>&#160;&#160;&#160;&#160;println!(&#34;Got:&#160;{}&#34;,&#160;received);<br/>}<br/>
<b>Listing&#160;16-9:&#160;Attempting&#160;to&#160;use&#160;&#160;</b>val&#160;<b>&#160;after&#160;we’ve&#160;sent&#160;it&#160;down&#160;the&#160;channel</b><br/>
Here, we try to print&#160;&#160;val&#160;&#160;after we’ve sent it down the channel via&#160;&#160;tx.send&#160;. Allowing this<br/>would be a bad idea: once the value has been sent to another thread, that thread could<br/>modify or drop it before we try to use the value again. Potentially, the other thread’s<br/>modiﬁcations could cause errors or unexpected results due to inconsistent or nonexistent<br/>data. However, Rust gives us an error if we try to compile the code in Listing 16-9:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;message-passing&#160;v0.1.0&#160;(file:///projects/message-passing)<br/>error[E0382]:&#160;borrow&#160;of&#160;moved&#160;value:&#160;`val`<br/>&#160;&#160;--&gt;&#160;src/main.rs:10:31<br/>&#160;&#160;&#160;|<br/>8&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;val&#160;=&#160;String::from(&#34;hi&#34;);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;---&#160;move&#160;occurs&#160;because&#160;`val`&#160;has&#160;type&#160;`String`,&#160;which&#160;does&#160;<br/>not&#160;implement&#160;the&#160;`Copy`&#160;trait<br/>9&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tx.send(val).unwrap();<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;---&#160;value&#160;moved&#160;here<br/>10&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;val&#160;is&#160;{}&#34;,&#160;val);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^&#160;value&#160;borrowed&#160;here&#160;after&#160;move<br/>&#160;&#160;&#160;|<br/>&#160;&#160;&#160;=&#160;note:&#160;this&#160;error&#160;originates&#160;in&#160;the&#160;macro&#160;`$crate::format_args_nl`&#160;which&#160;<br/>comes&#160;from&#160;the&#160;expansion&#160;of&#160;the&#160;macro&#160;`println`&#160;(in&#160;Nightly&#160;builds,&#160;run&#160;with&#160;-Z&#160;<br/>macro-backtrace&#160;for&#160;more&#160;info)<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0382`.<br/>error:&#160;could&#160;not&#160;compile&#160;`message-passing`&#160;due&#160;to&#160;previous&#160;error<br/>
Our concurrency mistake has caused a compile time error. The&#160;&#160;send&#160;&#160;function takes<br/>ownership of its parameter, and when the value is moved, the receiver takes ownership of<br/>
https://doc.rust-lang.org/book/print.html<br/>
445/627<br/>
<hr/>
<a name=446></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
it. This stops us from accidentally using the value again after sending it; the ownership<br/>system checks that everything is okay.<br/>
<a href="tests.html#446"><b>Sending&#160;Multiple&#160;Values&#160;and&#160;Seeing&#160;the&#160;Receiver&#160;Waiting</b></a><br/>
The code in Listing 16-8 compiled and ran, but it didn’t clearly show us that two separate<br/>threads were talking to each other over the channel. In Listing 16-10 we’ve made some<br/>modiﬁcations that will prove the code in Listing 16-8 is running concurrently: the spawned<br/>thread will now send multiple messages and pause for a second between each message.<br/>
Filename: src/main.rs<br/>
use&#160;std::sync::mpsc;<br/>use&#160;std::thread;<br/>use&#160;std::time::Duration;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;(tx,&#160;rx)&#160;=&#160;mpsc::channel();<br/>
&#160;&#160;&#160;&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;vals&#160;=&#160;vec![<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;hi&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;from&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;the&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;thread&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;];<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;val&#160;in&#160;vals&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tx.send(val).unwrap();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::sleep(Duration::from_secs(1));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;for&#160;received&#160;in&#160;rx&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Got:&#160;{}&#34;,&#160;received);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;16-10:&#160;Sending&#160;multiple&#160;messages&#160;and&#160;pausing&#160;between&#160;each</b><br/>
This time, the spawned thread has a vector of strings that we want to send to the main<br/>thread. We iterate over them, sending each individually, and pause between each by calling<br/>the&#160;&#160;thread::sleep&#160;&#160;function with a&#160;&#160;Duration&#160;&#160;value of 1 second.<br/>
In the main thread, we’re not calling the&#160;&#160;recv&#160;&#160;function explicitly anymore: instead, we’re<br/>treating&#160;&#160;rx&#160;&#160;as an iterator. For each value received, we’re printing it. When the channel is<br/>closed, iteration will end.<br/>
When running the code in Listing 16-10, you should see the following output with a 1-<br/>second pause in between each line:<br/>
https://doc.rust-lang.org/book/print.html<br/>
446/627<br/>
<hr/>
<a name=447></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Got:&#160;hi<br/>Got:&#160;from<br/>Got:&#160;the<br/>Got:&#160;thread<br/>
Because we don’t have any code that pauses or delays in the&#160;&#160;for&#160;&#160;loop in the main thread,<br/>we can tell that the main thread is waiting to receive values from the spawned thread.<br/>
<a href="tests.html#447"><b>Creating&#160;Multiple&#160;Producers&#160;by&#160;Cloning&#160;the&#160;Transmitter</b></a><br/>
Earlier we mentioned that&#160;&#160;mpsc&#160;&#160;was an acronym for&#160;<i>multiple producer, single consumer</i>. Let’s<br/>put&#160;&#160;mpsc&#160;&#160;to use and expand the code in Listing 16-10 to create multiple threads that all<br/>send values to the same receiver. We can do so by cloning the transmitter, as shown in<br/>Listing 16-11:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
447/627<br/>
<hr/>
<a name=448></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;let&#160;(tx,&#160;rx)&#160;=&#160;mpsc::channel();<br/>
&#160;&#160;&#160;&#160;let&#160;tx1&#160;=&#160;tx.clone();<br/>&#160;&#160;&#160;&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;vals&#160;=&#160;vec![<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;hi&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;from&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;the&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;thread&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;];<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;val&#160;in&#160;vals&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tx1.send(val).unwrap();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::sleep(Duration::from_secs(1));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;vals&#160;=&#160;vec![<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;more&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;messages&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;for&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;you&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;];<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;val&#160;in&#160;vals&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tx.send(val).unwrap();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::sleep(Duration::from_secs(1));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;for&#160;received&#160;in&#160;rx&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Got:&#160;{}&#34;,&#160;received);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
<b>Listing&#160;16-11:&#160;Sending&#160;multiple&#160;messages&#160;from&#160;multiple&#160;producers</b><br/>
This time, before we create the&#160;ﬁrst spawned thread, we call&#160;&#160;clone&#160;&#160;on the transmitter. This<br/>will give us a new transmitter we can pass to the&#160;ﬁrst spawned thread. We pass the original<br/>transmitter to a second spawned thread. This gives us two threads, each sending diﬀerent<br/>messages to the one receiver.<br/>
When you run the code, your output should look something like this:<br/>
https://doc.rust-lang.org/book/print.html<br/>
448/627<br/>
<hr/>
<a name=449></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Got:&#160;hi<br/>Got:&#160;more<br/>Got:&#160;from<br/>Got:&#160;messages<br/>Got:&#160;for<br/>Got:&#160;the<br/>Got:&#160;thread<br/>Got:&#160;you<br/>
You might see the values in another order, depending on your system. This is what makes<br/>concurrency interesting as well as diﬃcult. If you experiment with&#160;&#160;thread::sleep&#160;, giving it<br/>various values in the diﬀerent threads, each run will be more nondeterministic and create<br/>diﬀerent output each time.<br/>
Now that we’ve looked at how channels work, let’s look at a diﬀerent method of<br/>concurrency.<br/>
https://doc.rust-lang.org/book/print.html<br/>
449/627<br/>
<hr/>
<a name=450></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#450"><b>Shared-State Concurrency</b></a><br/>
Message passing is a&#160;ﬁne way of handling concurrency, but it’s not the only one. Another<br/>method would be for multiple threads to access the same shared data. Consider this part of<br/>the slogan from the Go language documentation again: “do not communicate by sharing<br/>memory.”<br/>
What would communicating by sharing memory look like? In addition, why would message-<br/>passing enthusiasts caution not to use memory sharing?<br/>
In a way, channels in any programming language are similar to single ownership, because<br/>once you transfer a value down a channel, you should no longer use that value. Shared<br/>memory concurrency is like multiple ownership: multiple threads can access the same<br/>memory location at the same time. As you saw in Chapter 15, where smart pointers made<br/>multiple ownership possible, multiple ownership can add complexity because these<br/>diﬀerent owners need managing. Rust’s type system and ownership rules greatly assist in<br/>getting this management correct. For an example, let’s look at mutexes, one of the more<br/>common concurrency primitives for shared memory.<br/>
<a href="tests.html#450"><b>Using&#160;Mutexes&#160;to&#160;Allow&#160;Access&#160;to&#160;Data&#160;from&#160;One&#160;Thread&#160;at&#160;a&#160;Time</b></a><br/>
<i>Mutex</i>&#160;is an abbreviation for&#160;<i>mutual exclusion</i>, as in, a mutex allows only one thread to access<br/>some data at any given time. To access the data in a mutex, a thread must&#160;ﬁrst signal that it<br/>wants access by asking to acquire the mutex’s&#160;<i>lock</i>. The lock is a data structure that is part of<br/>the mutex that keeps track of who currently has exclusive access to the data. Therefore, the<br/>mutex is described as&#160;<i>guarding</i>&#160;the data it holds via the locking system.<br/>
Mutexes have a reputation for being diﬃcult to use because you have to remember two<br/>rules:<br/>
You must attempt to acquire the lock before using the data.<br/>When you’re done with the data that the mutex guards, you must unlock the data so<br/>other threads can acquire the lock.<br/>
For a real-world metaphor for a mutex, imagine a panel discussion at a conference with only<br/>one microphone. Before a panelist can speak, they have to ask or signal that they want to<br/>use the microphone. When they get the microphone, they can talk for as long as they want<br/>to and then hand the microphone to the next panelist who requests to speak. If a panelist<br/>forgets to hand the microphone oﬀ&#160;when they’re&#160;ﬁnished with it, no one else is able to<br/>speak. If management of the shared microphone goes wrong, the panel won’t work as<br/>planned!<br/>
https://doc.rust-lang.org/book/print.html<br/>
450/627<br/>
<hr/>
<a name=451></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Management of mutexes can be incredibly tricky to get right, which is why so many people<br/>are enthusiastic about channels. However, thanks to Rust’s type system and ownership<br/>rules, you can’t get locking and unlocking wrong.<br/>
<a href="tests.html#451"><b>The API of&#160;</b>Mutex&lt;T&gt;</a><br/>
As an example of how to use a mutex, let’s start by using a mutex in a single-threaded<br/>context, as shown in Listing 16-12:<br/>
Filename: src/main.rs<br/>
use&#160;std::sync::Mutex;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;m&#160;=&#160;Mutex::new(5);<br/>
&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;num&#160;=&#160;m.lock().unwrap();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*num&#160;=&#160;6;<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;m&#160;=&#160;{:?}&#34;,&#160;m);<br/>}<br/>
<b>Listing&#160;16-12:&#160;Exploring&#160;the&#160;API&#160;of&#160;&#160;</b>Mutex&lt;T&gt;&#160;<b>&#160;in&#160;a&#160;single-threaded&#160;context&#160;for&#160;simplicity</b><br/>
As with many types, we create a&#160;&#160;Mutex&lt;T&gt;&#160;&#160;using the associated function&#160;&#160;new&#160;. To access the<br/>data inside the mutex, we use the&#160;&#160;lock&#160;&#160;method to acquire the lock. This call will block the<br/>current thread so it can’t do any work until it’s our turn to have the lock.<br/>
The call to&#160;&#160;lock&#160;&#160;would fail if another thread holding the lock panicked. In that case, no one<br/>would ever be able to get the lock, so we’ve chosen to&#160;&#160;unwrap&#160;&#160;and have this thread panic if<br/>we’re in that situation.<br/>
After we’ve acquired the lock, we can treat the return value, named&#160;&#160;num&#160;&#160;in this case, as a<br/>mutable reference to the data inside. The type system ensures that we acquire a lock before<br/>using the value in&#160;&#160;m&#160;. The type of&#160;&#160;m&#160;&#160;is&#160;&#160;Mutex&lt;i32&gt;&#160;, not&#160;&#160;i32&#160;, so we&#160;<i>must</i>&#160;call&#160;&#160;lock&#160;&#160;to be<br/>able to use the&#160;&#160;i32&#160;&#160;value. We can’t forget; the type system won’t let us access the inner<br/>
i32&#160;&#160;otherwise.<br/>
As you might suspect,&#160;&#160;Mutex&lt;T&gt;&#160;&#160;is a smart pointer. More accurately, the call to&#160;&#160;lock<br/><i>returns</i>&#160;a smart pointer called&#160;&#160;MutexGuard&#160;, wrapped in a&#160;&#160;LockResult&#160;&#160;that we handled with<br/>the call to&#160;&#160;unwrap&#160;. The&#160;&#160;MutexGuard&#160;&#160;smart pointer implements&#160;&#160;Deref&#160;&#160;to point at our inner<br/>data; the smart pointer also has a&#160;&#160;Drop&#160;&#160;implementation that releases the lock automatically<br/>when a&#160;&#160;MutexGuard&#160;&#160;goes out of scope, which happens at the end of the inner scope. As a<br/>result, we don’t risk forgetting to release the lock and blocking the mutex from being used<br/>by other threads, because the lock release happens automatically.<br/>
https://doc.rust-lang.org/book/print.html<br/>
451/627<br/>
<hr/>
<a name=452></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
After dropping the lock, we can print the mutex value and see that we were able to change<br/>the inner&#160;&#160;i32&#160;&#160;to 6.<br/>
<a href="tests.html#452"><b>Sharing a&#160;</b>Mutex&lt;T&gt;<b>&#160;Between Multiple Threads</b></a><br/>
Now, let’s try to share a value between multiple threads using&#160;&#160;Mutex&lt;T&gt;&#160;. We’ll spin up 10<br/>threads and have them each increment a counter value by 1, so the counter goes from 0 to<br/>10. The next example in Listing 16-13 will have a compiler error, and we’ll use that error to<br/>learn more about using&#160;&#160;Mutex&lt;T&gt;&#160;&#160;and how Rust helps us use it correctly.<br/>
Filename: src/main.rs<br/>
use&#160;std::sync::Mutex;<br/>use&#160;std::thread;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;counter&#160;=&#160;Mutex::new(0);<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;handles&#160;=&#160;vec![];<br/>
&#160;&#160;&#160;&#160;for&#160;_&#160;in&#160;0..10&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;num&#160;=&#160;counter.lock().unwrap();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*num&#160;+=&#160;1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handles.push(handle);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;for&#160;handle&#160;in&#160;handles&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handle.join().unwrap();<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;Result:&#160;{}&#34;,&#160;*counter.lock().unwrap());<br/>}<br/>
<b>Listing&#160;16-13:&#160;Ten&#160;threads&#160;each&#160;increment&#160;a&#160;counter&#160;guarded&#160;by&#160;a&#160;&#160;</b>Mutex&lt;T&gt;<br/>
We create a&#160;&#160;counter&#160;&#160;variable to hold an&#160;&#160;i32&#160;&#160;inside a&#160;&#160;Mutex&lt;T&gt;&#160;, as we did in Listing 16-12.<br/>Next, we create 10 threads by iterating over a range of numbers. We use&#160;&#160;thread::spawn<br/>and give all the threads the same closure: one that moves the counter into the thread,<br/>acquires a lock on the&#160;&#160;Mutex&lt;T&gt;&#160;&#160;by calling the&#160;&#160;lock&#160;&#160;method, and then adds 1 to the value<br/>in the mutex. When a thread&#160;ﬁnishes running its closure,&#160;&#160;num&#160;&#160;will go out of scope and<br/>release the lock so another thread can acquire it.<br/>
In the main thread, we collect all the join handles. Then, as we did in Listing 16-2, we call<br/>
join&#160;&#160;on each handle to make sure all the threads&#160;ﬁnish. At that point, the main thread will<br/>
acquire the lock and print the result of this program.<br/>
We hinted that this example wouldn’t compile. Now let’s&#160;ﬁnd out why!<br/>
https://doc.rust-lang.org/book/print.html<br/>
452/627<br/>
<hr/>
<a name=453></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;shared-state&#160;v0.1.0&#160;(file:///projects/shared-state)<br/>error[E0382]:&#160;use&#160;of&#160;moved&#160;value:&#160;`counter`<br/>&#160;&#160;--&gt;&#160;src/main.rs:9:36<br/>&#160;&#160;&#160;|<br/>5&#160;&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;counter&#160;=&#160;Mutex::new(0);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-------&#160;move&#160;occurs&#160;because&#160;`counter`&#160;has&#160;type&#160;`Mutex&lt;i32&gt;`,&#160;which&#160;<br/>does&#160;not&#160;implement&#160;the&#160;`Copy`&#160;trait<br/>...<br/>9&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^&#160;value&#160;moved&#160;into&#160;closure&#160;here,&#160;<br/>in&#160;previous&#160;iteration&#160;of&#160;loop<br/>10&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;num&#160;=&#160;counter.lock().unwrap();<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-------&#160;use&#160;occurs&#160;due&#160;to&#160;use&#160;in&#160;closure<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0382`.<br/>error:&#160;could&#160;not&#160;compile&#160;`shared-state`&#160;due&#160;to&#160;previous&#160;error<br/>
The error message states that the&#160;&#160;counter&#160;&#160;value was moved in the previous iteration of the<br/>loop. Rust is telling us that we can’t move the ownership of lock&#160;&#160;counter&#160;&#160;into multiple<br/>threads. Let’s&#160;ﬁx the compiler error with a multiple-ownership method we discussed in<br/>Chapter 15.<br/>
<a href="tests.html#453"><b>Multiple Ownership with Multiple Threads</b></a><br/>
In Chapter 15, we gave a value multiple owners by using the smart pointer&#160;&#160;Rc&lt;T&gt;&#160;&#160;to create<br/>a reference counted value. Let’s do the same here and see what happens. We’ll wrap the<br/>
Mutex&lt;T&gt;&#160;&#160;in&#160;&#160;Rc&lt;T&gt;&#160;&#160;in Listing 16-14 and clone the&#160;&#160;Rc&lt;T&gt;&#160;&#160;before moving ownership to the<br/>
thread.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
453/627<br/>
<hr/>
<a name=454></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::rc::Rc;<br/>use&#160;std::sync::Mutex;<br/>use&#160;std::thread;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;counter&#160;=&#160;Rc::new(Mutex::new(0));<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;handles&#160;=&#160;vec![];<br/>
&#160;&#160;&#160;&#160;for&#160;_&#160;in&#160;0..10&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;counter&#160;=&#160;Rc::clone(&amp;counter);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;num&#160;=&#160;counter.lock().unwrap();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*num&#160;+=&#160;1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handles.push(handle);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;for&#160;handle&#160;in&#160;handles&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handle.join().unwrap();<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;Result:&#160;{}&#34;,&#160;*counter.lock().unwrap());<br/>}<br/>
<b>Listing&#160;16-14:&#160;Attempting&#160;to&#160;use&#160;&#160;</b>Rc&lt;T&gt;&#160;<b>&#160;to&#160;allow&#160;multiple&#160;threads&#160;to&#160;own&#160;the&#160;&#160;</b>Mutex&lt;T&gt;<br/>
Once again, we compile and get... diﬀerent errors! The compiler is teaching us a lot.<br/>
https://doc.rust-lang.org/book/print.html<br/>
454/627<br/>
<hr/>
<a name=455></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;shared-state&#160;v0.1.0&#160;(file:///projects/shared-state)<br/>error[E0277]:&#160;`Rc&lt;Mutex&lt;i32&gt;&gt;`&#160;cannot&#160;be&#160;sent&#160;between&#160;threads&#160;safely<br/>&#160;&#160;--&gt;&#160;src/main.rs:11:36<br/>&#160;&#160;&#160;|<br/>11&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-------------&#160;^------<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;&#160;|&#160;&#160;______________________|_____________within&#160;this&#160;<br/>`[closure@src/main.rs:11:36:&#160;11:43]`<br/>&#160;&#160;&#160;|&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;&#160;|&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;required&#160;by&#160;a&#160;bound&#160;introduced&#160;by&#160;this&#160;call<br/>12&#160;|&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;num&#160;=&#160;counter.lock().unwrap();<br/>13&#160;|&#160;|<br/>14&#160;|&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*num&#160;+=&#160;1;<br/>15&#160;|&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>&#160;&#160;&#160;|&#160;|_________^&#160;`Rc&lt;Mutex&lt;i32&gt;&gt;`&#160;cannot&#160;be&#160;sent&#160;between&#160;threads&#160;safely<br/>&#160;&#160;&#160;|<br/>&#160;&#160;&#160;=&#160;help:&#160;within&#160;`[closure@src/main.rs:11:36:&#160;11:43]`,&#160;the&#160;trait&#160;`Send`&#160;is&#160;not&#160;<br/>implemented&#160;for&#160;`Rc&lt;Mutex&lt;i32&gt;&gt;`<br/>note:&#160;required&#160;because&#160;it's&#160;used&#160;within&#160;this&#160;closure<br/>&#160;&#160;--&gt;&#160;src/main.rs:11:36<br/>&#160;&#160;&#160;|<br/>11&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^<br/>note:&#160;required&#160;by&#160;a&#160;bound&#160;in&#160;`spawn`<br/>&#160;&#160;--&gt;&#160;<br/>/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/mod.rs:7<br/>04:8<br/>&#160;&#160;&#160;|<br/>&#160;&#160;&#160;=&#160;note:&#160;required&#160;by&#160;this&#160;bound&#160;in&#160;`spawn`<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0277`.<br/>error:&#160;could&#160;not&#160;compile&#160;`shared-state`&#160;due&#160;to&#160;previous&#160;error<br/>
Wow, that error message is very wordy! Here’s the important part to focus on:<br/>
`Rc&lt;Mutex&lt;i32&gt;&gt;`&#160;cannot&#160;be&#160;sent&#160;between&#160;threads&#160;safely&#160;. The compiler is also telling<br/>
us the reason why:&#160;&#160;the&#160;trait&#160;`Send`&#160;is&#160;not&#160;implemented&#160;for&#160;`Rc&lt;Mutex&lt;i32&gt;&gt;`&#160;&#160;. We’ll<br/>talk about&#160;&#160;Send&#160;&#160;in the next section: it’s one of the traits that ensures the types we use with<br/>threads are meant for use in concurrent situations.<br/>
Unfortunately,&#160;&#160;Rc&lt;T&gt;&#160;&#160;is not safe to share across threads. When&#160;&#160;Rc&lt;T&gt;&#160;&#160;manages the<br/>reference count, it adds to the count for each call to&#160;&#160;clone&#160;&#160;and subtracts from the count<br/>when each clone is dropped. But it doesn’t use any concurrency primitives to make sure<br/>that changes to the count can’t be interrupted by another thread. This could lead to wrong<br/>counts—subtle bugs that could in turn lead to memory leaks or a value being dropped<br/>before we’re done with it. What we need is a type exactly like&#160;&#160;Rc&lt;T&gt;&#160;&#160;but one that makes<br/>changes to the reference count in a thread-safe way.<br/>
https://doc.rust-lang.org/book/print.html<br/>
455/627<br/>
<hr/>
<a name=456></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#456"><b>Atomic Reference Counting with&#160;</b>Arc&lt;T&gt;</a><br/>
Fortunately,&#160;&#160;Arc&lt;T&gt;&#160;&#160;<i>is</i>&#160;a type like&#160;&#160;Rc&lt;T&gt;&#160;&#160;that is safe to use in concurrent situations. The&#160;<i>a<br/></i>stands for&#160;<i>atomic</i>, meaning it’s an&#160;<i>atomically reference counted</i>&#160;type. Atomics are an<br/>additional kind of concurrency primitive that we won’t cover in detail here: see the standard<br/><a href="https://doc.rust-lang.org/std/sync/atomic/index.html">library documentation for&#160;&#160;std::sync::atomic&#160;&#160;for more details. At this point, you just need<br/></a>to know that atomics work like primitive types but are safe to share across threads.<br/>
You might then wonder why all primitive types aren’t atomic and why standard library types<br/>aren’t implemented to use&#160;&#160;Arc&lt;T&gt;&#160;&#160;by default. The reason is that thread safety comes with a<br/>performance penalty that you only want to pay when you really need to. If you’re just<br/>performing operations on values within a single thread, your code can run faster if it doesn’t<br/>have to enforce the guarantees atomics provide.<br/>
Let’s return to our example:&#160;&#160;Arc&lt;T&gt;&#160;&#160;and&#160;&#160;Rc&lt;T&gt;&#160;&#160;have the same API, so we&#160;ﬁx our program<br/>by changing the&#160;&#160;use&#160;&#160;line, the call to&#160;&#160;new&#160;, and the call to&#160;&#160;clone&#160;. The code in Listing 16-15<br/>will&#160;ﬁnally compile and run:<br/>
Filename: src/main.rs<br/>
use&#160;std::sync::{Arc,&#160;Mutex};<br/>use&#160;std::thread;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;counter&#160;=&#160;Arc::new(Mutex::new(0));<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;handles&#160;=&#160;vec![];<br/>
&#160;&#160;&#160;&#160;for&#160;_&#160;in&#160;0..10&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;counter&#160;=&#160;Arc::clone(&amp;counter);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;handle&#160;=&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;num&#160;=&#160;counter.lock().unwrap();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*num&#160;+=&#160;1;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handles.push(handle);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;for&#160;handle&#160;in&#160;handles&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handle.join().unwrap();<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;Result:&#160;{}&#34;,&#160;*counter.lock().unwrap());<br/>}<br/>
<b>Listing&#160;16-15:&#160;Using&#160;an&#160;&#160;</b>Arc&lt;T&gt;&#160;<b>&#160;to&#160;wrap&#160;the&#160;&#160;</b>Mutex&lt;T&gt;&#160;<b>&#160;to&#160;be&#160;able&#160;to&#160;share&#160;ownership&#160;across&#160;multiple&#160;threads</b><br/>
This code will print the following:<br/>
Result:&#160;10<br/>
https://doc.rust-lang.org/book/print.html<br/>
456/627<br/>
<hr/>
<a name=457></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We did it! We counted from 0 to 10, which may not seem very impressive, but it did teach us<br/>a lot about&#160;&#160;Mutex&lt;T&gt;&#160;&#160;and thread safety. You could also use this program’s structure to do<br/>more complicated operations than just incrementing a counter. Using this strategy, you can<br/>divide a calculation into independent parts, split those parts across threads, and then use a<br/>
Mutex&lt;T&gt;&#160;&#160;to have each thread update the&#160;ﬁnal result with its part.<br/>
Note that if you are doing simple numerical operations, there are types simpler than<br/>
Mutex&lt;T&gt;&#160;<a href="https://doc.rust-lang.org/std/sync/atomic/index.html">&#160;types provided by the&#160;&#160;std::sync::atomic&#160;&#160;module of the standard library</a>. These<br/>
types provide safe, concurrent, atomic access to primitive types. We chose to use&#160;&#160;Mutex&lt;T&gt;<br/>with a primitive type for this example so we could concentrate on how&#160;&#160;Mutex&lt;T&gt;&#160;&#160;works.<br/>
<a href="tests.html#457"><b>Similarities&#160;Between&#160;</b>RefCell&lt;T&gt;<b>/</b>Rc&lt;T&gt;<b>&#160;and&#160;</b>Mutex&lt;T&gt;<b>/</b>Arc&lt;T&gt;</a><br/>
You might have noticed that&#160;&#160;counter&#160;&#160;is immutable but we could get a mutable reference to<br/>the value inside it; this means&#160;&#160;Mutex&lt;T&gt;&#160;&#160;provides interior mutability, as the&#160;&#160;Cell&#160;&#160;family<br/>does. In the same way we used&#160;&#160;RefCell&lt;T&gt;&#160;&#160;in Chapter 15 to allow us to mutate contents<br/>inside an&#160;&#160;Rc&lt;T&gt;&#160;, we use&#160;&#160;Mutex&lt;T&gt;&#160;&#160;to mutate contents inside an&#160;&#160;Arc&lt;T&gt;&#160;.<br/>
Another detail to note is that Rust can’t protect you from all kinds of logic errors when you<br/>use&#160;&#160;Mutex&lt;T&gt;&#160;. Recall in Chapter 15 that using&#160;&#160;Rc&lt;T&gt;&#160;&#160;came with the risk of creating<br/>reference cycles, where two&#160;&#160;Rc&lt;T&gt;&#160;&#160;values refer to each other, causing memory leaks.<br/>Similarly,&#160;&#160;Mutex&lt;T&gt;&#160;&#160;comes with the risk of creating&#160;<i>deadlocks</i>. These occur when an<br/>operation needs to lock two resources and two threads have each acquired one of the locks,<br/>causing them to wait for each other forever. If you’re interested in deadlocks, try creating a<br/>Rust program that has a deadlock; then research deadlock mitigation strategies for mutexes<br/>in any language and have a go at implementing them in Rust. The standard library API<br/>documentation for&#160;&#160;Mutex&lt;T&gt;&#160;&#160;and&#160;&#160;MutexGuard&#160;&#160;oﬀers useful information.<br/>
We’ll round out this chapter by talking about the&#160;&#160;Send&#160;&#160;and&#160;&#160;Sync&#160;&#160;traits and how we can use<br/>them with custom types.<br/>
https://doc.rust-lang.org/book/print.html<br/>
457/627<br/>
<hr/>
<a name=458></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#458"><b>Extensible Concurrency with the&#160;</b>Sync<b>&#160;and&#160;</b>Send<b>&#160;Traits</b></a><br/>
Interestingly, the Rust language has&#160;<i>very</i>&#160;few concurrency features. Almost every<br/>concurrency feature we’ve talked about so far in this chapter has been part of the standard<br/>library, not the language. Your options for handling concurrency are not limited to the<br/>language or the standard library; you can write your own concurrency features or use those<br/>written by others.<br/>
However, two concurrency concepts are embedded in the language: the&#160;&#160;std::marker&#160;&#160;traits<br/>
Sync&#160;&#160;and&#160;&#160;Send&#160;.<br/>
<a href="tests.html#458"><b>Allowing&#160;Transference&#160;of&#160;Ownership&#160;Between&#160;Threads&#160;with&#160;</b>Send</a><br/>
The&#160;&#160;Send&#160;&#160;marker trait indicates that ownership of values of the type implementing&#160;&#160;Send<br/>can be transferred between threads. Almost every Rust type is&#160;&#160;Send&#160;, but there are some<br/>exceptions, including&#160;&#160;Rc&lt;T&gt;&#160;: this cannot be&#160;&#160;Send&#160;&#160;because if you cloned an&#160;&#160;Rc&lt;T&gt;&#160;&#160;value<br/>and tried to transfer ownership of the clone to another thread, both threads might update<br/>the reference count at the same time. For this reason,&#160;&#160;Rc&lt;T&gt;&#160;&#160;is implemented for use in<br/>single-threaded situations where you don’t want to pay the thread-safe performance<br/>penalty.<br/>
Therefore, Rust’s type system and trait bounds ensure that you can never accidentally send<br/>an&#160;&#160;Rc&lt;T&gt;&#160;&#160;value across threads unsafely. When we tried to do this in Listing 16-14, we got<br/>the error&#160;&#160;the&#160;trait&#160;Send&#160;is&#160;not&#160;implemented&#160;for&#160;Rc&lt;Mutex&lt;i32&gt;&gt;&#160;. When we switched to<br/>
Arc&lt;T&gt;&#160;, which is&#160;&#160;Send&#160;, the code compiled.<br/>
Any type composed entirely of&#160;&#160;Send&#160;&#160;types is automatically marked as&#160;&#160;Send&#160;&#160;as well. Almost<br/>all primitive types are&#160;&#160;Send&#160;, aside from raw pointers, which we’ll discuss in Chapter 19.<br/>
<a href="tests.html#458"><b>Allowing&#160;Access&#160;from&#160;Multiple&#160;Threads&#160;with&#160;</b>Sync</a><br/>
The&#160;&#160;Sync&#160;&#160;marker trait indicates that it is safe for the type implementing&#160;&#160;Sync&#160;&#160;to be<br/>referenced from multiple threads. In other words, any type&#160;&#160;T&#160;&#160;is&#160;&#160;Sync&#160;&#160;if&#160;&#160;&amp;T&#160;&#160;(an immutable<br/>reference to&#160;&#160;T&#160;) is&#160;&#160;Send&#160;, meaning the reference can be sent safely to another thread.<br/>Similar to&#160;&#160;Send&#160;, primitive types are&#160;&#160;Sync&#160;, and types composed entirely of types that are<br/>
Sync&#160;&#160;are also&#160;&#160;Sync&#160;.<br/>
The smart pointer&#160;&#160;Rc&lt;T&gt;&#160;&#160;is also not&#160;&#160;Sync&#160;&#160;for the same reasons that it’s not&#160;&#160;Send&#160;. The<br/>
RefCell&lt;T&gt;&#160;&#160;type (which we talked about in Chapter 15) and the family of related&#160;&#160;Cell&lt;T&gt;<br/>
types are not&#160;&#160;Sync&#160;. The implementation of borrow checking that&#160;&#160;RefCell&lt;T&gt;&#160;&#160;does at<br/>
https://doc.rust-lang.org/book/print.html<br/>
458/627<br/>
<hr/>
<a name=459></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
runtime is not thread-safe. The smart pointer&#160;&#160;Mutex&lt;T&gt;&#160;&#160;is&#160;&#160;Sync&#160;&#160;and can be used to share<br/><a href="https://doc.rust-lang.org/book/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads">access with multiple threads as you saw in the&#160;“Sharing a&#160;&#160;Mutex&lt;T&gt;&#160;&#160;Between Multiple<br/>Threads”&#160;section.</a><br/>
<a href="tests.html#459"><b>Implementing&#160;</b>Send<b>&#160;and&#160;</b>Sync<b>&#160;Manually&#160;Is&#160;Unsafe</b></a><br/>
Because types that are made up of&#160;&#160;Send&#160;&#160;and&#160;&#160;Sync&#160;&#160;traits are automatically also&#160;&#160;Send&#160;&#160;and<br/>
Sync&#160;, we don’t have to implement those traits manually. As marker traits, they don’t even<br/>
have any methods to implement. They’re just useful for enforcing invariants related to<br/>concurrency.<br/>
Manually implementing these traits involves implementing unsafe Rust code. We’ll talk<br/>about using unsafe Rust code in Chapter 19; for now, the important information is that<br/>building new concurrent types not made up of&#160;&#160;Send&#160;&#160;and&#160;&#160;Sync&#160;&#160;parts requires careful<br/>thought to uphold the safety guarantees.&#160;<a href="https://doc.rust-lang.org/nomicon/index.html">“The Rustonomicon”</a>&#160;has more information about<br/>these guarantees and how to uphold them.<br/>
<a href="tests.html#459"><b>Summary</b></a><br/>
This isn’t the last you’ll see of concurrency in this book: the project in Chapter 20 will use the<br/>concepts in this chapter in a more realistic situation than the smaller examples discussed<br/>here.<br/>
As mentioned earlier, because very little of how Rust handles concurrency is part of the<br/>language, many concurrency solutions are implemented as crates. These evolve more<br/>quickly than the standard library, so be sure to search online for the current, state-of-the-art<br/>crates to use in multithreaded situations.<br/>
The Rust standard library provides channels for message passing and smart pointer types,<br/>such as&#160;&#160;Mutex&lt;T&gt;&#160;&#160;and&#160;&#160;Arc&lt;T&gt;&#160;, that are safe to use in concurrent contexts. The type system<br/>and the borrow checker ensure that the code using these solutions won’t end up with data<br/>races or invalid references. Once you get your code to compile, you can rest assured that it<br/>will happily run on multiple threads without the kinds of hard-to-track-down bugs common<br/>in other languages. Concurrent programming is no longer a concept to be afraid of: go forth<br/>and make your programs concurrent, fearlessly!<br/>
Next, we’ll talk about idiomatic ways to model problems and structure solutions as your<br/>Rust programs get bigger. In addition, we’ll discuss how Rust’s idioms relate to those you<br/>might be familiar with from object-oriented programming.<br/>
https://doc.rust-lang.org/book/print.html<br/>
459/627<br/>
<hr/>
<a name=460></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#460"><b>Object-Oriented Programming Features of<br/>Rust</b></a><br/>
Object-oriented programming (OOP) is a way of modeling programs. Objects as a<br/>programmatic concept were introduced in the programming language Simula in the 1960s.<br/>Those objects inﬂuenced Alan Kay’s programming architecture in which objects pass<br/>messages to each other. To describe this architecture, he coined the term&#160;<i>object-oriented<br/>programming</i>&#160;in 1967. Many competing deﬁnitions describe what OOP is, and by some of<br/>these deﬁnitions Rust is object-oriented, but by others it is not. In this chapter, we’ll explore<br/>certain characteristics that are commonly considered object-oriented and how those<br/>characteristics translate to idiomatic Rust. We’ll then show you how to implement an object-<br/>oriented design pattern in Rust and discuss the trade-oﬀs of doing so versus implementing<br/>a solution using some of Rust’s strengths instead.<br/>
https://doc.rust-lang.org/book/print.html<br/>
460/627<br/>
<hr/>
<a name=461></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#461"><b>Characteristics of Object-Oriented Languages</b></a><br/>
There is no consensus in the programming community about what features a language<br/>must have to be considered object-oriented. Rust is inﬂuenced by many programming<br/>paradigms, including OOP; for example, we explored the features that came from functional<br/>programming in Chapter 13. Arguably, OOP languages share certain common<br/>characteristics, namely objects, encapsulation, and inheritance. Let’s look at what each of<br/>those characteristics means and whether Rust supports it.<br/>
<a href="tests.html#461"><b>Objects&#160;Contain&#160;Data&#160;and&#160;Behavior</b></a><br/>
The book&#160;<i>Design Patterns: Elements of Reusable Object-Oriented Software</i>&#160;by Erich Gamma,<br/>Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional, 1994),<br/>colloquially referred to as&#160;<i>The Gang of Four</i>&#160;book, is a catalog of object-oriented design<br/>patterns. It deﬁnes OOP this way:<br/>
Object-oriented programs are made up of objects. An&#160;<i>object</i>&#160;packages both data and<br/>the procedures that operate on that data. The procedures are typically called&#160;<i>methods<br/></i>or&#160;<i>operations</i>.<br/>
Using this deﬁnition, Rust is object-oriented: structs and enums have data, and&#160;&#160;impl&#160;&#160;blocks<br/>provide methods on structs and enums. Even though structs and enums with methods<br/>aren’t&#160;<i>called</i>&#160;objects, they provide the same functionality, according to the Gang of Four’s<br/>deﬁnition of objects.<br/>
<a href="tests.html#461"><b>Encapsulation&#160;that&#160;Hides&#160;Implementation&#160;Details</b></a><br/>
Another aspect commonly associated with OOP is the idea of&#160;<i>encapsulation</i>, which means<br/>that the implementation details of an object aren’t accessible to code using that object.<br/>Therefore, the only way to interact with an object is through its public API; code using the<br/>object shouldn’t be able to reach into the object’s internals and change data or behavior<br/>directly. This enables the programmer to change and refactor an object’s internals without<br/>needing to change the code that uses the object.<br/>
We discussed how to control encapsulation in Chapter 7: we can use the&#160;&#160;pub&#160;&#160;keyword to<br/>decide which modules, types, functions, and methods in our code should be public, and by<br/>default everything else is private. For example, we can deﬁne a struct&#160;&#160;AveragedCollection<br/>that has a&#160;ﬁeld containing a vector of&#160;&#160;i32&#160;&#160;values. The struct can also have a&#160;ﬁeld that<br/>contains the average of the values in the vector, meaning the average doesn’t have to be<br/>
https://doc.rust-lang.org/book/print.html<br/>
461/627<br/>
<hr/>
<a name=462></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
computed on demand whenever anyone needs it. In other words,&#160;&#160;AveragedCollection&#160;&#160;will<br/>cache the calculated average for us. Listing 17-1 has the deﬁnition of the<br/>
AveragedCollection&#160;&#160;struct:<br/>
Filename: src/lib.rs<br/>
pub&#160;struct&#160;AveragedCollection&#160;{<br/>&#160;&#160;&#160;&#160;list:&#160;Vec&lt;i32&gt;,<br/>&#160;&#160;&#160;&#160;average:&#160;f64,<br/>}<br/>
<b>Listing&#160;17-1:&#160;An&#160;&#160;</b>AveragedCollection&#160;<b>&#160;struct&#160;that&#160;maintains&#160;a&#160;list&#160;of&#160;integers&#160;and&#160;the&#160;average&#160;of&#160;the&#160;items&#160;in&#160;the<br/>collection</b><br/>
The struct is marked&#160;&#160;pub&#160;&#160;so that other code can use it, but the&#160;ﬁelds within the struct<br/>remain private. This is important in this case because we want to ensure that whenever a<br/>value is added or removed from the list, the average is also updated. We do this by<br/>implementing&#160;&#160;add&#160;,&#160;&#160;remove&#160;, and&#160;&#160;average&#160;&#160;methods on the struct, as shown in Listing 17-2:<br/>
Filename: src/lib.rs<br/>
impl&#160;AveragedCollection&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;add(&amp;mut&#160;self,&#160;value:&#160;i32)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.list.push(value);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.update_average();<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;pub&#160;fn&#160;remove(&amp;mut&#160;self)&#160;-&gt;&#160;Option&lt;i32&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;result&#160;=&#160;self.list.pop();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;result&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(value)&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.update_average();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(value)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;None&#160;=&gt;&#160;None,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;pub&#160;fn&#160;average(&amp;self)&#160;-&gt;&#160;f64&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.average<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;fn&#160;update_average(&amp;mut&#160;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;total:&#160;i32&#160;=&#160;self.list.iter().sum();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.average&#160;=&#160;total&#160;as&#160;f64&#160;/&#160;self.list.len()&#160;as&#160;f64;<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;17-2:&#160;Implementations&#160;of&#160;the&#160;public&#160;methods&#160;&#160;</b>add&#160;<b>,&#160;&#160;</b>remove&#160;<b>,&#160;and&#160;&#160;</b>average&#160;<b>&#160;on&#160;&#160;</b>AveragedCollection<br/>
The public methods&#160;&#160;add&#160;,&#160;&#160;remove&#160;, and&#160;&#160;average&#160;&#160;are the only ways to access or modify data<br/>in an instance of&#160;&#160;AveragedCollection&#160;. When an item is added to&#160;&#160;list&#160;&#160;using the&#160;&#160;add<br/>
https://doc.rust-lang.org/book/print.html<br/>
462/627<br/>
<hr/>
<a name=463></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
method or removed using the&#160;&#160;remove&#160;&#160;method, the implementations of each call the private<br/>
update_average&#160;&#160;method that handles updating the&#160;&#160;average&#160;&#160;ﬁeld as well.<br/>
We leave the&#160;&#160;list&#160;&#160;and&#160;&#160;average&#160;&#160;ﬁelds private so there is no way for external code to add<br/>or remove items to or from the&#160;&#160;list&#160;&#160;ﬁeld directly; otherwise, the&#160;&#160;average&#160;&#160;ﬁeld might<br/>become out of sync when the&#160;&#160;list&#160;&#160;changes. The&#160;&#160;average&#160;&#160;method returns the value in the<br/>
average&#160;&#160;ﬁeld, allowing external code to read the&#160;&#160;average&#160;&#160;but not modify it.<br/>
Because we’ve encapsulated the implementation details of the struct&#160;&#160;AveragedCollection&#160;,<br/>we can easily change aspects, such as the data structure, in the future. For instance, we<br/>could use a&#160;&#160;HashSet&lt;i32&gt;&#160;&#160;instead of a&#160;&#160;Vec&lt;i32&gt;&#160;&#160;for the&#160;&#160;list&#160;&#160;ﬁeld. As long as the<br/>signatures of the&#160;&#160;add&#160;,&#160;&#160;remove&#160;, and&#160;&#160;average&#160;&#160;public methods stay the same, code using<br/>
AveragedCollection&#160;&#160;wouldn’t need to change. If we made&#160;&#160;list&#160;&#160;public instead, this<br/>
wouldn’t necessarily be the case:&#160;&#160;HashSet&lt;i32&gt;&#160;&#160;and&#160;&#160;Vec&lt;i32&gt;&#160;&#160;have diﬀerent methods for<br/>adding and removing items, so the external code would likely have to change if it were<br/>modifying&#160;&#160;list&#160;&#160;directly.<br/>
If encapsulation is a required aspect for a language to be considered object-oriented, then<br/>Rust meets that requirement. The option to use&#160;&#160;pub&#160;&#160;or not for diﬀerent parts of code<br/>enables encapsulation of implementation details.<br/>
<a href="tests.html#463"><b>Inheritance&#160;as&#160;a&#160;Type&#160;System&#160;and&#160;as&#160;Code&#160;Sharing</b></a><br/>
<i>Inheritance</i>&#160;is a mechanism whereby an object can inherit elements from another object’s<br/>deﬁnition, thus gaining the parent object’s data and behavior without you having to deﬁne<br/>them again.<br/>
If a language must have inheritance to be an object-oriented language, then Rust is not one.<br/>There is no way to deﬁne a struct that inherits the parent struct’s&#160;ﬁelds and method<br/>implementations without using a macro.<br/>
However, if you’re used to having inheritance in your programming toolbox, you can use<br/>other solutions in Rust, depending on your reason for reaching for inheritance in the&#160;ﬁrst<br/>place.<br/>
You would choose inheritance for two main reasons. One is for reuse of code: you can<br/>implement particular behavior for one type, and inheritance enables you to reuse that<br/>implementation for a diﬀerent type. You can do this in a limited way in Rust code using<br/>default trait method implementations, which you saw in Listing 10-14 when we added a<br/>default implementation of the&#160;&#160;summarize&#160;&#160;method on the&#160;&#160;Summary&#160;&#160;trait. Any type<br/>implementing the&#160;&#160;Summary&#160;&#160;trait would have the&#160;&#160;summarize&#160;&#160;method available on it without<br/>any further code. This is similar to a parent class having an implementation of a method and<br/>an inheriting child class also having the implementation of the method. We can also<br/>override the default implementation of the&#160;&#160;summarize&#160;&#160;method when we implement the<br/>
https://doc.rust-lang.org/book/print.html<br/>
463/627<br/>
<hr/>
<a name=464></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Summary&#160;&#160;trait, which is similar to a child class overriding the implementation of a method<br/>
inherited from a parent class.<br/>
The other reason to use inheritance relates to the type system: to enable a child type to be<br/>used in the same places as the parent type. This is also called&#160;<i>polymorphism</i>, which means<br/>that you can substitute multiple objects for each other at runtime if they share certain<br/>characteristics.<br/>
<a href="tests.html#464"><b>Polymorphism</b></a><br/>
To many people, polymorphism is synonymous with inheritance. But it’s actually a<br/>more general concept that refers to code that can work with data of multiple types. For<br/>inheritance, those types are generally subclasses.<br/>
Rust instead uses generics to abstract over diﬀerent possible types and trait bounds to<br/>impose constraints on what those types must provide. This is sometimes called<br/><i>bounded parametric polymorphism</i>.<br/>
Inheritance has recently fallen out of favor as a programming design solution in many<br/>programming languages because it’s often at risk of sharing more code than necessary.<br/>Subclasses shouldn’t always share all characteristics of their parent class but will do so with<br/>inheritance. This can make a program’s design less&#160;ﬂexible. It also introduces the possibility<br/>of calling methods on subclasses that don’t make sense or that cause errors because the<br/>methods don’t apply to the subclass. In addition, some languages will only allow single<br/>inheritance (meaning a subclass can only inherit from one class), further restricting the<br/>ﬂexibility of a program’s design.<br/>
For these reasons, Rust takes the diﬀerent approach of using trait objects instead of<br/>inheritance. Let’s look at how trait objects enable polymorphism in Rust.<br/>
https://doc.rust-lang.org/book/print.html<br/>
464/627<br/>
<hr/>
<a name=465></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#465"><b>Using Trait Objects That Allow for Values of Diﬀerent<br/>Types</b></a><br/>
In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of<br/>only one type. We created a workaround in Listing 8-9 where we deﬁned a<br/>
SpreadsheetCell&#160;&#160;enum that had variants to hold integers,&#160;ﬂoats, and text. This meant we<br/>
could store diﬀerent types of data in each cell and still have a vector that represented a row<br/>of cells. This is a perfectly good solution when our interchangeable items are a&#160;ﬁxed set of<br/>types that we know when our code is compiled.<br/>
However, sometimes we want our library user to be able to extend the set of types that are<br/>valid in a particular situation. To show how we might achieve this, we’ll create an example<br/>graphical user interface (GUI) tool that iterates through a list of items, calling a&#160;&#160;draw<br/>method on each one to draw it to the screen—a common technique for GUI tools. We’ll<br/>create a library crate called&#160;&#160;gui&#160;&#160;that contains the structure of a GUI library. This crate might<br/>include some types for people to use, such as&#160;&#160;Button&#160;&#160;or&#160;&#160;TextField&#160;. In addition,&#160;&#160;gui&#160;&#160;users<br/>will want to create their own types that can be drawn: for instance, one programmer might<br/>add an&#160;&#160;Image&#160;&#160;and another might add a&#160;&#160;SelectBox&#160;.<br/>
We won’t implement a fully&#160;ﬂedged GUI library for this example but will show how the<br/>pieces would&#160;ﬁt together. At the time of writing the library, we can’t know and deﬁne all the<br/>types other programmers might want to create. But we do know that&#160;&#160;gui&#160;&#160;needs to keep<br/>track of many values of diﬀerent types, and it needs to call a&#160;&#160;draw&#160;&#160;method on each of these<br/>diﬀerently typed values. It doesn’t need to know exactly what will happen when we call the<br/>
draw&#160;&#160;method, just that the value will have that method available for us to call.<br/>
To do this in a language with inheritance, we might deﬁne a class named&#160;&#160;Component&#160;&#160;that<br/>has a method named&#160;&#160;draw&#160;&#160;on it. The other classes, such as&#160;&#160;Button&#160;,&#160;&#160;Image&#160;, and<br/>
SelectBox&#160;, would inherit from&#160;&#160;Component&#160;&#160;and thus inherit the&#160;&#160;draw&#160;&#160;method. They could<br/>
each override the&#160;&#160;draw&#160;&#160;method to deﬁne their custom behavior, but the framework could<br/>treat all of the types as if they were&#160;&#160;Component&#160;&#160;instances and call&#160;&#160;draw&#160;&#160;on them. But<br/>because Rust doesn’t have inheritance, we need another way to structure the&#160;&#160;gui&#160;&#160;library to<br/>allow users to extend it with new types.<br/>
<a href="tests.html#465"><b>Deﬁning&#160;a&#160;Trait&#160;for&#160;Common&#160;Behavior</b></a><br/>
To implement the behavior we want&#160;&#160;gui&#160;&#160;to have, we’ll deﬁne a trait named&#160;&#160;Draw&#160;&#160;that will<br/>have one method named&#160;&#160;draw&#160;. Then we can deﬁne a vector that takes a&#160;<i>trait object</i>. A trait<br/>object points to both an instance of a type implementing our speciﬁed trait and a table used<br/>to look up trait methods on that type at runtime. We create a trait object by specifying some<br/>sort of pointer, such as a&#160;&#160;&amp;&#160;&#160;reference or a&#160;&#160;Box&lt;T&gt;&#160;&#160;smart pointer, then the&#160;&#160;dyn&#160;&#160;keyword,<br/>
https://doc.rust-lang.org/book/print.html<br/>
465/627<br/>
<hr/>
<a name=466></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
and then specifying the relevant trait. (We’ll talk about the reason trait objects must use a<br/><a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">pointer in Chapter 19 in the section&#160;“Dynamically Sized Types and the&#160;&#160;Sized&#160;&#160;Trait.”</a>) We can<br/>use trait objects in place of a generic or concrete type. Wherever we use a trait object, Rust’s<br/>type system will ensure at compile time that any value used in that context will implement<br/>the trait object’s trait. Consequently, we don’t need to know all the possible types at compile<br/>time.<br/>
We’ve mentioned that, in Rust, we refrain from calling structs and enums “objects” to<br/>distinguish them from other languages’ objects. In a struct or enum, the data in the struct<br/>ﬁelds and the behavior in&#160;&#160;impl&#160;&#160;blocks are separated, whereas in other languages, the data<br/>and behavior combined into one concept is often labeled an object. However, trait objects<br/><i>are</i>&#160;more like objects in other languages in the sense that they combine data and behavior.<br/>But trait objects diﬀer from traditional objects in that we can’t add data to a trait object.<br/>Trait objects aren’t as generally useful as objects in other languages: their speciﬁc purpose is<br/>to allow abstraction across common behavior.<br/>
Listing 17-3 shows how to deﬁne a trait named&#160;&#160;Draw&#160;&#160;with one method named&#160;&#160;draw&#160;:<br/>
Filename: src/lib.rs<br/>
pub&#160;trait&#160;Draw&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;draw(&amp;self);<br/>}<br/>
<b>Listing&#160;17-3:&#160;Deﬁnition&#160;of&#160;the&#160;&#160;</b>Draw&#160;<b>&#160;trait</b><br/>
This syntax should look familiar from our discussions on how to deﬁne traits in Chapter 10.<br/>Next comes some new syntax: Listing 17-4 deﬁnes a struct named&#160;&#160;Screen&#160;&#160;that holds a<br/>vector named&#160;&#160;components&#160;. This vector is of type&#160;&#160;Box&lt;dyn&#160;Draw&gt;&#160;, which is a trait object; it’s<br/>a stand-in for any type inside a&#160;&#160;Box&#160;&#160;that implements the&#160;&#160;Draw&#160;&#160;trait.<br/>
Filename: src/lib.rs<br/>
pub&#160;struct&#160;Screen&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;components:&#160;Vec&lt;Box&lt;dyn&#160;Draw&gt;&gt;,<br/>}<br/>
<b>Listing&#160;17-4:&#160;Deﬁnition&#160;of&#160;the&#160;&#160;</b>Screen&#160;<b>&#160;struct&#160;with&#160;a&#160;&#160;</b>components&#160;<b>&#160;ﬁeld&#160;holding&#160;a&#160;vector&#160;of&#160;trait&#160;objects&#160;that<br/>implement&#160;the&#160;&#160;</b>Draw&#160;<b>&#160;trait</b><br/>
On the&#160;&#160;Screen&#160;&#160;struct, we’ll deﬁne a method named&#160;&#160;run&#160;&#160;that will call the&#160;&#160;draw&#160;&#160;method on<br/>each of its&#160;&#160;components&#160;, as shown in Listing 17-5:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
466/627<br/>
<hr/>
<a name=467></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
impl&#160;Screen&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;run(&amp;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;component&#160;in&#160;self.components.iter()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;component.draw();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;17-5:&#160;A&#160;&#160;</b>run&#160;<b>&#160;method&#160;on&#160;&#160;</b>Screen&#160;<b>&#160;that&#160;calls&#160;the&#160;&#160;</b>draw&#160;<b>&#160;method&#160;on&#160;each&#160;component</b><br/>
This works diﬀerently from deﬁning a struct that uses a generic type parameter with trait<br/>bounds. A generic type parameter can only be substituted with one concrete type at a time,<br/>whereas trait objects allow for multiple concrete types to&#160;ﬁll in for the trait object at<br/>runtime. For example, we could have deﬁned the&#160;&#160;Screen&#160;&#160;struct using a generic type and a<br/>trait bound as in Listing 17-6:<br/>
Filename: src/lib.rs<br/>
pub&#160;struct&#160;Screen&lt;T:&#160;Draw&gt;&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;components:&#160;Vec&lt;T&gt;,<br/>}<br/>
impl&lt;T&gt;&#160;Screen&lt;T&gt;<br/>where<br/>&#160;&#160;&#160;&#160;T:&#160;Draw,<br/>{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;run(&amp;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;component&#160;in&#160;self.components.iter()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;component.draw();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;17-6:&#160;An&#160;alternate&#160;implementation&#160;of&#160;the&#160;&#160;</b>Screen&#160;<b>&#160;struct&#160;and&#160;its&#160;&#160;</b>run&#160;<b>&#160;method&#160;using&#160;generics&#160;and&#160;trait</b><br/>
<b>bounds</b><br/>
This restricts us to a&#160;&#160;Screen&#160;&#160;instance that has a list of components all of type&#160;&#160;Button&#160;&#160;or all<br/>of type&#160;&#160;TextField&#160;. If you’ll only ever have homogeneous collections, using generics and<br/>trait bounds is preferable because the deﬁnitions will be monomorphized at compile time to<br/>use the concrete types.<br/>
On the other hand, with the method using trait objects, one&#160;&#160;Screen&#160;&#160;instance can hold a<br/>
Vec&lt;T&gt;&#160;&#160;that contains a&#160;&#160;Box&lt;Button&gt;&#160;&#160;as well as a&#160;&#160;Box&lt;TextField&gt;&#160;. Let’s look at how this<br/>
works, and then we’ll talk about the runtime performance implications.<br/>
https://doc.rust-lang.org/book/print.html<br/>
467/627<br/>
<hr/>
<a name=468></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#468"><b>Implementing&#160;the&#160;Trait</b></a><br/>
Now we’ll add some types that implement the&#160;&#160;Draw&#160;&#160;trait. We’ll provide the&#160;&#160;Button&#160;&#160;type.<br/>Again, actually implementing a GUI library is beyond the scope of this book, so the&#160;&#160;draw<br/>method won’t have any useful implementation in its body. To imagine what the<br/>implementation might look like, a&#160;&#160;Button&#160;&#160;struct might have&#160;ﬁelds for&#160;&#160;width&#160;,&#160;&#160;height&#160;, and<br/>
label&#160;, as shown in Listing 17-7:<br/>
Filename: src/lib.rs<br/>
pub&#160;struct&#160;Button&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;width:&#160;u32,<br/>&#160;&#160;&#160;&#160;pub&#160;height:&#160;u32,<br/>&#160;&#160;&#160;&#160;pub&#160;label:&#160;String,<br/>}<br/>
impl&#160;Draw&#160;for&#160;Button&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;draw(&amp;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;code&#160;to&#160;actually&#160;draw&#160;a&#160;button<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;17-7:&#160;A&#160;&#160;</b>Button&#160;<b>&#160;struct&#160;that&#160;implements&#160;the&#160;&#160;</b>Draw&#160;<b>&#160;trait</b><br/>
The&#160;&#160;width&#160;,&#160;&#160;height&#160;, and&#160;&#160;label&#160;&#160;ﬁelds on&#160;&#160;Button&#160;&#160;will diﬀer from the&#160;ﬁelds on other<br/>components; for example, a&#160;&#160;TextField&#160;&#160;type might have those same&#160;ﬁelds plus a<br/>
placeholder&#160;&#160;ﬁeld. Each of the types we want to draw on the screen will implement the<br/>Draw&#160;&#160;trait but will use diﬀerent code in the&#160;&#160;draw&#160;&#160;method to deﬁne how to draw that<br/>
particular type, as&#160;&#160;Button&#160;&#160;has here (without the actual GUI code, as mentioned). The<br/>
Button&#160;&#160;type, for instance, might have an additional&#160;&#160;impl&#160;&#160;block containing methods related<br/>
to what happens when a user clicks the button. These kinds of methods won’t apply to types<br/>like&#160;&#160;TextField&#160;.<br/>
If someone using our library decides to implement a&#160;&#160;SelectBox&#160;&#160;struct that has&#160;&#160;width&#160;,<br/>
height&#160;, and&#160;&#160;options&#160;&#160;ﬁelds, they implement the&#160;&#160;Draw&#160;&#160;trait on the&#160;&#160;SelectBox&#160;&#160;type as well,<br/>
as shown in Listing 17-8:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
468/627<br/>
<hr/>
<a name=469></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;gui::Draw;<br/>
struct&#160;SelectBox&#160;{<br/>&#160;&#160;&#160;&#160;width:&#160;u32,<br/>&#160;&#160;&#160;&#160;height:&#160;u32,<br/>&#160;&#160;&#160;&#160;options:&#160;Vec&lt;String&gt;,<br/>}<br/>
impl&#160;Draw&#160;for&#160;SelectBox&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;draw(&amp;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;code&#160;to&#160;actually&#160;draw&#160;a&#160;select&#160;box<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;17-8:&#160;Another&#160;crate&#160;using&#160;&#160;</b>gui&#160;<b>&#160;and&#160;implementing&#160;the&#160;&#160;</b>Draw&#160;<b>&#160;trait&#160;on&#160;a&#160;&#160;</b>SelectBox&#160;<b>&#160;struct</b><br/>
Our library’s user can now write their&#160;&#160;main&#160;&#160;function to create a&#160;&#160;Screen&#160;&#160;instance. To the<br/>
Screen&#160;&#160;instance, they can add a&#160;&#160;SelectBox&#160;&#160;and a&#160;&#160;Button&#160;&#160;by putting each in a&#160;&#160;Box&lt;T&gt;&#160;&#160;to<br/>
become a trait object. They can then call the&#160;&#160;run&#160;&#160;method on the&#160;&#160;Screen&#160;&#160;instance, which<br/>will call&#160;&#160;draw&#160;&#160;on each of the components. Listing 17-9 shows this implementation:<br/>
Filename: src/main.rs<br/>
use&#160;gui::{Button,&#160;Screen};<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;screen&#160;=&#160;Screen&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;components:&#160;vec![<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Box::new(SelectBox&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;75,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;10,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;options:&#160;vec![<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;Yes&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;Maybe&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;No&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;],<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Box::new(Button&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;width:&#160;50,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;height:&#160;10,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;label:&#160;String::from(&#34;OK&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;],<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;screen.run();<br/>}<br/>
<b>Listing&#160;17-9:&#160;Using&#160;trait&#160;objects&#160;to&#160;store&#160;values&#160;of&#160;diﬀerent&#160;types&#160;that&#160;implement&#160;the&#160;same&#160;trait</b><br/>
When we wrote the library, we didn’t know that someone might add the&#160;&#160;SelectBox&#160;&#160;type,<br/>but our&#160;&#160;Screen&#160;&#160;implementation was able to operate on the new type and draw it because<br/>
SelectBox&#160;&#160;implements the&#160;&#160;Draw&#160;&#160;trait, which means it implements the&#160;&#160;draw&#160;&#160;method.<br/>
https://doc.rust-lang.org/book/print.html<br/>
469/627<br/>
<hr/>
<a name=470></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
This concept—of being concerned only with the messages a value responds to rather than<br/>the value’s concrete type—is similar to the concept of&#160;<i>duck typing</i>&#160;in dynamically typed<br/>languages: if it walks like a duck and quacks like a duck, then it must be a duck! In the<br/>implementation of&#160;&#160;run&#160;&#160;on&#160;&#160;Screen&#160;&#160;in Listing 17-5,&#160;&#160;run&#160;&#160;doesn’t need to know what the<br/>concrete type of each component is. It doesn’t check whether a component is an instance of<br/>a&#160;&#160;Button&#160;&#160;or a&#160;&#160;SelectBox&#160;, it just calls the&#160;&#160;draw&#160;&#160;method on the component. By specifying<br/>
Box&lt;dyn&#160;Draw&gt;&#160;&#160;as the type of the values in the&#160;&#160;components&#160;&#160;vector, we’ve deﬁned&#160;&#160;Screen<br/>
to need values that we can call the&#160;&#160;draw&#160;&#160;method on.<br/>
The advantage of using trait objects and Rust’s type system to write code similar to code<br/>using duck typing is that we never have to check whether a value implements a particular<br/>method at runtime or worry about getting errors if a value doesn’t implement a method but<br/>we call it anyway. Rust won’t compile our code if the values don’t implement the traits that<br/>the trait objects need.<br/>
For example, Listing 17-10 shows what happens if we try to create a&#160;&#160;Screen&#160;&#160;with a&#160;&#160;String<br/>as a component:<br/>
Filename: src/main.rs<br/>
use&#160;gui::Screen;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;screen&#160;=&#160;Screen&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;components:&#160;vec![Box::new(String::from(&#34;Hi&#34;))],<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;screen.run();<br/>}<br/>
<b>Listing&#160;17-10:&#160;Attempting&#160;to&#160;use&#160;a&#160;type&#160;that&#160;doesn’t&#160;implement&#160;the&#160;trait&#160;object’s&#160;trait</b><br/>
We’ll get this error because&#160;&#160;String&#160;&#160;doesn’t implement the&#160;&#160;Draw&#160;&#160;trait:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;gui&#160;v0.1.0&#160;(file:///projects/gui)<br/>error[E0277]:&#160;the&#160;trait&#160;bound&#160;`String:&#160;Draw`&#160;is&#160;not&#160;satisfied<br/>&#160;--&gt;&#160;src/main.rs:5:26<br/>&#160;&#160;|<br/>5&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;components:&#160;vec![Box::new(String::from(&#34;Hi&#34;))],<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#160;the&#160;trait&#160;`Draw`&#160;is&#160;<br/>not&#160;implemented&#160;for&#160;`String`<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;help:&#160;the&#160;trait&#160;`Draw`&#160;is&#160;implemented&#160;for&#160;`Button`<br/>&#160;&#160;=&#160;note:&#160;required&#160;for&#160;the&#160;cast&#160;from&#160;`String`&#160;to&#160;the&#160;object&#160;type&#160;`dyn&#160;Draw`<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0277`.<br/>error:&#160;could&#160;not&#160;compile&#160;`gui`&#160;due&#160;to&#160;previous&#160;error<br/>
https://doc.rust-lang.org/book/print.html<br/>
470/627<br/>
<hr/>
<a name=471></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
This error lets us know that either we’re passing something to&#160;&#160;Screen&#160;&#160;we didn’t mean to<br/>pass and so should pass a diﬀerent type or we should implement&#160;&#160;Draw&#160;&#160;on&#160;&#160;String&#160;&#160;so that<br/>
Screen&#160;&#160;is able to call&#160;&#160;draw&#160;&#160;on it.<br/>
<a href="tests.html#471"><b>Trait&#160;Objects&#160;Perform&#160;Dynamic&#160;Dispatch</b></a><br/>
<a href="https://doc.rust-lang.org/book/ch10-01-syntax.html#performance-of-code-using-generics">Recall in the&#160;“Performance of Code Using Generics”&#160;section in Chapter 10 our discussion on<br/></a>the monomorphization process performed by the compiler when we use trait bounds on<br/>generics: the compiler generates nongeneric implementations of functions and methods for<br/>each concrete type that we use in place of a generic type parameter. The code that results<br/>from monomorphization is doing&#160;<i>static dispatch</i>, which is when the compiler knows what<br/>method you’re calling at compile time. This is opposed to&#160;<i>dynamic dispatch</i>, which is when<br/>the compiler can’t tell at compile time which method you’re calling. In dynamic dispatch<br/>cases, the compiler emits code that at runtime will&#160;ﬁgure out which method to call.<br/>
When we use trait objects, Rust must use dynamic dispatch. The compiler doesn’t know all<br/>the types that might be used with the code that’s using trait objects, so it doesn’t know<br/>which method implemented on which type to call. Instead, at runtime, Rust uses the<br/>pointers inside the trait object to know which method to call. This lookup incurs a runtime<br/>cost that doesn’t occur with static dispatch. Dynamic dispatch also prevents the compiler<br/>from choosing to inline a method’s code, which in turn prevents some optimizations.<br/>However, we did get extra&#160;ﬂexibility in the code that we wrote in Listing 17-5 and were able<br/>to support in Listing 17-9, so it’s a trade-oﬀ&#160;to consider.<br/>
https://doc.rust-lang.org/book/print.html<br/>
471/627<br/>
<hr/>
<a name=472></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#472"><b>Implementing an Object-Oriented Design Pattern</b></a><br/>
The&#160;<i>state pattern</i>&#160;is an object-oriented design pattern. The crux of the pattern is that we<br/>deﬁne a set of states a value can have internally. The states are represented by a set of&#160;<i>state<br/>objects</i>, and the value’s behavior changes based on its state. We’re going to work through an<br/>example of a blog post struct that has a&#160;ﬁeld to hold its state, which will be a state object<br/>from the set &#34;draft&#34;, &#34;review&#34;, or &#34;published&#34;.<br/>
The state objects share functionality: in Rust, of course, we use structs and traits rather than<br/>objects and inheritance. Each state object is responsible for its own behavior and for<br/>governing when it should change into another state. The value that holds a state object<br/>knows nothing about the diﬀerent behavior of the states or when to transition between<br/>states.<br/>
The advantage of using the state pattern is that, when the business requirements of the<br/>program change, we won’t need to change the code of the value holding the state or the<br/>code that uses the value. We’ll only need to update the code inside one of the state objects<br/>to change its rules or perhaps add more state objects.<br/>
First, we’re going to implement the state pattern in a more traditional object-oriented way,<br/>then we’ll use an approach that’s a bit more natural in Rust. Let’s dig in to incrementally<br/>implementing a blog post workﬂow using the state pattern.<br/>
The&#160;ﬁnal functionality will look like this:<br/>
1.&#160;A blog post starts as an empty draft.<br/>2.&#160;When the draft is done, a review of the post is requested.<br/>3.&#160;When the post is approved, it gets published.<br/>4.&#160;Only published blog posts return content to print, so unapproved posts can’t<br/>
accidentally be published.<br/>
Any other changes attempted on a post should have no eﬀect. For example, if we try to<br/>approve a draft blog post before we’ve requested a review, the post should remain an<br/>unpublished draft.<br/>
Listing 17-11 shows this workﬂow in code form: this is an example usage of the API we’ll<br/>implement in a library crate named&#160;&#160;blog&#160;. This won’t compile yet because we haven’t<br/>implemented the&#160;&#160;blog&#160;&#160;crate.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
472/627<br/>
<hr/>
<a name=473></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;blog::Post;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;post&#160;=&#160;Post::new();<br/>
&#160;&#160;&#160;&#160;post.add_text(&#34;I&#160;ate&#160;a&#160;salad&#160;for&#160;lunch&#160;today&#34;);<br/>&#160;&#160;&#160;&#160;assert_eq!(&#34;&#34;,&#160;post.content());<br/>
&#160;&#160;&#160;&#160;post.request_review();<br/>&#160;&#160;&#160;&#160;assert_eq!(&#34;&#34;,&#160;post.content());<br/>
&#160;&#160;&#160;&#160;post.approve();<br/>&#160;&#160;&#160;&#160;assert_eq!(&#34;I&#160;ate&#160;a&#160;salad&#160;for&#160;lunch&#160;today&#34;,&#160;post.content());<br/>}<br/>
<b>Listing&#160;17-11:&#160;Code&#160;that&#160;demonstrates&#160;the&#160;desired&#160;behavior&#160;we&#160;want&#160;our&#160;&#160;</b>blog&#160;<b>&#160;crate&#160;to&#160;have</b><br/>
We want to allow the user to create a new draft blog post with&#160;&#160;Post::new&#160;. We want to allow<br/>text to be added to the blog post. If we try to get the post’s content immediately, before<br/>approval, we shouldn’t get any text because the post is still a draft. We’ve added<br/>
assert_eq!&#160;&#160;in the code for demonstration purposes. An excellent unit test for this would<br/>
be to assert that a draft blog post returns an empty string from the&#160;&#160;content&#160;&#160;method, but<br/>we’re not going to write tests for this example.<br/>
Next, we want to enable a request for a review of the post, and we want&#160;&#160;content&#160;&#160;to return<br/>an empty string while waiting for the review. When the post receives approval, it should get<br/>published, meaning the text of the post will be returned when&#160;&#160;content&#160;&#160;is called.<br/>
Notice that the only type we’re interacting with from the crate is the&#160;&#160;Post&#160;&#160;type. This type<br/>will use the state pattern and will hold a value that will be one of three state objects<br/>representing the various states a post can be in—draft, waiting for review, or published.<br/>Changing from one state to another will be managed internally within the&#160;&#160;Post&#160;&#160;type. The<br/>states change in response to the methods called by our library’s users on the&#160;&#160;Post<br/>instance, but they don’t have to manage the state changes directly. Also, users can’t make a<br/>mistake with the states, like publishing a post before it’s reviewed.<br/>
<a href="tests.html#473"><b>Deﬁning&#160;</b>Post<b>&#160;and&#160;Creating&#160;a&#160;New&#160;Instance&#160;in&#160;the&#160;Draft&#160;State</b></a><br/>
Let’s get started on the implementation of the library! We know we need a public&#160;&#160;Post<br/>struct that holds some content, so we’ll start with the deﬁnition of the struct and an<br/>associated public&#160;&#160;new&#160;&#160;function to create an instance of&#160;&#160;Post&#160;, as shown in Listing 17-12.<br/>We’ll also make a private&#160;&#160;State&#160;&#160;trait that will deﬁne the behavior that all state objects for a<br/>
Post&#160;&#160;must have.<br/>
Then&#160;&#160;Post&#160;&#160;will hold a trait object of&#160;&#160;Box&lt;dyn&#160;State&gt;&#160;&#160;inside an&#160;&#160;Option&lt;T&gt;&#160;&#160;in a private&#160;ﬁeld<br/>named&#160;&#160;state&#160;&#160;to hold the state object. You’ll see why the&#160;&#160;Option&lt;T&gt;&#160;&#160;is necessary in a bit.<br/>
https://doc.rust-lang.org/book/print.html<br/>
473/627<br/>
<hr/>
<a name=474></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Filename: src/lib.rs<br/>
pub&#160;struct&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;state:&#160;Option&lt;Box&lt;dyn&#160;State&gt;&gt;,<br/>&#160;&#160;&#160;&#160;content:&#160;String,<br/>}<br/>
impl&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new()&#160;-&gt;&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;state:&#160;Some(Box::new(Draft&#160;{})),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content:&#160;String::new(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
trait&#160;State&#160;{}<br/>
struct&#160;Draft&#160;{}<br/>
impl&#160;State&#160;for&#160;Draft&#160;{}<br/>
<b>Listing&#160;17-12:&#160;Deﬁnition&#160;of&#160;a&#160;&#160;</b>Post&#160;<b>&#160;struct&#160;and&#160;a&#160;&#160;</b>new&#160;<b>&#160;function&#160;that&#160;creates&#160;a&#160;new&#160;&#160;</b>Post&#160;<b>&#160;instance,&#160;a&#160;&#160;</b>State&#160;<b>&#160;trait,<br/>and&#160;a&#160;&#160;</b>Draft&#160;<b>&#160;struct</b><br/>
The&#160;&#160;State&#160;&#160;trait deﬁnes the behavior shared by diﬀerent post states. The state objects are<br/>
Draft&#160;,&#160;&#160;PendingReview&#160;, and&#160;&#160;Published&#160;, and they will all implement the&#160;&#160;State&#160;&#160;trait. For<br/>
now, the trait doesn’t have any methods, and we’ll start by deﬁning just the&#160;&#160;Draft&#160;&#160;state<br/>because that is the state we want a post to start in.<br/>
When we create a new&#160;&#160;Post&#160;, we set its&#160;&#160;state&#160;&#160;ﬁeld to a&#160;&#160;Some&#160;&#160;value that holds a&#160;&#160;Box&#160;. This<br/>
Box&#160;&#160;points to a new instance of the&#160;&#160;Draft&#160;&#160;struct. This ensures whenever we create a new<br/>
instance of&#160;&#160;Post&#160;, it will start out as a draft. Because the&#160;&#160;state&#160;&#160;ﬁeld of&#160;&#160;Post&#160;&#160;is private,<br/>there is no way to create a&#160;&#160;Post&#160;&#160;in any other state! In the&#160;&#160;Post::new&#160;&#160;function, we set the<br/>
content&#160;&#160;ﬁeld to a new, empty&#160;&#160;String&#160;.<br/>
<a href="tests.html#474"><b>Storing&#160;the&#160;Text&#160;of&#160;the&#160;Post&#160;Content</b></a><br/>
We saw in Listing 17-11 that we want to be able to call a method named&#160;&#160;add_text&#160;&#160;and pass<br/>it a&#160;&#160;&amp;str&#160;&#160;that is then added as the text content of the blog post. We implement this as a<br/>method, rather than exposing the&#160;&#160;content&#160;&#160;ﬁeld as&#160;&#160;pub&#160;, so that later we can implement a<br/>method that will control how the&#160;&#160;content&#160;&#160;ﬁeld’s data is read. The&#160;&#160;add_text&#160;&#160;method is<br/>pretty straightforward, so let’s add the implementation in Listing 17-13 to the&#160;&#160;impl&#160;Post<br/>block:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
474/627<br/>
<hr/>
<a name=475></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
impl&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;add_text(&amp;mut&#160;self,&#160;text:&#160;&amp;str)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.content.push_str(text);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;17-13:&#160;Implementing&#160;the&#160;&#160;</b>add_text&#160;<b>&#160;method&#160;to&#160;add&#160;text&#160;to&#160;a&#160;post’s&#160;&#160;</b>content<br/>
The&#160;&#160;add_text&#160;&#160;method takes a mutable reference to&#160;&#160;self&#160;, because we’re changing the<br/>
Post&#160;&#160;instance that we’re calling&#160;&#160;add_text&#160;&#160;on. We then call&#160;&#160;push_str&#160;&#160;on the&#160;&#160;String&#160;&#160;in<br/>content&#160;&#160;and pass the&#160;&#160;text&#160;&#160;argument to add to the saved&#160;&#160;content&#160;. This behavior doesn’t<br/>
depend on the state the post is in, so it’s not part of the state pattern. The&#160;&#160;add_text<br/>method doesn’t interact with the&#160;&#160;state&#160;&#160;ﬁeld at all, but it is part of the behavior we want to<br/>support.<br/>
<a href="tests.html#475"><b>Ensuring&#160;the&#160;Content&#160;of&#160;a&#160;Draft&#160;Post&#160;Is&#160;Empty</b></a><br/>
Even after we’ve called&#160;&#160;add_text&#160;&#160;and added some content to our post, we still want the<br/>
content&#160;&#160;method to return an empty string slice because the post is still in the draft state,<br/>
as shown on line 7 of Listing 17-11. For now, let’s implement the&#160;&#160;content&#160;&#160;method with the<br/>simplest thing that will fulﬁll this requirement: always returning an empty string slice. We’ll<br/>change this later once we implement the ability to change a post’s state so it can be<br/>published. So far, posts can only be in the draft state, so the post content should always be<br/>empty. Listing 17-14 shows this placeholder implementation:<br/>
Filename: src/lib.rs<br/>
impl&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;content(&amp;self)&#160;-&gt;&#160;&amp;str&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;&#34;<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;17-14:&#160;Adding&#160;a&#160;placeholder&#160;implementation&#160;for&#160;the&#160;&#160;</b>content&#160;<b>&#160;method&#160;on&#160;&#160;</b>Post&#160;<b>&#160;that&#160;always&#160;returns&#160;an</b><br/>
<b>empty&#160;string&#160;slice</b><br/>
With this added&#160;&#160;content&#160;&#160;method, everything in Listing 17-11 up to line 7 works as intended.<br/>
<a href="tests.html#475"><b>Requesting&#160;a&#160;Review&#160;of&#160;the&#160;Post&#160;Changes&#160;Its&#160;State</b></a><br/>
Next, we need to add functionality to request a review of a post, which should change its<br/>state from&#160;&#160;Draft&#160;&#160;to&#160;&#160;PendingReview&#160;. Listing 17-15 shows this code:<br/>
https://doc.rust-lang.org/book/print.html<br/>
475/627<br/>
<hr/>
<a name=476></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Filename: src/lib.rs<br/>
impl&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;request_review(&amp;mut&#160;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;let&#160;Some(s)&#160;=&#160;self.state.take()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.state&#160;=&#160;Some(s.request_review())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
trait&#160;State&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;request_review(self:&#160;Box&lt;Self&gt;)&#160;-&gt;&#160;Box&lt;dyn&#160;State&gt;;<br/>}<br/>
struct&#160;Draft&#160;{}<br/>
impl&#160;State&#160;for&#160;Draft&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;request_review(self:&#160;Box&lt;Self&gt;)&#160;-&gt;&#160;Box&lt;dyn&#160;State&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Box::new(PendingReview&#160;{})<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
struct&#160;PendingReview&#160;{}<br/>
impl&#160;State&#160;for&#160;PendingReview&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;request_review(self:&#160;Box&lt;Self&gt;)&#160;-&gt;&#160;Box&lt;dyn&#160;State&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;17-15:&#160;Implementing&#160;&#160;</b>request_review&#160;<b>&#160;methods&#160;on&#160;&#160;</b>Post&#160;<b>&#160;and&#160;the&#160;&#160;</b>State&#160;<b>&#160;trait</b><br/>
We give&#160;&#160;Post&#160;&#160;a public method named&#160;&#160;request_review&#160;&#160;that will take a mutable reference<br/>to&#160;&#160;self&#160;. Then we call an internal&#160;&#160;request_review&#160;&#160;method on the current state of&#160;&#160;Post&#160;,<br/>and this second&#160;&#160;request_review&#160;&#160;method consumes the current state and returns a new<br/>state.<br/>
We add the&#160;&#160;request_review&#160;&#160;method to the&#160;&#160;State&#160;&#160;trait; all types that implement the trait<br/>will now need to implement the&#160;&#160;request_review&#160;&#160;method. Note that rather than having<br/>
self&#160;,&#160;&#160;&amp;self&#160;, or&#160;&#160;&amp;mut&#160;self&#160;&#160;as the&#160;ﬁrst parameter of the method, we have&#160;&#160;self:&#160;<br/>
Box&lt;Self&gt;&#160;. This syntax means the method is only valid when called on a&#160;&#160;Box&#160;&#160;holding the<br/>type. This syntax takes ownership of&#160;&#160;Box&lt;Self&gt;&#160;, invalidating the old state so the state value<br/>of the&#160;&#160;Post&#160;&#160;can transform into a new state.<br/>
To consume the old state, the&#160;&#160;request_review&#160;&#160;method needs to take ownership of the<br/>state value. This is where the&#160;&#160;Option&#160;&#160;in the&#160;&#160;state&#160;&#160;ﬁeld of&#160;&#160;Post&#160;&#160;comes in: we call the&#160;&#160;take<br/>method to take the&#160;&#160;Some&#160;&#160;value out of the&#160;&#160;state&#160;&#160;ﬁeld and leave a&#160;&#160;None&#160;&#160;in its place,<br/>because Rust doesn’t let us have unpopulated&#160;ﬁelds in structs. This lets us move the&#160;&#160;state<br/>value out of&#160;&#160;Post&#160;&#160;rather than borrowing it. Then we’ll set the post’s&#160;&#160;state&#160;&#160;value to the<br/>result of this operation.<br/>
https://doc.rust-lang.org/book/print.html<br/>
476/627<br/>
<hr/>
<a name=477></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We need to set&#160;&#160;state&#160;&#160;to&#160;&#160;None&#160;&#160;temporarily rather than setting it directly with code like<br/>
self.state&#160;=&#160;self.state.request_review();&#160;&#160;to get ownership of the&#160;&#160;state&#160;&#160;value. This<br/>
ensures&#160;&#160;Post&#160;&#160;can’t use the old&#160;&#160;state&#160;&#160;value after we’ve transformed it into a new state.<br/>
The&#160;&#160;request_review&#160;&#160;method on&#160;&#160;Draft&#160;&#160;returns a new, boxed instance of a new<br/>
PendingReview&#160;&#160;struct, which represents the state when a post is waiting for a review. The<br/>PendingReview&#160;&#160;struct also implements the&#160;&#160;request_review&#160;&#160;method but doesn’t do any<br/>
transformations. Rather, it returns itself, because when we request a review on a post<br/>already in the&#160;&#160;PendingReview&#160;&#160;state, it should stay in the&#160;&#160;PendingReview&#160;&#160;state.<br/>
Now we can start seeing the advantages of the state pattern: the&#160;&#160;request_review&#160;&#160;method<br/>on&#160;&#160;Post&#160;&#160;is the same no matter its&#160;&#160;state&#160;&#160;value. Each state is responsible for its own rules.<br/>
We’ll leave the&#160;&#160;content&#160;&#160;method on&#160;&#160;Post&#160;&#160;as is, returning an empty string slice. We can now<br/>have a&#160;&#160;Post&#160;&#160;in the&#160;&#160;PendingReview&#160;&#160;state as well as in the&#160;&#160;Draft&#160;&#160;state, but we want the<br/>same behavior in the&#160;&#160;PendingReview&#160;&#160;state. Listing 17-11 now works up to line 10!<br/>
<a href="tests.html#477"><b>Adding&#160;</b>approve<b>&#160;to&#160;Change&#160;the&#160;Behavior&#160;of&#160;</b>content</a><br/>
The&#160;&#160;approve&#160;&#160;method will be similar to the&#160;&#160;request_review&#160;&#160;method: it will set&#160;&#160;state&#160;&#160;to the<br/>value that the current state says it should have when that state is approved, as shown in<br/>Listing 17-16:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
477/627<br/>
<hr/>
<a name=478></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
impl&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;approve(&amp;mut&#160;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;let&#160;Some(s)&#160;=&#160;self.state.take()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.state&#160;=&#160;Some(s.approve())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
trait&#160;State&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;request_review(self:&#160;Box&lt;Self&gt;)&#160;-&gt;&#160;Box&lt;dyn&#160;State&gt;;<br/>&#160;&#160;&#160;&#160;fn&#160;approve(self:&#160;Box&lt;Self&gt;)&#160;-&gt;&#160;Box&lt;dyn&#160;State&gt;;<br/>}<br/>
struct&#160;Draft&#160;{}<br/>
impl&#160;State&#160;for&#160;Draft&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;fn&#160;approve(self:&#160;Box&lt;Self&gt;)&#160;-&gt;&#160;Box&lt;dyn&#160;State&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
struct&#160;PendingReview&#160;{}<br/>
impl&#160;State&#160;for&#160;PendingReview&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;fn&#160;approve(self:&#160;Box&lt;Self&gt;)&#160;-&gt;&#160;Box&lt;dyn&#160;State&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Box::new(Published&#160;{})<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
struct&#160;Published&#160;{}<br/>
impl&#160;State&#160;for&#160;Published&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;request_review(self:&#160;Box&lt;Self&gt;)&#160;-&gt;&#160;Box&lt;dyn&#160;State&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;fn&#160;approve(self:&#160;Box&lt;Self&gt;)&#160;-&gt;&#160;Box&lt;dyn&#160;State&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;17-16:&#160;Implementing&#160;the&#160;&#160;</b>approve&#160;<b>&#160;method&#160;on&#160;&#160;</b>Post&#160;<b>&#160;and&#160;the&#160;&#160;</b>State&#160;<b>&#160;trait</b><br/>
We add the&#160;&#160;approve&#160;&#160;method to the&#160;&#160;State&#160;&#160;trait and add a new struct that implements<br/>
State&#160;, the&#160;&#160;Published&#160;&#160;state.<br/>
Similar to the way&#160;&#160;request_review&#160;&#160;on&#160;&#160;PendingReview&#160;&#160;works, if we call the&#160;&#160;approve<br/>method on a&#160;&#160;Draft&#160;, it will have no eﬀect because&#160;&#160;approve&#160;&#160;will return&#160;&#160;self&#160;. When we call<br/>
approve&#160;&#160;on&#160;&#160;PendingReview&#160;, it returns a new, boxed instance of the&#160;&#160;Published&#160;&#160;struct. The<br/>Published&#160;&#160;struct implements the&#160;&#160;State&#160;&#160;trait, and for both the&#160;&#160;request_review&#160;&#160;method<br/>
https://doc.rust-lang.org/book/print.html<br/>
478/627<br/>
<hr/>
<a name=479></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
and the&#160;&#160;approve&#160;&#160;method, it returns itself, because the post should stay in the&#160;&#160;Published<br/>state in those cases.<br/>
Now we need to update the&#160;&#160;content&#160;&#160;method on&#160;&#160;Post&#160;. We want the value returned from<br/>
content&#160;&#160;to depend on the current state of the&#160;&#160;Post&#160;, so we’re going to have the&#160;&#160;Post<br/>
delegate to a&#160;&#160;content&#160;&#160;method deﬁned on its&#160;&#160;state&#160;, as shown in Listing 17-17:<br/>
Filename: src/lib.rs<br/>
impl&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;content(&amp;self)&#160;-&gt;&#160;&amp;str&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.state.as_ref().unwrap().content(self)<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
<b>Listing&#160;17-17:&#160;Updating&#160;the&#160;&#160;</b>content&#160;<b>&#160;method&#160;on&#160;&#160;</b>Post&#160;<b>&#160;to&#160;delegate&#160;to&#160;a&#160;&#160;</b>content&#160;<b>&#160;method&#160;on&#160;&#160;</b>State<br/>
Because the goal is to keep all these rules inside the structs that implement&#160;&#160;State&#160;, we call a<br/>
content&#160;&#160;method on the value in&#160;&#160;state&#160;&#160;and pass the post instance (that is,&#160;&#160;self&#160;) as an<br/>
argument. Then we return the value that’s returned from using the&#160;&#160;content&#160;&#160;method on the<br/>
state&#160;&#160;value.<br/>
We call the&#160;&#160;as_ref&#160;&#160;method on the&#160;&#160;Option&#160;&#160;because we want a reference to the value inside<br/>the&#160;&#160;Option&#160;&#160;rather than ownership of the value. Because&#160;&#160;state&#160;&#160;is an&#160;&#160;Option&lt;Box&lt;dyn&#160;<br/>State&gt;&gt;&#160;, when we call&#160;&#160;as_ref&#160;, an&#160;&#160;Option&lt;&amp;Box&lt;dyn&#160;State&gt;&gt;&#160;&#160;is returned. If we didn’t call<br/>
as_ref&#160;, we would get an error because we can’t move&#160;&#160;state&#160;&#160;out of the borrowed&#160;&#160;&amp;self<br/>
of the function parameter.<br/>
We then call the&#160;&#160;unwrap&#160;&#160;method, which we know will never panic, because we know the<br/>methods on&#160;&#160;Post&#160;&#160;ensure that&#160;&#160;state&#160;&#160;will always contain a&#160;&#160;Some&#160;&#160;value when those<br/><a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">methods are done. This is one of the cases we talked about in the&#160;“Cases In Which You Have<br/>More Information Than the Compiler”&#160;section of Chapter 9 when we know that a&#160;&#160;None<br/></a>value is never possible, even though the compiler isn’t able to understand that.<br/>
At this point, when we call&#160;&#160;content&#160;&#160;on the&#160;&#160;&amp;Box&lt;dyn&#160;State&gt;&#160;, deref coercion will take eﬀect<br/>on the&#160;&#160;&amp;&#160;&#160;and the&#160;&#160;Box&#160;&#160;so the&#160;&#160;content&#160;&#160;method will ultimately be called on the type that<br/>implements the&#160;&#160;State&#160;&#160;trait. That means we need to add&#160;&#160;content&#160;&#160;to the&#160;&#160;State&#160;&#160;trait<br/>deﬁnition, and that is where we’ll put the logic for what content to return depending on<br/>which state we have, as shown in Listing 17-18:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
479/627<br/>
<hr/>
<a name=480></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
trait&#160;State&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;fn&#160;content&lt;'a&gt;(&amp;self,&#160;post:&#160;&amp;'a&#160;Post)&#160;-&gt;&#160;&amp;'a&#160;str&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;&#34;<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
//&#160;--snip--<br/>struct&#160;Published&#160;{}<br/>
impl&#160;State&#160;for&#160;Published&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;fn&#160;content&lt;'a&gt;(&amp;self,&#160;post:&#160;&amp;'a&#160;Post)&#160;-&gt;&#160;&amp;'a&#160;str&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&amp;post.content<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;17-18:&#160;Adding&#160;the&#160;&#160;</b>content&#160;<b>&#160;method&#160;to&#160;the&#160;&#160;</b>State&#160;<b>&#160;trait</b><br/>
We add a default implementation for the&#160;&#160;content&#160;&#160;method that returns an empty string<br/>slice. That means we don’t need to implement&#160;&#160;content&#160;&#160;on the&#160;&#160;Draft&#160;&#160;and&#160;&#160;PendingReview<br/>structs. The&#160;&#160;Published&#160;&#160;struct will override the&#160;&#160;content&#160;&#160;method and return the value in<br/>
post.content&#160;.<br/>
Note that we need lifetime annotations on this method, as we discussed in Chapter 10.<br/>We’re taking a reference to a&#160;&#160;post&#160;&#160;as an argument and returning a reference to part of that<br/>
post&#160;, so the lifetime of the returned reference is related to the lifetime of the&#160;&#160;post<br/>
argument.<br/>
And we’re done—all of Listing 17-11 now works! We’ve implemented the state pattern with<br/>the rules of the blog post workﬂow. The logic related to the rules lives in the state objects<br/>rather than being scattered throughout&#160;&#160;Post&#160;.<br/>
<a href="tests.html#480"><b>Why Not An Enum?</b></a><br/>
You may have been wondering why we didn’t use an&#160;&#160;enum&#160;&#160;with the diﬀerent possible<br/>post states as variants. That’s certainly a possible solution, try it and compare the end<br/>results to see which you prefer! One disadvantage of using an enum is every place that<br/>checks the value of the enum will need a&#160;&#160;match&#160;&#160;expression or similar to handle every<br/>possible variant. This could get more repetitive than this trait object solution.<br/>
<a href="tests.html#480"><b>Trade-oﬀs&#160;of&#160;the&#160;State&#160;Pattern</b></a><br/>
We’ve shown that Rust is capable of implementing the object-oriented state pattern to<br/>encapsulate the diﬀerent kinds of behavior a post should have in each state. The methods<br/>
https://doc.rust-lang.org/book/print.html<br/>
480/627<br/>
<hr/>
<a name=481></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
on&#160;&#160;Post&#160;&#160;know nothing about the various behaviors. The way we organized the code, we<br/>have to look in only one place to know the diﬀerent ways a published post can behave: the<br/>implementation of the&#160;&#160;State&#160;&#160;trait on the&#160;&#160;Published&#160;&#160;struct.<br/>
If we were to create an alternative implementation that didn’t use the state pattern, we<br/>might instead use&#160;&#160;match&#160;&#160;expressions in the methods on&#160;&#160;Post&#160;&#160;or even in the&#160;&#160;main&#160;&#160;code<br/>that checks the state of the post and changes behavior in those places. That would mean we<br/>would have to look in several places to understand all the implications of a post being in the<br/>published state! This would only increase the more states we added: each of those&#160;&#160;match<br/>expressions would need another arm.<br/>
With the state pattern, the&#160;&#160;Post&#160;&#160;methods and the places we use&#160;&#160;Post&#160;&#160;don’t need&#160;&#160;match<br/>expressions, and to add a new state, we would only need to add a new struct and<br/>implement the trait methods on that one struct.<br/>
The implementation using the state pattern is easy to extend to add more functionality. To<br/>see the simplicity of maintaining code that uses the state pattern, try a few of these<br/>suggestions:<br/>
Add a&#160;&#160;reject&#160;&#160;method that changes the post’s state from&#160;&#160;PendingReview&#160;&#160;back to<br/>
Draft&#160;.<br/>
Require two calls to&#160;&#160;approve&#160;&#160;before the state can be changed to&#160;&#160;Published&#160;.<br/>Allow users to add text content only when a post is in the&#160;&#160;Draft&#160;&#160;state. Hint: have the<br/>state object responsible for what might change about the content but not responsible<br/>for modifying the&#160;&#160;Post&#160;.<br/>
One downside of the state pattern is that, because the states implement the transitions<br/>between states, some of the states are coupled to each other. If we add another state<br/>between&#160;&#160;PendingReview&#160;&#160;and&#160;&#160;Published&#160;, such as&#160;&#160;Scheduled&#160;, we would have to change the<br/>code in&#160;&#160;PendingReview&#160;&#160;to transition to&#160;&#160;Scheduled&#160;&#160;instead. It would be less work if<br/>
PendingReview&#160;&#160;didn’t need to change with the addition of a new state, but that would mean<br/>
switching to another design pattern.<br/>
Another downside is that we’ve duplicated some logic. To eliminate some of the duplication,<br/>we might try to make default implementations for the&#160;&#160;request_review&#160;&#160;and&#160;&#160;approve<br/>methods on the&#160;&#160;State&#160;&#160;trait that return&#160;&#160;self&#160;; however, this would violate object safety,<br/>because the trait doesn’t know what the concrete&#160;&#160;self&#160;&#160;will be exactly. We want to be able<br/>to use&#160;&#160;State&#160;&#160;as a trait object, so we need its methods to be object safe.<br/>
Other duplication includes the similar implementations of the&#160;&#160;request_review&#160;&#160;and<br/>
approve&#160;&#160;methods on&#160;&#160;Post&#160;. Both methods delegate to the implementation of the same<br/>
method on the value in the&#160;&#160;state&#160;&#160;ﬁeld of&#160;&#160;Option&#160;&#160;and set the new value of the&#160;&#160;state&#160;&#160;ﬁeld<br/>to the result. If we had a lot of methods on&#160;&#160;Post&#160;&#160;that followed this pattern, we might<br/>consider deﬁning a macro to eliminate the repetition (see the&#160;<a href="https://doc.rust-lang.org/book/ch19-06-macros.html#macros">“Macros”</a>&#160;section in Chapter<br/>19).<br/>
https://doc.rust-lang.org/book/print.html<br/>
481/627<br/>
<hr/>
<a name=482></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
By implementing the state pattern exactly as it’s deﬁned for object-oriented languages,<br/>we’re not taking as full advantage of Rust’s strengths as we could. Let’s look at some<br/>changes we can make to the&#160;&#160;blog&#160;&#160;crate that can make invalid states and transitions into<br/>compile time errors.<br/>
<a href="tests.html#482"><b>Encoding States and Behavior as Types</b></a><br/>
We’ll show you how to rethink the state pattern to get a diﬀerent set of trade-oﬀs. Rather<br/>than encapsulating the states and transitions completely so outside code has no knowledge<br/>of them, we’ll encode the states into diﬀerent types. Consequently, Rust’s type checking<br/>system will prevent attempts to use draft posts where only published posts are allowed by<br/>issuing a compiler error.<br/>
Let’s consider the&#160;ﬁrst part of&#160;&#160;main&#160;&#160;in Listing 17-11:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;post&#160;=&#160;Post::new();<br/>
&#160;&#160;&#160;&#160;post.add_text(&#34;I&#160;ate&#160;a&#160;salad&#160;for&#160;lunch&#160;today&#34;);<br/>&#160;&#160;&#160;&#160;assert_eq!(&#34;&#34;,&#160;post.content());<br/>}<br/>
We still enable the creation of new posts in the draft state using&#160;&#160;Post::new&#160;&#160;and the ability<br/>to add text to the post’s content. But instead of having a&#160;&#160;content&#160;&#160;method on a draft post<br/>that returns an empty string, we’ll make it so draft posts don’t have the&#160;&#160;content&#160;&#160;method at<br/>all. That way, if we try to get a draft post’s content, we’ll get a compiler error telling us the<br/>method doesn’t exist. As a result, it will be impossible for us to accidentally display draft<br/>post content in production, because that code won’t even compile. Listing 17-19 shows the<br/>deﬁnition of a&#160;&#160;Post&#160;&#160;struct and a&#160;&#160;DraftPost&#160;&#160;struct, as well as methods on each:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
482/627<br/>
<hr/>
<a name=483></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;struct&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;content:&#160;String,<br/>}<br/>
pub&#160;struct&#160;DraftPost&#160;{<br/>&#160;&#160;&#160;&#160;content:&#160;String,<br/>}<br/>
impl&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new()&#160;-&gt;&#160;DraftPost&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DraftPost&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content:&#160;String::new(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;pub&#160;fn&#160;content(&amp;self)&#160;-&gt;&#160;&amp;str&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&amp;self.content<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
impl&#160;DraftPost&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;add_text(&amp;mut&#160;self,&#160;text:&#160;&amp;str)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.content.push_str(text);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;17-19:&#160;A&#160;&#160;</b>Post&#160;<b>&#160;with&#160;a&#160;&#160;</b>content&#160;<b>&#160;method&#160;and&#160;a&#160;&#160;</b>DraftPost&#160;<b>&#160;without&#160;a&#160;&#160;</b>content&#160;<b>&#160;method</b><br/>
Both the&#160;&#160;Post&#160;&#160;and&#160;&#160;DraftPost&#160;&#160;structs have a private&#160;&#160;content&#160;&#160;ﬁeld that stores the blog<br/>post text. The structs no longer have the&#160;&#160;state&#160;&#160;ﬁeld because we’re moving the encoding of<br/>the state to the types of the structs. The&#160;&#160;Post&#160;&#160;struct will represent a published post, and it<br/>has a&#160;&#160;content&#160;&#160;method that returns the&#160;&#160;content&#160;.<br/>
We still have a&#160;&#160;Post::new&#160;&#160;function, but instead of returning an instance of&#160;&#160;Post&#160;, it returns<br/>an instance of&#160;&#160;DraftPost&#160;. Because&#160;&#160;content&#160;&#160;is private and there aren’t any functions that<br/>return&#160;&#160;Post&#160;, it’s not possible to create an instance of&#160;&#160;Post&#160;&#160;right now.<br/>
The&#160;&#160;DraftPost&#160;&#160;struct has an&#160;&#160;add_text&#160;&#160;method, so we can add text to&#160;&#160;content&#160;&#160;as before,<br/>but note that&#160;&#160;DraftPost&#160;&#160;does not have a&#160;&#160;content&#160;&#160;method deﬁned! So now the program<br/>ensures all posts start as draft posts, and draft posts don’t have their content available for<br/>display. Any attempt to get around these constraints will result in a compiler error.<br/>
<a href="tests.html#483"><b>Implementing Transitions as Transformations into Diﬀerent Types</b></a><br/>
So how do we get a published post? We want to enforce the rule that a draft post has to be<br/>reviewed and approved before it can be published. A post in the pending review state<br/>should still not display any content. Let’s implement these constraints by adding another<br/>struct,&#160;&#160;PendingReviewPost&#160;, deﬁning the&#160;&#160;request_review&#160;&#160;method on&#160;&#160;DraftPost&#160;&#160;to return<br/>a&#160;&#160;PendingReviewPost&#160;, and deﬁning an&#160;&#160;approve&#160;&#160;method on&#160;&#160;PendingReviewPost&#160;&#160;to return a<br/>
Post&#160;, as shown in Listing 17-20:<br/>
https://doc.rust-lang.org/book/print.html<br/>
483/627<br/>
<hr/>
<a name=484></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Filename: src/lib.rs<br/>
impl&#160;DraftPost&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;request_review(self)&#160;-&gt;&#160;PendingReviewPost&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;PendingReviewPost&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content:&#160;self.content,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
pub&#160;struct&#160;PendingReviewPost&#160;{<br/>&#160;&#160;&#160;&#160;content:&#160;String,<br/>}<br/>
impl&#160;PendingReviewPost&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;approve(self)&#160;-&gt;&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Post&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;content:&#160;self.content,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;17-20:&#160;A&#160;&#160;</b>PendingReviewPost&#160;<b>&#160;that&#160;gets&#160;created&#160;by&#160;calling&#160;&#160;</b>request_review&#160;<b>&#160;on&#160;&#160;</b>DraftPost&#160;<b>&#160;and&#160;an&#160;&#160;</b>approve<br/><b>method&#160;that&#160;turns&#160;a&#160;&#160;</b>PendingReviewPost&#160;<b>&#160;into&#160;a&#160;published&#160;&#160;</b>Post<br/>
The&#160;&#160;request_review&#160;&#160;and&#160;&#160;approve&#160;&#160;methods take ownership of&#160;&#160;self&#160;, thus consuming the<br/>
DraftPost&#160;&#160;and&#160;&#160;PendingReviewPost&#160;&#160;instances and transforming them into a<br/>PendingReviewPost&#160;&#160;and a published&#160;&#160;Post&#160;, respectively. This way, we won’t have any<br/>
lingering&#160;&#160;DraftPost&#160;&#160;instances after we’ve called&#160;&#160;request_review&#160;&#160;on them, and so forth.<br/>The&#160;&#160;PendingReviewPost&#160;&#160;struct doesn’t have a&#160;&#160;content&#160;&#160;method deﬁned on it, so attempting<br/>to read its content results in a compiler error, as with&#160;&#160;DraftPost&#160;. Because the only way to<br/>get a published&#160;&#160;Post&#160;&#160;instance that does have a&#160;&#160;content&#160;&#160;method deﬁned is to call the<br/>
approve&#160;&#160;method on a&#160;&#160;PendingReviewPost&#160;, and the only way to get a&#160;&#160;PendingReviewPost<br/>
is to call the&#160;&#160;request_review&#160;&#160;method on a&#160;&#160;DraftPost&#160;, we’ve now encoded the blog post<br/>workﬂow into the type system.<br/>
But we also have to make some small changes to&#160;&#160;main&#160;. The&#160;&#160;request_review&#160;&#160;and&#160;&#160;approve<br/>methods return new instances rather than modifying the struct they’re called on, so we<br/>need to add more&#160;&#160;let&#160;post&#160;=&#160;&#160;shadowing assignments to save the returned instances. We<br/>also can’t have the assertions about the draft and pending review posts’ contents be empty<br/>strings, nor do we need them: we can’t compile code that tries to use the content of posts in<br/>those states any longer. The updated code in&#160;&#160;main&#160;&#160;is shown in Listing 17-21:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
484/627<br/>
<hr/>
<a name=485></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;blog::Post;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;post&#160;=&#160;Post::new();<br/>
&#160;&#160;&#160;&#160;post.add_text(&#34;I&#160;ate&#160;a&#160;salad&#160;for&#160;lunch&#160;today&#34;);<br/>
&#160;&#160;&#160;&#160;let&#160;post&#160;=&#160;post.request_review();<br/>
&#160;&#160;&#160;&#160;let&#160;post&#160;=&#160;post.approve();<br/>
&#160;&#160;&#160;&#160;assert_eq!(&#34;I&#160;ate&#160;a&#160;salad&#160;for&#160;lunch&#160;today&#34;,&#160;post.content());<br/>}<br/>
<b>Listing&#160;17-21:&#160;Modiﬁcations&#160;to&#160;&#160;</b>main&#160;<b>&#160;to&#160;use&#160;the&#160;new&#160;implementation&#160;of&#160;the&#160;blog&#160;post&#160;workﬂow</b><br/>
The changes we needed to make to&#160;&#160;main&#160;&#160;to reassign&#160;&#160;post&#160;&#160;mean that this implementation<br/>doesn’t quite follow the object-oriented state pattern anymore: the transformations<br/>between the states are no longer encapsulated entirely within the&#160;&#160;Post&#160;&#160;implementation.<br/>However, our gain is that invalid states are now impossible because of the type system and<br/>the type checking that happens at compile time! This ensures that certain bugs, such as<br/>display of the content of an unpublished post, will be discovered before they make it to<br/>production.<br/>
Try the tasks suggested at the start of this section on the&#160;&#160;blog&#160;&#160;crate as it is after Listing 17-<br/>21 to see what you think about the design of this version of the code. Note that some of the<br/>tasks might be completed already in this design.<br/>
We’ve seen that even though Rust is capable of implementing object-oriented design<br/>patterns, other patterns, such as encoding state into the type system, are also available in<br/>Rust. These patterns have diﬀerent trade-oﬀs. Although you might be very familiar with<br/>object-oriented patterns, rethinking the problem to take advantage of Rust’s features can<br/>provide beneﬁts, such as preventing some bugs at compile time. Object-oriented patterns<br/>won’t always be the best solution in Rust due to certain features, like ownership, that object-<br/>oriented languages don’t have.<br/>
<a href="tests.html#485"><b>Summary</b></a><br/>
No matter whether or not you think Rust is an object-oriented language after reading this<br/>chapter, you now know that you can use trait objects to get some object-oriented features<br/>in Rust. Dynamic dispatch can give your code some&#160;ﬂexibility in exchange for a bit of<br/>runtime performance. You can use this&#160;ﬂexibility to implement object-oriented patterns that<br/>can help your code’s maintainability. Rust also has other features, like ownership, that<br/>object-oriented languages don’t have. An object-oriented pattern won’t always be the best<br/>way to take advantage of Rust’s strengths, but is an available option.<br/>
https://doc.rust-lang.org/book/print.html<br/>
485/627<br/>
<hr/>
<a name=486></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Next, we’ll look at patterns, which are another of Rust’s features that enable lots of<br/>ﬂexibility. We’ve looked at them brieﬂy throughout the book but haven’t seen their full<br/>capability yet. Let’s go!<br/>
https://doc.rust-lang.org/book/print.html<br/>
486/627<br/>
<hr/>
<a name=487></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#487"><b>Patterns and Matching</b></a><br/>
<i>Patterns</i>&#160;are a special syntax in Rust for matching against the structure of types, both<br/>complex and simple. Using patterns in conjunction with&#160;&#160;match&#160;&#160;expressions and other<br/>constructs gives you more control over a program’s control&#160;ﬂow. A pattern consists of some<br/>combination of the following:<br/>
Literals<br/>Destructured arrays, enums, structs, or tuples<br/>Variables<br/>Wildcards<br/>Placeholders<br/>
Some example patterns include&#160;&#160;x&#160;,&#160;&#160;(a,&#160;3)&#160;, and&#160;&#160;Some(Color::Red)&#160;. In the contexts in<br/>which patterns are valid, these components describe the shape of data. Our program then<br/>matches values against the patterns to determine whether it has the correct shape of data<br/>to continue running a particular piece of code.<br/>
To use a pattern, we compare it to some value. If the pattern matches the value, we use the<br/>value parts in our code. Recall the&#160;&#160;match&#160;&#160;expressions in Chapter 6 that used patterns, such<br/>as the coin-sorting machine example. If the value&#160;ﬁts the shape of the pattern, we can use<br/>the named pieces. If it doesn’t, the code associated with the pattern won’t run.<br/>
This chapter is a reference on all things related to patterns. We’ll cover the valid places to<br/>use patterns, the diﬀerence between refutable and irrefutable patterns, and the diﬀerent<br/>kinds of pattern syntax that you might see. By the end of the chapter, you’ll know how to<br/>use patterns to express many concepts in a clear way.<br/>
https://doc.rust-lang.org/book/print.html<br/>
487/627<br/>
<hr/>
<a name=488></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#488"><b>All the Places Patterns Can Be Used</b></a><br/>
Patterns pop up in a number of places in Rust, and you’ve been using them a lot without<br/>realizing it! This section discusses all the places where patterns are valid.<br/>
<a href="tests.html#488">match<b>&#160;Arms</b></a><br/>
As discussed in Chapter 6, we use patterns in the arms of&#160;&#160;match&#160;&#160;expressions. Formally,<br/>
match&#160;&#160;expressions are deﬁned as the keyword&#160;&#160;match&#160;, a value to match on, and one or<br/>
more match arms that consist of a pattern and an expression to run if the value matches<br/>that arm’s pattern, like this:<br/>
match&#160;VALUE&#160;{<br/>&#160;&#160;&#160;&#160;PATTERN&#160;=&gt;&#160;EXPRESSION,<br/>&#160;&#160;&#160;&#160;PATTERN&#160;=&gt;&#160;EXPRESSION,<br/>&#160;&#160;&#160;&#160;PATTERN&#160;=&gt;&#160;EXPRESSION,<br/>}<br/>
For example, here's the&#160;&#160;match&#160;&#160;expression from Listing 6-5 that matches on an<br/>
Option&lt;i32&gt;&#160;&#160;value in the variable&#160;&#160;x&#160;:<br/>
match&#160;x&#160;{<br/>&#160;&#160;&#160;&#160;None&#160;=&gt;&#160;None,<br/>&#160;&#160;&#160;&#160;Some(i)&#160;=&gt;&#160;Some(i&#160;+&#160;1),<br/>}<br/>
The patterns in this&#160;&#160;match&#160;&#160;expression are the&#160;&#160;None&#160;&#160;and&#160;&#160;Some(i)&#160;&#160;on the left of each arrow.<br/>
One requirement for&#160;&#160;match&#160;&#160;expressions is that they need to be&#160;<i>exhaustive</i>&#160;in the sense that<br/>all possibilities for the value in the&#160;&#160;match&#160;&#160;expression must be accounted for. One way to<br/>ensure you’ve covered every possibility is to have a catchall pattern for the last arm: for<br/>example, a variable name matching any value can never fail and thus covers every<br/>remaining case.<br/>
The particular pattern&#160;&#160;_&#160;&#160;will match anything, but it never binds to a variable, so it’s often<br/>used in the last match arm. The&#160;&#160;_&#160;&#160;pattern can be useful when you want to ignore any value<br/><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">not speciﬁed, for example. We’ll cover the&#160;&#160;_&#160;&#160;pattern in more detail in the&#160;“Ignoring Values<br/>in a Pattern”&#160;section later in this chapter.</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
488/627<br/>
<hr/>
<a name=489></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#489"><b>Conditional&#160;</b>if&#160;let<b>&#160;Expressions</b></a><br/>
In Chapter 6 we discussed how to use&#160;&#160;if&#160;let&#160;&#160;expressions mainly as a shorter way to write<br/>the equivalent of a&#160;&#160;match&#160;&#160;that only matches one case. Optionally,&#160;&#160;if&#160;let&#160;&#160;can have a<br/>corresponding&#160;&#160;else&#160;&#160;containing code to run if the pattern in the&#160;&#160;if&#160;let&#160;&#160;doesn’t match.<br/>
Listing 18-1 shows that it’s also possible to mix and match&#160;&#160;if&#160;let&#160;,&#160;&#160;else&#160;if&#160;, and&#160;&#160;else&#160;if&#160;<br/>let&#160;&#160;expressions. Doing so gives us more&#160;ﬂexibility than a&#160;&#160;match&#160;&#160;expression in which we<br/>can express only one value to compare with the patterns. Also, Rust doesn't require that the<br/>conditions in a series of&#160;&#160;if&#160;let&#160;,&#160;&#160;else&#160;if&#160;,&#160;&#160;else&#160;if&#160;let&#160;&#160;arms relate to each other.<br/>
The code in Listing 18-1 determines what color to make your background based on a series<br/>of checks for several conditions. For this example, we’ve created variables with hardcoded<br/>values that a real program might receive from user input.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;favorite_color:&#160;Option&lt;&amp;str&gt;&#160;=&#160;None;<br/>&#160;&#160;&#160;&#160;let&#160;is_tuesday&#160;=&#160;false;<br/>&#160;&#160;&#160;&#160;let&#160;age:&#160;Result&lt;u8,&#160;_&gt;&#160;=&#160;&#34;34&#34;.parse();<br/>
&#160;&#160;&#160;&#160;if&#160;let&#160;Some(color)&#160;=&#160;favorite_color&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Using&#160;your&#160;favorite&#160;color,&#160;{color},&#160;as&#160;the&#160;background&#34;);<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;if&#160;is_tuesday&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Tuesday&#160;is&#160;green&#160;day!&#34;);<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;if&#160;let&#160;Ok(age)&#160;=&#160;age&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;age&#160;&gt;&#160;30&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Using&#160;purple&#160;as&#160;the&#160;background&#160;color&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Using&#160;orange&#160;as&#160;the&#160;background&#160;color&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Using&#160;blue&#160;as&#160;the&#160;background&#160;color&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;18-1:&#160;Mixing&#160;&#160;</b>if&#160;let&#160;<b>,&#160;&#160;</b>else&#160;if&#160;<b>,&#160;&#160;</b>else&#160;if&#160;let&#160;<b>,&#160;and&#160;&#160;</b>else<br/>
If the user speciﬁes a favorite color, that color is used as the background. If no favorite color<br/>is speciﬁed and today is Tuesday, the background color is green. Otherwise, if the user<br/>speciﬁes their age as a string and we can parse it as a number successfully, the color is<br/>either purple or orange depending on the value of the number. If none of these conditions<br/>apply, the background color is blue.<br/>
This conditional structure lets us support complex requirements. With the hardcoded values<br/>we have here, this example will print&#160;&#160;Using&#160;purple&#160;as&#160;the&#160;background&#160;color&#160;.<br/>
You can see that&#160;&#160;if&#160;let&#160;&#160;can also introduce shadowed variables in the same way that<br/>
match&#160;&#160;arms can: the line&#160;&#160;if&#160;let&#160;Ok(age)&#160;=&#160;age&#160;&#160;introduces a new shadowed&#160;&#160;age&#160;&#160;variable<br/>
https://doc.rust-lang.org/book/print.html<br/>
489/627<br/>
<hr/>
<a name=490></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
that contains the value inside the&#160;&#160;Ok&#160;&#160;variant. This means we need to place the&#160;&#160;if&#160;age&#160;&gt;&#160;<br/>30&#160;&#160;condition within that block: we can’t combine these two conditions into&#160;&#160;if&#160;let&#160;Ok(age)&#160;<br/>=&#160;age&#160;&amp;&amp;&#160;age&#160;&gt;&#160;30&#160;. The shadowed&#160;&#160;age&#160;&#160;we want to compare to 30 isn’t valid until the new<br/>scope starts with the curly bracket.<br/>
The downside of using&#160;&#160;if&#160;let&#160;&#160;expressions is that the compiler doesn’t check for<br/>exhaustiveness, whereas with&#160;&#160;match&#160;&#160;expressions it does. If we omitted the last&#160;&#160;else&#160;&#160;block<br/>and therefore missed handling some cases, the compiler would not alert us to the possible<br/>logic bug.<br/>
<a href="tests.html#490">while&#160;let<b>&#160;Conditional&#160;Loops</b></a><br/>
Similar in construction to&#160;&#160;if&#160;let&#160;, the&#160;&#160;while&#160;let&#160;&#160;conditional loop allows a&#160;&#160;while&#160;&#160;loop to<br/>run for as long as a pattern continues to match. In Listing 18-2 we code a&#160;&#160;while&#160;let&#160;&#160;loop<br/>that uses a vector as a stack and prints the values in the vector in the opposite order in<br/>which they were pushed.<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;stack&#160;=&#160;Vec::new();<br/>
&#160;&#160;&#160;&#160;stack.push(1);<br/>&#160;&#160;&#160;&#160;stack.push(2);<br/>&#160;&#160;&#160;&#160;stack.push(3);<br/>
&#160;&#160;&#160;&#160;while&#160;let&#160;Some(top)&#160;=&#160;stack.pop()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;{}&#34;,&#160;top);<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;18-2:&#160;Using&#160;a&#160;&#160;</b>while&#160;let&#160;<b>&#160;loop&#160;to&#160;print&#160;values&#160;for&#160;as&#160;long&#160;as&#160;&#160;</b>stack.pop()&#160;<b>&#160;returns&#160;&#160;</b>Some<br/>
This example prints 3, 2, and then 1. The&#160;&#160;pop&#160;&#160;method takes the last element out of the<br/>vector and returns&#160;&#160;Some(value)&#160;. If the vector is empty,&#160;&#160;pop&#160;&#160;returns&#160;&#160;None&#160;. The&#160;&#160;while&#160;&#160;loop<br/>continues running the code in its block as long as&#160;&#160;pop&#160;&#160;returns&#160;&#160;Some&#160;. When&#160;&#160;pop&#160;&#160;returns<br/>
None&#160;, the loop stops. We can use&#160;&#160;while&#160;let&#160;&#160;to pop every element oﬀ&#160;our stack.<br/>
<a href="tests.html#490">for<b>&#160;Loops</b></a><br/>
In a&#160;&#160;for&#160;&#160;loop, the value that directly follows the keyword&#160;&#160;for&#160;&#160;is a pattern. For example, in<br/>
for&#160;x&#160;in&#160;y&#160;&#160;the&#160;&#160;x&#160;&#160;is the pattern. Listing 18-3 demonstrates how to use a pattern in a&#160;&#160;for<br/>
loop to destructure, or break apart, a tuple as part of the&#160;&#160;for&#160;&#160;loop.<br/>
https://doc.rust-lang.org/book/print.html<br/>
490/627<br/>
<hr/>
<a name=491></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;let&#160;v&#160;=&#160;vec!['a',&#160;'b',&#160;'c'];<br/>
&#160;&#160;&#160;&#160;for&#160;(index,&#160;value)&#160;in&#160;v.iter().enumerate()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;{}&#160;is&#160;at&#160;index&#160;{}&#34;,&#160;value,&#160;index);<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;18-3:&#160;Using&#160;a&#160;pattern&#160;in&#160;a&#160;&#160;</b>for&#160;<b>&#160;loop&#160;to&#160;destructure&#160;a&#160;tuple</b><br/>
The code in Listing 18-3 will print the following:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;patterns&#160;v0.1.0&#160;(file:///projects/patterns)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.52s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/patterns`<br/>a&#160;is&#160;at&#160;index&#160;0<br/>b&#160;is&#160;at&#160;index&#160;1<br/>c&#160;is&#160;at&#160;index&#160;2<br/>
We adapt an iterator using the&#160;&#160;enumerate&#160;&#160;method so it produces a value and the index for<br/>that value, placed into a tuple. The&#160;ﬁrst value produced is the tuple&#160;&#160;(0,&#160;'a')&#160;. When this<br/>value is matched to the pattern&#160;&#160;(index,&#160;value)&#160;,&#160;&#160;index&#160;&#160;will be&#160;&#160;0&#160;&#160;and&#160;&#160;value&#160;&#160;will be&#160;&#160;'a'&#160;,<br/>printing the&#160;ﬁrst line of the output.<br/>
<a href="tests.html#491">let<b>&#160;Statements</b></a><br/>
Prior to this chapter, we had only explicitly discussed using patterns with&#160;&#160;match&#160;&#160;and&#160;&#160;if&#160;<br/>let&#160;, but in fact, we’ve used patterns in other places as well, including in&#160;&#160;let&#160;&#160;statements.<br/>For example, consider this straightforward variable assignment with&#160;&#160;let&#160;:<br/>
let&#160;x&#160;=&#160;5;<br/>
Every time you've used a&#160;&#160;let&#160;&#160;statement like this you've been using patterns, although you<br/>might not have realized it! More formally, a&#160;&#160;let&#160;&#160;statement looks like this:<br/>
let&#160;PATTERN&#160;=&#160;EXPRESSION;<br/>
In statements like&#160;&#160;let&#160;x&#160;=&#160;5;&#160;&#160;with a variable name in the&#160;&#160;PATTERN&#160;&#160;slot, the variable name<br/>is just a particularly simple form of a pattern. Rust compares the expression against the<br/>pattern and assigns any names it&#160;ﬁnds. So in the&#160;&#160;let&#160;x&#160;=&#160;5;&#160;&#160;example,&#160;&#160;x&#160;&#160;is a pattern that<br/>means “bind what matches here to the variable&#160;&#160;x&#160;.” Because the name&#160;&#160;x&#160;&#160;is the whole<br/>pattern, this pattern eﬀectively means “bind everything to the variable&#160;&#160;x&#160;, whatever the<br/>value is.”<br/>
To see the pattern matching aspect of&#160;&#160;let&#160;&#160;more clearly, consider Listing 18-4, which uses a<br/>pattern with&#160;&#160;let&#160;&#160;to destructure a tuple.<br/>
https://doc.rust-lang.org/book/print.html<br/>
491/627<br/>
<hr/>
<a name=492></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;let&#160;(x,&#160;y,&#160;z)&#160;=&#160;(1,&#160;2,&#160;3);<br/>
<b>Listing&#160;18-4:&#160;Using&#160;a&#160;pattern&#160;to&#160;destructure&#160;a&#160;tuple&#160;and&#160;create&#160;three&#160;variables&#160;at&#160;once</b><br/>
Here, we match a tuple against a pattern. Rust compares the value&#160;&#160;(1,&#160;2,&#160;3)&#160;&#160;to the<br/>pattern&#160;&#160;(x,&#160;y,&#160;z)&#160;&#160;and sees that the value matches the pattern, so Rust binds&#160;&#160;1&#160;&#160;to&#160;&#160;x&#160;,&#160;&#160;2<br/>to&#160;&#160;y&#160;, and&#160;&#160;3&#160;&#160;to&#160;&#160;z&#160;. You can think of this tuple pattern as nesting three individual variable<br/>patterns inside it.<br/>
If the number of elements in the pattern doesn’t match the number of elements in the<br/>tuple, the overall type won’t match and we’ll get a compiler error. For example, Listing 18-5<br/>shows an attempt to destructure a tuple with three elements into two variables, which won’t<br/>work.<br/>
&#160;&#160;&#160;&#160;let&#160;(x,&#160;y)&#160;=&#160;(1,&#160;2,&#160;3);<br/>
<b>Listing&#160;18-5:&#160;Incorrectly&#160;constructing&#160;a&#160;pattern&#160;whose&#160;variables&#160;don’t&#160;match&#160;the&#160;number&#160;of&#160;elements&#160;in&#160;the<br/>tuple</b><br/>
Attempting to compile this code results in this type error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;patterns&#160;v0.1.0&#160;(file:///projects/patterns)<br/>error[E0308]:&#160;mismatched&#160;types<br/>&#160;--&gt;&#160;src/main.rs:2:9<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;(x,&#160;y)&#160;=&#160;(1,&#160;2,&#160;3);<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^&#160;&#160;&#160;---------&#160;this&#160;expression&#160;has&#160;type&#160;`({integer},&#160;{integer},&#160;<br/>{integer})`<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;expected&#160;a&#160;tuple&#160;with&#160;3&#160;elements,&#160;found&#160;one&#160;with&#160;2&#160;elements<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;expected&#160;tuple&#160;`({integer},&#160;{integer},&#160;{integer})`<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;found&#160;tuple&#160;`(_,&#160;_)`<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0308`.<br/>error:&#160;could&#160;not&#160;compile&#160;`patterns`&#160;due&#160;to&#160;previous&#160;error<br/>
To&#160;ﬁx the error, we could ignore one or more of the values in the tuple using&#160;&#160;_&#160;&#160;or&#160;&#160;..&#160;, as<br/><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">you’ll see in the&#160;“Ignoring Values in a Pattern”</a>&#160;section. If the problem is that we have too<br/>many variables in the pattern, the solution is to make the types match by removing<br/>variables so the number of variables equals the number of elements in the tuple.<br/>
<a href="tests.html#492"><b>Function&#160;Parameters</b></a><br/>
Function parameters can also be patterns. The code in Listing 18-6, which declares a<br/>function named&#160;&#160;foo&#160;&#160;that takes one parameter named&#160;&#160;x&#160;&#160;of type&#160;&#160;i32&#160;, should by now look<br/>
https://doc.rust-lang.org/book/print.html<br/>
492/627<br/>
<hr/>
<a name=493></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
familiar.<br/>
fn&#160;foo(x:&#160;i32)&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;code&#160;goes&#160;here<br/>}<br/>
<b>Listing&#160;18-6:&#160;A&#160;function&#160;signature&#160;uses&#160;patterns&#160;in&#160;the&#160;parameters</b><br/>
The&#160;&#160;x&#160;&#160;part is a pattern! As we did with&#160;&#160;let&#160;, we could match a tuple in a function’s<br/>arguments to the pattern. Listing 18-7 splits the values in a tuple as we pass it to a function.<br/>
Filename: src/main.rs<br/>
fn&#160;print_coordinates(&amp;(x,&#160;y):&#160;&amp;(i32,&#160;i32))&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Current&#160;location:&#160;({},&#160;{})&#34;,&#160;x,&#160;y);<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;point&#160;=&#160;(3,&#160;5);<br/>&#160;&#160;&#160;&#160;print_coordinates(&amp;point);<br/>}<br/>
<b>Listing&#160;18-7:&#160;A&#160;function&#160;with&#160;parameters&#160;that&#160;destructure&#160;a&#160;tuple</b><br/>
This code prints&#160;&#160;Current&#160;location:&#160;(3,&#160;5)&#160;. The values&#160;&#160;&amp;(3,&#160;5)&#160;&#160;match the pattern&#160;&#160;&amp;(x,&#160;<br/>y)&#160;, so&#160;&#160;x&#160;&#160;is the value&#160;&#160;3&#160;&#160;and&#160;&#160;y&#160;&#160;is the value&#160;&#160;5&#160;.<br/>
We can also use patterns in closure parameter lists in the same way as in function<br/>parameter lists, because closures are similar to functions, as discussed in Chapter 13.<br/>
At this point, you’ve seen several ways of using patterns, but patterns don’t work the same<br/>in every place we can use them. In some places, the patterns must be irrefutable; in other<br/>circumstances, they can be refutable. We’ll discuss these two concepts next.<br/>
https://doc.rust-lang.org/book/print.html<br/>
493/627<br/>
<hr/>
<a name=494></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#494"><b>Refutability: Whether a Pattern Might Fail to Match</b></a><br/>
Patterns come in two forms: refutable and irrefutable. Patterns that will match for any<br/>possible value passed are&#160;<i>irrefutable</i>. An example would be&#160;&#160;x&#160;&#160;in the statement&#160;&#160;let&#160;x&#160;=&#160;5;<br/>because&#160;&#160;x&#160;&#160;matches anything and therefore cannot fail to match. Patterns that can fail to<br/>match for some possible value are&#160;<i>refutable</i>. An example would be&#160;&#160;Some(x)&#160;&#160;in the<br/>expression&#160;&#160;if&#160;let&#160;Some(x)&#160;=&#160;a_value&#160;&#160;because if the value in the&#160;&#160;a_value&#160;&#160;variable is<br/>
None&#160;&#160;rather than&#160;&#160;Some&#160;, the&#160;&#160;Some(x)&#160;&#160;pattern will not match.<br/>
Function parameters,&#160;&#160;let&#160;&#160;statements, and&#160;&#160;for&#160;&#160;loops can only accept irrefutable patterns,<br/>because the program cannot do anything meaningful when values don’t match. The&#160;&#160;if&#160;let<br/>and&#160;&#160;while&#160;let&#160;&#160;expressions accept refutable and irrefutable patterns, but the compiler<br/>warns against irrefutable patterns because by deﬁnition they’re intended to handle possible<br/>failure: the functionality of a conditional is in its ability to perform diﬀerently depending on<br/>success or failure.<br/>
In general, you shouldn’t have to worry about the distinction between refutable and<br/>irrefutable patterns; however, you do need to be familiar with the concept of refutability so<br/>you can respond when you see it in an error message. In those cases, you’ll need to change<br/>either the pattern or the construct you’re using the pattern with, depending on the intended<br/>behavior of the code.<br/>
Let’s look at an example of what happens when we try to use a refutable pattern where Rust<br/>requires an irrefutable pattern and vice versa. Listing 18-8 shows a&#160;&#160;let&#160;&#160;statement, but for<br/>the pattern we’ve speciﬁed&#160;&#160;Some(x)&#160;, a refutable pattern. As you might expect, this code will<br/>not compile.<br/>
&#160;&#160;&#160;&#160;let&#160;Some(x)&#160;=&#160;some_option_value;<br/>
<b>Listing&#160;18-8:&#160;Attempting&#160;to&#160;use&#160;a&#160;refutable&#160;pattern&#160;with&#160;&#160;</b>let<br/>
If&#160;&#160;some_option_value&#160;&#160;was a&#160;&#160;None&#160;&#160;value, it would fail to match the pattern&#160;&#160;Some(x)&#160;,<br/>meaning the pattern is refutable. However, the&#160;&#160;let&#160;&#160;statement can only accept an<br/>irrefutable pattern because there is nothing valid the code can do with a&#160;&#160;None&#160;&#160;value. At<br/>compile time, Rust will complain that we’ve tried to use a refutable pattern where an<br/>irrefutable pattern is required:<br/>
https://doc.rust-lang.org/book/print.html<br/>
494/627<br/>
<hr/>
<a name=495></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;patterns&#160;v0.1.0&#160;(file:///projects/patterns)<br/>error[E0005]:&#160;refutable&#160;pattern&#160;in&#160;local&#160;binding:&#160;`None`&#160;not&#160;covered<br/>&#160;--&gt;&#160;src/main.rs:3:9<br/>&#160;&#160;|<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;Some(x)&#160;=&#160;some_option_value;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^&#160;pattern&#160;`None`&#160;not&#160;covered<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;`let`&#160;bindings&#160;require&#160;an&#160;&#34;irrefutable&#160;pattern&#34;,&#160;like&#160;a&#160;`struct`&#160;or&#160;<br/>an&#160;`enum`&#160;with&#160;only&#160;one&#160;variant<br/>&#160;&#160;=&#160;note:&#160;for&#160;more&#160;information,&#160;visit&#160;https://doc.rust-lang.org/book/ch18-02-<br/>refutability.html<br/>note:&#160;`Option&lt;i32&gt;`&#160;defined&#160;here<br/>&#160;--&gt;&#160;<br/>/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:518:<br/>1<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;<br/>/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:522:<br/>5:&#160;not&#160;covered<br/>&#160;&#160;=&#160;note:&#160;the&#160;matched&#160;value&#160;is&#160;of&#160;type&#160;`Option&lt;i32&gt;`<br/>help:&#160;you&#160;might&#160;want&#160;to&#160;use&#160;`if&#160;let`&#160;to&#160;ignore&#160;the&#160;variant&#160;that&#160;isn't&#160;matched<br/>&#160;&#160;|<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;if&#160;let&#160;Some(x)&#160;=&#160;some_option_value&#160;{&#160;x&#160;}&#160;else&#160;{&#160;todo!()&#160;};<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;++++++++++&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++++++++++++++++++++++<br/>help:&#160;alternatively,&#160;you&#160;might&#160;want&#160;to&#160;use&#160;let&#160;else&#160;to&#160;handle&#160;the&#160;variant&#160;that&#160;<br/>isn't&#160;matched<br/>&#160;&#160;|<br/>3&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;Some(x)&#160;=&#160;some_option_value&#160;else&#160;{&#160;todo!()&#160;};<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;++++++++++++++++<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0005`.<br/>error:&#160;could&#160;not&#160;compile&#160;`patterns`&#160;due&#160;to&#160;previous&#160;error<br/>
Because we didn’t cover (and couldn’t cover!) every valid value with the pattern&#160;&#160;Some(x)&#160;,<br/>Rust rightfully produces a compiler error.<br/>
If we have a refutable pattern where an irrefutable pattern is needed, we can&#160;ﬁx it by<br/>changing the code that uses the pattern: instead of using&#160;&#160;let&#160;, we can use&#160;&#160;if&#160;let&#160;. Then if<br/>the pattern doesn’t match, the code will just skip the code in the curly brackets, giving it a<br/>way to continue validly. Listing 18-9 shows how to&#160;ﬁx the code in Listing 18-8.<br/>
&#160;&#160;&#160;&#160;if&#160;let&#160;Some(x)&#160;=&#160;some_option_value&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;{}&#34;,&#160;x);<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;18-9:&#160;Using&#160;&#160;</b>if&#160;let&#160;<b>&#160;and&#160;a&#160;block&#160;with&#160;refutable&#160;patterns&#160;instead&#160;of&#160;&#160;</b>let<br/>
We’ve given the code an out! This code is perfectly valid, although it means we cannot use<br/>an irrefutable pattern without receiving an error. If we give&#160;&#160;if&#160;let&#160;&#160;a pattern that will<br/>always match, such as&#160;&#160;x&#160;, as shown in Listing 18-10, the compiler will give a warning.<br/>
https://doc.rust-lang.org/book/print.html<br/>
495/627<br/>
<hr/>
<a name=496></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;if&#160;let&#160;x&#160;=&#160;5&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;{}&#34;,&#160;x);<br/>&#160;&#160;&#160;&#160;};<br/>
<b>Listing&#160;18-10:&#160;Attempting&#160;to&#160;use&#160;an&#160;irrefutable&#160;pattern&#160;with&#160;&#160;</b>if&#160;let<br/>
Rust complains that it doesn’t make sense to use&#160;&#160;if&#160;let&#160;&#160;with an irrefutable pattern:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;patterns&#160;v0.1.0&#160;(file:///projects/patterns)<br/>warning:&#160;irrefutable&#160;`if&#160;let`&#160;pattern<br/>&#160;--&gt;&#160;src/main.rs:2:8<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;if&#160;let&#160;x&#160;=&#160;5&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;this&#160;pattern&#160;will&#160;always&#160;match,&#160;so&#160;the&#160;`if&#160;let`&#160;is&#160;useless<br/>&#160;&#160;=&#160;help:&#160;consider&#160;replacing&#160;the&#160;`if&#160;let`&#160;with&#160;a&#160;`let`<br/>&#160;&#160;=&#160;note:&#160;`#[warn(irrefutable_let_patterns)]`&#160;on&#160;by&#160;default<br/>
warning:&#160;`patterns`&#160;(bin&#160;&#34;patterns&#34;)&#160;generated&#160;1&#160;warning<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.39s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/patterns`<br/>5<br/>
For this reason, match arms must use refutable patterns, except for the last arm, which<br/>should match any remaining values with an irrefutable pattern. Rust allows us to use an<br/>irrefutable pattern in a&#160;&#160;match&#160;&#160;with only one arm, but this syntax isn’t particularly useful and<br/>could be replaced with a simpler&#160;&#160;let&#160;&#160;statement.<br/>
Now that you know where to use patterns and the diﬀerence between refutable and<br/>irrefutable patterns, let’s cover all the syntax we can use to create patterns.<br/>
https://doc.rust-lang.org/book/print.html<br/>
496/627<br/>
<hr/>
<a name=497></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#497"><b>Pattern Syntax</b></a><br/>
In this section, we gather all the syntax valid in patterns and discuss why and when you<br/>might want to use each one.<br/>
<a href="tests.html#497"><b>Matching&#160;Literals</b></a><br/>
As you saw in Chapter 6, you can match patterns against literals directly. The following code<br/>gives some examples:<br/>
&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;1;<br/>
&#160;&#160;&#160;&#160;match&#160;x&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1&#160;=&gt;&#160;println!(&#34;one&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2&#160;=&gt;&#160;println!(&#34;two&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3&#160;=&gt;&#160;println!(&#34;three&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;println!(&#34;anything&#34;),<br/>&#160;&#160;&#160;&#160;}<br/>
This code prints&#160;&#160;one&#160;&#160;because the value in&#160;&#160;x&#160;&#160;is 1. This syntax is useful when you want your<br/>code to take an action if it gets a particular concrete value.<br/>
<a href="tests.html#497"><b>Matching&#160;Named&#160;Variables</b></a><br/>
Named variables are irrefutable patterns that match any value, and we’ve used them many<br/>times in the book. However, there is a complication when you use named variables in<br/>
match&#160;&#160;expressions. Because&#160;&#160;match&#160;&#160;starts a new scope, variables declared as part of a<br/>
pattern inside the&#160;&#160;match&#160;&#160;expression will shadow those with the same name outside the<br/>
match&#160;&#160;construct, as is the case with all variables. In Listing 18-11, we declare a variable<br/>
named&#160;&#160;x&#160;&#160;with the value&#160;&#160;Some(5)&#160;&#160;and a variable&#160;&#160;y&#160;&#160;with the value&#160;&#160;10&#160;. We then create a<br/>
match&#160;&#160;expression on the value&#160;&#160;x&#160;. Look at the patterns in the match arms and&#160;&#160;println!&#160;&#160;at<br/>
the end, and try to&#160;ﬁgure out what the code will print before running this code or reading<br/>further.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
497/627<br/>
<hr/>
<a name=498></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;Some(5);<br/>&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;10;<br/>
&#160;&#160;&#160;&#160;match&#160;x&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(50)&#160;=&gt;&#160;println!(&#34;Got&#160;50&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(y)&#160;=&gt;&#160;println!(&#34;Matched,&#160;y&#160;=&#160;{y}&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;println!(&#34;Default&#160;case,&#160;x&#160;=&#160;{:?}&#34;,&#160;x),<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;at&#160;the&#160;end:&#160;x&#160;=&#160;{:?},&#160;y&#160;=&#160;{y}&#34;,&#160;x);<br/>
<b>Listing&#160;18-11:&#160;A&#160;&#160;</b>match&#160;<b>&#160;expression&#160;with&#160;an&#160;arm&#160;that&#160;introduces&#160;a&#160;shadowed&#160;variable&#160;&#160;</b>y<br/>
Let’s walk through what happens when the&#160;&#160;match&#160;&#160;expression runs. The pattern in the&#160;ﬁrst<br/>match arm doesn’t match the deﬁned value of&#160;&#160;x&#160;, so the code continues.<br/>
The pattern in the second match arm introduces a new variable named&#160;&#160;y&#160;&#160;that will match<br/>any value inside a&#160;&#160;Some&#160;&#160;value. Because we’re in a new scope inside the&#160;&#160;match&#160;&#160;expression,<br/>this is a new&#160;&#160;y&#160;&#160;variable, not the&#160;&#160;y&#160;&#160;we declared at the beginning with the value 10. This new<br/>
y&#160;&#160;binding will match any value inside a&#160;&#160;Some&#160;, which is what we have in&#160;&#160;x&#160;. Therefore, this<br/>
new&#160;&#160;y&#160;&#160;binds to the inner value of the&#160;&#160;Some&#160;&#160;in&#160;&#160;x&#160;. That value is&#160;&#160;5&#160;, so the expression for<br/>that arm executes and prints&#160;&#160;Matched,&#160;y&#160;=&#160;5&#160;.<br/>
If&#160;&#160;x&#160;&#160;had been a&#160;&#160;None&#160;&#160;value instead of&#160;&#160;Some(5)&#160;, the patterns in the&#160;ﬁrst two arms wouldn’t<br/>have matched, so the value would have matched to the underscore. We didn’t introduce the<br/>
x&#160;&#160;variable in the pattern of the underscore arm, so the&#160;&#160;x&#160;&#160;in the expression is still the outer<br/>x&#160;&#160;that hasn’t been shadowed. In this hypothetical case, the&#160;&#160;match&#160;&#160;would print&#160;&#160;Default&#160;<br/>
case,&#160;x&#160;=&#160;None&#160;.<br/>
When the&#160;&#160;match&#160;&#160;expression is done, its scope ends, and so does the scope of the inner&#160;&#160;y&#160;.<br/>The last&#160;&#160;println!&#160;&#160;produces&#160;&#160;at&#160;the&#160;end:&#160;x&#160;=&#160;Some(5),&#160;y&#160;=&#160;10&#160;.<br/>
To create a&#160;&#160;match&#160;&#160;expression that compares the values of the outer&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;, rather than<br/>introducing a shadowed variable, we would need to use a match guard conditional instead.<br/><a href="https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#extra-conditionals-with-match-guards">We’ll talk about match guards later in the&#160;“Extra Conditionals with Match Guards”&#160;section.</a><br/>
<a href="tests.html#498"><b>Multiple&#160;Patterns</b></a><br/>
In&#160;&#160;match&#160;&#160;expressions, you can match multiple patterns using the&#160;&#160;|&#160;&#160;syntax, which is the<br/>pattern&#160;<i>or</i>&#160;operator. For example, in the following code we match the value of&#160;&#160;x&#160;&#160;against the<br/>match arms, the&#160;ﬁrst of which has an&#160;<i>or</i>&#160;option, meaning if the value of&#160;&#160;x&#160;&#160;matches either of<br/>the values in that arm, that arm’s code will run:<br/>
https://doc.rust-lang.org/book/print.html<br/>
498/627<br/>
<hr/>
<a name=499></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;1;<br/>
&#160;&#160;&#160;&#160;match&#160;x&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1&#160;|&#160;2&#160;=&gt;&#160;println!(&#34;one&#160;or&#160;two&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3&#160;=&gt;&#160;println!(&#34;three&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;println!(&#34;anything&#34;),<br/>&#160;&#160;&#160;&#160;}<br/>
This code prints&#160;&#160;one&#160;or&#160;two&#160;.<br/>
<a href="tests.html#499"><b>Matching&#160;Ranges&#160;of&#160;Values&#160;with&#160;</b>..=</a><br/>
The&#160;&#160;..=&#160;&#160;syntax allows us to match to an inclusive range of values. In the following code,<br/>when a pattern matches any of the values within the given range, that arm will execute:<br/>
&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;5;<br/>
&#160;&#160;&#160;&#160;match&#160;x&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1..=5&#160;=&gt;&#160;println!(&#34;one&#160;through&#160;five&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;println!(&#34;something&#160;else&#34;),<br/>&#160;&#160;&#160;&#160;}<br/>
If&#160;&#160;x&#160;&#160;is 1, 2, 3, 4, or 5, the&#160;ﬁrst arm will match. This syntax is more convenient for multiple<br/>match values than using the&#160;&#160;|&#160;&#160;operator to express the same idea; if we were to use&#160;&#160;|&#160;&#160;we<br/>would have to specify&#160;&#160;1&#160;|&#160;2&#160;|&#160;3&#160;|&#160;4&#160;|&#160;5&#160;. Specifying a range is much shorter, especially if<br/>we want to match, say, any number between 1 and 1,000!<br/>
The compiler checks that the range isn’t empty at compile time, and because the only types<br/>for which Rust can tell if a range is empty or not are&#160;&#160;char&#160;&#160;and numeric values, ranges are<br/>only allowed with numeric or&#160;&#160;char&#160;&#160;values.<br/>
Here is an example using ranges of&#160;&#160;char&#160;&#160;values:<br/>
&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;'c';<br/>
&#160;&#160;&#160;&#160;match&#160;x&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'a'..='j'&#160;=&gt;&#160;println!(&#34;early&#160;ASCII&#160;letter&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;'k'..='z'&#160;=&gt;&#160;println!(&#34;late&#160;ASCII&#160;letter&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;println!(&#34;something&#160;else&#34;),<br/>&#160;&#160;&#160;&#160;}<br/>
Rust can tell that&#160;&#160;'c'&#160;&#160;is within the&#160;ﬁrst pattern’s range and prints&#160;&#160;early&#160;ASCII&#160;letter&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
499/627<br/>
<hr/>
<a name=500></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#500"><b>Destructuring&#160;to&#160;Break&#160;Apart&#160;Values</b></a><br/>
We can also use patterns to destructure structs, enums, and tuples to use diﬀerent parts of<br/>these values. Let’s walk through each value.<br/>
<a href="tests.html#500"><b>Destructuring Structs</b></a><br/>
Listing 18-12 shows a&#160;&#160;Point&#160;&#160;struct with two&#160;ﬁelds,&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;, that we can break apart using<br/>a pattern with a&#160;&#160;let&#160;&#160;statement.<br/>
Filename: src/main.rs<br/>
struct&#160;Point&#160;{<br/>&#160;&#160;&#160;&#160;x:&#160;i32,<br/>&#160;&#160;&#160;&#160;y:&#160;i32,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;p&#160;=&#160;Point&#160;{&#160;x:&#160;0,&#160;y:&#160;7&#160;};<br/>
&#160;&#160;&#160;&#160;let&#160;Point&#160;{&#160;x:&#160;a,&#160;y:&#160;b&#160;}&#160;=&#160;p;<br/>&#160;&#160;&#160;&#160;assert_eq!(0,&#160;a);<br/>&#160;&#160;&#160;&#160;assert_eq!(7,&#160;b);<br/>}<br/>
<b>Listing&#160;18-12:&#160;Destructuring&#160;a&#160;struct’s&#160;ﬁelds&#160;into&#160;separate&#160;variables</b><br/>
This code creates the variables&#160;&#160;a&#160;&#160;and&#160;&#160;b&#160;&#160;that match the values of the&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;&#160;ﬁelds of the<br/>
p&#160;&#160;struct. This example shows that the names of the variables in the pattern don’t have to<br/>
match the&#160;ﬁeld names of the struct. However, it’s common to match the variable names to<br/>the&#160;ﬁeld names to make it easier to remember which variables came from which&#160;ﬁelds.<br/>Because of this common usage, and because writing&#160;&#160;let&#160;Point&#160;{&#160;x:&#160;x,&#160;y:&#160;y&#160;}&#160;=&#160;p;<br/>contains a lot of duplication, Rust has a shorthand for patterns that match struct&#160;ﬁelds: you<br/>only need to list the name of the struct&#160;ﬁeld, and the variables created from the pattern will<br/>have the same names. Listing 18-13 behaves in the same way as the code in Listing 18-12,<br/>but the variables created in the&#160;&#160;let&#160;&#160;pattern are&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;&#160;instead of&#160;&#160;a&#160;&#160;and&#160;&#160;b&#160;.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
500/627<br/>
<hr/>
<a name=501></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
struct&#160;Point&#160;{<br/>&#160;&#160;&#160;&#160;x:&#160;i32,<br/>&#160;&#160;&#160;&#160;y:&#160;i32,<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;p&#160;=&#160;Point&#160;{&#160;x:&#160;0,&#160;y:&#160;7&#160;};<br/>
&#160;&#160;&#160;&#160;let&#160;Point&#160;{&#160;x,&#160;y&#160;}&#160;=&#160;p;<br/>&#160;&#160;&#160;&#160;assert_eq!(0,&#160;x);<br/>&#160;&#160;&#160;&#160;assert_eq!(7,&#160;y);<br/>}<br/>
<b>Listing&#160;18-13:&#160;Destructuring&#160;struct&#160;ﬁelds&#160;using&#160;struct&#160;ﬁeld&#160;shorthand</b><br/>
This code creates the variables&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;&#160;that match the&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;&#160;ﬁelds of the&#160;&#160;p&#160;&#160;variable.<br/>The outcome is that the variables&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;&#160;contain the values from the&#160;&#160;p&#160;&#160;struct.<br/>
We can also destructure with literal values as part of the struct pattern rather than creating<br/>variables for all the&#160;ﬁelds. Doing so allows us to test some of the&#160;ﬁelds for particular values<br/>while creating variables to destructure the other&#160;ﬁelds.<br/>
In Listing 18-14, we have a&#160;&#160;match&#160;&#160;expression that separates&#160;&#160;Point&#160;&#160;values into three cases:<br/>points that lie directly on the&#160;&#160;x&#160;&#160;axis (which is true when&#160;&#160;y&#160;=&#160;0&#160;), on the&#160;&#160;y&#160;&#160;axis (&#160;x&#160;=&#160;0&#160;), or<br/>neither.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;p&#160;=&#160;Point&#160;{&#160;x:&#160;0,&#160;y:&#160;7&#160;};<br/>
&#160;&#160;&#160;&#160;match&#160;p&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Point&#160;{&#160;x,&#160;y:&#160;0&#160;}&#160;=&gt;&#160;println!(&#34;On&#160;the&#160;x&#160;axis&#160;at&#160;{x}&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Point&#160;{&#160;x:&#160;0,&#160;y&#160;}&#160;=&gt;&#160;println!(&#34;On&#160;the&#160;y&#160;axis&#160;at&#160;{y}&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Point&#160;{&#160;x,&#160;y&#160;}&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;On&#160;neither&#160;axis:&#160;({x},&#160;{y})&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;18-14:&#160;Destructuring&#160;and&#160;matching&#160;literal&#160;values&#160;in&#160;one&#160;pattern</b><br/>
The&#160;ﬁrst arm will match any point that lies on the&#160;&#160;x&#160;&#160;axis by specifying that the&#160;&#160;y&#160;&#160;ﬁeld<br/>matches if its value matches the literal&#160;&#160;0&#160;. The pattern still creates an&#160;&#160;x&#160;&#160;variable that we<br/>can use in the code for this arm.<br/>
Similarly, the second arm matches any point on the&#160;&#160;y&#160;&#160;axis by specifying that the&#160;&#160;x&#160;&#160;ﬁeld<br/>matches if its value is&#160;&#160;0&#160;&#160;and creates a variable&#160;&#160;y&#160;&#160;for the value of the&#160;&#160;y&#160;&#160;ﬁeld. The third arm<br/>doesn’t specify any literals, so it matches any other&#160;&#160;Point&#160;&#160;and creates variables for both<br/>the&#160;&#160;x&#160;&#160;and&#160;&#160;y&#160;&#160;ﬁelds.<br/>
https://doc.rust-lang.org/book/print.html<br/>
501/627<br/>
<hr/>
<a name=502></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
In this example, the value&#160;&#160;p&#160;&#160;matches the second arm by virtue of&#160;&#160;x&#160;&#160;containing a 0, so this<br/>code will print&#160;&#160;On&#160;the&#160;y&#160;axis&#160;at&#160;7&#160;.<br/>
Remember that a&#160;&#160;match&#160;&#160;expression stops checking arms once it has found the&#160;ﬁrst<br/>matching pattern, so even though&#160;&#160;Point&#160;{&#160;x:&#160;0,&#160;y:&#160;0}&#160;&#160;is on the&#160;&#160;x&#160;&#160;axis and the&#160;&#160;y&#160;&#160;axis,<br/>this code would only print&#160;&#160;On&#160;the&#160;x&#160;axis&#160;at&#160;0&#160;.<br/>
<a href="tests.html#502"><b>Destructuring Enums</b></a><br/>
We've destructured enums in this book (for example, Listing 6-5 in Chapter 6), but haven’t<br/>yet explicitly discussed that the pattern to destructure an enum corresponds to the way the<br/>data stored within the enum is deﬁned. As an example, in Listing 18-15 we use the&#160;&#160;Message<br/>enum from Listing 6-2 and write a&#160;&#160;match&#160;&#160;with patterns that will destructure each inner<br/>value.<br/>
Filename: src/main.rs<br/>
enum&#160;Message&#160;{<br/>&#160;&#160;&#160;&#160;Quit,<br/>&#160;&#160;&#160;&#160;Move&#160;{&#160;x:&#160;i32,&#160;y:&#160;i32&#160;},<br/>&#160;&#160;&#160;&#160;Write(String),<br/>&#160;&#160;&#160;&#160;ChangeColor(i32,&#160;i32,&#160;i32),<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;msg&#160;=&#160;Message::ChangeColor(0,&#160;160,&#160;255);<br/>
&#160;&#160;&#160;&#160;match&#160;msg&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Message::Quit&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;The&#160;Quit&#160;variant&#160;has&#160;no&#160;data&#160;to&#160;destructure.&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Message::Move&#160;{&#160;x,&#160;y&#160;}&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Move&#160;in&#160;the&#160;x&#160;direction&#160;{x}&#160;and&#160;in&#160;the&#160;y&#160;direction&#160;{y}&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Message::Write(text)&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Text&#160;message:&#160;{text}&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Message::ChangeColor(r,&#160;g,&#160;b)&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Change&#160;the&#160;color&#160;to&#160;red&#160;{r},&#160;green&#160;{g},&#160;and&#160;blue&#160;{b}&#34;,)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;18-15:&#160;Destructuring&#160;enum&#160;variants&#160;that&#160;hold&#160;diﬀerent&#160;kinds&#160;of&#160;values</b><br/>
This code will print&#160;&#160;Change&#160;the&#160;color&#160;to&#160;red&#160;0,&#160;green&#160;160,&#160;and&#160;blue&#160;255&#160;. Try changing<br/>the value of&#160;&#160;msg&#160;&#160;to see the code from the other arms run.<br/>
For enum variants without any data, like&#160;&#160;Message::Quit&#160;, we can’t destructure the value any<br/>further. We can only match on the literal&#160;&#160;Message::Quit&#160;&#160;value, and no variables are in that<br/>
https://doc.rust-lang.org/book/print.html<br/>
502/627<br/>
<hr/>
<a name=503></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pattern.<br/>
For struct-like enum variants, such as&#160;&#160;Message::Move&#160;, we can use a pattern similar to the<br/>pattern we specify to match structs. After the variant name, we place curly brackets and<br/>then list the&#160;ﬁelds with variables so we break apart the pieces to use in the code for this<br/>arm. Here we use the shorthand form as we did in Listing 18-13.<br/>
For tuple-like enum variants, like&#160;&#160;Message::Write&#160;&#160;that holds a tuple with one element and<br/>
Message::ChangeColor&#160;&#160;that holds a tuple with three elements, the pattern is similar to the<br/>
pattern we specify to match tuples. The number of variables in the pattern must match the<br/>number of elements in the variant we’re matching.<br/>
<a href="tests.html#503"><b>Destructuring Nested Structs and Enums</b></a><br/>
So far, our examples have all been matching structs or enums one level deep, but matching<br/>can work on nested items too! For example, we can refactor the code in Listing 18-15 to<br/>support RGB and HSV colors in the&#160;&#160;ChangeColor&#160;&#160;message, as shown in Listing 18-16.<br/>
enum&#160;Color&#160;{<br/>&#160;&#160;&#160;&#160;Rgb(i32,&#160;i32,&#160;i32),<br/>&#160;&#160;&#160;&#160;Hsv(i32,&#160;i32,&#160;i32),<br/>}<br/>
enum&#160;Message&#160;{<br/>&#160;&#160;&#160;&#160;Quit,<br/>&#160;&#160;&#160;&#160;Move&#160;{&#160;x:&#160;i32,&#160;y:&#160;i32&#160;},<br/>&#160;&#160;&#160;&#160;Write(String),<br/>&#160;&#160;&#160;&#160;ChangeColor(Color),<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;msg&#160;=&#160;Message::ChangeColor(Color::Hsv(0,&#160;160,&#160;255));<br/>
&#160;&#160;&#160;&#160;match&#160;msg&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Message::ChangeColor(Color::Rgb(r,&#160;g,&#160;b))&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Change&#160;color&#160;to&#160;red&#160;{r},&#160;green&#160;{g},&#160;and&#160;blue&#160;{b}&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Message::ChangeColor(Color::Hsv(h,&#160;s,&#160;v))&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Change&#160;color&#160;to&#160;hue&#160;{h},&#160;saturation&#160;{s},&#160;value&#160;{v}&#34;)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;(),<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;18-16:&#160;Matching&#160;on&#160;nested&#160;enums</b><br/>
The pattern of the&#160;ﬁrst arm in the&#160;&#160;match&#160;&#160;expression matches a&#160;&#160;Message::ChangeColor<br/>enum variant that contains a&#160;&#160;Color::Rgb&#160;&#160;variant; then the pattern binds to the three inner<br/>
i32&#160;&#160;values. The pattern of the second arm also matches a&#160;&#160;Message::ChangeColor&#160;&#160;enum<br/>
https://doc.rust-lang.org/book/print.html<br/>
503/627<br/>
<hr/>
<a name=504></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
variant, but the inner enum matches&#160;&#160;Color::Hsv&#160;&#160;instead. We can specify these complex<br/>conditions in one&#160;&#160;match&#160;&#160;expression, even though two enums are involved.<br/>
<a href="tests.html#504"><b>Destructuring Structs and Tuples</b></a><br/>
We can mix, match, and nest destructuring patterns in even more complex ways. The<br/>following example shows a complicated destructure where we nest structs and tuples inside<br/>a tuple and destructure all the primitive values out:<br/>
&#160;&#160;&#160;&#160;let&#160;((feet,&#160;inches),&#160;Point&#160;{&#160;x,&#160;y&#160;})&#160;=&#160;((3,&#160;10),&#160;Point&#160;{&#160;x:&#160;3,&#160;y:&#160;-10&#160;});<br/>
This code lets us break complex types into their component parts so we can use the values<br/>we’re interested in separately.<br/>
Destructuring with patterns is a convenient way to use pieces of values, such as the value<br/>from each&#160;ﬁeld in a struct, separately from each other.<br/>
<a href="tests.html#504"><b>Ignoring&#160;Values&#160;in&#160;a&#160;Pattern</b></a><br/>
You’ve seen that it’s sometimes useful to ignore values in a pattern, such as in the last arm<br/>of a&#160;&#160;match&#160;, to get a catchall that doesn’t actually do anything but does account for all<br/>remaining possible values. There are a few ways to ignore entire values or parts of values in<br/>a pattern: using the&#160;&#160;_&#160;&#160;pattern (which you’ve seen), using the&#160;&#160;_&#160;&#160;pattern within another<br/>pattern, using a name that starts with an underscore, or using&#160;&#160;..&#160;&#160;to ignore remaining parts<br/>of a value. Let’s explore how and why to use each of these patterns.<br/>
<a href="tests.html#504"><b>Ignoring an Entire Value with&#160;</b>_</a><br/>
We’ve used the underscore as a wildcard pattern that will match any value but not bind to<br/>the value. This is especially useful as the last arm in a&#160;&#160;match&#160;&#160;expression, but we can also<br/>use it in any pattern, including function parameters, as shown in Listing 18-17.<br/>
Filename: src/main.rs<br/>
fn&#160;foo(_:&#160;i32,&#160;y:&#160;i32)&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;This&#160;code&#160;only&#160;uses&#160;the&#160;y&#160;parameter:&#160;{}&#34;,&#160;y);<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;foo(3,&#160;4);<br/>}<br/>
<b>Listing&#160;18-17:&#160;Using&#160;&#160;</b>_&#160;<b>&#160;in&#160;a&#160;function&#160;signature</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
504/627<br/>
<hr/>
<a name=505></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
This code will completely ignore the value&#160;&#160;3&#160;&#160;passed as the&#160;ﬁrst argument, and will print<br/>
This&#160;code&#160;only&#160;uses&#160;the&#160;y&#160;parameter:&#160;4&#160;.<br/>
In most cases when you no longer need a particular function parameter, you would change<br/>the signature so it doesn’t include the unused parameter. Ignoring a function parameter can<br/>be especially useful in cases when, for example, you're implementing a trait when you need<br/>a certain type signature but the function body in your implementation doesn’t need one of<br/>the parameters. You then avoid getting a compiler warning about unused function<br/>parameters, as you would if you used a name instead.<br/>
<a href="tests.html#505"><b>Ignoring Parts of a Value with a Nested&#160;</b>_</a><br/>
We can also use&#160;&#160;_&#160;&#160;inside another pattern to ignore just part of a value, for example, when<br/>we want to test for only part of a value but have no use for the other parts in the<br/>corresponding code we want to run. Listing 18-18 shows code responsible for managing a<br/>setting’s value. The business requirements are that the user should not be allowed to<br/>overwrite an existing customization of a setting but can unset the setting and give it a value<br/>if it is currently unset.<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;setting_value&#160;=&#160;Some(5);<br/>&#160;&#160;&#160;&#160;let&#160;new_setting_value&#160;=&#160;Some(10);<br/>
&#160;&#160;&#160;&#160;match&#160;(setting_value,&#160;new_setting_value)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(Some(_),&#160;Some(_))&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Can't&#160;overwrite&#160;an&#160;existing&#160;customized&#160;value&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;setting_value&#160;=&#160;new_setting_value;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;setting&#160;is&#160;{:?}&#34;,&#160;setting_value);<br/>
<b>Listing&#160;18-18:&#160;Using&#160;an&#160;underscore&#160;within&#160;patterns&#160;that&#160;match&#160;&#160;</b>Some&#160;<b>&#160;variants&#160;when&#160;we&#160;don’t&#160;need&#160;to&#160;use&#160;the<br/>value&#160;inside&#160;the&#160;&#160;</b>Some<br/>
This code will print&#160;&#160;Can't&#160;overwrite&#160;an&#160;existing&#160;customized&#160;value&#160;&#160;and then&#160;&#160;setting&#160;is&#160;<br/>Some(5)&#160;. In the&#160;ﬁrst match arm, we don’t need to match on or use the values inside either<br/>
Some&#160;&#160;variant, but we do need to test for the case when&#160;&#160;setting_value&#160;&#160;and<br/>new_setting_value&#160;&#160;are the&#160;&#160;Some&#160;&#160;variant. In that case, we print the reason for not changing<br/>setting_value&#160;, and it doesn’t get changed.<br/>
In all other cases (if either&#160;&#160;setting_value&#160;&#160;or&#160;&#160;new_setting_value&#160;&#160;are&#160;&#160;None&#160;) expressed by<br/>the&#160;&#160;_&#160;&#160;pattern in the second arm, we want to allow&#160;&#160;new_setting_value&#160;&#160;to become<br/>
setting_value&#160;.<br/>
We can also use underscores in multiple places within one pattern to ignore particular<br/>values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple<br/>
https://doc.rust-lang.org/book/print.html<br/>
505/627<br/>
<hr/>
<a name=506></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
of&#160;ﬁve items.<br/>
&#160;&#160;&#160;&#160;let&#160;numbers&#160;=&#160;(2,&#160;4,&#160;8,&#160;16,&#160;32);<br/>
&#160;&#160;&#160;&#160;match&#160;numbers&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(first,&#160;_,&#160;third,&#160;_,&#160;fifth)&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Some&#160;numbers:&#160;{first},&#160;{third},&#160;{fifth}&#34;)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;18-19:&#160;Ignoring&#160;multiple&#160;parts&#160;of&#160;a&#160;tuple</b><br/>
This code will print&#160;&#160;Some&#160;numbers:&#160;2,&#160;8,&#160;32&#160;, and the values 4 and 16 will be ignored.<br/>
<a href="tests.html#506"><b>Ignoring an Unused Variable by Starting Its Name with&#160;</b>_</a><br/>
If you create a variable but don’t use it anywhere, Rust will usually issue a warning because<br/>an unused variable could be a bug. However, sometimes it’s useful to be able to create a<br/>variable you won’t use yet, such as when you’re prototyping or just starting a project. In this<br/>situation, you can tell Rust not to warn you about the unused variable by starting the name<br/>of the variable with an underscore. In Listing 18-20, we create two unused variables, but<br/>when we compile this code, we should only get a warning about one of them.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;_x&#160;=&#160;5;<br/>&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;10;<br/>}<br/>
<b>Listing&#160;18-20:&#160;Starting&#160;a&#160;variable&#160;name&#160;with&#160;an&#160;underscore&#160;to&#160;avoid&#160;getting&#160;unused&#160;variable&#160;warnings</b><br/>
Here we get a warning about not using the variable&#160;&#160;y&#160;, but we don’t get a warning about not<br/>using&#160;&#160;_x&#160;.<br/>
Note that there is a subtle diﬀerence between using only&#160;&#160;_&#160;&#160;and using a name that starts<br/>with an underscore. The syntax&#160;&#160;_x&#160;&#160;still binds the value to the variable, whereas&#160;&#160;_&#160;&#160;doesn’t<br/>bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with<br/>an error.<br/>
&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;Some(String::from(&#34;Hello!&#34;));<br/>
&#160;&#160;&#160;&#160;if&#160;let&#160;Some(_s)&#160;=&#160;s&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;found&#160;a&#160;string&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;{:?}&#34;,&#160;s);<br/>
https://doc.rust-lang.org/book/print.html<br/>
506/627<br/>
<hr/>
<a name=507></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Listing&#160;18-21:&#160;An&#160;unused&#160;variable&#160;starting&#160;with&#160;an&#160;underscore&#160;still&#160;binds&#160;the&#160;value,&#160;which&#160;might&#160;take&#160;ownership<br/>of&#160;the&#160;value</b><br/>
We’ll receive an error because the&#160;&#160;s&#160;&#160;value will still be moved into&#160;&#160;_s&#160;, which prevents us<br/>from using&#160;&#160;s&#160;&#160;again. However, using the underscore by itself doesn’t ever bind to the value.<br/>Listing 18-22 will compile without any errors because&#160;&#160;s&#160;&#160;doesn’t get moved into&#160;&#160;_&#160;.<br/>
&#160;&#160;&#160;&#160;let&#160;s&#160;=&#160;Some(String::from(&#34;Hello!&#34;));<br/>
&#160;&#160;&#160;&#160;if&#160;let&#160;Some(_)&#160;=&#160;s&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;found&#160;a&#160;string&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;{:?}&#34;,&#160;s);<br/>
<b>Listing&#160;18-22:&#160;Using&#160;an&#160;underscore&#160;does&#160;not&#160;bind&#160;the&#160;value</b><br/>
This code works just&#160;ﬁne because we never bind&#160;&#160;s&#160;&#160;to anything; it isn’t moved.<br/>
<a href="tests.html#507"><b>Ignoring Remaining Parts of a Value with&#160;</b>..</a><br/>
With values that have many parts, we can use the&#160;&#160;..&#160;&#160;syntax to use speciﬁc parts and ignore<br/>the rest, avoiding the need to list underscores for each ignored value. The&#160;&#160;..&#160;&#160;pattern<br/>ignores any parts of a value that we haven’t explicitly matched in the rest of the pattern. In<br/>Listing 18-23, we have a&#160;&#160;Point&#160;&#160;struct that holds a coordinate in three-dimensional space. In<br/>the&#160;&#160;match&#160;&#160;expression, we want to operate only on the&#160;&#160;x&#160;&#160;coordinate and ignore the values<br/>in the&#160;&#160;y&#160;&#160;and&#160;&#160;z&#160;&#160;ﬁelds.<br/>
&#160;&#160;&#160;&#160;struct&#160;Point&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x:&#160;i32,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;i32,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;z:&#160;i32,<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;let&#160;origin&#160;=&#160;Point&#160;{&#160;x:&#160;0,&#160;y:&#160;0,&#160;z:&#160;0&#160;};<br/>
&#160;&#160;&#160;&#160;match&#160;origin&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Point&#160;{&#160;x,&#160;..&#160;}&#160;=&gt;&#160;println!(&#34;x&#160;is&#160;{}&#34;,&#160;x),<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;18-23:&#160;Ignoring&#160;all&#160;ﬁelds&#160;of&#160;a&#160;&#160;</b>Point&#160;<b>&#160;except&#160;for&#160;&#160;</b>x&#160;<b>&#160;by&#160;using&#160;&#160;</b>..<br/>
We list the&#160;&#160;x&#160;&#160;value and then just include the&#160;&#160;..&#160;&#160;pattern. This is quicker than having to list<br/>
y:&#160;_&#160;&#160;and&#160;&#160;z:&#160;_&#160;, particularly when we’re working with structs that have lots of&#160;ﬁelds in<br/>
situations where only one or two&#160;ﬁelds are relevant.<br/>
The syntax&#160;&#160;..&#160;&#160;will expand to as many values as it needs to be. Listing 18-24 shows how to<br/>use&#160;&#160;..&#160;&#160;with a tuple.<br/>
https://doc.rust-lang.org/book/print.html<br/>
507/627<br/>
<hr/>
<a name=508></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;numbers&#160;=&#160;(2,&#160;4,&#160;8,&#160;16,&#160;32);<br/>
&#160;&#160;&#160;&#160;match&#160;numbers&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(first,&#160;..,&#160;last)&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Some&#160;numbers:&#160;{first},&#160;{last}&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;18-24:&#160;Matching&#160;only&#160;the&#160;ﬁrst&#160;and&#160;last&#160;values&#160;in&#160;a&#160;tuple&#160;and&#160;ignoring&#160;all&#160;other&#160;values</b><br/>
In this code, the&#160;ﬁrst and last value are matched with&#160;&#160;first&#160;&#160;and&#160;&#160;last&#160;. The&#160;&#160;..&#160;&#160;will match<br/>and ignore everything in the middle.<br/>
However, using&#160;&#160;..&#160;&#160;must be unambiguous. If it is unclear which values are intended for<br/>matching and which should be ignored, Rust will give us an error. Listing 18-25 shows an<br/>example of using&#160;&#160;..&#160;&#160;ambiguously, so it will not compile.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;numbers&#160;=&#160;(2,&#160;4,&#160;8,&#160;16,&#160;32);<br/>
&#160;&#160;&#160;&#160;match&#160;numbers&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(..,&#160;second,&#160;..)&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Some&#160;numbers:&#160;{}&#34;,&#160;second)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;},<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;18-25:&#160;An&#160;attempt&#160;to&#160;use&#160;&#160;</b>..&#160;<b>&#160;in&#160;an&#160;ambiguous&#160;way</b><br/>
When we compile this example, we get this error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;patterns&#160;v0.1.0&#160;(file:///projects/patterns)<br/>error:&#160;`..`&#160;can&#160;only&#160;be&#160;used&#160;once&#160;per&#160;tuple&#160;pattern<br/>&#160;--&gt;&#160;src/main.rs:5:22<br/>&#160;&#160;|<br/>5&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(..,&#160;second,&#160;..)&#160;=&gt;&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^&#160;can&#160;only&#160;be&#160;used&#160;once&#160;per&#160;tuple&#160;pattern<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;previously&#160;used&#160;here<br/>
error:&#160;could&#160;not&#160;compile&#160;`patterns`&#160;due&#160;to&#160;previous&#160;error<br/>
It’s impossible for Rust to determine how many values in the tuple to ignore before<br/>matching a value with&#160;&#160;second&#160;&#160;and then how many further values to ignore thereafter. This<br/>
https://doc.rust-lang.org/book/print.html<br/>
508/627<br/>
<hr/>
<a name=509></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
code could mean that we want to ignore&#160;&#160;2&#160;, bind&#160;&#160;second&#160;&#160;to&#160;&#160;4&#160;, and then ignore&#160;&#160;8&#160;,&#160;&#160;16&#160;, and<br/>
32&#160;; or that we want to ignore&#160;&#160;2&#160;&#160;and&#160;&#160;4&#160;, bind&#160;&#160;second&#160;&#160;to&#160;&#160;8&#160;, and then ignore&#160;&#160;16&#160;&#160;and&#160;&#160;32&#160;;<br/>
and so forth. The variable name&#160;&#160;second&#160;&#160;doesn’t mean anything special to Rust, so we get a<br/>compiler error because using&#160;&#160;..&#160;&#160;in two places like this is ambiguous.<br/>
<a href="tests.html#509"><b>Extra&#160;Conditionals&#160;with&#160;Match&#160;Guards</b></a><br/>
A&#160;<i>match guard</i>&#160;is an additional&#160;&#160;if&#160;&#160;condition, speciﬁed after the pattern in a&#160;&#160;match&#160;&#160;arm, that<br/>must also match for that arm to be chosen. Match guards are useful for expressing more<br/>complex ideas than a pattern alone allows.<br/>
The condition can use variables created in the pattern. Listing 18-26 shows a&#160;&#160;match&#160;&#160;where<br/>the&#160;ﬁrst arm has the pattern&#160;&#160;Some(x)&#160;&#160;and also has a match guard of&#160;&#160;if&#160;x&#160;%&#160;2&#160;==&#160;0&#160;&#160;(which<br/>will be true if the number is even).<br/>
&#160;&#160;&#160;&#160;let&#160;num&#160;=&#160;Some(4);<br/>
&#160;&#160;&#160;&#160;match&#160;num&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(x)&#160;if&#160;x&#160;%&#160;2&#160;==&#160;0&#160;=&gt;&#160;println!(&#34;The&#160;number&#160;{}&#160;is&#160;even&#34;,&#160;x),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(x)&#160;=&gt;&#160;println!(&#34;The&#160;number&#160;{}&#160;is&#160;odd&#34;,&#160;x),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;None&#160;=&gt;&#160;(),<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;18-26:&#160;Adding&#160;a&#160;match&#160;guard&#160;to&#160;a&#160;pattern</b><br/>
This example will print&#160;&#160;The&#160;number&#160;4&#160;is&#160;even&#160;. When&#160;&#160;num&#160;&#160;is compared to the pattern in<br/>the&#160;ﬁrst arm, it matches, because&#160;&#160;Some(4)&#160;&#160;matches&#160;&#160;Some(x)&#160;. Then the match guard checks<br/>whether the remainder of dividing&#160;&#160;x&#160;&#160;by 2 is equal to 0, and because it is, the&#160;ﬁrst arm is<br/>selected.<br/>
If&#160;&#160;num&#160;&#160;had been&#160;&#160;Some(5)&#160;&#160;instead, the match guard in the&#160;ﬁrst arm would have been false<br/>because the remainder of 5 divided by 2 is 1, which is not equal to 0. Rust would then go to<br/>the second arm, which would match because the second arm doesn’t have a match guard<br/>and therefore matches any&#160;&#160;Some&#160;&#160;variant.<br/>
There is no way to express the&#160;&#160;if&#160;x&#160;%&#160;2&#160;==&#160;0&#160;&#160;condition within a pattern, so the match<br/>guard gives us the ability to express this logic. The downside of this additional<br/>expressiveness is that the compiler doesn't try to check for exhaustiveness when match<br/>guard expressions are involved.<br/>
In Listing 18-11, we mentioned that we could use match guards to solve our pattern-<br/>shadowing problem. Recall that we created a new variable inside the pattern in the&#160;&#160;match<br/>expression instead of using the variable outside the&#160;&#160;match&#160;. That new variable meant we<br/>couldn’t test against the value of the outer variable. Listing 18-27 shows how we can use a<br/>match guard to&#160;ﬁx this problem.<br/>
https://doc.rust-lang.org/book/print.html<br/>
509/627<br/>
<hr/>
<a name=510></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;Some(5);<br/>&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;10;<br/>
&#160;&#160;&#160;&#160;match&#160;x&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(50)&#160;=&gt;&#160;println!(&#34;Got&#160;50&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(n)&#160;if&#160;n&#160;==&#160;y&#160;=&gt;&#160;println!(&#34;Matched,&#160;n&#160;=&#160;{n}&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;println!(&#34;Default&#160;case,&#160;x&#160;=&#160;{:?}&#34;,&#160;x),<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;at&#160;the&#160;end:&#160;x&#160;=&#160;{:?},&#160;y&#160;=&#160;{y}&#34;,&#160;x);<br/>}<br/>
<b>Listing&#160;18-27:&#160;Using&#160;a&#160;match&#160;guard&#160;to&#160;test&#160;for&#160;equality&#160;with&#160;an&#160;outer&#160;variable</b><br/>
This code will now print&#160;&#160;Default&#160;case,&#160;x&#160;=&#160;Some(5)&#160;. The pattern in the second match arm<br/>doesn’t introduce a new variable&#160;&#160;y&#160;&#160;that would shadow the outer&#160;&#160;y&#160;, meaning we can use<br/>the outer&#160;&#160;y&#160;&#160;in the match guard. Instead of specifying the pattern as&#160;&#160;Some(y)&#160;, which would<br/>have shadowed the outer&#160;&#160;y&#160;, we specify&#160;&#160;Some(n)&#160;. This creates a new variable&#160;&#160;n&#160;&#160;that<br/>doesn’t shadow anything because there is no&#160;&#160;n&#160;&#160;variable outside the&#160;&#160;match&#160;.<br/>
The match guard&#160;&#160;if&#160;n&#160;==&#160;y&#160;&#160;is not a pattern and therefore doesn’t introduce new variables.<br/>This&#160;&#160;y&#160;&#160;<i>is</i>&#160;the outer&#160;&#160;y&#160;&#160;rather than a new shadowed&#160;&#160;y&#160;, and we can look for a value that has<br/>the same value as the outer&#160;&#160;y&#160;&#160;by comparing&#160;&#160;n&#160;&#160;to&#160;&#160;y&#160;.<br/>
You can also use the&#160;<i>or</i>&#160;operator&#160;&#160;|&#160;&#160;in a match guard to specify multiple patterns; the match<br/>guard condition will apply to all the patterns. Listing 18-28 shows the precedence when<br/>combining a pattern that uses&#160;&#160;|&#160;&#160;with a match guard. The important part of this example is<br/>that the&#160;&#160;if&#160;y&#160;&#160;match guard applies to&#160;&#160;4&#160;,&#160;&#160;5&#160;,&#160;<i>and</i>&#160;&#160;6&#160;, even though it might look like&#160;&#160;if&#160;y<br/>only applies to&#160;&#160;6&#160;.<br/>
&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;4;<br/>&#160;&#160;&#160;&#160;let&#160;y&#160;=&#160;false;<br/>
&#160;&#160;&#160;&#160;match&#160;x&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;4&#160;|&#160;5&#160;|&#160;6&#160;if&#160;y&#160;=&gt;&#160;println!(&#34;yes&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;println!(&#34;no&#34;),<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;18-28:&#160;Combining&#160;multiple&#160;patterns&#160;with&#160;a&#160;match&#160;guard</b><br/>
The match condition states that the arm only matches if the value of&#160;&#160;x&#160;&#160;is equal to&#160;&#160;4&#160;,&#160;&#160;5&#160;, or<br/>
6&#160;&#160;<i>and</i>&#160;if&#160;&#160;y&#160;&#160;is&#160;&#160;true&#160;. When this code runs, the pattern of the&#160;ﬁrst arm matches because&#160;&#160;x&#160;&#160;is<br/>4&#160;, but the match guard&#160;&#160;if&#160;y&#160;&#160;is false, so the&#160;ﬁrst arm is not chosen. The code moves on to<br/>
the second arm, which does match, and this program prints&#160;&#160;no&#160;. The reason is that the&#160;&#160;if<br/>condition applies to the whole pattern&#160;&#160;4&#160;|&#160;5&#160;|&#160;6&#160;, not only to the last value&#160;&#160;6&#160;. In other<br/>words, the precedence of a match guard in relation to a pattern behaves like this:<br/>
https://doc.rust-lang.org/book/print.html<br/>
510/627<br/>
<hr/>
<a name=511></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
(4&#160;|&#160;5&#160;|&#160;6)&#160;if&#160;y&#160;=&gt;&#160;...<br/>
rather than this:<br/>
4&#160;|&#160;5&#160;|&#160;(6&#160;if&#160;y)&#160;=&gt;&#160;...<br/>
After running the code, the precedence behavior is evident: if the match guard were applied<br/>only to the&#160;ﬁnal value in the list of values speciﬁed using the&#160;&#160;|&#160;&#160;operator, the arm would<br/>have matched and the program would have printed&#160;&#160;yes&#160;.<br/>
<a href="tests.html#511">@<b>&#160;Bindings</b></a><br/>
The&#160;<i>at</i>&#160;operator&#160;&#160;@&#160;&#160;lets us create a variable that holds a value at the same time as we’re<br/>testing that value for a pattern match. In Listing 18-29, we want to test that a<br/>
Message::Hello&#160;&#160;&#160;id&#160;&#160;ﬁeld is within the range&#160;&#160;3..=7&#160;. We also want to bind the value to the<br/>
variable&#160;&#160;id_variable&#160;&#160;so we can use it in the code associated with the arm. We could name<br/>this variable&#160;&#160;id&#160;, the same as the&#160;ﬁeld, but for this example we’ll use a diﬀerent name.<br/>
&#160;&#160;&#160;&#160;enum&#160;Message&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Hello&#160;{&#160;id:&#160;i32&#160;},<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;let&#160;msg&#160;=&#160;Message::Hello&#160;{&#160;id:&#160;5&#160;};<br/>
&#160;&#160;&#160;&#160;match&#160;msg&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Message::Hello&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;id:&#160;id_variable&#160;@&#160;3..=7,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;=&gt;&#160;println!(&#34;Found&#160;an&#160;id&#160;in&#160;range:&#160;{}&#34;,&#160;id_variable),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Message::Hello&#160;{&#160;id:&#160;10..=12&#160;}&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Found&#160;an&#160;id&#160;in&#160;another&#160;range&#34;)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Message::Hello&#160;{&#160;id&#160;}&#160;=&gt;&#160;println!(&#34;Found&#160;some&#160;other&#160;id:&#160;{}&#34;,&#160;id),<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;18-29:&#160;Using&#160;&#160;</b>@&#160;<b>&#160;to&#160;bind&#160;to&#160;a&#160;value&#160;in&#160;a&#160;pattern&#160;while&#160;also&#160;testing&#160;it</b><br/>
This example will print&#160;&#160;Found&#160;an&#160;id&#160;in&#160;range:&#160;5&#160;. By specifying&#160;&#160;id_variable&#160;@&#160;&#160;before the<br/>range&#160;&#160;3..=7&#160;, we’re capturing whatever value matched the range while also testing that the<br/>value matched the range pattern.<br/>
In the second arm, where we only have a range speciﬁed in the pattern, the code associated<br/>with the arm doesn’t have a variable that contains the actual value of the&#160;&#160;id&#160;&#160;ﬁeld. The&#160;&#160;id<br/>ﬁeld’s value could have been 10, 11, or 12, but the code that goes with that pattern doesn’t<br/>know which it is. The pattern code isn’t able to use the value from the&#160;&#160;id&#160;&#160;ﬁeld, because we<br/>haven’t saved the&#160;&#160;id&#160;&#160;value in a variable.<br/>
https://doc.rust-lang.org/book/print.html<br/>
511/627<br/>
<hr/>
<a name=512></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
In the last arm, where we’ve speciﬁed a variable without a range, we do have the value<br/>available to use in the arm’s code in a variable named&#160;&#160;id&#160;. The reason is that we’ve used the<br/>struct&#160;ﬁeld shorthand syntax. But we haven’t applied any test to the value in the&#160;&#160;id&#160;&#160;ﬁeld in<br/>this arm, as we did with the&#160;ﬁrst two arms: any value would match this pattern.<br/>
Using&#160;&#160;@&#160;&#160;lets us test a value and save it in a variable within one pattern.<br/>
<a href="tests.html#512"><b>Summary</b></a><br/>
Rust’s patterns are very useful in distinguishing between diﬀerent kinds of data. When used<br/>in&#160;&#160;match&#160;&#160;expressions, Rust ensures your patterns cover every possible value, or your<br/>program won’t compile. Patterns in&#160;&#160;let&#160;&#160;statements and function parameters make those<br/>constructs more useful, enabling the destructuring of values into smaller parts at the same<br/>time as assigning to variables. We can create simple or complex patterns to suit our needs.<br/>
Next, for the penultimate chapter of the book, we’ll look at some advanced aspects of a<br/>variety of Rust’s features.<br/>
https://doc.rust-lang.org/book/print.html<br/>
512/627<br/>
<hr/>
<a name=513></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#513"><b>Advanced Features</b></a><br/>
By now, you’ve learned the most commonly used parts of the Rust programming language.<br/>Before we do one more project in Chapter 20, we’ll look at a few aspects of the language<br/>you might run into every once in a while, but may not use every day. You can use this<br/>chapter as a reference for when you encounter any unknowns. The features covered here<br/>are useful in very speciﬁc situations. Although you might not reach for them often, we want<br/>to make sure you have a grasp of all the features Rust has to oﬀer.<br/>
In this chapter, we’ll cover:<br/>
Unsafe Rust: how to opt out of some of Rust’s guarantees and take responsibility for<br/>manually upholding those guarantees<br/>Advanced traits: associated types, default type parameters, fully qualiﬁed syntax,<br/>supertraits, and the newtype pattern in relation to traits<br/>Advanced types: more about the newtype pattern, type aliases, the never type, and<br/>dynamically sized types<br/>Advanced functions and closures: function pointers and returning closures<br/>Macros: ways to deﬁne code that deﬁnes more code at compile time<br/>
It’s a panoply of Rust features with something for everyone! Let’s dive in!<br/>
https://doc.rust-lang.org/book/print.html<br/>
513/627<br/>
<hr/>
<a name=514></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#514"><b>Unsafe Rust</b></a><br/>
All the code we’ve discussed so far has had Rust’s memory safety guarantees enforced at<br/>compile time. However, Rust has a second language hidden inside it that doesn’t enforce<br/>these memory safety guarantees: it’s called&#160;<i>unsafe Rust</i>&#160;and works just like regular Rust, but<br/>gives us extra superpowers.<br/>
Unsafe Rust exists because, by nature, static analysis is conservative. When the compiler<br/>tries to determine whether or not code upholds the guarantees, it’s better for it to reject<br/>some valid programs than to accept some invalid programs. Although the code&#160;<i>might</i>&#160;be<br/>okay, if the Rust compiler doesn’t have enough information to be conﬁdent, it will reject the<br/>code. In these cases, you can use unsafe code to tell the compiler, “Trust me, I know what<br/>I’m doing.” Be warned, however, that you use unsafe Rust at your own risk: if you use unsafe<br/>code incorrectly, problems can occur due to memory unsafety, such as null pointer<br/>dereferencing.<br/>
Another reason Rust has an unsafe alter ego is that the underlying computer hardware is<br/>inherently unsafe. If Rust didn’t let you do unsafe operations, you couldn’t do certain tasks.<br/>Rust needs to allow you to do low-level systems programming, such as directly interacting<br/>with the operating system or even writing your own operating system. Working with low-<br/>level systems programming is one of the goals of the language. Let’s explore what we can<br/>do with unsafe Rust and how to do it.<br/>
<a href="tests.html#514"><b>Unsafe&#160;Superpowers</b></a><br/>
To switch to unsafe Rust, use the&#160;&#160;unsafe&#160;&#160;keyword and then start a new block that holds the<br/>unsafe code. You can take&#160;ﬁve actions in unsafe Rust that you can’t in safe Rust, which we<br/>call&#160;<i>unsafe superpowers</i>. Those superpowers include the ability to:<br/>
Dereference a raw pointer<br/>Call an unsafe function or method<br/>Access or modify a mutable static variable<br/>Implement an unsafe trait<br/>Access&#160;ﬁelds of&#160;&#160;union&#160;s<br/>
It’s important to understand that&#160;&#160;unsafe&#160;&#160;doesn’t turn oﬀ&#160;the borrow checker or disable any<br/>other of Rust’s safety checks: if you use a reference in unsafe code, it will still be checked.<br/>The&#160;&#160;unsafe&#160;&#160;keyword only gives you access to these&#160;ﬁve features that are then not checked<br/>by the compiler for memory safety. You’ll still get some degree of safety inside of an unsafe<br/>block.<br/>
https://doc.rust-lang.org/book/print.html<br/>
514/627<br/>
<hr/>
<a name=515></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
In addition,&#160;&#160;unsafe&#160;&#160;does not mean the code inside the block is necessarily dangerous or<br/>that it will deﬁnitely have memory safety problems: the intent is that as the programmer,<br/>you’ll ensure the code inside an&#160;&#160;unsafe&#160;&#160;block will access memory in a valid way.<br/>
People are fallible, and mistakes will happen, but by requiring these&#160;ﬁve unsafe operations<br/>to be inside blocks annotated with&#160;&#160;unsafe&#160;&#160;you’ll know that any errors related to memory<br/>safety must be within an&#160;&#160;unsafe&#160;&#160;block. Keep&#160;&#160;unsafe&#160;&#160;blocks small; you’ll be thankful later<br/>when you investigate memory bugs.<br/>
To isolate unsafe code as much as possible, it’s best to enclose unsafe code within a safe<br/>abstraction and provide a safe API, which we’ll discuss later in the chapter when we examine<br/>unsafe functions and methods. Parts of the standard library are implemented as safe<br/>abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe<br/>abstraction prevents uses of&#160;&#160;unsafe&#160;&#160;from leaking out into all the places that you or your<br/>users might want to use the functionality implemented with&#160;&#160;unsafe&#160;&#160;code, because using a<br/>safe abstraction is safe.<br/>
Let’s look at each of the&#160;ﬁve unsafe superpowers in turn. We’ll also look at some<br/>abstractions that provide a safe interface to unsafe code.<br/>
<a href="tests.html#515"><b>Dereferencing&#160;a&#160;Raw&#160;Pointer</b></a><br/>
In Chapter 4, in the&#160;<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#dangling-references">“Dangling References”</a>&#160;section, we mentioned that the compiler ensures<br/>references are always valid. Unsafe Rust has two new types called&#160;<i>raw pointers</i>&#160;that are<br/>similar to references. As with references, raw pointers can be immutable or mutable and<br/>are written as&#160;&#160;*const&#160;T&#160;&#160;and&#160;&#160;*mut&#160;T&#160;, respectively. The asterisk isn’t the dereference<br/>operator; it’s part of the type name. In the context of raw pointers,&#160;<i>immutable</i>&#160;means that<br/>the pointer can’t be directly assigned to after being dereferenced.<br/>
Diﬀerent from references and smart pointers, raw pointers:<br/>
Are allowed to ignore the borrowing rules by having both immutable and mutable<br/>pointers or multiple mutable pointers to the same location<br/>Aren’t guaranteed to point to valid memory<br/>Are allowed to be null<br/>Don’t implement any automatic cleanup<br/>
By opting out of having Rust enforce these guarantees, you can give up guaranteed safety in<br/>exchange for greater performance or the ability to interface with another language or<br/>hardware where Rust’s guarantees don’t apply.<br/>
Listing 19-1 shows how to create an immutable and a mutable raw pointer from references.<br/>
https://doc.rust-lang.org/book/print.html<br/>
515/627<br/>
<hr/>
<a name=516></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;num&#160;=&#160;5;<br/>
&#160;&#160;&#160;&#160;let&#160;r1&#160;=&#160;&amp;num&#160;as&#160;*const&#160;i32;<br/>&#160;&#160;&#160;&#160;let&#160;r2&#160;=&#160;&amp;mut&#160;num&#160;as&#160;*mut&#160;i32;<br/>
<b>Listing&#160;19-1:&#160;Creating&#160;raw&#160;pointers&#160;from&#160;references</b><br/>
Notice that we don’t include the&#160;&#160;unsafe&#160;&#160;keyword in this code. We can create raw pointers in<br/>safe code; we just can’t dereference raw pointers outside an unsafe block, as you’ll see in a<br/>bit.<br/>
We’ve created raw pointers by using&#160;&#160;as&#160;&#160;to cast an immutable and a mutable reference into<br/>their corresponding raw pointer types. Because we created them directly from references<br/>guaranteed to be valid, we know these particular raw pointers are valid, but we can’t make<br/>that assumption about just any raw pointer.<br/>
To demonstrate this, next we’ll create a raw pointer whose validity we can’t be so certain of.<br/>Listing 19-2 shows how to create a raw pointer to an arbitrary location in memory. Trying to<br/>use arbitrary memory is undeﬁned: there might be data at that address or there might not,<br/>the compiler might optimize the code so there is no memory access, or the program might<br/>error with a segmentation fault. Usually, there is no good reason to write code like this, but<br/>it is possible.<br/>
&#160;&#160;&#160;&#160;let&#160;address&#160;=&#160;0x012345usize;<br/>&#160;&#160;&#160;&#160;let&#160;r&#160;=&#160;address&#160;as&#160;*const&#160;i32;<br/>
<b>Listing&#160;19-2:&#160;Creating&#160;a&#160;raw&#160;pointer&#160;to&#160;an&#160;arbitrary&#160;memory&#160;address</b><br/>
Recall that we can create raw pointers in safe code, but we can’t&#160;<i>dereference</i>&#160;raw pointers<br/>and read the data being pointed to. In Listing 19-3, we use the dereference operator&#160;&#160;*&#160;&#160;on a<br/>raw pointer that requires an&#160;&#160;unsafe&#160;&#160;block.<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;num&#160;=&#160;5;<br/>
&#160;&#160;&#160;&#160;let&#160;r1&#160;=&#160;&amp;num&#160;as&#160;*const&#160;i32;<br/>&#160;&#160;&#160;&#160;let&#160;r2&#160;=&#160;&amp;mut&#160;num&#160;as&#160;*mut&#160;i32;<br/>
&#160;&#160;&#160;&#160;unsafe&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;r1&#160;is:&#160;{}&#34;,&#160;*r1);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;r2&#160;is:&#160;{}&#34;,&#160;*r2);<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;19-3:&#160;Dereferencing&#160;raw&#160;pointers&#160;within&#160;an&#160;&#160;</b>unsafe&#160;<b>&#160;block</b><br/>
Creating a pointer does no harm; it’s only when we try to access the value that it points at<br/>that we might end up dealing with an invalid value.<br/>
https://doc.rust-lang.org/book/print.html<br/>
516/627<br/>
<hr/>
<a name=517></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Note also that in Listing 19-1 and 19-3, we created&#160;&#160;*const&#160;i32&#160;&#160;and&#160;&#160;*mut&#160;i32&#160;&#160;raw pointers<br/>that both pointed to the same memory location, where&#160;&#160;num&#160;&#160;is stored. If we instead tried to<br/>create an immutable and a mutable reference to&#160;&#160;num&#160;, the code would not have compiled<br/>because Rust’s ownership rules don’t allow a mutable reference at the same time as any<br/>immutable references. With raw pointers, we can create a mutable pointer and an<br/>immutable pointer to the same location and change data through the mutable pointer,<br/>potentially creating a data race. Be careful!<br/>
With all of these dangers, why would you ever use raw pointers? One major use case is<br/><a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#calling-an-unsafe-function-or-method">when interfacing with C code, as you’ll see in the next section,&#160;“Calling an Unsafe Function or<br/>Method.”&#160;Another case is when building up safe abstractions that the borrow checker<br/></a>doesn’t understand. We’ll introduce unsafe functions and then look at an example of a safe<br/>abstraction that uses unsafe code.<br/>
<a href="tests.html#517"><b>Calling&#160;an&#160;Unsafe&#160;Function&#160;or&#160;Method</b></a><br/>
The second type of operation you can perform in an unsafe block is calling unsafe functions.<br/>Unsafe functions and methods look exactly like regular functions and methods, but they<br/>have an extra&#160;&#160;unsafe&#160;&#160;before the rest of the deﬁnition. The&#160;&#160;unsafe&#160;&#160;keyword in this context<br/>indicates the function has requirements we need to uphold when we call this function,<br/>because Rust can’t guarantee we’ve met these requirements. By calling an unsafe function<br/>within an&#160;&#160;unsafe&#160;&#160;block, we’re saying that we’ve read this function’s documentation and<br/>take responsibility for upholding the function’s contracts.<br/>
Here is an unsafe function named&#160;&#160;dangerous&#160;&#160;that doesn’t do anything in its body:<br/>
&#160;&#160;&#160;&#160;unsafe&#160;fn&#160;dangerous()&#160;{}<br/>
&#160;&#160;&#160;&#160;unsafe&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dangerous();<br/>&#160;&#160;&#160;&#160;}<br/>
We must call the&#160;&#160;dangerous&#160;&#160;function within a separate&#160;&#160;unsafe&#160;&#160;block. If we try to call<br/>
dangerous&#160;&#160;without the&#160;&#160;unsafe&#160;&#160;block, we’ll get an error:<br/>
https://doc.rust-lang.org/book/print.html<br/>
517/627<br/>
<hr/>
<a name=518></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;unsafe-example&#160;v0.1.0&#160;(file:///projects/unsafe-example)<br/>error[E0133]:&#160;call&#160;to&#160;unsafe&#160;function&#160;is&#160;unsafe&#160;and&#160;requires&#160;unsafe&#160;function&#160;or&#160;<br/>block<br/>&#160;--&gt;&#160;src/main.rs:4:5<br/>&#160;&#160;|<br/>4&#160;|&#160;&#160;&#160;&#160;&#160;dangerous();<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^&#160;call&#160;to&#160;unsafe&#160;function<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;consult&#160;the&#160;function's&#160;documentation&#160;for&#160;information&#160;on&#160;how&#160;to&#160;avoid&#160;<br/>undefined&#160;behavior<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0133`.<br/>error:&#160;could&#160;not&#160;compile&#160;`unsafe-example`&#160;due&#160;to&#160;previous&#160;error<br/>
With the&#160;&#160;unsafe&#160;&#160;block, we’re asserting to Rust that we’ve read the function’s<br/>documentation, we understand how to use it properly, and we’ve veriﬁed that we’re fulﬁlling<br/>the contract of the function.<br/>
Bodies of unsafe functions are eﬀectively&#160;&#160;unsafe&#160;&#160;blocks, so to perform other unsafe<br/>operations within an unsafe function, we don’t need to add another&#160;&#160;unsafe&#160;&#160;block.<br/>
<a href="tests.html#518"><b>Creating a Safe Abstraction over Unsafe Code</b></a><br/>
Just because a function contains unsafe code doesn’t mean we need to mark the entire<br/>function as unsafe. In fact, wrapping unsafe code in a safe function is a common<br/>abstraction. As an example, let’s study the&#160;&#160;split_at_mut&#160;&#160;function from the standard<br/>library, which requires some unsafe code. We’ll explore how we might implement it. This<br/>safe method is deﬁned on mutable slices: it takes one slice and makes it two by splitting the<br/>slice at the index given as an argument. Listing 19-4 shows how to use&#160;&#160;split_at_mut&#160;.<br/>
&#160;&#160;&#160;&#160;let&#160;mut&#160;v&#160;=&#160;vec![1,&#160;2,&#160;3,&#160;4,&#160;5,&#160;6];<br/>
&#160;&#160;&#160;&#160;let&#160;r&#160;=&#160;&amp;mut&#160;v[..];<br/>
&#160;&#160;&#160;&#160;let&#160;(a,&#160;b)&#160;=&#160;r.split_at_mut(3);<br/>
&#160;&#160;&#160;&#160;assert_eq!(a,&#160;&amp;mut&#160;[1,&#160;2,&#160;3]);<br/>&#160;&#160;&#160;&#160;assert_eq!(b,&#160;&amp;mut&#160;[4,&#160;5,&#160;6]);<br/>
<b>Listing&#160;19-4:&#160;Using&#160;the&#160;safe&#160;&#160;</b>split_at_mut&#160;<b>&#160;function</b><br/>
We can’t implement this function using only safe Rust. An attempt might look something like<br/>Listing 19-5, which won’t compile. For simplicity, we’ll implement&#160;&#160;split_at_mut&#160;&#160;as a<br/>function rather than a method and only for slices of&#160;&#160;i32&#160;&#160;values rather than for a generic<br/>type&#160;&#160;T&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
518/627<br/>
<hr/>
<a name=519></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;split_at_mut(values:&#160;&amp;mut&#160;[i32],&#160;mid:&#160;usize)&#160;-&gt;&#160;(&amp;mut&#160;[i32],&#160;&amp;mut&#160;[i32])&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;len&#160;=&#160;values.len();<br/>
&#160;&#160;&#160;&#160;assert!(mid&#160;&lt;=&#160;len);<br/>
&#160;&#160;&#160;&#160;(&amp;mut&#160;values[..mid],&#160;&amp;mut&#160;values[mid..])<br/>}<br/>
<b>Listing&#160;19-5:&#160;An&#160;attempted&#160;implementation&#160;of&#160;&#160;</b>split_at_mut&#160;<b>&#160;using&#160;only&#160;safe&#160;Rust</b><br/>
This function&#160;ﬁrst gets the total length of the slice. Then it asserts that the index given as a<br/>parameter is within the slice by checking whether it’s less than or equal to the length. The<br/>assertion means that if we pass an index that is greater than the length to split the slice at,<br/>the function will panic before it attempts to use that index.<br/>
Then we return two mutable slices in a tuple: one from the start of the original slice to the<br/>
mid&#160;&#160;index and another from&#160;&#160;mid&#160;&#160;to the end of the slice.<br/>
When we try to compile the code in Listing 19-5, we’ll get an error.<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;unsafe-example&#160;v0.1.0&#160;(file:///projects/unsafe-example)<br/>error[E0499]:&#160;cannot&#160;borrow&#160;`*values`&#160;as&#160;mutable&#160;more&#160;than&#160;once&#160;at&#160;a&#160;time<br/>&#160;--&gt;&#160;src/main.rs:6:31<br/>&#160;&#160;|<br/>1&#160;|&#160;fn&#160;split_at_mut(values:&#160;&amp;mut&#160;[i32],&#160;mid:&#160;usize)&#160;-&gt;&#160;(&amp;mut&#160;[i32],&#160;&amp;mut&#160;[i32])&#160;<br/>{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;-&#160;let's&#160;call&#160;the&#160;lifetime&#160;of&#160;this&#160;reference&#160;`'1`<br/>...<br/>6&#160;|&#160;&#160;&#160;&#160;&#160;(&amp;mut&#160;values[..mid],&#160;&amp;mut&#160;values[mid..])<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;--------------------------^^^^^^--------<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;second&#160;mutable&#160;borrow&#160;occurs&#160;here<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;first&#160;mutable&#160;borrow&#160;occurs&#160;here<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;returning&#160;this&#160;value&#160;requires&#160;that&#160;`*values`&#160;is&#160;borrowed&#160;for&#160;`'1`<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0499`.<br/>error:&#160;could&#160;not&#160;compile&#160;`unsafe-example`&#160;due&#160;to&#160;previous&#160;error<br/>
Rust’s borrow checker can’t understand that we’re borrowing diﬀerent parts of the slice; it<br/>only knows that we’re borrowing from the same slice twice. Borrowing diﬀerent parts of a<br/>slice is fundamentally okay because the two slices aren’t overlapping, but Rust isn’t smart<br/>enough to know this. When we know code is okay, but Rust doesn’t, it’s time to reach for<br/>unsafe code.<br/>
Listing 19-6 shows how to use an&#160;&#160;unsafe&#160;&#160;block, a raw pointer, and some calls to unsafe<br/>functions to make the implementation of&#160;&#160;split_at_mut&#160;&#160;work.<br/>
https://doc.rust-lang.org/book/print.html<br/>
519/627<br/>
<hr/>
<a name=520></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::slice;<br/>
fn&#160;split_at_mut(values:&#160;&amp;mut&#160;[i32],&#160;mid:&#160;usize)&#160;-&gt;&#160;(&amp;mut&#160;[i32],&#160;&amp;mut&#160;[i32])&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;len&#160;=&#160;values.len();<br/>&#160;&#160;&#160;&#160;let&#160;ptr&#160;=&#160;values.as_mut_ptr();<br/>
&#160;&#160;&#160;&#160;assert!(mid&#160;&lt;=&#160;len);<br/>
&#160;&#160;&#160;&#160;unsafe&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slice::from_raw_parts_mut(ptr,&#160;mid),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;slice::from_raw_parts_mut(ptr.add(mid),&#160;len&#160;-&#160;mid),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;)<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;19-6:&#160;Using&#160;unsafe&#160;code&#160;in&#160;the&#160;implementation&#160;of&#160;the&#160;&#160;</b>split_at_mut&#160;<b>&#160;function</b><br/>
<a href="https://doc.rust-lang.org/book/ch04-03-slices.html#the-slice-type">Recall from&#160;“The Slice Type”&#160;section in Chapter 4 that slices are a pointer to some data and<br/></a>the length of the slice. We use the&#160;&#160;len&#160;&#160;method to get the length of a slice and the<br/>
as_mut_ptr&#160;&#160;method to access the raw pointer of a slice. In this case, because we have a<br/>
mutable slice to&#160;&#160;i32&#160;&#160;values,&#160;&#160;as_mut_ptr&#160;&#160;returns a raw pointer with the type&#160;&#160;*mut&#160;i32&#160;,<br/>which we’ve stored in the variable&#160;&#160;ptr&#160;.<br/>
We keep the assertion that the&#160;&#160;mid&#160;&#160;index is within the slice. Then we get to the unsafe<br/>code: the&#160;&#160;slice::from_raw_parts_mut&#160;&#160;function takes a raw pointer and a length, and it<br/>creates a slice. We use this function to create a slice that starts from&#160;&#160;ptr&#160;&#160;and is&#160;&#160;mid&#160;&#160;items<br/>long. Then we call the&#160;&#160;add&#160;&#160;method on&#160;&#160;ptr&#160;&#160;with&#160;&#160;mid&#160;&#160;as an argument to get a raw pointer<br/>that starts at&#160;&#160;mid&#160;, and we create a slice using that pointer and the remaining number of<br/>items after&#160;&#160;mid&#160;&#160;as the length.<br/>
The function&#160;&#160;slice::from_raw_parts_mut&#160;&#160;is unsafe because it takes a raw pointer and<br/>must trust that this pointer is valid. The&#160;&#160;add&#160;&#160;method on raw pointers is also unsafe,<br/>because it must trust that the oﬀset location is also a valid pointer. Therefore, we had to put<br/>an&#160;&#160;unsafe&#160;&#160;block around our calls to&#160;&#160;slice::from_raw_parts_mut&#160;&#160;and&#160;&#160;add&#160;&#160;so we could call<br/>them. By looking at the code and by adding the assertion that&#160;&#160;mid&#160;&#160;must be less than or<br/>equal to&#160;&#160;len&#160;, we can tell that all the raw pointers used within the&#160;&#160;unsafe&#160;&#160;block will be valid<br/>pointers to data within the slice. This is an acceptable and appropriate use of&#160;&#160;unsafe&#160;.<br/>
Note that we don’t need to mark the resulting&#160;&#160;split_at_mut&#160;&#160;function as&#160;&#160;unsafe&#160;, and we<br/>can call this function from safe Rust. We’ve created a safe abstraction to the unsafe code<br/>with an implementation of the function that uses&#160;&#160;unsafe&#160;&#160;code in a safe way, because it<br/>creates only valid pointers from the data this function has access to.<br/>
In contrast, the use of&#160;&#160;slice::from_raw_parts_mut&#160;&#160;in Listing 19-7 would likely crash when<br/>the slice is used. This code takes an arbitrary memory location and creates a slice 10,000<br/>items long.<br/>
https://doc.rust-lang.org/book/print.html<br/>
520/627<br/>
<hr/>
<a name=521></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;use&#160;std::slice;<br/>
&#160;&#160;&#160;&#160;let&#160;address&#160;=&#160;0x01234usize;<br/>&#160;&#160;&#160;&#160;let&#160;r&#160;=&#160;address&#160;as&#160;*mut&#160;i32;<br/>
&#160;&#160;&#160;&#160;let&#160;values:&#160;&amp;[i32]&#160;=&#160;unsafe&#160;{&#160;slice::from_raw_parts_mut(r,&#160;10000)&#160;};<br/>
<b>Listing&#160;19-7:&#160;Creating&#160;a&#160;slice&#160;from&#160;an&#160;arbitrary&#160;memory&#160;location</b><br/>
We don’t own the memory at this arbitrary location, and there is no guarantee that the slice<br/>this code creates contains valid&#160;&#160;i32&#160;&#160;values. Attempting to use&#160;&#160;values&#160;&#160;as though it’s a valid<br/>slice results in undeﬁned behavior.<br/>
<a href="tests.html#521"><b>Using&#160;</b>extern<b>&#160;Functions to Call External Code</b></a><br/>
Sometimes, your Rust code might need to interact with code written in another language.<br/>For this, Rust has the keyword&#160;&#160;extern&#160;&#160;that facilitates the creation and use of a&#160;<i>Foreign<br/>Function Interface (FFI)</i>. An FFI is a way for a programming language to deﬁne functions and<br/>enable a diﬀerent (foreign) programming language to call those functions.<br/>
Listing 19-8 demonstrates how to set up an integration with the&#160;&#160;abs&#160;&#160;function from the C<br/>standard library. Functions declared within&#160;&#160;extern&#160;&#160;blocks are always unsafe to call from<br/>Rust code. The reason is that other languages don’t enforce Rust’s rules and guarantees,<br/>and Rust can’t check them, so responsibility falls on the programmer to ensure safety.<br/>
Filename: src/main.rs<br/>
extern&#160;&#34;C&#34;&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;abs(input:&#160;i32)&#160;-&gt;&#160;i32;<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;unsafe&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Absolute&#160;value&#160;of&#160;-3&#160;according&#160;to&#160;C:&#160;{}&#34;,&#160;abs(-3));<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;19-8:&#160;Declaring&#160;and&#160;calling&#160;an&#160;&#160;</b>extern&#160;<b>&#160;function&#160;deﬁned&#160;in&#160;another&#160;language</b><br/>
Within the&#160;&#160;extern&#160;&#34;C&#34;&#160;&#160;block, we list the names and signatures of external functions from<br/>another language we want to call. The&#160;&#160;&#34;C&#34;&#160;&#160;part deﬁnes which&#160;<i>application binary interface<br/>(ABI)</i>&#160;the external function uses: the ABI deﬁnes how to call the function at the assembly<br/>level. The&#160;&#160;&#34;C&#34;&#160;&#160;ABI is the most common and follows the C programming language’s ABI.<br/>
https://doc.rust-lang.org/book/print.html<br/>
521/627<br/>
<hr/>
<a name=522></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#522"><b>Calling Rust Functions from Other Languages</b></a><br/>
We can also use&#160;&#160;extern&#160;&#160;to create an interface that allows other languages to call Rust<br/>functions. Instead of creating a whole&#160;&#160;extern&#160;&#160;block, we add the&#160;&#160;extern&#160;&#160;keyword and<br/>specify the ABI to use just before the&#160;&#160;fn&#160;&#160;keyword for the relevant function. We also<br/>need to add a&#160;&#160;#[no_mangle]&#160;&#160;annotation to tell the Rust compiler not to mangle the<br/>name of this function.&#160;<i>Mangling</i>&#160;is when a compiler changes the name we’ve given a<br/>function to a diﬀerent name that contains more information for other parts of the<br/>compilation process to consume but is less human readable. Every programming<br/>language compiler mangles names slightly diﬀerently, so for a Rust function to be<br/>nameable by other languages, we must disable the Rust compiler’s name mangling.<br/>
In the following example, we make the&#160;&#160;call_from_c&#160;&#160;function accessible from C code,<br/>after it’s compiled to a shared library and linked from C:<br/>
#[no_mangle]<br/>pub&#160;extern&#160;&#34;C&#34;&#160;fn&#160;call_from_c()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;Just&#160;called&#160;a&#160;Rust&#160;function&#160;from&#160;C!&#34;);<br/>}<br/>
This usage of&#160;&#160;extern&#160;&#160;does not require&#160;&#160;unsafe&#160;.<br/>
<a href="tests.html#522"><b>Accessing&#160;or&#160;Modifying&#160;a&#160;Mutable&#160;Static&#160;Variable</b></a><br/>
In this book, we’ve not yet talked about&#160;<i>global variables</i>, which Rust does support but can be<br/>problematic with Rust’s ownership rules. If two threads are accessing the same mutable<br/>global variable, it can cause a data race.<br/>
In Rust, global variables are called&#160;<i>static</i>&#160;variables. Listing 19-9 shows an example<br/>declaration and use of a static variable with a string slice as a value.<br/>
Filename: src/main.rs<br/>
static&#160;HELLO_WORLD:&#160;&amp;str&#160;=&#160;&#34;Hello,&#160;world!&#34;;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;name&#160;is:&#160;{}&#34;,&#160;HELLO_WORLD);<br/>}<br/>
<b>Listing&#160;19-9:&#160;Deﬁning&#160;and&#160;using&#160;an&#160;immutable&#160;static&#160;variable</b><br/>
<a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#constants">Static variables are similar to constants, which we discussed in the&#160;“Diﬀerences Between<br/>Variables and Constants”&#160;section in Chapter 3. The names of static variables are in</a><br/>
SCREAMING_SNAKE_CASE&#160;&#160;by convention. Static variables can only store references with the<br/>
https://doc.rust-lang.org/book/print.html<br/>
522/627<br/>
<hr/>
<a name=523></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
'static&#160;&#160;lifetime, which means the Rust compiler can&#160;ﬁgure out the lifetime and we aren’t<br/>
required to annotate it explicitly. Accessing an immutable static variable is safe.<br/>
A subtle diﬀerence between constants and immutable static variables is that values in a<br/>static variable have a&#160;ﬁxed address in memory. Using the value will always access the same<br/>data. Constants, on the other hand, are allowed to duplicate their data whenever they’re<br/>used. Another diﬀerence is that static variables can be mutable. Accessing and modifying<br/>mutable static variables is&#160;<i>unsafe</i>. Listing 19-10 shows how to declare, access, and modify a<br/>mutable static variable named&#160;&#160;COUNTER&#160;.<br/>
Filename: src/main.rs<br/>
static&#160;mut&#160;COUNTER:&#160;u32&#160;=&#160;0;<br/>
fn&#160;add_to_count(inc:&#160;u32)&#160;{<br/>&#160;&#160;&#160;&#160;unsafe&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;COUNTER&#160;+=&#160;inc;<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;add_to_count(3);<br/>
&#160;&#160;&#160;&#160;unsafe&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;COUNTER:&#160;{}&#34;,&#160;COUNTER);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;19-10:&#160;Reading&#160;from&#160;or&#160;writing&#160;to&#160;a&#160;mutable&#160;static&#160;variable&#160;is&#160;unsafe</b><br/>
As with regular variables, we specify mutability using the&#160;&#160;mut&#160;&#160;keyword. Any code that reads<br/>or writes from&#160;&#160;COUNTER&#160;&#160;must be within an&#160;&#160;unsafe&#160;&#160;block. This code compiles and prints<br/>
COUNTER:&#160;3&#160;&#160;as we would expect because it’s single threaded. Having multiple threads<br/>
access&#160;&#160;COUNTER&#160;&#160;would likely result in data races.<br/>
With mutable data that is globally accessible, it’s diﬃcult to ensure there are no data races,<br/>which is why Rust considers mutable static variables to be unsafe. Where possible, it’s<br/>preferable to use the concurrency techniques and thread-safe smart pointers we discussed<br/>in Chapter 16 so the compiler checks that data accessed from diﬀerent threads is done<br/>safely.<br/>
<a href="tests.html#523"><b>Implementing&#160;an&#160;Unsafe&#160;Trait</b></a><br/>
We can use&#160;&#160;unsafe&#160;&#160;to implement an unsafe trait. A trait is unsafe when at least one of its<br/>methods has some invariant that the compiler can’t verify. We declare that a trait is&#160;&#160;unsafe<br/>by adding the&#160;&#160;unsafe&#160;&#160;keyword before&#160;&#160;trait&#160;&#160;and marking the implementation of the trait<br/>as&#160;&#160;unsafe&#160;&#160;too, as shown in Listing 19-11.<br/>
https://doc.rust-lang.org/book/print.html<br/>
523/627<br/>
<hr/>
<a name=524></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
unsafe&#160;trait&#160;Foo&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;methods&#160;go&#160;here<br/>}<br/>
unsafe&#160;impl&#160;Foo&#160;for&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;method&#160;implementations&#160;go&#160;here<br/>}<br/>
fn&#160;main()&#160;{}<br/>
<b>Listing&#160;19-11:&#160;Deﬁning&#160;and&#160;implementing&#160;an&#160;unsafe&#160;trait</b><br/>
By using&#160;&#160;unsafe&#160;impl&#160;, we’re promising that we’ll uphold the invariants that the compiler<br/>can’t verify.<br/>
<a href="https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">As an example, recall the&#160;&#160;Sync&#160;&#160;and&#160;&#160;Send&#160;&#160;marker traits we discussed in the&#160;“Extensible<br/>Concurrency with the&#160;&#160;Sync&#160;&#160;and&#160;&#160;Send&#160;&#160;Traits”&#160;section in Chapter 16: the compiler<br/></a>implements these traits automatically if our types are composed entirely of&#160;&#160;Send&#160;&#160;and&#160;&#160;Sync<br/>types. If we implement a type that contains a type that is not&#160;&#160;Send&#160;&#160;or&#160;&#160;Sync&#160;, such as raw<br/>pointers, and we want to mark that type as&#160;&#160;Send&#160;&#160;or&#160;&#160;Sync&#160;, we must use&#160;&#160;unsafe&#160;. Rust can’t<br/>verify that our type upholds the guarantees that it can be safely sent across threads or<br/>accessed from multiple threads; therefore, we need to do those checks manually and<br/>indicate as such with&#160;&#160;unsafe&#160;.<br/>
<a href="tests.html#524"><b>Accessing&#160;Fields&#160;of&#160;a&#160;Union</b></a><br/>
The&#160;ﬁnal action that works only with&#160;&#160;unsafe&#160;&#160;is accessing&#160;ﬁelds of a&#160;<i>union</i>. A&#160;&#160;union&#160;&#160;is<br/>similar to a&#160;&#160;struct&#160;, but only one declared&#160;ﬁeld is used in a particular instance at one time.<br/>Unions are primarily used to interface with unions in C code. Accessing union&#160;ﬁelds is<br/>unsafe because Rust can’t guarantee the type of the data currently being stored in the union<br/>instance. You can learn more about unions in&#160;<a href="https://doc.rust-lang.org/reference/items/unions.html">the Rust Reference.</a><br/>
<a href="tests.html#524"><b>When&#160;to&#160;Use&#160;Unsafe&#160;Code</b></a><br/>
Using&#160;&#160;unsafe&#160;&#160;to take one of the&#160;ﬁve actions (superpowers) just discussed isn’t wrong or<br/>even frowned upon. But it is trickier to get&#160;&#160;unsafe&#160;&#160;code correct because the compiler can’t<br/>help uphold memory safety. When you have a reason to use&#160;&#160;unsafe&#160;&#160;code, you can do so,<br/>and having the explicit&#160;&#160;unsafe&#160;&#160;annotation makes it easier to track down the source of<br/>problems when they occur.<br/>
https://doc.rust-lang.org/book/print.html<br/>
524/627<br/>
<hr/>
<a name=525></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#525"><b>Advanced Traits</b></a><br/>
We&#160;ﬁ<a href="https://doc.rust-lang.org/book/ch10-02-traits.html#traits-defining-shared-behavior">rst covered traits in the&#160;“Traits: Deﬁning Shared Behavior”&#160;section of Chapter 10, but<br/></a>we didn’t discuss the more advanced details. Now that you know more about Rust, we can<br/>get into the nitty-gritty.<br/>
<a href="tests.html#525"><b>Specifying&#160;Placeholder&#160;Types&#160;in&#160;Trait&#160;Deﬁnitions&#160;with&#160;Associated&#160;Types</b></a><br/>
<i>Associated types</i>&#160;connect a type placeholder with a trait such that the trait method<br/>deﬁnitions can use these placeholder types in their signatures. The implementor of a trait<br/>will specify the concrete type to be used instead of the placeholder type for the particular<br/>implementation. That way, we can deﬁne a trait that uses some types without needing to<br/>know exactly what those types are until the trait is implemented.<br/>
We’ve described most of the advanced features in this chapter as being rarely needed.<br/>Associated types are somewhere in the middle: they’re used more rarely than features<br/>explained in the rest of the book but more commonly than many of the other features<br/>discussed in this chapter.<br/>
One example of a trait with an associated type is the&#160;&#160;Iterator&#160;&#160;trait that the standard<br/>library provides. The associated type is named&#160;&#160;Item&#160;&#160;and stands in for the type of the values<br/>the type implementing the&#160;&#160;Iterator&#160;&#160;trait is iterating over. The deﬁnition of the&#160;&#160;Iterator<br/>trait is as shown in Listing 19-12.<br/>
pub&#160;trait&#160;Iterator&#160;{<br/>&#160;&#160;&#160;&#160;type&#160;Item;<br/>
&#160;&#160;&#160;&#160;fn&#160;next(&amp;mut&#160;self)&#160;-&gt;&#160;Option&lt;Self::Item&gt;;<br/>}<br/>
<b>Listing&#160;19-12:&#160;The&#160;deﬁnition&#160;of&#160;the&#160;&#160;</b>Iterator&#160;<b>&#160;trait&#160;that&#160;has&#160;an&#160;associated&#160;type&#160;&#160;</b>Item<br/>
The type&#160;&#160;Item&#160;&#160;is a placeholder, and the&#160;&#160;next&#160;&#160;method’s deﬁnition shows that it will return<br/>values of type&#160;&#160;Option&lt;Self::Item&gt;&#160;. Implementors of the&#160;&#160;Iterator&#160;&#160;trait will specify the<br/>concrete type for&#160;&#160;Item&#160;, and the&#160;&#160;next&#160;&#160;method will return an&#160;&#160;Option&#160;&#160;containing a value of<br/>that concrete type.<br/>
Associated types might seem like a similar concept to generics, in that the latter allow us to<br/>deﬁne a function without specifying what types it can handle. To examine the diﬀerence<br/>between the two concepts, we’ll look at an implementation of the&#160;&#160;Iterator&#160;&#160;trait on a type<br/>named&#160;&#160;Counter&#160;&#160;that speciﬁes the&#160;&#160;Item&#160;&#160;type is&#160;&#160;u32&#160;:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
525/627<br/>
<hr/>
<a name=526></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
impl&#160;Iterator&#160;for&#160;Counter&#160;{<br/>&#160;&#160;&#160;&#160;type&#160;Item&#160;=&#160;u32;<br/>
&#160;&#160;&#160;&#160;fn&#160;next(&amp;mut&#160;self)&#160;-&gt;&#160;Option&lt;Self::Item&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
This syntax seems comparable to that of generics. So why not just deﬁne the&#160;&#160;Iterator&#160;&#160;trait<br/>with generics, as shown in Listing 19-13?<br/>
pub&#160;trait&#160;Iterator&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;next(&amp;mut&#160;self)&#160;-&gt;&#160;Option&lt;T&gt;;<br/>}<br/>
<b>Listing&#160;19-13:&#160;A&#160;hypothetical&#160;deﬁnition&#160;of&#160;the&#160;&#160;</b>Iterator&#160;<b>&#160;trait&#160;using&#160;generics</b><br/>
The diﬀerence is that when using generics, as in Listing 19-13, we must annotate the types<br/>in each implementation; because we can also implement&#160;&#160;Iterator&lt;String&gt;&#160;for&#160;Counter<br/>or any other type, we could have multiple implementations of&#160;&#160;Iterator&#160;&#160;for&#160;&#160;Counter&#160;. In<br/>other words, when a trait has a generic parameter, it can be implemented for a type<br/>multiple times, changing the concrete types of the generic type parameters each time.<br/>When we use the&#160;&#160;next&#160;&#160;method on&#160;&#160;Counter&#160;, we would have to provide type annotations to<br/>indicate which implementation of&#160;&#160;Iterator&#160;&#160;we want to use.<br/>
With associated types, we don’t need to annotate types because we can’t implement a trait<br/>on a type multiple times. In Listing 19-12 with the deﬁnition that uses associated types, we<br/>can only choose what the type of&#160;&#160;Item&#160;&#160;will be once, because there can only be one&#160;&#160;impl&#160;<br/>Iterator&#160;for&#160;Counter&#160;. We don’t have to specify that we want an iterator of&#160;&#160;u32&#160;&#160;values<br/>everywhere that we call&#160;&#160;next&#160;&#160;on&#160;&#160;Counter&#160;.<br/>
Associated types also become part of the trait’s contract: implementors of the trait must<br/>provide a type to stand in for the associated type placeholder. Associated types often have a<br/>name that describes how the type will be used, and documenting the associated type in the<br/>API documentation is good practice.<br/>
<a href="tests.html#526"><b>Default&#160;Generic&#160;Type&#160;Parameters&#160;and&#160;Operator&#160;Overloading</b></a><br/>
When we use generic type parameters, we can specify a default concrete type for the<br/>generic type. This eliminates the need for implementors of the trait to specify a concrete<br/>type if the default type works. You specify a default type when declaring a generic type with<br/>the&#160;&#160;&lt;PlaceholderType=ConcreteType&gt;&#160;&#160;syntax.<br/>
A great example of a situation where this technique is useful is with&#160;<i>operator overloading</i>, in<br/>which you customize the behavior of an operator (such as&#160;&#160;+&#160;) in particular situations.<br/>
Rust doesn’t allow you to create your own operators or overload arbitrary operators. But<br/>you can overload the operations and corresponding traits listed in&#160;&#160;std::ops&#160;&#160;by<br/>
https://doc.rust-lang.org/book/print.html<br/>
526/627<br/>
<hr/>
<a name=527></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
implementing the traits associated with the operator. For example, in Listing 19-14 we<br/>overload the&#160;&#160;+&#160;&#160;operator to add two&#160;&#160;Point&#160;&#160;instances together. We do this by implementing<br/>the&#160;&#160;Add&#160;&#160;trait on a&#160;&#160;Point&#160;&#160;struct:<br/>
Filename: src/main.rs<br/>
use&#160;std::ops::Add;<br/>
#[derive(Debug,&#160;Copy,&#160;Clone,&#160;PartialEq)]<br/>struct&#160;Point&#160;{<br/>&#160;&#160;&#160;&#160;x:&#160;i32,<br/>&#160;&#160;&#160;&#160;y:&#160;i32,<br/>}<br/>
impl&#160;Add&#160;for&#160;Point&#160;{<br/>&#160;&#160;&#160;&#160;type&#160;Output&#160;=&#160;Point;<br/>
&#160;&#160;&#160;&#160;fn&#160;add(self,&#160;other:&#160;Point)&#160;-&gt;&#160;Point&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Point&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x:&#160;self.x&#160;+&#160;other.x,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;self.y&#160;+&#160;other.y,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;assert_eq!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Point&#160;{&#160;x:&#160;1,&#160;y:&#160;0&#160;}&#160;+&#160;Point&#160;{&#160;x:&#160;2,&#160;y:&#160;3&#160;},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Point&#160;{&#160;x:&#160;3,&#160;y:&#160;3&#160;}<br/>&#160;&#160;&#160;&#160;);<br/>}<br/>
<b>Listing&#160;19-14:&#160;Implementing&#160;the&#160;&#160;</b>Add&#160;<b>&#160;trait&#160;to&#160;overload&#160;the&#160;&#160;</b>+&#160;<b>&#160;operator&#160;for&#160;&#160;</b>Point&#160;<b>&#160;instances</b><br/>
The&#160;&#160;add&#160;&#160;method adds the&#160;&#160;x&#160;&#160;values of two&#160;&#160;Point&#160;&#160;instances and the&#160;&#160;y&#160;&#160;values of two<br/>
Point&#160;&#160;instances to create a new&#160;&#160;Point&#160;. The&#160;&#160;Add&#160;&#160;trait has an associated type named<br/>Output&#160;&#160;that determines the type returned from the&#160;&#160;add&#160;&#160;method.<br/>
The default generic type in this code is within the&#160;&#160;Add&#160;&#160;trait. Here is its deﬁnition:<br/>
trait&#160;Add&lt;Rhs=Self&gt;&#160;{<br/>&#160;&#160;&#160;&#160;type&#160;Output;<br/>
&#160;&#160;&#160;&#160;fn&#160;add(self,&#160;rhs:&#160;Rhs)&#160;-&gt;&#160;Self::Output;<br/>}<br/>
This code should look generally familiar: a trait with one method and an associated type.<br/>The new part is&#160;&#160;Rhs=Self&#160;: this syntax is called&#160;<i>default type parameters</i>. The&#160;&#160;Rhs&#160;&#160;generic<br/>type parameter (short for “right hand side”) deﬁnes the type of the&#160;&#160;rhs&#160;&#160;parameter in the<br/>
add&#160;&#160;method. If we don’t specify a concrete type for&#160;&#160;Rhs&#160;&#160;when we implement the&#160;&#160;Add&#160;&#160;trait,<br/>
the type of&#160;&#160;Rhs&#160;&#160;will default to&#160;&#160;Self&#160;, which will be the type we’re implementing&#160;&#160;Add&#160;&#160;on.<br/>
https://doc.rust-lang.org/book/print.html<br/>
527/627<br/>
<hr/>
<a name=528></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
When we implemented&#160;&#160;Add&#160;&#160;for&#160;&#160;Point&#160;, we used the default for&#160;&#160;Rhs&#160;&#160;because we wanted to<br/>add two&#160;&#160;Point&#160;&#160;instances. Let’s look at an example of implementing the&#160;&#160;Add&#160;&#160;trait where we<br/>want to customize the&#160;&#160;Rhs&#160;&#160;type rather than using the default.<br/>
We have two structs,&#160;&#160;Millimeters&#160;&#160;and&#160;&#160;Meters&#160;, holding values in diﬀerent units. This thin<br/>wrapping of an existing type in another struct is known as the&#160;<i>newtype pattern</i>, which we<br/><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">describe in more detail in the&#160;“Using the Newtype Pattern to Implement External Traits on<br/>External Types”&#160;section. We want to add values in millimeters to values in meters and have<br/></a>the implementation of&#160;&#160;Add&#160;&#160;do the conversion correctly. We can implement&#160;&#160;Add&#160;&#160;for<br/>
Millimeters&#160;&#160;with&#160;&#160;Meters&#160;&#160;as the&#160;&#160;Rhs&#160;, as shown in Listing 19-15.<br/>
Filename: src/lib.rs<br/>
use&#160;std::ops::Add;<br/>
struct&#160;Millimeters(u32);<br/>struct&#160;Meters(u32);<br/>
impl&#160;Add&lt;Meters&gt;&#160;for&#160;Millimeters&#160;{<br/>&#160;&#160;&#160;&#160;type&#160;Output&#160;=&#160;Millimeters;<br/>
&#160;&#160;&#160;&#160;fn&#160;add(self,&#160;other:&#160;Meters)&#160;-&gt;&#160;Millimeters&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Millimeters(self.0&#160;+&#160;(other.0&#160;*&#160;1000))<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;19-15:&#160;Implementing&#160;the&#160;&#160;</b>Add&#160;<b>&#160;trait&#160;on&#160;&#160;</b>Millimeters&#160;<b>&#160;to&#160;add&#160;&#160;</b>Millimeters&#160;<b>&#160;to&#160;&#160;</b>Meters<br/>
To add&#160;&#160;Millimeters&#160;&#160;and&#160;&#160;Meters&#160;, we specify&#160;&#160;impl&#160;Add&lt;Meters&gt;&#160;&#160;to set the value of the<br/>
Rhs&#160;&#160;type parameter instead of using the default of&#160;&#160;Self&#160;.<br/>
You’ll use default type parameters in two main ways:<br/>
To extend a type without breaking existing code<br/>To allow customization in speciﬁc cases most users won’t need<br/>
The standard library’s&#160;&#160;Add&#160;&#160;trait is an example of the second purpose: usually, you’ll add two<br/>like types, but the&#160;&#160;Add&#160;&#160;trait provides the ability to customize beyond that. Using a default<br/>type parameter in the&#160;&#160;Add&#160;&#160;trait deﬁnition means you don’t have to specify the extra<br/>parameter most of the time. In other words, a bit of implementation boilerplate isn’t<br/>needed, making it easier to use the trait.<br/>
The&#160;ﬁrst purpose is similar to the second but in reverse: if you want to add a type parameter<br/>to an existing trait, you can give it a default to allow extension of the functionality of the trait<br/>without breaking the existing implementation code.<br/>
https://doc.rust-lang.org/book/print.html<br/>
528/627<br/>
<hr/>
<a name=529></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#529"><b>Fully&#160;Qualiﬁed&#160;Syntax&#160;for&#160;Disambiguation:&#160;Calling&#160;Methods&#160;with&#160;the</b></a><br/>
<a href="tests.html#529"><b>Same&#160;Name</b></a><br/>
Nothing in Rust prevents a trait from having a method with the same name as another<br/>trait’s method, nor does Rust prevent you from implementing both traits on one type. It’s<br/>also possible to implement a method directly on the type with the same name as methods<br/>from traits.<br/>
When calling methods with the same name, you’ll need to tell Rust which one you want to<br/>use. Consider the code in Listing 19-16 where we’ve deﬁned two traits,&#160;&#160;Pilot&#160;&#160;and&#160;&#160;Wizard&#160;,<br/>that both have a method called&#160;&#160;fly&#160;. We then implement both traits on a type&#160;&#160;Human&#160;&#160;that<br/>already has a method named&#160;&#160;fly&#160;&#160;implemented on it. Each&#160;&#160;fly&#160;&#160;method does something<br/>diﬀerent.<br/>
Filename: src/main.rs<br/>
trait&#160;Pilot&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;fly(&amp;self);<br/>}<br/>
trait&#160;Wizard&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;fly(&amp;self);<br/>}<br/>
struct&#160;Human;<br/>
impl&#160;Pilot&#160;for&#160;Human&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;fly(&amp;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;This&#160;is&#160;your&#160;captain&#160;speaking.&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
impl&#160;Wizard&#160;for&#160;Human&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;fly(&amp;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Up!&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
impl&#160;Human&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;fly(&amp;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;*waving&#160;arms&#160;furiously*&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;19-16:&#160;Two&#160;traits&#160;are&#160;deﬁned&#160;to&#160;have&#160;a&#160;&#160;</b>fly&#160;<b>&#160;method&#160;and&#160;are&#160;implemented&#160;on&#160;the&#160;&#160;</b>Human&#160;<b>&#160;type,&#160;and&#160;a&#160;&#160;</b>fly<br/><b>method&#160;is&#160;implemented&#160;on&#160;&#160;</b>Human&#160;<b>&#160;directly</b><br/>
When we call&#160;&#160;fly&#160;&#160;on an instance of&#160;&#160;Human&#160;, the compiler defaults to calling the method that<br/>is directly implemented on the type, as shown in Listing 19-17.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
529/627<br/>
<hr/>
<a name=530></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;person&#160;=&#160;Human;<br/>&#160;&#160;&#160;&#160;person.fly();<br/>}<br/>
<b>Listing&#160;19-17:&#160;Calling&#160;&#160;</b>fly&#160;<b>&#160;on&#160;an&#160;instance&#160;of&#160;&#160;</b>Human<br/>
Running this code will print&#160;&#160;*waving&#160;arms&#160;furiously*&#160;, showing that Rust called the&#160;&#160;fly<br/>method implemented on&#160;&#160;Human&#160;&#160;directly.<br/>
To call the&#160;&#160;fly&#160;&#160;methods from either the&#160;&#160;Pilot&#160;&#160;trait or the&#160;&#160;Wizard&#160;&#160;trait, we need to use<br/>more explicit syntax to specify which&#160;&#160;fly&#160;&#160;method we mean. Listing 19-18 demonstrates<br/>this syntax.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;person&#160;=&#160;Human;<br/>&#160;&#160;&#160;&#160;Pilot::fly(&amp;person);<br/>&#160;&#160;&#160;&#160;Wizard::fly(&amp;person);<br/>&#160;&#160;&#160;&#160;person.fly();<br/>}<br/>
<b>Listing&#160;19-18:&#160;Specifying&#160;which&#160;trait’s&#160;&#160;</b>fly&#160;<b>&#160;method&#160;we&#160;want&#160;to&#160;call</b><br/>
Specifying the trait name before the method name clariﬁes to Rust which implementation of<br/>
fly&#160;&#160;we want to call. We could also write&#160;&#160;Human::fly(&amp;person)&#160;, which is equivalent to the<br/>person.fly()&#160;&#160;that we used in Listing 19-18, but this is a bit longer to write if we don’t need<br/>
to disambiguate.<br/>
Running this code prints the following:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;traits-example&#160;v0.1.0&#160;(file:///projects/traits-example)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.46s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/traits-example`<br/>This&#160;is&#160;your&#160;captain&#160;speaking.<br/>Up!<br/>*waving&#160;arms&#160;furiously*<br/>
Because the&#160;&#160;fly&#160;&#160;method takes a&#160;&#160;self&#160;&#160;parameter, if we had two&#160;<i>types</i>&#160;that both implement<br/>one&#160;<i>trait</i>, Rust could&#160;ﬁgure out which implementation of a trait to use based on the type of<br/>
self&#160;.<br/>
However, associated functions that are not methods don’t have a&#160;&#160;self&#160;&#160;parameter. When<br/>there are multiple types or traits that deﬁne non-method functions with the same function<br/>name, Rust doesn't always know which type you mean unless you use&#160;<i>fully qualiﬁed syntax</i>.<br/>For example, in Listing 19-19 we create a trait for an animal shelter that wants to name all<br/>baby dogs&#160;<i>Spot</i>. We make an&#160;&#160;Animal&#160;&#160;trait with an associated non-method function<br/>
https://doc.rust-lang.org/book/print.html<br/>
530/627<br/>
<hr/>
<a name=531></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
baby_name&#160;. The&#160;&#160;Animal&#160;&#160;trait is implemented for the struct&#160;&#160;Dog&#160;, on which we also provide<br/>
an associated non-method function&#160;&#160;baby_name&#160;&#160;directly.<br/>
Filename: src/main.rs<br/>
trait&#160;Animal&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;baby_name()&#160;-&gt;&#160;String;<br/>}<br/>
struct&#160;Dog;<br/>
impl&#160;Dog&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;baby_name()&#160;-&gt;&#160;String&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;Spot&#34;)<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
impl&#160;Animal&#160;for&#160;Dog&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;baby_name()&#160;-&gt;&#160;String&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;String::from(&#34;puppy&#34;)<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;A&#160;baby&#160;dog&#160;is&#160;called&#160;a&#160;{}&#34;,&#160;Dog::baby_name());<br/>}<br/>
<b>Listing&#160;19-19:&#160;A&#160;trait&#160;with&#160;an&#160;associated&#160;function&#160;and&#160;a&#160;type&#160;with&#160;an&#160;associated&#160;function&#160;of&#160;the&#160;same&#160;name&#160;that<br/>also&#160;implements&#160;the&#160;trait</b><br/>
We implement the code for naming all puppies Spot in the&#160;&#160;baby_name&#160;&#160;associated function<br/>that is deﬁned on&#160;&#160;Dog&#160;. The&#160;&#160;Dog&#160;&#160;type also implements the trait&#160;&#160;Animal&#160;, which describes<br/>characteristics that all animals have. Baby dogs are called puppies, and that is expressed in<br/>the implementation of the&#160;&#160;Animal&#160;&#160;trait on&#160;&#160;Dog&#160;&#160;in the&#160;&#160;baby_name&#160;&#160;function associated with<br/>the&#160;&#160;Animal&#160;&#160;trait.<br/>
In&#160;&#160;main&#160;, we call the&#160;&#160;Dog::baby_name&#160;&#160;function, which calls the associated function deﬁned<br/>on&#160;&#160;Dog&#160;&#160;directly. This code prints the following:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;traits-example&#160;v0.1.0&#160;(file:///projects/traits-example)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.54s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/traits-example`<br/>A&#160;baby&#160;dog&#160;is&#160;called&#160;a&#160;Spot<br/>
This output isn’t what we wanted. We want to call the&#160;&#160;baby_name&#160;&#160;function that is part of the<br/>
Animal&#160;&#160;trait that we implemented on&#160;&#160;Dog&#160;&#160;so the code prints&#160;&#160;A&#160;baby&#160;dog&#160;is&#160;called&#160;a&#160;<br/>
puppy&#160;. The technique of specifying the trait name that we used in Listing 19-18 doesn’t help<br/>here; if we change&#160;&#160;main&#160;&#160;to the code in Listing 19-20, we’ll get a compilation error.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
531/627<br/>
<hr/>
<a name=532></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;A&#160;baby&#160;dog&#160;is&#160;called&#160;a&#160;{}&#34;,&#160;Animal::baby_name());<br/>}<br/>
<b>Listing&#160;19-20:&#160;Attempting&#160;to&#160;call&#160;the&#160;&#160;</b>baby_name&#160;<b>&#160;function&#160;from&#160;the&#160;&#160;</b>Animal&#160;<b>&#160;trait,&#160;but&#160;Rust&#160;doesn’t&#160;know&#160;which<br/>implementation&#160;to&#160;use</b><br/>
Because&#160;&#160;Animal::baby_name&#160;&#160;doesn’t have a&#160;&#160;self&#160;&#160;parameter, and there could be other<br/>types that implement the&#160;&#160;Animal&#160;&#160;trait, Rust can’t&#160;ﬁgure out which implementation of<br/>
Animal::baby_name&#160;&#160;we want. We’ll get this compiler error:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;traits-example&#160;v0.1.0&#160;(file:///projects/traits-example)<br/>error[E0790]:&#160;cannot&#160;call&#160;associated&#160;function&#160;on&#160;trait&#160;without&#160;specifying&#160;the&#160;<br/>corresponding&#160;`impl`&#160;type<br/>&#160;&#160;--&gt;&#160;src/main.rs:20:43<br/>&#160;&#160;&#160;|<br/>2&#160;&#160;|&#160;&#160;&#160;&#160;&#160;fn&#160;baby_name()&#160;-&gt;&#160;String;<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;-------------------------&#160;`Animal::baby_name`&#160;defined&#160;here<br/>...<br/>20&#160;|&#160;&#160;&#160;&#160;&#160;println!(&#34;A&#160;baby&#160;dog&#160;is&#160;called&#160;a&#160;{}&#34;,&#160;Animal::baby_name());<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^^&#160;cannot&#160;call&#160;<br/>associated&#160;function&#160;of&#160;trait<br/>&#160;&#160;&#160;|<br/>help:&#160;use&#160;the&#160;fully-qualified&#160;path&#160;to&#160;the&#160;only&#160;available&#160;implementation<br/>&#160;&#160;&#160;|<br/>20&#160;|&#160;&#160;&#160;&#160;&#160;println!(&#34;A&#160;baby&#160;dog&#160;is&#160;called&#160;a&#160;{}&#34;,&#160;&lt;Dog&#160;as&#160;Animal&gt;::baby_name());<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+++++++&#160;&#160;&#160;&#160;&#160;&#160;&#160;+<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0790`.<br/>error:&#160;could&#160;not&#160;compile&#160;`traits-example`&#160;due&#160;to&#160;previous&#160;error<br/>
To disambiguate and tell Rust that we want to use the implementation of&#160;&#160;Animal&#160;&#160;for&#160;&#160;Dog<br/>as opposed to the implementation of&#160;&#160;Animal&#160;&#160;for some other type, we need to use fully<br/>qualiﬁed syntax. Listing 19-21 demonstrates how to use fully qualiﬁed syntax.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;println!(&#34;A&#160;baby&#160;dog&#160;is&#160;called&#160;a&#160;{}&#34;,&#160;&lt;Dog&#160;as&#160;Animal&gt;::baby_name());<br/>}<br/>
<b>Listing&#160;19-21:&#160;Using&#160;fully&#160;qualiﬁed&#160;syntax&#160;to&#160;specify&#160;that&#160;we&#160;want&#160;to&#160;call&#160;the&#160;&#160;</b>baby_name&#160;<b>&#160;function&#160;from&#160;the</b><br/>
Animal&#160;<b>&#160;trait&#160;as&#160;implemented&#160;on&#160;&#160;</b>Dog<br/>
We’re providing Rust with a type annotation within the angle brackets, which indicates we<br/>want to call the&#160;&#160;baby_name&#160;&#160;method from the&#160;&#160;Animal&#160;&#160;trait as implemented on&#160;&#160;Dog&#160;&#160;by<br/>saying that we want to treat the&#160;&#160;Dog&#160;&#160;type as an&#160;&#160;Animal&#160;&#160;for this function call. This code will<br/>now print what we want:<br/>
https://doc.rust-lang.org/book/print.html<br/>
532/627<br/>
<hr/>
<a name=533></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;traits-example&#160;v0.1.0&#160;(file:///projects/traits-example)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.48s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/traits-example`<br/>A&#160;baby&#160;dog&#160;is&#160;called&#160;a&#160;puppy<br/>
In general, fully qualiﬁed syntax is deﬁned as follows:<br/>
&lt;Type&#160;as&#160;Trait&gt;::function(receiver_if_method,&#160;next_arg,&#160;...);<br/>
For associated functions that aren’t methods, there would not be a&#160;&#160;receiver&#160;: there would<br/>only be the list of other arguments. You could use fully qualiﬁed syntax everywhere that you<br/>call functions or methods. However, you’re allowed to omit any part of this syntax that Rust<br/>can&#160;ﬁgure out from other information in the program. You only need to use this more<br/>verbose syntax in cases where there are multiple implementations that use the same name<br/>and Rust needs help to identify which implementation you want to call.<br/>
<a href="tests.html#533"><b>Using&#160;Supertraits&#160;to&#160;Require&#160;One&#160;Trait’s&#160;Functionality&#160;Within&#160;Another</b></a><br/>
<a href="tests.html#533"><b>Trait</b></a><br/>
Sometimes, you might write a trait deﬁnition that depends on another trait: for a type to<br/>implement the&#160;ﬁrst trait, you want to require that type to also implement the second trait.<br/>You would do this so that your trait deﬁnition can make use of the associated items of the<br/>second trait. The trait your trait deﬁnition is relying on is called a&#160;<i>supertrait</i>&#160;of your trait.<br/>
For example, let’s say we want to make an&#160;&#160;OutlinePrint&#160;&#160;trait with an&#160;&#160;outline_print<br/>method that will print a given value formatted so that it's framed in asterisks. That is, given<br/>a&#160;&#160;Point&#160;&#160;struct that implements the standard library trait&#160;&#160;Display&#160;&#160;to result in&#160;&#160;(x,&#160;y)&#160;,<br/>when we call&#160;&#160;outline_print&#160;&#160;on a&#160;&#160;Point&#160;&#160;instance that has&#160;&#160;1&#160;&#160;for&#160;&#160;x&#160;&#160;and&#160;&#160;3&#160;&#160;for&#160;&#160;y&#160;, it should<br/>print the following:<br/>
**********<br/>*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*<br/>*&#160;(1,&#160;3)&#160;*<br/>*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*<br/>**********<br/>
In the implementation of the&#160;&#160;outline_print&#160;&#160;method, we want to use the&#160;&#160;Display&#160;&#160;trait’s<br/>functionality. Therefore, we need to specify that the&#160;&#160;OutlinePrint&#160;&#160;trait will work only for<br/>types that also implement&#160;&#160;Display&#160;&#160;and provide the functionality that&#160;&#160;OutlinePrint&#160;&#160;needs.<br/>We can do that in the trait deﬁnition by specifying&#160;&#160;OutlinePrint:&#160;Display&#160;. This technique<br/>is similar to adding a trait bound to the trait. Listing 19-22 shows an implementation of the<br/>
OutlinePrint&#160;&#160;trait.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
533/627<br/>
<hr/>
<a name=534></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::fmt;<br/>
trait&#160;OutlinePrint:&#160;fmt::Display&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;outline_print(&amp;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;output&#160;=&#160;self.to_string();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;len&#160;=&#160;output.len();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;{}&#34;,&#160;&#34;*&#34;.repeat(len&#160;+&#160;4));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;*{}*&#34;,&#160;&#34;&#160;&#34;.repeat(len&#160;+&#160;2));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;*&#160;{}&#160;*&#34;,&#160;output);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;*{}*&#34;,&#160;&#34;&#160;&#34;.repeat(len&#160;+&#160;2));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;{}&#34;,&#160;&#34;*&#34;.repeat(len&#160;+&#160;4));<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;19-22:&#160;Implementing&#160;the&#160;&#160;</b>OutlinePrint&#160;<b>&#160;trait&#160;that&#160;requires&#160;the&#160;functionality&#160;from&#160;&#160;</b>Display<br/>
Because we’ve speciﬁed that&#160;&#160;OutlinePrint&#160;&#160;requires the&#160;&#160;Display&#160;&#160;trait, we can use the<br/>
to_string&#160;&#160;function that is automatically implemented for any type that implements<br/>Display&#160;. If we tried to use&#160;&#160;to_string&#160;&#160;without adding a colon and specifying the&#160;&#160;Display<br/>
trait after the trait name, we’d get an error saying that no method named&#160;&#160;to_string&#160;&#160;was<br/>found for the type&#160;&#160;&amp;Self&#160;&#160;in the current scope.<br/>
Let’s see what happens when we try to implement&#160;&#160;OutlinePrint&#160;&#160;on a type that doesn’t<br/>implement&#160;&#160;Display&#160;, such as the&#160;&#160;Point&#160;&#160;struct:<br/>
Filename: src/main.rs<br/>
struct&#160;Point&#160;{<br/>&#160;&#160;&#160;&#160;x:&#160;i32,<br/>&#160;&#160;&#160;&#160;y:&#160;i32,<br/>}<br/>
impl&#160;OutlinePrint&#160;for&#160;Point&#160;{}<br/>
We get an error saying that&#160;&#160;Display&#160;&#160;is required but not implemented:<br/>
https://doc.rust-lang.org/book/print.html<br/>
534/627<br/>
<hr/>
<a name=535></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;traits-example&#160;v0.1.0&#160;(file:///projects/traits-example)<br/>error[E0277]:&#160;`Point`&#160;doesn't&#160;implement&#160;`std::fmt::Display`<br/>&#160;&#160;--&gt;&#160;src/main.rs:20:6<br/>&#160;&#160;&#160;|<br/>20&#160;|&#160;impl&#160;OutlinePrint&#160;for&#160;Point&#160;{}<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^&#160;`Point`&#160;cannot&#160;be&#160;formatted&#160;with&#160;the&#160;default&#160;formatter<br/>&#160;&#160;&#160;|<br/>&#160;&#160;&#160;=&#160;help:&#160;the&#160;trait&#160;`std::fmt::Display`&#160;is&#160;not&#160;implemented&#160;for&#160;`Point`<br/>&#160;&#160;&#160;=&#160;note:&#160;in&#160;format&#160;strings&#160;you&#160;may&#160;be&#160;able&#160;to&#160;use&#160;`{:?}`&#160;(or&#160;{:#?}&#160;for&#160;<br/>pretty-print)&#160;instead<br/>note:&#160;required&#160;by&#160;a&#160;bound&#160;in&#160;`OutlinePrint`<br/>&#160;&#160;--&gt;&#160;src/main.rs:3:21<br/>&#160;&#160;&#160;|<br/>3&#160;&#160;|&#160;trait&#160;OutlinePrint:&#160;fmt::Display&#160;{<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^&#160;required&#160;by&#160;this&#160;bound&#160;in&#160;`OutlinePrint`<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0277`.<br/>error:&#160;could&#160;not&#160;compile&#160;`traits-example`&#160;due&#160;to&#160;previous&#160;error<br/>
To&#160;ﬁx this, we implement&#160;&#160;Display&#160;&#160;on&#160;&#160;Point&#160;&#160;and satisfy the constraint that&#160;&#160;OutlinePrint<br/>requires, like so:<br/>
Filename: src/main.rs<br/>
use&#160;std::fmt;<br/>
impl&#160;fmt::Display&#160;for&#160;Point&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;fmt(&amp;self,&#160;f:&#160;&amp;mut&#160;fmt::Formatter)&#160;-&gt;&#160;fmt::Result&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;write!(f,&#160;&#34;({},&#160;{})&#34;,&#160;self.x,&#160;self.y)<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
Then implementing the&#160;&#160;OutlinePrint&#160;&#160;trait on&#160;&#160;Point&#160;&#160;will compile successfully, and we can<br/>call&#160;&#160;outline_print&#160;&#160;on a&#160;&#160;Point&#160;&#160;instance to display it within an outline of asterisks.<br/>
<a href="tests.html#535"><b>Using&#160;the&#160;Newtype&#160;Pattern&#160;to&#160;Implement&#160;External&#160;Traits&#160;on&#160;External</b></a><br/>
<a href="tests.html#535"><b>Types</b></a><br/>
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type">In Chapter 10 in the&#160;“Implementing a Trait on a Type”&#160;section, we mentioned the orphan<br/></a>rule that states we’re only allowed to implement a trait on a type if either the trait or the<br/>type are local to our crate. It’s possible to get around this restriction using the&#160;<i>newtype<br/>pattern</i>, which involves creating a new type in a tuple struct. (We covered tuple structs in the<br/><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">“Using Tuple Structs without Named Fields to Create Diﬀerent Types”</a>&#160;section of Chapter 5.)<br/>The tuple struct will have one&#160;ﬁeld and be a thin wrapper around the type we want to<br/>implement a trait for. Then the wrapper type is local to our crate, and we can implement the<br/>trait on the wrapper.&#160;<i>Newtype</i>&#160;is a term that originates from the Haskell programming<br/>language. There is no runtime performance penalty for using this pattern, and the wrapper<br/>type is elided at compile time.<br/>
https://doc.rust-lang.org/book/print.html<br/>
535/627<br/>
<hr/>
<a name=536></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
As an example, let’s say we want to implement&#160;&#160;Display&#160;&#160;on&#160;&#160;Vec&lt;T&gt;&#160;, which the orphan rule<br/>prevents us from doing directly because the&#160;&#160;Display&#160;&#160;trait and the&#160;&#160;Vec&lt;T&gt;&#160;&#160;type are deﬁned<br/>outside our crate. We can make a&#160;&#160;Wrapper&#160;&#160;struct that holds an instance of&#160;&#160;Vec&lt;T&gt;&#160;; then we<br/>can implement&#160;&#160;Display&#160;&#160;on&#160;&#160;Wrapper&#160;&#160;and use the&#160;&#160;Vec&lt;T&gt;&#160;&#160;value, as shown in Listing 19-23.<br/>
Filename: src/main.rs<br/>
use&#160;std::fmt;<br/>
struct&#160;Wrapper(Vec&lt;String&gt;);<br/>
impl&#160;fmt::Display&#160;for&#160;Wrapper&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;fmt(&amp;self,&#160;f:&#160;&amp;mut&#160;fmt::Formatter)&#160;-&gt;&#160;fmt::Result&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;write!(f,&#160;&#34;[{}]&#34;,&#160;self.0.join(&#34;,&#160;&#34;))<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;w&#160;=&#160;Wrapper(vec![String::from(&#34;hello&#34;),&#160;String::from(&#34;world&#34;)]);<br/>&#160;&#160;&#160;&#160;println!(&#34;w&#160;=&#160;{}&#34;,&#160;w);<br/>}<br/>
<b>Listing&#160;19-23:&#160;Creating&#160;a&#160;&#160;</b>Wrapper&#160;<b>&#160;type&#160;around&#160;&#160;</b>Vec&lt;String&gt;&#160;<b>&#160;to&#160;implement&#160;&#160;</b>Display<br/>
The implementation of&#160;&#160;Display&#160;&#160;uses&#160;&#160;self.0&#160;&#160;to access the inner&#160;&#160;Vec&lt;T&gt;&#160;, because<br/>
Wrapper&#160;&#160;is a tuple struct and&#160;&#160;Vec&lt;T&gt;&#160;&#160;is the item at index 0 in the tuple. Then we can use<br/>
the functionality of the&#160;&#160;Display&#160;&#160;type on&#160;&#160;Wrapper&#160;.<br/>
The downside of using this technique is that&#160;&#160;Wrapper&#160;&#160;is a new type, so it doesn’t have the<br/>methods of the value it’s holding. We would have to implement all the methods of&#160;&#160;Vec&lt;T&gt;<br/>directly on&#160;&#160;Wrapper&#160;&#160;such that the methods delegate to&#160;&#160;self.0&#160;, which would allow us to<br/>treat&#160;&#160;Wrapper&#160;&#160;exactly like a&#160;&#160;Vec&lt;T&gt;&#160;. If we wanted the new type to have every method the<br/><a href="https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">inner type has, implementing the&#160;&#160;Deref&#160;&#160;trait (discussed in Chapter 15 in the&#160;“Treating<br/>Smart Pointers Like Regular References with the&#160;&#160;Deref&#160;&#160;Trait”&#160;section) on the&#160;&#160;Wrapper&#160;</a>&#160;to<br/>return the inner type would be a solution. If we don’t want the&#160;&#160;Wrapper&#160;&#160;type to have all the<br/>methods of the inner type—for example, to restrict the&#160;&#160;Wrapper&#160;&#160;type’s behavior—we would<br/>have to implement just the methods we do want manually.<br/>
This newtype pattern is also useful even when traits are not involved. Let’s switch focus and<br/>look at some advanced ways to interact with Rust’s type system.<br/>
https://doc.rust-lang.org/book/print.html<br/>
536/627<br/>
<hr/>
<a name=537></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#537"><b>Advanced Types</b></a><br/>
The Rust type system has some features that we’ve so far mentioned but haven’t yet<br/>discussed. We’ll start by discussing newtypes in general as we examine why newtypes are<br/>useful as types. Then we’ll move on to type aliases, a feature similar to newtypes but with<br/>slightly diﬀerent semantics. We’ll also discuss the&#160;&#160;!&#160;&#160;type and dynamically sized types.<br/>
<a href="tests.html#537"><b>Using&#160;the&#160;Newtype&#160;Pattern&#160;for&#160;Type&#160;Safety&#160;and&#160;Abstraction</b></a><br/>
<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">Note: This section assumes you’ve read the earlier section&#160;“Using the Newtype Pattern<br/>to Implement External Traits on External Types.”</a><br/>
The newtype pattern is also useful for tasks beyond those we’ve discussed so far, including<br/>statically enforcing that values are never confused and indicating the units of a value. You<br/>saw an example of using newtypes to indicate units in Listing 19-15: recall that the<br/>
Millimeters&#160;&#160;and&#160;&#160;Meters&#160;&#160;structs wrapped&#160;&#160;u32&#160;&#160;values in a newtype. If we wrote a function<br/>
with a parameter of type&#160;&#160;Millimeters&#160;, we couldn’t compile a program that accidentally<br/>tried to call that function with a value of type&#160;&#160;Meters&#160;&#160;or a plain&#160;&#160;u32&#160;.<br/>
We can also use the newtype pattern to abstract away some implementation details of a<br/>type: the new type can expose a public API that is diﬀerent from the API of the private inner<br/>type.<br/>
Newtypes can also hide internal implementation. For example, we could provide a&#160;&#160;People<br/>type to wrap a&#160;&#160;HashMap&lt;i32,&#160;String&gt;&#160;&#160;that stores a person’s ID associated with their name.<br/>Code using&#160;&#160;People&#160;&#160;would only interact with the public API we provide, such as a method to<br/>add a name string to the&#160;&#160;People&#160;&#160;collection; that code wouldn’t need to know that we assign<br/>an&#160;&#160;i32&#160;&#160;ID to names internally. The newtype pattern is a lightweight way to achieve<br/><a href="https://doc.rust-lang.org/book/ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details">encapsulation to hide implementation details, which we discussed in the&#160;“Encapsulation<br/>that Hides Implementation Details”&#160;section of Chapter 17.</a><br/>
<a href="tests.html#537"><b>Creating&#160;Type&#160;Synonyms&#160;with&#160;Type&#160;Aliases</b></a><br/>
Rust provides the ability to declare a&#160;<i>type alias</i>&#160;to give an existing type another name. For<br/>this we use the&#160;&#160;type&#160;&#160;keyword. For example, we can create the alias&#160;&#160;Kilometers&#160;&#160;to&#160;&#160;i32<br/>like so:<br/>
&#160;&#160;&#160;&#160;type&#160;Kilometers&#160;=&#160;i32;<br/>
https://doc.rust-lang.org/book/print.html<br/>
537/627<br/>
<hr/>
<a name=538></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Now, the alias&#160;&#160;Kilometers&#160;&#160;is a&#160;<i>synonym</i>&#160;for&#160;&#160;i32&#160;; unlike the&#160;&#160;Millimeters&#160;&#160;and&#160;&#160;Meters<br/>types we created in Listing 19-15,&#160;&#160;Kilometers&#160;&#160;is not a separate, new type. Values that have<br/>the type&#160;&#160;Kilometers&#160;&#160;will be treated the same as values of type&#160;&#160;i32&#160;:<br/>
&#160;&#160;&#160;&#160;type&#160;Kilometers&#160;=&#160;i32;<br/>
&#160;&#160;&#160;&#160;let&#160;x:&#160;i32&#160;=&#160;5;<br/>&#160;&#160;&#160;&#160;let&#160;y:&#160;Kilometers&#160;=&#160;5;<br/>
&#160;&#160;&#160;&#160;println!(&#34;x&#160;+&#160;y&#160;=&#160;{}&#34;,&#160;x&#160;+&#160;y);<br/>
Because&#160;&#160;Kilometers&#160;&#160;and&#160;&#160;i32&#160;&#160;are the same type, we can add values of both types and we<br/>can pass&#160;&#160;Kilometers&#160;&#160;values to functions that take&#160;&#160;i32&#160;&#160;parameters. However, using this<br/>method, we don’t get the type checking beneﬁts that we get from the newtype pattern<br/>discussed earlier. In other words, if we mix up&#160;&#160;Kilometers&#160;&#160;and&#160;&#160;i32&#160;&#160;values somewhere, the<br/>compiler will not give us an error.<br/>
The main use case for type synonyms is to reduce repetition. For example, we might have a<br/>lengthy type like this:<br/>
Box&lt;dyn&#160;Fn()&#160;+&#160;Send&#160;+&#160;'static&gt;<br/>
Writing this lengthy type in function signatures and as type annotations all over the code<br/>can be tiresome and error prone. Imagine having a project full of code like that in Listing 19-<br/>24.<br/>
&#160;&#160;&#160;&#160;let&#160;f:&#160;Box&lt;dyn&#160;Fn()&#160;+&#160;Send&#160;+&#160;'static&gt;&#160;=&#160;Box::new(||&#160;println!(&#34;hi&#34;));<br/>
&#160;&#160;&#160;&#160;fn&#160;takes_long_type(f:&#160;Box&lt;dyn&#160;Fn()&#160;+&#160;Send&#160;+&#160;'static&gt;)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;fn&#160;returns_long_type()&#160;-&gt;&#160;Box&lt;dyn&#160;Fn()&#160;+&#160;Send&#160;+&#160;'static&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;19-24:&#160;Using&#160;a&#160;long&#160;type&#160;in&#160;many&#160;places</b><br/>
A type alias makes this code more manageable by reducing the repetition. In Listing 19-25,<br/>we’ve introduced an alias named&#160;&#160;Thunk&#160;&#160;for the verbose type and can replace all uses of the<br/>type with the shorter alias&#160;&#160;Thunk&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
538/627<br/>
<hr/>
<a name=539></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;type&#160;Thunk&#160;=&#160;Box&lt;dyn&#160;Fn()&#160;+&#160;Send&#160;+&#160;'static&gt;;<br/>
&#160;&#160;&#160;&#160;let&#160;f:&#160;Thunk&#160;=&#160;Box::new(||&#160;println!(&#34;hi&#34;));<br/>
&#160;&#160;&#160;&#160;fn&#160;takes_long_type(f:&#160;Thunk)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;fn&#160;returns_long_type()&#160;-&gt;&#160;Thunk&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;19-25:&#160;Introducing&#160;a&#160;type&#160;alias&#160;&#160;</b>Thunk&#160;<b>&#160;to&#160;reduce&#160;repetition</b><br/>
This code is much easier to read and write! Choosing a meaningful name for a type alias can<br/>help communicate your intent as well (<i>thunk</i>&#160;is a word for code to be evaluated at a later<br/>time, so it’s an appropriate name for a closure that gets stored).<br/>
Type aliases are also commonly used with the&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;type for reducing repetition.<br/>Consider the&#160;&#160;std::io&#160;&#160;module in the standard library. I/O operations often return a<br/>
Result&lt;T,&#160;E&gt;&#160;&#160;to handle situations when operations fail to work. This library has a<br/>std::io::Error&#160;&#160;struct that represents all possible I/O errors. Many of the functions in<br/>std::io&#160;&#160;will be returning&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;where the&#160;&#160;E&#160;&#160;is&#160;&#160;std::io::Error&#160;, such as these<br/>
functions in the&#160;&#160;Write&#160;&#160;trait:<br/>
use&#160;std::fmt;<br/>use&#160;std::io::Error;<br/>
pub&#160;trait&#160;Write&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;write(&amp;mut&#160;self,&#160;buf:&#160;&amp;[u8])&#160;-&gt;&#160;Result&lt;usize,&#160;Error&gt;;<br/>&#160;&#160;&#160;&#160;fn&#160;flush(&amp;mut&#160;self)&#160;-&gt;&#160;Result&lt;(),&#160;Error&gt;;<br/>
&#160;&#160;&#160;&#160;fn&#160;write_all(&amp;mut&#160;self,&#160;buf:&#160;&amp;[u8])&#160;-&gt;&#160;Result&lt;(),&#160;Error&gt;;<br/>&#160;&#160;&#160;&#160;fn&#160;write_fmt(&amp;mut&#160;self,&#160;fmt:&#160;fmt::Arguments)&#160;-&gt;&#160;Result&lt;(),&#160;Error&gt;;<br/>}<br/>
The&#160;&#160;Result&lt;...,&#160;Error&gt;&#160;&#160;is repeated a lot. As such,&#160;&#160;std::io&#160;&#160;has this type alias declaration:<br/>
type&#160;Result&lt;T&gt;&#160;=&#160;std::result::Result&lt;T,&#160;std::io::Error&gt;;<br/>
Because this declaration is in the&#160;&#160;std::io&#160;&#160;module, we can use the fully qualiﬁed alias<br/>
std::io::Result&lt;T&gt;&#160;; that is, a&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;with the&#160;&#160;E&#160;&#160;ﬁlled in as&#160;&#160;std::io::Error&#160;. The<br/>Write&#160;&#160;trait function signatures end up looking like this:<br/>
https://doc.rust-lang.org/book/print.html<br/>
539/627<br/>
<hr/>
<a name=540></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;trait&#160;Write&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;write(&amp;mut&#160;self,&#160;buf:&#160;&amp;[u8])&#160;-&gt;&#160;Result&lt;usize&gt;;<br/>&#160;&#160;&#160;&#160;fn&#160;flush(&amp;mut&#160;self)&#160;-&gt;&#160;Result&lt;()&gt;;<br/>
&#160;&#160;&#160;&#160;fn&#160;write_all(&amp;mut&#160;self,&#160;buf:&#160;&amp;[u8])&#160;-&gt;&#160;Result&lt;()&gt;;<br/>&#160;&#160;&#160;&#160;fn&#160;write_fmt(&amp;mut&#160;self,&#160;fmt:&#160;fmt::Arguments)&#160;-&gt;&#160;Result&lt;()&gt;;<br/>}<br/>
The type alias helps in two ways: it makes code easier to write&#160;<i>and</i>&#160;it gives us a consistent<br/>interface across all of&#160;&#160;std::io&#160;. Because it’s an alias, it’s just another&#160;&#160;Result&lt;T,&#160;E&gt;&#160;, which<br/>means we can use any methods that work on&#160;&#160;Result&lt;T,&#160;E&gt;&#160;&#160;with it, as well as special<br/>syntax like the&#160;&#160;?&#160;&#160;operator.<br/>
<a href="tests.html#540"><b>The&#160;Never&#160;Type&#160;that&#160;Never&#160;Returns</b></a><br/>
Rust has a special type named&#160;&#160;!&#160;&#160;that’s known in type theory lingo as the&#160;<i>empty type<br/></i>because it has no values. We prefer to call it the&#160;<i>never type</i>&#160;because it stands in the place of<br/>the return type when a function will never return. Here is an example:<br/>
fn&#160;bar()&#160;-&gt;&#160;!&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
This code is read as “the function&#160;&#160;bar&#160;&#160;returns never.” Functions that return never are called<br/><i>diverging functions</i>. We can’t create values of the type&#160;&#160;!&#160;&#160;so&#160;&#160;bar&#160;&#160;can never possibly return.<br/>
But what use is a type you can never create values for? Recall the code from Listing 2-5, part<br/>of the number guessing game; we’ve reproduced a bit of it here in Listing 19-26.<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;guess:&#160;u32&#160;=&#160;match&#160;guess.trim().parse()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(num)&#160;=&gt;&#160;num,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(_)&#160;=&gt;&#160;continue,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;};<br/>
<b>Listing&#160;19-26:&#160;A&#160;&#160;</b>match&#160;<b>&#160;with&#160;an&#160;arm&#160;that&#160;ends&#160;in&#160;&#160;</b>continue<br/>
<a href="https://doc.rust-lang.org/book/ch06-02-match.html#the-match-control-flow-operator">At the time, we skipped over some details in this code. In Chapter 6 in&#160;“The&#160;&#160;match&#160;&#160;Control<br/>Flow Operator”&#160;section, we discussed that&#160;&#160;match&#160;&#160;arms must all return the same type. So,<br/></a>for example, the following code doesn’t work:<br/>
&#160;&#160;&#160;&#160;let&#160;guess&#160;=&#160;match&#160;guess.trim().parse()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(_)&#160;=&gt;&#160;5,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(_)&#160;=&gt;&#160;&#34;hello&#34;,<br/>&#160;&#160;&#160;&#160;};<br/>
The type of&#160;&#160;guess&#160;&#160;in this code would have to be an integer&#160;<i>and</i>&#160;a string, and Rust requires<br/>that&#160;&#160;guess&#160;&#160;have only one type. So what does&#160;&#160;continue&#160;&#160;return? How were we allowed to<br/>
https://doc.rust-lang.org/book/print.html<br/>
540/627<br/>
<hr/>
<a name=541></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
return a&#160;&#160;u32&#160;&#160;from one arm and have another arm that ends with&#160;&#160;continue&#160;&#160;in Listing 19-<br/>26?<br/>
As you might have guessed,&#160;&#160;continue&#160;&#160;has a&#160;&#160;!&#160;&#160;value. That is, when Rust computes the type<br/>of&#160;&#160;guess&#160;, it looks at both match arms, the former with a value of&#160;&#160;u32&#160;&#160;and the latter with a<br/>
!&#160;&#160;value. Because&#160;&#160;!&#160;&#160;can never have a value, Rust decides that the type of&#160;&#160;guess&#160;&#160;is&#160;&#160;u32&#160;.<br/>
The formal way of describing this behavior is that expressions of type&#160;&#160;!&#160;&#160;can be coerced into<br/>any other type. We’re allowed to end this&#160;&#160;match&#160;&#160;arm with&#160;&#160;continue&#160;&#160;because&#160;&#160;continue<br/>doesn’t return a value; instead, it moves control back to the top of the loop, so in the&#160;&#160;Err<br/>case, we never assign a value to&#160;&#160;guess&#160;.<br/>
The never type is useful with the&#160;&#160;panic!&#160;&#160;macro as well. Recall the&#160;&#160;unwrap&#160;&#160;function that we<br/>call on&#160;&#160;Option&lt;T&gt;&#160;&#160;values to produce a value or panic with this deﬁnition:<br/>
impl&lt;T&gt;&#160;Option&lt;T&gt;&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;unwrap(self)&#160;-&gt;&#160;T&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;self&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Some(val)&#160;=&gt;&#160;val,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;None&#160;=&gt;&#160;panic!(&#34;called&#160;`Option::unwrap()`&#160;on&#160;a&#160;`None`&#160;value&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
In this code, the same thing happens as in the&#160;&#160;match&#160;&#160;in Listing 19-26: Rust sees that&#160;&#160;val<br/>has the type&#160;&#160;T&#160;&#160;and&#160;&#160;panic!&#160;&#160;has the type&#160;&#160;!&#160;, so the result of the overall&#160;&#160;match&#160;&#160;expression is<br/>
T&#160;. This code works because&#160;&#160;panic!&#160;&#160;doesn’t produce a value; it ends the program. In the<br/>None&#160;&#160;case, we won’t be returning a value from&#160;&#160;unwrap&#160;, so this code is valid.<br/>
One&#160;ﬁnal expression that has the type&#160;&#160;!&#160;&#160;is a&#160;&#160;loop&#160;:<br/>
&#160;&#160;&#160;&#160;print!(&#34;forever&#160;&#34;);<br/>
&#160;&#160;&#160;&#160;loop&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print!(&#34;and&#160;ever&#160;&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>
Here, the loop never ends, so&#160;&#160;!&#160;&#160;is the value of the expression. However, this wouldn’t be<br/>true if we included a&#160;&#160;break&#160;, because the loop would terminate when it got to the&#160;&#160;break&#160;.<br/>
<a href="tests.html#541"><b>Dynamically&#160;Sized&#160;Types&#160;and&#160;the&#160;</b>Sized<b>&#160;Trait</b></a><br/>
Rust needs to know certain details about its types, such as how much space to allocate for a<br/>value of a particular type. This leaves one corner of its type system a little confusing at&#160;ﬁrst:<br/>the concept of&#160;<i>dynamically sized types</i>. Sometimes referred to as&#160;<i>DSTs</i>&#160;or&#160;<i>unsized types</i>, these<br/>types let us write code using values whose size we can know only at runtime.<br/>
https://doc.rust-lang.org/book/print.html<br/>
541/627<br/>
<hr/>
<a name=542></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Let’s dig into the details of a dynamically sized type called&#160;&#160;str&#160;, which we’ve been using<br/>throughout the book. That’s right, not&#160;&#160;&amp;str&#160;, but&#160;&#160;str&#160;&#160;on its own, is a DST. We can’t know<br/>how long the string is until runtime, meaning we can’t create a variable of type&#160;&#160;str&#160;, nor can<br/>we take an argument of type&#160;&#160;str&#160;. Consider the following code, which does not work:<br/>
&#160;&#160;&#160;&#160;let&#160;s1:&#160;str&#160;=&#160;&#34;Hello&#160;there!&#34;;<br/>&#160;&#160;&#160;&#160;let&#160;s2:&#160;str&#160;=&#160;&#34;How's&#160;it&#160;going?&#34;;<br/>
Rust needs to know how much memory to allocate for any value of a particular type, and all<br/>values of a type must use the same amount of memory. If Rust allowed us to write this<br/>code, these two&#160;&#160;str&#160;&#160;values would need to take up the same amount of space. But they<br/>have diﬀerent lengths:&#160;&#160;s1&#160;&#160;needs 12 bytes of storage and&#160;&#160;s2&#160;&#160;needs 15. This is why it’s not<br/>possible to create a variable holding a dynamically sized type.<br/>
So what do we do? In this case, you already know the answer: we make the types of&#160;&#160;s1&#160;&#160;and<br/>
s2&#160;&#160;a&#160;&#160;&amp;str&#160;&#160;rather than a&#160;&#160;str&#160;<a href="https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices">. Recall from the&#160;“String Slices”</a>&#160;section of Chapter 4 that the<br/>
slice data structure just stores the starting position and the length of the slice. So although a<br/>
&amp;T&#160;&#160;is a single value that stores the memory address of where the&#160;&#160;T&#160;&#160;is located, a&#160;&#160;&amp;str&#160;&#160;is<br/>
<i>two</i>&#160;values: the address of the&#160;&#160;str&#160;&#160;and its length. As such, we can know the size of a&#160;&#160;&amp;str<br/>value at compile time: it’s twice the length of a&#160;&#160;usize&#160;. That is, we always know the size of a<br/>
&amp;str&#160;, no matter how long the string it refers to is. In general, this is the way in which<br/>
dynamically sized types are used in Rust: they have an extra bit of metadata that stores the<br/>size of the dynamic information. The golden rule of dynamically sized types is that we must<br/>always put values of dynamically sized types behind a pointer of some kind.<br/>
We can combine&#160;&#160;str&#160;&#160;with all kinds of pointers: for example,&#160;&#160;Box&lt;str&gt;&#160;&#160;or&#160;&#160;Rc&lt;str&gt;&#160;. In fact,<br/>you’ve seen this before but with a diﬀerent dynamically sized type: traits. Every trait is a<br/>dynamically sized type we can refer to by using the name of the trait. In Chapter 17 in the<br/><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Using Trait Objects That Allow for Values of Diﬀerent Types”&#160;section, we mentioned that to<br/></a>use traits as trait objects, we must put them behind a pointer, such as&#160;&#160;&amp;dyn&#160;Trait&#160;&#160;or<br/>
Box&lt;dyn&#160;Trait&gt;&#160;&#160;(&#160;Rc&lt;dyn&#160;Trait&gt;&#160;&#160;would work too).<br/>
To work with DSTs, Rust provides the&#160;&#160;Sized&#160;&#160;trait to determine whether or not a type’s size<br/>is known at compile time. This trait is automatically implemented for everything whose size<br/>is known at compile time. In addition, Rust implicitly adds a bound on&#160;&#160;Sized&#160;&#160;to every<br/>generic function. That is, a generic function deﬁnition like this:<br/>
fn&#160;generic&lt;T&gt;(t:&#160;T)&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
is actually treated as though we had written this:<br/>
https://doc.rust-lang.org/book/print.html<br/>
542/627<br/>
<hr/>
<a name=543></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;generic&lt;T:&#160;Sized&gt;(t:&#160;T)&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
By default, generic functions will work only on types that have a known size at compile time.<br/>However, you can use the following special syntax to relax this restriction:<br/>
fn&#160;generic&lt;T:&#160;?Sized&gt;(t:&#160;&amp;T)&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
A trait bound on&#160;&#160;?Sized&#160;&#160;means “&#160;T&#160;&#160;may or may not be&#160;&#160;Sized&#160;” and this notation overrides<br/>the default that generic types must have a known size at compile time. The&#160;&#160;?Trait&#160;&#160;syntax<br/>with this meaning is only available for&#160;&#160;Sized&#160;, not any other traits.<br/>
Also note that we switched the type of the&#160;&#160;t&#160;&#160;parameter from&#160;&#160;T&#160;&#160;to&#160;&#160;&amp;T&#160;. Because the type<br/>might not be&#160;&#160;Sized&#160;, we need to use it behind some kind of pointer. In this case, we’ve<br/>chosen a reference.<br/>
Next, we’ll talk about functions and closures!<br/>
https://doc.rust-lang.org/book/print.html<br/>
543/627<br/>
<hr/>
<a name=544></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#544"><b>Advanced Functions and Closures</b></a><br/>
This section explores some advanced features related to functions and closures, including<br/>function pointers and returning closures.<br/>
<a href="tests.html#544"><b>Function&#160;Pointers</b></a><br/>
We’ve talked about how to pass closures to functions; you can also pass regular functions to<br/>functions! This technique is useful when you want to pass a function you’ve already deﬁned<br/>rather than deﬁning a new closure. Functions coerce to the type&#160;&#160;fn&#160;&#160;(with a lowercase f), not<br/>to be confused with the&#160;&#160;Fn&#160;&#160;closure trait. The&#160;&#160;fn&#160;&#160;type is called a&#160;<i>function pointer</i>. Passing<br/>functions with function pointers will allow you to use functions as arguments to other<br/>functions.<br/>
The syntax for specifying that a parameter is a function pointer is similar to that of closures,<br/>as shown in Listing 19-27, where we’ve deﬁned a function&#160;&#160;add_one&#160;&#160;that adds one to its<br/>parameter. The function&#160;&#160;do_twice&#160;&#160;takes two parameters: a function pointer to any function<br/>that takes an&#160;&#160;i32&#160;&#160;parameter and returns an&#160;&#160;i32&#160;, and one&#160;&#160;i32&#160;value&#160;. The&#160;&#160;do_twice<br/>function calls the function&#160;&#160;f&#160;&#160;twice, passing it the&#160;&#160;arg&#160;&#160;value, then adds the two function call<br/>results together. The&#160;&#160;main&#160;&#160;function calls&#160;&#160;do_twice&#160;&#160;with the arguments&#160;&#160;add_one&#160;&#160;and&#160;&#160;5&#160;.<br/>
Filename: src/main.rs<br/>
fn&#160;add_one(x:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;x&#160;+&#160;1<br/>}<br/>
fn&#160;do_twice(f:&#160;fn(i32)&#160;-&gt;&#160;i32,&#160;arg:&#160;i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;f(arg)&#160;+&#160;f(arg)<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;answer&#160;=&#160;do_twice(add_one,&#160;5);<br/>
&#160;&#160;&#160;&#160;println!(&#34;The&#160;answer&#160;is:&#160;{}&#34;,&#160;answer);<br/>}<br/>
<b>Listing&#160;19-27:&#160;Using&#160;the&#160;&#160;</b>fn&#160;<b>&#160;type&#160;to&#160;accept&#160;a&#160;function&#160;pointer&#160;as&#160;an&#160;argument</b><br/>
This code prints&#160;&#160;The&#160;answer&#160;is:&#160;12&#160;. We specify that the parameter&#160;&#160;f&#160;&#160;in&#160;&#160;do_twice&#160;&#160;is an<br/>
fn&#160;&#160;that takes one parameter of type&#160;&#160;i32&#160;&#160;and returns an&#160;&#160;i32&#160;. We can then call&#160;&#160;f&#160;&#160;in the<br/>
body of&#160;&#160;do_twice&#160;. In&#160;&#160;main&#160;, we can pass the function name&#160;&#160;add_one&#160;&#160;as the&#160;ﬁrst argument<br/>to&#160;&#160;do_twice&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
544/627<br/>
<hr/>
<a name=545></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Unlike closures,&#160;&#160;fn&#160;&#160;is a type rather than a trait, so we specify&#160;&#160;fn&#160;&#160;as the parameter type<br/>directly rather than declaring a generic type parameter with one of the&#160;&#160;Fn&#160;&#160;traits as a trait<br/>bound.<br/>
Function pointers implement all three of the closure traits (&#160;Fn&#160;,&#160;&#160;FnMut&#160;, and&#160;&#160;FnOnce&#160;),<br/>meaning you can always pass a function pointer as an argument for a function that expects<br/>a closure. It’s best to write functions using a generic type and one of the closure traits so<br/>your functions can accept either functions or closures.<br/>
That said, one example of where you would want to only accept&#160;&#160;fn&#160;&#160;and not closures is<br/>when interfacing with external code that doesn’t have closures: C functions can accept<br/>functions as arguments, but C doesn’t have closures.<br/>
As an example of where you could use either a closure deﬁned inline or a named function,<br/>let’s look at a use of the&#160;&#160;map&#160;&#160;method provided by the&#160;&#160;Iterator&#160;&#160;trait in the standard library.<br/>To use the&#160;&#160;map&#160;&#160;function to turn a vector of numbers into a vector of strings, we could use a<br/>closure, like this:<br/>
&#160;&#160;&#160;&#160;let&#160;list_of_numbers&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>&#160;&#160;&#160;&#160;let&#160;list_of_strings:&#160;Vec&lt;String&gt;&#160;=<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;list_of_numbers.iter().map(|i|&#160;i.to_string()).collect();<br/>
Or we could name a function as the argument to&#160;&#160;map&#160;&#160;instead of the closure, like this:<br/>
&#160;&#160;&#160;&#160;let&#160;list_of_numbers&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>&#160;&#160;&#160;&#160;let&#160;list_of_strings:&#160;Vec&lt;String&gt;&#160;=<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;list_of_numbers.iter().map(ToString::to_string).collect();<br/>
Note that we must use the fully qualiﬁed syntax that we talked about earlier in the<br/><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#advanced-traits">“Advanced Traits”&#160;section because there are multiple functions available named&#160;&#160;</a>to_string&#160;.<br/>Here, we’re using the&#160;&#160;to_string&#160;&#160;function deﬁned in the&#160;&#160;ToString&#160;&#160;trait, which the standard<br/>library has implemented for any type that implements&#160;&#160;Display&#160;.<br/>
Recall from the&#160;<a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#enum-values">“Enum values”</a>&#160;section of Chapter 6 that the name of each enum variant that<br/>we deﬁne also becomes an initializer function. We can use these initializer functions as<br/>function pointers that implement the closure traits, which means we can specify the<br/>initializer functions as arguments for methods that take closures, like so:<br/>
&#160;&#160;&#160;&#160;enum&#160;Status&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Value(u32),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Stop,<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;let&#160;list_of_statuses:&#160;Vec&lt;Status&gt;&#160;=&#160;<br/>(0u32..20).map(Status::Value).collect();<br/>
Here we create&#160;&#160;Status::Value&#160;&#160;instances using each&#160;&#160;u32&#160;&#160;value in the range that&#160;&#160;map&#160;&#160;is<br/>called on by using the initializer function of&#160;&#160;Status::Value&#160;. Some people prefer this style,<br/>
https://doc.rust-lang.org/book/print.html<br/>
545/627<br/>
<hr/>
<a name=546></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
and some people prefer to use closures. They compile to the same code, so use whichever<br/>style is clearer to you.<br/>
<a href="tests.html#546"><b>Returning&#160;Closures</b></a><br/>
Closures are represented by traits, which means you can’t return closures directly. In most<br/>cases where you might want to return a trait, you can instead use the concrete type that<br/>implements the trait as the return value of the function. However, you can’t do that with<br/>closures because they don’t have a concrete type that is returnable; you’re not allowed to<br/>use the function pointer&#160;&#160;fn&#160;&#160;as a return type, for example.<br/>
The following code tries to return a closure directly, but it won’t compile:<br/>
fn&#160;returns_closure()&#160;-&gt;&#160;dyn&#160;Fn(i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;&#160;&#160;|x|&#160;x&#160;+&#160;1<br/>}<br/>
The compiler error is as follows:<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;Compiling&#160;functions-example&#160;v0.1.0&#160;(file:///projects/functions-example)<br/>error[E0746]:&#160;return&#160;type&#160;cannot&#160;have&#160;an&#160;unboxed&#160;trait&#160;object<br/>&#160;--&gt;&#160;src/lib.rs:1:25<br/>&#160;&#160;|<br/>1&#160;|&#160;fn&#160;returns_closure()&#160;-&gt;&#160;dyn&#160;Fn(i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^^^&#160;doesn't&#160;have&#160;a&#160;size&#160;known&#160;at&#160;<br/>compile-time<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;for&#160;information&#160;on&#160;`impl&#160;Trait`,&#160;see&#160;&lt;https://doc.rust-<br/>lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits&gt;<br/>help:&#160;use&#160;`impl&#160;Fn(i32)&#160;-&gt;&#160;i32`&#160;as&#160;the&#160;return&#160;type,&#160;as&#160;all&#160;return&#160;paths&#160;are&#160;of&#160;<br/>type&#160;`[closure@src/lib.rs:2:5:&#160;2:8]`,&#160;which&#160;implements&#160;`Fn(i32)&#160;-&gt;&#160;i32`<br/>&#160;&#160;|<br/>1&#160;|&#160;fn&#160;returns_closure()&#160;-&gt;&#160;impl&#160;Fn(i32)&#160;-&gt;&#160;i32&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;~~~~~~~~~~~~~~~~~~~<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0746`.<br/>error:&#160;could&#160;not&#160;compile&#160;`functions-example`&#160;due&#160;to&#160;previous&#160;error<br/>
The error references the&#160;&#160;Sized&#160;&#160;trait again! Rust doesn’t know how much space it will need<br/>to store the closure. We saw a solution to this problem earlier. We can use a trait object:<br/>
fn&#160;returns_closure()&#160;-&gt;&#160;Box&lt;dyn&#160;Fn(i32)&#160;-&gt;&#160;i32&gt;&#160;{<br/>&#160;&#160;&#160;&#160;Box::new(|x|&#160;x&#160;+&#160;1)<br/>}<br/>
<a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">This code will compile just&#160;ﬁne. For more about trait objects, refer to the section&#160;“Using Trait<br/>Objects That Allow for Values of Diﬀerent Types”&#160;in Chapter 17.</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
546/627<br/>
<hr/>
<a name=547></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Next, let’s look at macros!<br/>
https://doc.rust-lang.org/book/print.html<br/>
547/627<br/>
<hr/>
<a name=548></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#548"><b>Macros</b></a><br/>
We’ve used macros like&#160;&#160;println!&#160;&#160;throughout this book, but we haven’t fully explored what<br/>a macro is and how it works. The term&#160;<i>macro</i>&#160;refers to a family of features in Rust:<br/><i>declarative</i>&#160;macros with&#160;&#160;macro_rules!&#160;&#160;and three kinds of&#160;<i>procedural</i>&#160;macros:<br/>
Custom&#160;&#160;#[derive]&#160;&#160;macros that specify code added with the&#160;&#160;derive&#160;&#160;attribute used<br/>on structs and enums<br/>Attribute-like macros that deﬁne custom attributes usable on any item<br/>Function-like macros that look like function calls but operate on the tokens speciﬁed as<br/>their argument<br/>
We’ll talk about each of these in turn, but&#160;ﬁrst, let’s look at why we even need macros when<br/>we already have functions.<br/>
<a href="tests.html#548"><b>The&#160;Diﬀerence&#160;Between&#160;Macros&#160;and&#160;Functions</b></a><br/>
Fundamentally, macros are a way of writing code that writes other code, which is known as<br/><i>metaprogramming</i>. In Appendix C, we discuss the&#160;&#160;derive&#160;&#160;attribute, which generates an<br/>implementation of various traits for you. We’ve also used the&#160;&#160;println!&#160;&#160;and&#160;&#160;vec!&#160;&#160;macros<br/>throughout the book. All of these macros&#160;<i>expand</i>&#160;to produce more code than the code<br/>you’ve written manually.<br/>
Metaprogramming is useful for reducing the amount of code you have to write and<br/>maintain, which is also one of the roles of functions. However, macros have some additional<br/>powers that functions don’t.<br/>
A function signature must declare the number and type of parameters the function has.<br/>Macros, on the other hand, can take a variable number of parameters: we can call&#160;&#160;println!<br/>(&#34;hello&#34;)&#160;&#160;with one argument or&#160;&#160;println!(&#34;hello&#160;{}&#34;,&#160;name)&#160;&#160;with two arguments. Also,<br/>macros are expanded before the compiler interprets the meaning of the code, so a macro<br/>can, for example, implement a trait on a given type. A function can’t, because it gets called at<br/>runtime and a trait needs to be implemented at compile time.<br/>
The downside to implementing a macro instead of a function is that macro deﬁnitions are<br/>more complex than function deﬁnitions because you’re writing Rust code that writes Rust<br/>code. Due to this indirection, macro deﬁnitions are generally more diﬃcult to read,<br/>understand, and maintain than function deﬁnitions.<br/>
Another important diﬀerence between macros and functions is that you must deﬁne<br/>macros or bring them into scope&#160;<i>before</i>&#160;you call them in a&#160;ﬁle, as opposed to functions you<br/>can deﬁne anywhere and call anywhere.<br/>
https://doc.rust-lang.org/book/print.html<br/>
548/627<br/>
<hr/>
<a name=549></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#549"><b>Declarative&#160;Macros&#160;with&#160;</b>macro_rules!<b>&#160;for&#160;General&#160;Metaprogramming</b></a><br/>
The most widely used form of macros in Rust is the&#160;<i>declarative macro</i>. These are also<br/>sometimes referred to as “macros by example,” “&#160;macro_rules!&#160;&#160;macros,” or just plain<br/>“macros.” At their core, declarative macros allow you to write something similar to a Rust<br/>
match&#160;&#160;expression. As discussed in Chapter 6,&#160;&#160;match&#160;&#160;expressions are control structures that<br/>
take an expression, compare the resulting value of the expression to patterns, and then run<br/>the code associated with the matching pattern. Macros also compare a value to patterns<br/>that are associated with particular code: in this situation, the value is the literal Rust source<br/>code passed to the macro; the patterns are compared with the structure of that source<br/>code; and the code associated with each pattern, when matched, replaces the code passed<br/>to the macro. This all happens during compilation.<br/>
To deﬁne a macro, you use the&#160;&#160;macro_rules!&#160;&#160;construct. Let’s explore how to use<br/>
macro_rules!&#160;&#160;by looking at how the&#160;&#160;vec!&#160;&#160;macro is deﬁned. Chapter 8 covered how we can<br/>
use the&#160;&#160;vec!&#160;&#160;macro to create a new vector with particular values. For example, the<br/>following macro creates a new vector containing three integers:<br/>
let&#160;v:&#160;Vec&lt;u32&gt;&#160;=&#160;vec![1,&#160;2,&#160;3];<br/>
We could also use the&#160;&#160;vec!&#160;&#160;macro to make a vector of two integers or a vector of&#160;ﬁve string<br/>slices. We wouldn’t be able to use a function to do the same because we wouldn’t know the<br/>number or type of values up front.<br/>
Listing 19-28 shows a slightly simpliﬁed deﬁnition of the&#160;&#160;vec!&#160;&#160;macro.<br/>
Filename: src/lib.rs<br/>
#[macro_export]<br/>macro_rules!&#160;vec&#160;{<br/>&#160;&#160;&#160;&#160;(&#160;$(&#160;$x:expr&#160;),*&#160;)&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;temp_vec&#160;=&#160;Vec::new();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;$(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp_vec.push($x);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;)*<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;temp_vec<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;};<br/>}<br/>
<b>Listing&#160;19-28:&#160;A&#160;simpliﬁed&#160;version&#160;of&#160;the&#160;&#160;</b>vec!&#160;<b>&#160;macro&#160;deﬁnition</b><br/>
Note: The actual deﬁnition of the&#160;&#160;vec!&#160;&#160;macro in the standard library includes code to<br/>preallocate the correct amount of memory up front. That code is an optimization that<br/>we don’t include here to make the example simpler.<br/>
https://doc.rust-lang.org/book/print.html<br/>
549/627<br/>
<hr/>
<a name=550></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The&#160;&#160;#[macro_export]&#160;&#160;annotation indicates that this macro should be made available<br/>whenever the crate in which the macro is deﬁned is brought into scope. Without this<br/>annotation, the macro can’t be brought into scope.<br/>
We then start the macro deﬁnition with&#160;&#160;macro_rules!&#160;&#160;and the name of the macro we’re<br/>deﬁning&#160;<i>without</i>&#160;the exclamation mark. The name, in this case&#160;&#160;vec&#160;, is followed by curly<br/>brackets denoting the body of the macro deﬁnition.<br/>
The structure in the&#160;&#160;vec!&#160;&#160;body is similar to the structure of a&#160;&#160;match&#160;&#160;expression. Here we<br/>have one arm with the pattern&#160;&#160;(&#160;$(&#160;$x:expr&#160;),*&#160;)&#160;, followed by&#160;&#160;=&gt;&#160;&#160;and the block of code<br/>associated with this pattern. If the pattern matches, the associated block of code will be<br/>emitted. Given that this is the only pattern in this macro, there is only one valid way to<br/>match; any other pattern will result in an error. More complex macros will have more than<br/>one arm.<br/>
Valid pattern syntax in macro deﬁnitions is diﬀerent than the pattern syntax covered in<br/>Chapter 18 because macro patterns are matched against Rust code structure rather than<br/>values. Let’s walk through what the pattern pieces in Listing 19-28 mean; for the full macro<br/><a href="https://doc.rust-lang.org/reference/macros-by-example.html">pattern syntax, see the&#160;Rust Reference</a>.<br/>
First, we use a set of parentheses to encompass the whole pattern. We use a dollar sign (&#160;$&#160;)<br/>to declare a variable in the macro system that will contain the Rust code matching the<br/>pattern. The dollar sign makes it clear this is a macro variable as opposed to a regular Rust<br/>variable. Next comes a set of parentheses that captures values that match the pattern<br/>within the parentheses for use in the replacement code. Within&#160;&#160;$()&#160;&#160;is&#160;&#160;$x:expr&#160;, which<br/>matches any Rust expression and gives the expression the name&#160;&#160;$x&#160;.<br/>
The comma following&#160;&#160;$()&#160;&#160;indicates that a literal comma separator character could<br/>optionally appear after the code that matches the code in&#160;&#160;$()&#160;. The&#160;&#160;*&#160;&#160;speciﬁes that the<br/>pattern matches zero or more of whatever precedes the&#160;&#160;*&#160;.<br/>
When we call this macro with&#160;&#160;vec![1,&#160;2,&#160;3];&#160;, the&#160;&#160;$x&#160;&#160;pattern matches three times with<br/>the three expressions&#160;&#160;1&#160;,&#160;&#160;2&#160;, and&#160;&#160;3&#160;.<br/>
Now let’s look at the pattern in the body of the code associated with this arm:<br/>
temp_vec.push()&#160;&#160;within&#160;&#160;$()*&#160;&#160;is generated for each part that matches&#160;&#160;$()&#160;&#160;in the pattern<br/>
zero or more times depending on how many times the pattern matches. The&#160;&#160;$x&#160;&#160;is replaced<br/>with each expression matched. When we call this macro with&#160;&#160;vec![1,&#160;2,&#160;3];&#160;, the code<br/>generated that replaces this macro call will be the following:<br/>
https://doc.rust-lang.org/book/print.html<br/>
550/627<br/>
<hr/>
<a name=551></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;temp_vec&#160;=&#160;Vec::new();<br/>&#160;&#160;&#160;&#160;temp_vec.push(1);<br/>&#160;&#160;&#160;&#160;temp_vec.push(2);<br/>&#160;&#160;&#160;&#160;temp_vec.push(3);<br/>&#160;&#160;&#160;&#160;temp_vec<br/>}<br/>
We’ve deﬁned a macro that can take any number of arguments of any type and can<br/>generate code to create a vector containing the speciﬁed elements.<br/>
To learn more about how to write macros, consult the online documentation or other<br/><a href="https://veykril.github.io/tlborm/">resources, such as&#160;“The Little Book of Rust Macros”</a>&#160;started by Daniel Keep and continued by<br/>Lukas Wirth.<br/>
<a href="tests.html#551"><b>Procedural&#160;Macros&#160;for&#160;Generating&#160;Code&#160;from&#160;Attributes</b></a><br/>
The second form of macros is the&#160;<i>procedural macro</i>, which acts more like a function (and is a<br/>type of procedure). Procedural macros accept some code as an input, operate on that code,<br/>and produce some code as an output rather than matching against patterns and replacing<br/>the code with other code as declarative macros do. The three kinds of procedural macros<br/>are custom derive, attribute-like, and function-like, and all work in a similar fashion.<br/>
When creating procedural macros, the deﬁnitions must reside in their own crate with a<br/>special crate type. This is for complex technical reasons that we hope to eliminate in the<br/>future. In Listing 19-29, we show how to deﬁne a procedural macro, where&#160;&#160;some_attribute<br/>is a placeholder for using a speciﬁc macro variety.<br/>
Filename: src/lib.rs<br/>
use&#160;proc_macro;<br/>
#[some_attribute]<br/>pub&#160;fn&#160;some_name(input:&#160;TokenStream)&#160;-&gt;&#160;TokenStream&#160;{<br/>}<br/>
<b>Listing&#160;19-29:&#160;An&#160;example&#160;of&#160;deﬁning&#160;a&#160;procedural&#160;macro</b><br/>
The function that deﬁnes a procedural macro takes a&#160;&#160;TokenStream&#160;&#160;as an input and<br/>produces a&#160;&#160;TokenStream&#160;&#160;as an output. The&#160;&#160;TokenStream&#160;&#160;type is deﬁned by the<br/>
proc_macro&#160;&#160;crate that is included with Rust and represents a sequence of tokens. This is<br/>
the core of the macro: the source code that the macro is operating on makes up the input<br/>
TokenStream&#160;, and the code the macro produces is the output&#160;&#160;TokenStream&#160;. The function<br/>
also has an attribute attached to it that speciﬁes which kind of procedural macro we’re<br/>creating. We can have multiple kinds of procedural macros in the same crate.<br/>
https://doc.rust-lang.org/book/print.html<br/>
551/627<br/>
<hr/>
<a name=552></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Let’s look at the diﬀerent kinds of procedural macros. We’ll start with a custom derive macro<br/>and then explain the small dissimilarities that make the other forms diﬀerent.<br/>
<a href="tests.html#552"><b>How&#160;to&#160;Write&#160;a&#160;Custom&#160;</b>derive<b>&#160;Macro</b></a><br/>
Let’s create a crate named&#160;&#160;hello_macro&#160;&#160;that deﬁnes a trait named&#160;&#160;HelloMacro&#160;&#160;with one<br/>associated function named&#160;&#160;hello_macro&#160;. Rather than making our users implement the<br/>
HelloMacro&#160;&#160;trait for each of their types, we’ll provide a procedural macro so users can<br/>
annotate their type with&#160;&#160;#[derive(HelloMacro)]&#160;&#160;to get a default implementation of the<br/>
hello_macro&#160;&#160;function. The default implementation will print&#160;&#160;Hello,&#160;Macro!&#160;My&#160;name&#160;is&#160;<br/>
TypeName!&#160;&#160;where&#160;&#160;TypeName&#160;&#160;is the name of the type on which this trait has been deﬁned. In<br/>other words, we’ll write a crate that enables another programmer to write code like Listing<br/>19-30 using our crate.<br/>
Filename: src/main.rs<br/>
use&#160;hello_macro::HelloMacro;<br/>use&#160;hello_macro_derive::HelloMacro;<br/>
#[derive(HelloMacro)]<br/>struct&#160;Pancakes;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;Pancakes::hello_macro();<br/>}<br/>
<b>Listing&#160;19-30:&#160;The&#160;code&#160;a&#160;user&#160;of&#160;our&#160;crate&#160;will&#160;be&#160;able&#160;to&#160;write&#160;when&#160;using&#160;our&#160;procedural&#160;macro</b><br/>
This code will print&#160;&#160;Hello,&#160;Macro!&#160;My&#160;name&#160;is&#160;Pancakes!&#160;&#160;when we’re done. The&#160;ﬁrst step<br/>is to make a new library crate, like this:<br/>
$&#160;cargo&#160;new&#160;hello_macro&#160;--lib<br/>
Next, we’ll deﬁne the&#160;&#160;HelloMacro&#160;&#160;trait and its associated function:<br/>
Filename: src/lib.rs<br/>
pub&#160;trait&#160;HelloMacro&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;hello_macro();<br/>}<br/>
We have a trait and its function. At this point, our crate user could implement the trait to<br/>achieve the desired functionality, like so:<br/>
https://doc.rust-lang.org/book/print.html<br/>
552/627<br/>
<hr/>
<a name=553></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;hello_macro::HelloMacro;<br/>
struct&#160;Pancakes;<br/>
impl&#160;HelloMacro&#160;for&#160;Pancakes&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;hello_macro()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Hello,&#160;Macro!&#160;My&#160;name&#160;is&#160;Pancakes!&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;Pancakes::hello_macro();<br/>}<br/>
However, they would need to write the implementation block for each type they wanted to<br/>use with&#160;&#160;hello_macro&#160;; we want to spare them from having to do this work.<br/>
Additionally, we can’t yet provide the&#160;&#160;hello_macro&#160;&#160;function with default implementation<br/>that will print the name of the type the trait is implemented on: Rust doesn’t have reﬂection<br/>capabilities, so it can’t look up the type’s name at runtime. We need a macro to generate<br/>code at compile time.<br/>
The next step is to deﬁne the procedural macro. At the time of this writing, procedural<br/>macros need to be in their own crate. Eventually, this restriction might be lifted. The<br/>convention for structuring crates and macro crates is as follows: for a crate named&#160;&#160;foo&#160;, a<br/>custom derive procedural macro crate is called&#160;&#160;foo_derive&#160;. Let’s start a new crate called<br/>
hello_macro_derive&#160;&#160;inside our&#160;&#160;hello_macro&#160;&#160;project:<br/>
$&#160;cargo&#160;new&#160;hello_macro_derive&#160;--lib<br/>
Our two crates are tightly related, so we create the procedural macro crate within the<br/>directory of our&#160;&#160;hello_macro&#160;&#160;crate. If we change the trait deﬁnition in&#160;&#160;hello_macro&#160;, we’ll<br/>have to change the implementation of the procedural macro in&#160;&#160;hello_macro_derive&#160;&#160;as<br/>well. The two crates will need to be published separately, and programmers using these<br/>crates will need to add both as dependencies and bring them both into scope. We could<br/>instead have the&#160;&#160;hello_macro&#160;&#160;crate use&#160;&#160;hello_macro_derive&#160;&#160;as a dependency and re-<br/>export the procedural macro code. However, the way we’ve structured the project makes it<br/>possible for programmers to use&#160;&#160;hello_macro&#160;&#160;even if they don’t want the&#160;&#160;derive<br/>functionality.<br/>
We need to declare the&#160;&#160;hello_macro_derive&#160;&#160;crate as a procedural macro crate. We’ll also<br/>need functionality from the&#160;&#160;syn&#160;&#160;and&#160;&#160;quote&#160;&#160;crates, as you’ll see in a moment, so we need to<br/>add them as dependencies. Add the following to the&#160;<i>Cargo.toml</i>&#160;ﬁle for<br/>
hello_macro_derive&#160;:<br/>
Filename: hello_macro_derive/Cargo.toml<br/>
https://doc.rust-lang.org/book/print.html<br/>
553/627<br/>
<hr/>
<a name=554></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
[lib]<br/>proc-macro&#160;=&#160;true<br/>
[dependencies]<br/>syn&#160;=&#160;&#34;1.0&#34;<br/>quote&#160;=&#160;&#34;1.0&#34;<br/>
To start deﬁning the procedural macro, place the code in Listing 19-31 into your&#160;<i>src/lib.rs</i>&#160;ﬁle<br/>for the&#160;&#160;hello_macro_derive&#160;&#160;crate. Note that this code won’t compile until we add a<br/>deﬁnition for the&#160;&#160;impl_hello_macro&#160;&#160;function.<br/>
Filename: hello_macro_derive/src/lib.rs<br/>
use&#160;proc_macro::TokenStream;<br/>use&#160;quote::quote;<br/>use&#160;syn;<br/>
#[proc_macro_derive(HelloMacro)]<br/>pub&#160;fn&#160;hello_macro_derive(input:&#160;TokenStream)&#160;-&gt;&#160;TokenStream&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;Construct&#160;a&#160;representation&#160;of&#160;Rust&#160;code&#160;as&#160;a&#160;syntax&#160;tree<br/>&#160;&#160;&#160;&#160;//&#160;that&#160;we&#160;can&#160;manipulate<br/>&#160;&#160;&#160;&#160;let&#160;ast&#160;=&#160;syn::parse(input).unwrap();<br/>
&#160;&#160;&#160;&#160;//&#160;Build&#160;the&#160;trait&#160;implementation<br/>&#160;&#160;&#160;&#160;impl_hello_macro(&amp;ast)<br/>}<br/>
<b>Listing&#160;19-31:&#160;Code&#160;that&#160;most&#160;procedural&#160;macro&#160;crates&#160;will&#160;require&#160;in&#160;order&#160;to&#160;process&#160;Rust&#160;code</b><br/>
Notice that we’ve split the code into the&#160;&#160;hello_macro_derive&#160;&#160;function, which is responsible<br/>for parsing the&#160;&#160;TokenStream&#160;, and the&#160;&#160;impl_hello_macro&#160;&#160;function, which is responsible for<br/>transforming the syntax tree: this makes writing a procedural macro more convenient. The<br/>code in the outer function (&#160;hello_macro_derive&#160;&#160;in this case) will be the same for almost<br/>every procedural macro crate you see or create. The code you specify in the body of the<br/>inner function (&#160;impl_hello_macro&#160;&#160;in this case) will be diﬀerent depending on your<br/>procedural macro’s purpose.<br/>
We’ve introduced three new crates:&#160;&#160;proc_macro&#160;<a href="https://crates.io/crates/syn">,&#160;&#160;syn&#160;, and&#160;&#160;</a><a href="https://crates.io/crates/quote">quote&#160;</a>. The&#160;&#160;proc_macro&#160;&#160;crate<br/>comes with Rust, so we didn’t need to add that to the dependencies in&#160;<i>Cargo.toml</i>. The<br/>
proc_macro&#160;&#160;crate is the compiler’s API that allows us to read and manipulate Rust code<br/>
from our code.<br/>
The&#160;&#160;syn&#160;&#160;crate parses Rust code from a string into a data structure that we can perform<br/>operations on. The&#160;&#160;quote&#160;&#160;crate turns&#160;&#160;syn&#160;&#160;data structures back into Rust code. These<br/>crates make it much simpler to parse any sort of Rust code we might want to handle: writing<br/>a full parser for Rust code is no simple task.<br/>
The&#160;&#160;hello_macro_derive&#160;&#160;function will be called when a user of our library speciﬁes&#160;&#160;#<br/>[derive(HelloMacro)]&#160;&#160;on a type. This is possible because we’ve annotated the<br/>
https://doc.rust-lang.org/book/print.html<br/>
554/627<br/>
<hr/>
<a name=555></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
hello_macro_derive&#160;&#160;function here with&#160;&#160;proc_macro_derive&#160;&#160;and speciﬁed the name<br/>HelloMacro&#160;, which matches our trait name; this is the convention most procedural macros<br/>
follow.<br/>
The&#160;&#160;hello_macro_derive&#160;&#160;function&#160;ﬁrst converts the&#160;&#160;input&#160;&#160;from a&#160;&#160;TokenStream&#160;&#160;to a data<br/>structure that we can then interpret and perform operations on. This is where&#160;&#160;syn&#160;&#160;comes<br/>into play. The&#160;&#160;parse&#160;&#160;function in&#160;&#160;syn&#160;&#160;takes a&#160;&#160;TokenStream&#160;&#160;and returns a&#160;&#160;DeriveInput<br/>struct representing the parsed Rust code. Listing 19-32 shows the relevant parts of the<br/>
DeriveInput&#160;&#160;struct we get from parsing the&#160;&#160;struct&#160;Pancakes;&#160;&#160;string:<br/>
DeriveInput&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;ident:&#160;Ident&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ident:&#160;&#34;Pancakes&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;span:&#160;#0&#160;bytes(95..103)<br/>&#160;&#160;&#160;&#160;},<br/>&#160;&#160;&#160;&#160;data:&#160;Struct(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;DataStruct&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;struct_token:&#160;Struct,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fields:&#160;Unit,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;semi_token:&#160;Some(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Semi<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;)<br/>}<br/>
<b>Listing&#160;19-32:&#160;The&#160;&#160;</b>DeriveInput&#160;<b>&#160;instance&#160;we&#160;get&#160;when&#160;parsing&#160;the&#160;code&#160;that&#160;has&#160;the&#160;macro’s&#160;attribute&#160;in&#160;Listing<br/>19-30</b><br/>
The&#160;ﬁelds of this struct show that the Rust code we’ve parsed is a unit struct with the&#160;&#160;ident<br/>(identiﬁer, meaning the name) of&#160;&#160;Pancakes&#160;. There are more&#160;ﬁelds on this struct for<br/>describing all sorts of Rust code; check the&#160;&#160;<a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html">syn&#160;&#160;documentation for&#160;&#160;DeriveInput&#160;</a>&#160;for more<br/>information.<br/>
Soon we’ll deﬁne the&#160;&#160;impl_hello_macro&#160;&#160;function, which is where we’ll build the new Rust<br/>code we want to include. But before we do, note that the output for our derive macro is also<br/>a&#160;&#160;TokenStream&#160;. The returned&#160;&#160;TokenStream&#160;&#160;is added to the code that our crate users write,<br/>so when they compile their crate, they’ll get the extra functionality that we provide in the<br/>modiﬁed&#160;&#160;TokenStream&#160;.<br/>
You might have noticed that we’re calling&#160;&#160;unwrap&#160;&#160;to cause the&#160;&#160;hello_macro_derive<br/>function to panic if the call to the&#160;&#160;syn::parse&#160;&#160;function fails here. It’s necessary for our<br/>procedural macro to panic on errors because&#160;&#160;proc_macro_derive&#160;&#160;functions must return<br/>
TokenStream&#160;&#160;rather than&#160;&#160;Result&#160;&#160;to conform to the procedural macro API. We’ve simpliﬁed<br/>
this example by using&#160;&#160;unwrap&#160;; in production code, you should provide more speciﬁc error<br/>messages about what went wrong by using&#160;&#160;panic!&#160;&#160;or&#160;&#160;expect&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
555/627<br/>
<hr/>
<a name=556></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Now that we have the code to turn the annotated Rust code from a&#160;&#160;TokenStream&#160;&#160;into a<br/>
DeriveInput&#160;&#160;instance, let’s generate the code that implements the&#160;&#160;HelloMacro&#160;&#160;trait on the<br/>
annotated type, as shown in Listing 19-33.<br/>
Filename: hello_macro_derive/src/lib.rs<br/>
fn&#160;impl_hello_macro(ast:&#160;&amp;syn::DeriveInput)&#160;-&gt;&#160;TokenStream&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;name&#160;=&#160;&amp;ast.ident;<br/>&#160;&#160;&#160;&#160;let&#160;gen&#160;=&#160;quote!&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;impl&#160;HelloMacro&#160;for&#160;#name&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fn&#160;hello_macro()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Hello,&#160;Macro!&#160;My&#160;name&#160;is&#160;{}!&#34;,&#160;stringify!(#name));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;};<br/>&#160;&#160;&#160;&#160;gen.into()<br/>}<br/>
<b>Listing&#160;19-33:&#160;Implementing&#160;the&#160;&#160;</b>HelloMacro&#160;<b>&#160;trait&#160;using&#160;the&#160;parsed&#160;Rust&#160;code</b><br/>
We get an&#160;&#160;Ident&#160;&#160;struct instance containing the name (identiﬁer) of the annotated type<br/>using&#160;&#160;ast.ident&#160;. The struct in Listing 19-32 shows that when we run the<br/>
impl_hello_macro&#160;&#160;function on the code in Listing 19-30, the&#160;&#160;ident&#160;&#160;we get will have the<br/>ident&#160;&#160;ﬁeld with a value of&#160;&#160;&#34;Pancakes&#34;&#160;. Thus, the&#160;&#160;name&#160;&#160;variable in Listing 19-33 will<br/>
contain an&#160;&#160;Ident&#160;&#160;struct instance that, when printed, will be the string&#160;&#160;&#34;Pancakes&#34;&#160;, the<br/>name of the struct in Listing 19-30.<br/>
The&#160;&#160;quote!&#160;&#160;macro lets us deﬁne the Rust code that we want to return. The compiler<br/>expects something diﬀerent to the direct result of the&#160;&#160;quote!&#160;&#160;macro’s execution, so we<br/>need to convert it to a&#160;&#160;TokenStream&#160;. We do this by calling the&#160;&#160;into&#160;&#160;method, which<br/>consumes this intermediate representation and returns a value of the required<br/>
TokenStream&#160;&#160;type.<br/>
The&#160;&#160;quote!&#160;&#160;macro also provides some very cool templating mechanics: we can enter<br/>
#name&#160;, and&#160;&#160;quote!&#160;&#160;will replace it with the value in the variable&#160;&#160;name&#160;. You can even do<br/>
<a href="https://docs.rs/quote">some repetition similar to the way regular macros work. Check out&#160;the&#160;&#160;quote&#160;&#160;crate’s docs<br/></a>for a thorough introduction.<br/>
We want our procedural macro to generate an implementation of our&#160;&#160;HelloMacro&#160;&#160;trait for<br/>the type the user annotated, which we can get by using&#160;&#160;#name&#160;. The trait implementation<br/>has the one function&#160;&#160;hello_macro&#160;, whose body contains the functionality we want to<br/>provide: printing&#160;&#160;Hello,&#160;Macro!&#160;My&#160;name&#160;is&#160;&#160;and then the name of the annotated type.<br/>
The&#160;&#160;stringify!&#160;&#160;macro used here is built into Rust. It takes a Rust expression, such as&#160;&#160;1&#160;+&#160;<br/>2&#160;, and at compile time turns the expression into a string literal, such as&#160;&#160;&#34;1&#160;+&#160;2&#34;&#160;. This is<br/>diﬀerent than&#160;&#160;format!&#160;&#160;or&#160;&#160;println!&#160;, macros which evaluate the expression and then turn<br/>the result into a&#160;&#160;String&#160;. There is a possibility that the&#160;&#160;#name&#160;&#160;input might be an expression<br/>
https://doc.rust-lang.org/book/print.html<br/>
556/627<br/>
<hr/>
<a name=557></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
to print literally, so we use&#160;&#160;stringify!&#160;. Using&#160;&#160;stringify!&#160;&#160;also saves an allocation by<br/>converting&#160;&#160;#name&#160;&#160;to a string literal at compile time.<br/>
At this point,&#160;&#160;cargo&#160;build&#160;&#160;should complete successfully in both&#160;&#160;hello_macro&#160;&#160;and<br/>
hello_macro_derive&#160;. Let’s hook up these crates to the code in Listing 19-30 to see the<br/>
procedural macro in action! Create a new binary project in your&#160;<i>projects</i>&#160;directory using<br/>
cargo&#160;new&#160;pancakes&#160;. We need to add&#160;&#160;hello_macro&#160;&#160;and&#160;&#160;hello_macro_derive&#160;&#160;as<br/>
dependencies in the&#160;&#160;pancakes&#160;&#160;crate’s&#160;<i>Cargo.toml</i>. If you’re publishing your versions of<br/>
hello_macro&#160;&#160;and&#160;&#160;hello_macro_derive&#160;&#160;to&#160;<a href="https://crates.io/">crates.io, they would be regular dependencies; if</a><br/>
not, you can specify them as&#160;&#160;path&#160;&#160;dependencies as follows:<br/>
hello_macro&#160;=&#160;{&#160;path&#160;=&#160;&#34;../hello_macro&#34;&#160;}<br/>hello_macro_derive&#160;=&#160;{&#160;path&#160;=&#160;&#34;../hello_macro/hello_macro_derive&#34;&#160;}<br/>
Put the code in Listing 19-30 into&#160;<i>src/main.rs</i>, and run&#160;&#160;cargo&#160;run&#160;: it should print&#160;&#160;Hello,&#160;<br/>Macro!&#160;My&#160;name&#160;is&#160;Pancakes!&#160;&#160;The implementation of the&#160;&#160;HelloMacro&#160;&#160;trait from the<br/>procedural macro was included without the&#160;&#160;pancakes&#160;&#160;crate needing to implement it; the&#160;&#160;#<br/>[derive(HelloMacro)]&#160;&#160;added the trait implementation.<br/>
Next, let’s explore how the other kinds of procedural macros diﬀer from custom derive<br/>macros.<br/>
<a href="tests.html#557"><b>Attribute-like&#160;macros</b></a><br/>
Attribute-like macros are similar to custom derive macros, but instead of generating code<br/>for the&#160;&#160;derive&#160;&#160;attribute, they allow you to create new attributes. They’re also more&#160;ﬂexible:<br/>
derive&#160;&#160;only works for structs and enums; attributes can be applied to other items as well,<br/>
such as functions. Here’s an example of using an attribute-like macro: say you have an<br/>attribute named&#160;&#160;route&#160;&#160;that annotates functions when using a web application framework:<br/>
#[route(GET,&#160;&#34;/&#34;)]<br/>fn&#160;index()&#160;{<br/>
This&#160;&#160;#[route]&#160;&#160;attribute would be deﬁned by the framework as a procedural macro. The<br/>signature of the macro deﬁnition function would look like this:<br/>
#[proc_macro_attribute]<br/>pub&#160;fn&#160;route(attr:&#160;TokenStream,&#160;item:&#160;TokenStream)&#160;-&gt;&#160;TokenStream&#160;{<br/>
Here, we have two parameters of type&#160;&#160;TokenStream&#160;. The&#160;ﬁrst is for the contents of the<br/>attribute: the&#160;&#160;GET,&#160;&#34;/&#34;&#160;&#160;part. The second is the body of the item the attribute is attached to:<br/>in this case,&#160;&#160;fn&#160;index()&#160;{}&#160;&#160;and the rest of the function’s body.<br/>
https://doc.rust-lang.org/book/print.html<br/>
557/627<br/>
<hr/>
<a name=558></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Other than that, attribute-like macros work the same way as custom derive macros: you<br/>create a crate with the&#160;&#160;proc-macro&#160;&#160;crate type and implement a function that generates the<br/>code you want!<br/>
<a href="tests.html#558"><b>Function-like&#160;macros</b></a><br/>
Function-like macros deﬁne macros that look like function calls. Similarly to&#160;&#160;macro_rules!<br/>macros, they’re more&#160;ﬂexible than functions; for example, they can take an unknown<br/>number of arguments. However,&#160;&#160;macro_rules!&#160;&#160;macros can be deﬁned only using the<br/><a href="https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">match-like syntax we discussed in the section&#160;“Declarative Macros with&#160;&#160;macro_rules!&#160;&#160;for<br/>General Metaprogramming”&#160;earlier. Function-like macros take a&#160;&#160;TokenStream&#160;&#160;parameter<br/></a>and their deﬁnition manipulates that&#160;&#160;TokenStream&#160;&#160;using Rust code as the other two types<br/>of procedural macros do. An example of a function-like macro is an&#160;&#160;sql!&#160;&#160;macro that might<br/>be called like so:<br/>
let&#160;sql&#160;=&#160;sql!(SELECT&#160;*&#160;FROM&#160;posts&#160;WHERE&#160;id=1);<br/>
This macro would parse the SQL statement inside it and check that it’s syntactically correct,<br/>which is much more complex processing than a&#160;&#160;macro_rules!&#160;&#160;macro can do. The&#160;&#160;sql!<br/>macro would be deﬁned like this:<br/>
#[proc_macro]<br/>pub&#160;fn&#160;sql(input:&#160;TokenStream)&#160;-&gt;&#160;TokenStream&#160;{<br/>
This deﬁnition is similar to the custom derive macro’s signature: we receive the tokens that<br/>are inside the parentheses and return the code we wanted to generate.<br/>
<a href="tests.html#558"><b>Summary</b></a><br/>
Whew! Now you have some Rust features in your toolbox that you likely won’t use often, but<br/>you’ll know they’re available in very particular circumstances. We’ve introduced several<br/>complex topics so that when you encounter them in error message suggestions or in other<br/>peoples’ code, you’ll be able to recognize these concepts and syntax. Use this chapter as a<br/>reference to guide you to solutions.<br/>
Next, we’ll put everything we’ve discussed throughout the book into practice and do one<br/>more project!<br/>
https://doc.rust-lang.org/book/print.html<br/>
558/627<br/>
<hr/>
<a name=559></a><img src="test-559_1.png"/><br/>
14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#559"><b>Final Project: Building a Multithreaded<br/>Web Server</b></a><br/>
It’s been a long journey, but we’ve reached the end of the book. In this chapter, we’ll build<br/>one more project together to demonstrate some of the concepts we covered in the&#160;ﬁnal<br/>chapters, as well as recap some earlier lessons.<br/>
For our&#160;ﬁnal project, we’ll make a web server that says “hello” and looks like Figure 20-1 in a<br/>web browser.<br/>
<b>Figure&#160;20-1:&#160;Our&#160;ﬁnal&#160;shared&#160;project</b><br/>
Here is our plan for building the web server:<br/>
1.&#160;Learn a bit about TCP and HTTP.<br/>2.&#160;Listen for TCP connections on a socket.<br/>3.&#160;Parse a small number of HTTP requests.<br/>4.&#160;Create a proper HTTP response.<br/>5.&#160;Improve the throughput of our server with a thread pool.<br/>
Before we get started, we should mention one detail: the method we’ll use won’t be the best<br/>way to build a web server with Rust. Community members have published a number of<br/><a href="https://crates.io/">production-ready crates available on&#160;crates.io</a>&#160;that provide more complete web server and<br/>thread pool implementations than we’ll build. However, our intention in this chapter is to<br/>help you learn, not to take the easy route. Because Rust is a systems programming<br/>language, we can choose the level of abstraction we want to work with and can go to a<br/>lower level than is possible or practical in other languages. We’ll therefore write the basic<br/>HTTP server and thread pool manually so you can learn the general ideas and techniques<br/>behind the crates you might use in the future.<br/>
https://doc.rust-lang.org/book/print.html<br/>
559/627<br/>
<hr/>
<a name=560></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#560"><b>Building a Single-Threaded Web Server</b></a><br/>
We’ll start by getting a single-threaded web server working. Before we begin, let’s look at a<br/>quick overview of the protocols involved in building web servers. The details of these<br/>protocols are beyond the scope of this book, but a brief overview will give you the<br/>information you need.<br/>
The two main protocols involved in web servers are&#160;<i>Hypertext Transfer Protocol</i>&#160;<i>(HTTP)</i>&#160;and<br/><i>Transmission Control Protocol</i>&#160;<i>(TCP)</i>. Both protocols are&#160;<i>request-response</i>&#160;protocols, meaning a<br/><i>client</i>&#160;initiates requests and a&#160;<i>server</i>&#160;listens to the requests and provides a response to the<br/>client. The contents of those requests and responses are deﬁned by the protocols.<br/>
TCP is the lower-level protocol that describes the details of how information gets from one<br/>server to another but doesn’t specify what that information is. HTTP builds on top of TCP by<br/>deﬁning the contents of the requests and responses. It’s technically possible to use HTTP<br/>with other protocols, but in the vast majority of cases, HTTP sends its data over TCP. We’ll<br/>work with the raw bytes of TCP and HTTP requests and responses.<br/>
<a href="tests.html#560"><b>Listening&#160;to&#160;the&#160;TCP&#160;Connection</b></a><br/>
Our web server needs to listen to a TCP connection, so that’s the&#160;ﬁrst part we’ll work on. The<br/>standard library oﬀers a&#160;&#160;std::net&#160;&#160;module that lets us do this. Let’s make a new project in<br/>the usual fashion:<br/>
$&#160;cargo&#160;new&#160;hello<br/>&#160;&#160;&#160;&#160;&#160;Created&#160;binary&#160;(application)&#160;`hello`&#160;project<br/>$&#160;cd&#160;hello<br/>
Now enter the code in Listing 20-1 in&#160;<i>src/main.rs</i>&#160;to start. This code will listen at the local<br/>address&#160;&#160;127.0.0.1:7878&#160;&#160;for incoming TCP streams. When it gets an incoming stream, it will<br/>print&#160;&#160;Connection&#160;established!&#160;.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
560/627<br/>
<hr/>
<a name=561></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::net::TcpListener;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;listener&#160;=&#160;TcpListener::bind(&#34;127.0.0.1:7878&#34;).unwrap();<br/>
&#160;&#160;&#160;&#160;for&#160;stream&#160;in&#160;listener.incoming()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;stream&#160;=&#160;stream.unwrap();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Connection&#160;established!&#34;);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;20-1:&#160;Listening&#160;for&#160;incoming&#160;streams&#160;and&#160;printing&#160;a&#160;message&#160;when&#160;we&#160;receive&#160;a&#160;stream</b><br/>
Using&#160;&#160;TcpListener&#160;, we can listen for TCP connections at the address&#160;&#160;127.0.0.1:7878&#160;. In<br/>the address, the section before the colon is an IP address representing your computer (this<br/>is the same on every computer and doesn’t represent the authors’ computer speciﬁcally),<br/>and&#160;&#160;7878&#160;&#160;is the port. We’ve chosen this port for two reasons: HTTP isn’t normally accepted<br/>on this port so our server is unlikely to conﬂict with any other web server you might have<br/>running on your machine, and 7878 is&#160;<i>rust</i>&#160;typed on a telephone.<br/>
The&#160;&#160;bind&#160;&#160;function in this scenario works like the&#160;&#160;new&#160;&#160;function in that it will return a new<br/>
TcpListener&#160;&#160;instance. The function is called&#160;&#160;bind&#160;&#160;because, in networking, connecting to a<br/>
port to listen to is known as “binding to a port.”<br/>
The&#160;&#160;bind&#160;&#160;function returns a&#160;&#160;Result&lt;T,&#160;E&gt;&#160;, which indicates that it’s possible for binding to<br/>fail. For example, connecting to port 80 requires administrator privileges (nonadministrators<br/>can listen only on ports higher than 1023), so if we tried to connect to port 80 without being<br/>an administrator, binding wouldn’t work. Binding also wouldn’t work, for example, if we ran<br/>two instances of our program and so had two programs listening to the same port. Because<br/>we’re writing a basic server just for learning purposes, we won’t worry about handling these<br/>kinds of errors; instead, we use&#160;&#160;unwrap&#160;&#160;to stop the program if errors happen.<br/>
The&#160;&#160;incoming&#160;&#160;method on&#160;&#160;TcpListener&#160;&#160;returns an iterator that gives us a sequence of<br/>streams (more speciﬁcally, streams of type&#160;&#160;TcpStream&#160;). A single&#160;<i>stream</i>&#160;represents an open<br/>connection between the client and the server. A&#160;<i>connection</i>&#160;is the name for the full request<br/>and response process in which a client connects to the server, the server generates a<br/>response, and the server closes the connection. As such, we will read from the&#160;&#160;TcpStream<br/>to see what the client sent and then write our response to the stream to send data back to<br/>the client. Overall, this&#160;&#160;for&#160;&#160;loop will process each connection in turn and produce a series<br/>of streams for us to handle.<br/>
For now, our handling of the stream consists of calling&#160;&#160;unwrap&#160;&#160;to terminate our program if<br/>the stream has any errors; if there aren’t any errors, the program prints a message. We’ll<br/>add more functionality for the success case in the next listing. The reason we might receive<br/>errors from the&#160;&#160;incoming&#160;&#160;method when a client connects to the server is that we’re not<br/>actually iterating over connections. Instead, we’re iterating over&#160;<i>connection attempts</i>. The<br/>connection might not be successful for a number of reasons, many of them operating<br/>
https://doc.rust-lang.org/book/print.html<br/>
561/627<br/>
<hr/>
<a name=562></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
system speciﬁc. For example, many operating systems have a limit to the number of<br/>simultaneous open connections they can support; new connection attempts beyond that<br/>number will produce an error until some of the open connections are closed.<br/>
Let’s try running this code! Invoke&#160;&#160;cargo&#160;run&#160;&#160;in the terminal and then load&#160;<i>127.0.0.1:7878</i>&#160;in<br/>a web browser. The browser should show an error message like “Connection reset,”<br/>because the server isn’t currently sending back any data. But when you look at your<br/>terminal, you should see several messages that were printed when the browser connected<br/>to the server!<br/>
&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/hello`<br/>Connection&#160;established!<br/>Connection&#160;established!<br/>Connection&#160;established!<br/>
Sometimes, you’ll see multiple messages printed for one browser request; the reason might<br/>be that the browser is making a request for the page as well as a request for other<br/>resources, like the&#160;<i>favicon.ico</i>&#160;icon that appears in the browser tab.<br/>
It could also be that the browser is trying to connect to the server multiple times because<br/>the server isn’t responding with any data. When&#160;&#160;stream&#160;&#160;goes out of scope and is dropped<br/>at the end of the loop, the connection is closed as part of the&#160;&#160;drop&#160;&#160;implementation.<br/>Browsers sometimes deal with closed connections by retrying, because the problem might<br/>be temporary. The important factor is that we’ve successfully gotten a handle to a TCP<br/>connection!<br/>
Remember to stop the program by pressing&#160;ctrl-c&#160;when you’re done running a particular<br/>version of the code. Then restart the program by invoking the&#160;&#160;cargo&#160;run&#160;&#160;command after<br/>you’ve made each set of code changes to make sure you’re running the newest code.<br/>
<a href="tests.html#562"><b>Reading&#160;the&#160;Request</b></a><br/>
Let’s implement the functionality to read the request from the browser! To separate the<br/>concerns of&#160;ﬁrst getting a connection and then taking some action with the connection, we’ll<br/>start a new function for processing connections. In this new&#160;&#160;handle_connection&#160;&#160;function,<br/>we’ll read data from the TCP stream and print it so we can see the data being sent from the<br/>browser. Change the code to look like Listing 20-2.<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
562/627<br/>
<hr/>
<a name=563></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::{<br/>&#160;&#160;&#160;&#160;io::{prelude::*,&#160;BufReader},<br/>&#160;&#160;&#160;&#160;net::{TcpListener,&#160;TcpStream},<br/>};<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;listener&#160;=&#160;TcpListener::bind(&#34;127.0.0.1:7878&#34;).unwrap();<br/>
&#160;&#160;&#160;&#160;for&#160;stream&#160;in&#160;listener.incoming()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;stream&#160;=&#160;stream.unwrap();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handle_connection(stream);<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
fn&#160;handle_connection(mut&#160;stream:&#160;TcpStream)&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;buf_reader&#160;=&#160;BufReader::new(&amp;mut&#160;stream);<br/>&#160;&#160;&#160;&#160;let&#160;http_request:&#160;Vec&lt;_&gt;&#160;=&#160;buf_reader<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.lines()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.map(|result|&#160;result.unwrap())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.take_while(|line|&#160;!line.is_empty())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.collect();<br/>
&#160;&#160;&#160;&#160;println!(&#34;Request:&#160;{:#?}&#34;,&#160;http_request);<br/>}<br/>
<b>Listing&#160;20-2:&#160;Reading&#160;from&#160;the&#160;&#160;</b>TcpStream&#160;<b>&#160;and&#160;printing&#160;the&#160;data</b><br/>
We bring&#160;&#160;std::io::prelude&#160;&#160;and&#160;&#160;std::io::BufReader&#160;&#160;into scope to get access to traits and<br/>types that let us read from and write to the stream. In the&#160;&#160;for&#160;&#160;loop in the&#160;&#160;main&#160;&#160;function,<br/>instead of printing a message that says we made a connection, we now call the new<br/>
handle_connection&#160;&#160;function and pass the&#160;&#160;stream&#160;&#160;to it.<br/>
In the&#160;&#160;handle_connection&#160;&#160;function, we create a new&#160;&#160;BufReader&#160;&#160;instance that wraps a<br/>mutable reference to the&#160;&#160;stream&#160;.&#160;&#160;BufReader&#160;&#160;adds buﬀering by managing calls to the<br/>
std::io::Read&#160;&#160;trait methods for us.<br/>
We create a variable named&#160;&#160;http_request&#160;&#160;to collect the lines of the request the browser<br/>sends to our server. We indicate that we want to collect these lines in a vector by adding the<br/>
Vec&lt;_&gt;&#160;&#160;type annotation.<br/>
BufReader&#160;&#160;implements the&#160;&#160;std::io::BufRead&#160;&#160;trait, which provides the&#160;&#160;lines&#160;&#160;method.<br/>
The&#160;&#160;lines&#160;&#160;method returns an iterator of&#160;&#160;Result&lt;String,&#160;std::io::Error&gt;&#160;&#160;by splitting the<br/>stream of data whenever it sees a newline byte. To get each&#160;&#160;String&#160;, we map and&#160;&#160;unwrap<br/>each&#160;&#160;Result&#160;. The&#160;&#160;Result&#160;&#160;might be an error if the data isn’t valid UTF-8 or if there was a<br/>problem reading from the stream. Again, a production program should handle these errors<br/>more gracefully, but we’re choosing to stop the program in the error case for simplicity.<br/>
The browser signals the end of an HTTP request by sending two newline characters in a row,<br/>so to get one request from the stream, we take lines until we get a line that is the empty<br/>string. Once we’ve collected the lines into the vector, we’re printing them out using pretty<br/>
https://doc.rust-lang.org/book/print.html<br/>
563/627<br/>
<hr/>
<a name=564></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
debug formatting so we can take a look at the instructions the web browser is sending to<br/>our server.<br/>
Let’s try this code! Start the program and make a request in a web browser again. Note that<br/>we’ll still get an error page in the browser, but our program’s output in the terminal will now<br/>look similar to this:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;hello&#160;v0.1.0&#160;(file:///projects/hello)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.42s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/hello`<br/>Request:&#160;[<br/>&#160;&#160;&#160;&#160;&#34;GET&#160;/&#160;HTTP/1.1&#34;,<br/>&#160;&#160;&#160;&#160;&#34;Host:&#160;127.0.0.1:7878&#34;,<br/>&#160;&#160;&#160;&#160;&#34;User-Agent:&#160;Mozilla/5.0&#160;(Macintosh;&#160;Intel&#160;Mac&#160;OS&#160;X&#160;10.15;&#160;rv:99.0)&#160;<br/>Gecko/20100101&#160;Firefox/99.0&#34;,<br/>&#160;&#160;&#160;&#160;&#34;Accept:&#160;<br/>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*<br/>;q=0.8&#34;,<br/>&#160;&#160;&#160;&#160;&#34;Accept-Language:&#160;en-US,en;q=0.5&#34;,<br/>&#160;&#160;&#160;&#160;&#34;Accept-Encoding:&#160;gzip,&#160;deflate,&#160;br&#34;,<br/>&#160;&#160;&#160;&#160;&#34;DNT:&#160;1&#34;,<br/>&#160;&#160;&#160;&#160;&#34;Connection:&#160;keep-alive&#34;,<br/>&#160;&#160;&#160;&#160;&#34;Upgrade-Insecure-Requests:&#160;1&#34;,<br/>&#160;&#160;&#160;&#160;&#34;Sec-Fetch-Dest:&#160;document&#34;,<br/>&#160;&#160;&#160;&#160;&#34;Sec-Fetch-Mode:&#160;navigate&#34;,<br/>&#160;&#160;&#160;&#160;&#34;Sec-Fetch-Site:&#160;none&#34;,<br/>&#160;&#160;&#160;&#160;&#34;Sec-Fetch-User:&#160;?1&#34;,<br/>&#160;&#160;&#160;&#160;&#34;Cache-Control:&#160;max-age=0&#34;,<br/>]<br/>
Depending on your browser, you might get slightly diﬀerent output. Now that we’re printing<br/>the request data, we can see why we get multiple connections from one browser request by<br/>looking at the path after&#160;&#160;GET&#160;&#160;in the&#160;ﬁrst line of the request. If the repeated connections are<br/>all requesting&#160;<i>/</i>, we know the browser is trying to fetch&#160;<i>/</i>&#160;repeatedly because it’s not getting a<br/>response from our program.<br/>
Let’s break down this request data to understand what the browser is asking of our<br/>program.<br/>
<a href="tests.html#564"><b>A&#160;Closer&#160;Look&#160;at&#160;an&#160;HTTP&#160;Request</b></a><br/>
HTTP is a text-based protocol, and a request takes this format:<br/>
Method&#160;Request-URI&#160;HTTP-Version&#160;CRLF<br/>headers&#160;CRLF<br/>message-body<br/>
The&#160;ﬁrst line is the&#160;<i>request line</i>&#160;that holds information about what the client is requesting.<br/>The&#160;ﬁrst part of the request line indicates the&#160;<i>method</i>&#160;being used, such as&#160;&#160;GET&#160;&#160;or&#160;&#160;POST&#160;,<br/>
https://doc.rust-lang.org/book/print.html<br/>
564/627<br/>
<hr/>
<a name=565></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
which describes how the client is making this request. Our client used a&#160;&#160;GET&#160;&#160;request, which<br/>means it is asking for information.<br/>
The next part of the request line is&#160;<i>/</i>, which indicates the&#160;<i>Uniform Resource Identiﬁer</i>&#160;<i>(URI)</i>&#160;the<br/>client is requesting: a URI is almost, but not quite, the same as a&#160;<i>Uniform Resource Locator<br/>(URL)</i>. The diﬀerence between URIs and URLs isn’t important for our purposes in this<br/>chapter, but the HTTP spec uses the term URI, so we can just mentally substitute URL for<br/>URI here.<br/>
The last part is the HTTP version the client uses, and then the request line ends in a&#160;<i>CRLF<br/>sequence</i>. (CRLF stands for&#160;<i>carriage return</i>&#160;and&#160;<i>line feed</i>, which are terms from the typewriter<br/>days!) The CRLF sequence can also be written as&#160;&#160;\r\n&#160;, where&#160;&#160;\r&#160;&#160;is a carriage return and<br/>
\n&#160;&#160;is a line feed. The CRLF sequence separates the request line from the rest of the request<br/>
data. Note that when the CRLF is printed, we see a new line start rather than&#160;&#160;\r\n&#160;.<br/>
Looking at the request line data we received from running our program so far, we see that<br/>
GET&#160;&#160;is the method,&#160;<i>/</i>&#160;is the request URI, and&#160;&#160;HTTP/1.1&#160;&#160;is the version.<br/>
After the request line, the remaining lines starting from&#160;&#160;Host:&#160;&#160;onward are headers.&#160;&#160;GET<br/>requests have no body.<br/>
Try making a request from a diﬀerent browser or asking for a diﬀerent address, such as<br/><i>127.0.0.1:7878/test</i>, to see how the request data changes.<br/>
Now that we know what the browser is asking for, let’s send back some data!<br/>
<a href="tests.html#565"><b>Writing&#160;a&#160;Response</b></a><br/>
We’re going to implement sending data in response to a client request. Responses have the<br/>following format:<br/>
HTTP-Version&#160;Status-Code&#160;Reason-Phrase&#160;CRLF<br/>headers&#160;CRLF<br/>message-body<br/>
The&#160;ﬁrst line is a&#160;<i>status line</i>&#160;that contains the HTTP version used in the response, a numeric<br/>status code that summarizes the result of the request, and a reason phrase that provides a<br/>text description of the status code. After the CRLF sequence are any headers, another CRLF<br/>sequence, and the body of the response.<br/>
Here is an example response that uses HTTP version 1.1, has a status code of 200, an OK<br/>reason phrase, no headers, and no body:<br/>
HTTP/1.1&#160;200&#160;OK\r\n\r\n<br/>
https://doc.rust-lang.org/book/print.html<br/>
565/627<br/>
<hr/>
<a name=566></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The status code 200 is the standard success response. The text is a tiny successful HTTP<br/>response. Let’s write this to the stream as our response to a successful request! From the<br/>
handle_connection&#160;&#160;function, remove the&#160;&#160;println!&#160;&#160;that was printing the request data and<br/>
replace it with the code in Listing 20-3.<br/>
Filename: src/main.rs<br/>
fn&#160;handle_connection(mut&#160;stream:&#160;TcpStream)&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;buf_reader&#160;=&#160;BufReader::new(&amp;mut&#160;stream);<br/>&#160;&#160;&#160;&#160;let&#160;http_request:&#160;Vec&lt;_&gt;&#160;=&#160;buf_reader<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.lines()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.map(|result|&#160;result.unwrap())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.take_while(|line|&#160;!line.is_empty())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.collect();<br/>
&#160;&#160;&#160;&#160;let&#160;response&#160;=&#160;&#34;HTTP/1.1&#160;200&#160;OK\r\n\r\n&#34;;<br/>
&#160;&#160;&#160;&#160;stream.write_all(response.as_bytes()).unwrap();<br/>}<br/>
<b>Listing&#160;20-3:&#160;Writing&#160;a&#160;tiny&#160;successful&#160;HTTP&#160;response&#160;to&#160;the&#160;stream</b><br/>
The&#160;ﬁrst new line deﬁnes the&#160;&#160;response&#160;&#160;variable that holds the success message’s data.<br/>Then we call&#160;&#160;as_bytes&#160;&#160;on our&#160;&#160;response&#160;&#160;to convert the string data to bytes. The&#160;&#160;write_all<br/>method on&#160;&#160;stream&#160;&#160;takes a&#160;&#160;&amp;[u8]&#160;&#160;and sends those bytes directly down the connection.<br/>Because the&#160;&#160;write_all&#160;&#160;operation could fail, we use&#160;&#160;unwrap&#160;&#160;on any error result as before.<br/>Again, in a real application you would add error handling here.<br/>
With these changes, let’s run our code and make a request. We’re no longer printing any<br/>data to the terminal, so we won’t see any output other than the output from Cargo. When<br/>you load&#160;<i>127.0.0.1:7878</i>&#160;in a web browser, you should get a blank page instead of an error.<br/>You’ve just hand-coded receiving an HTTP request and sending a response!<br/>
<a href="tests.html#566"><b>Returning&#160;Real&#160;HTML</b></a><br/>
Let’s implement the functionality for returning more than a blank page. Create the new&#160;ﬁle<br/><i>hello.html</i>&#160;in the root of your project directory, not in the&#160;<i>src</i>&#160;directory. You can input any<br/>HTML you want; Listing 20-4 shows one possibility.<br/>
Filename: hello.html<br/>
https://doc.rust-lang.org/book/print.html<br/>
566/627<br/>
<hr/>
<a name=567></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&lt;!DOCTYPE&#160;html&gt;<br/>&lt;html&#160;lang=&#34;en&#34;&gt;<br/>&#160;&#160;&lt;head&gt;<br/>&#160;&#160;&#160;&#160;&lt;meta&#160;charset=&#34;utf-8&#34;&gt;<br/>&#160;&#160;&#160;&#160;&lt;title&gt;Hello!&lt;/title&gt;<br/>&#160;&#160;&lt;/head&gt;<br/>&#160;&#160;&lt;body&gt;<br/>&#160;&#160;&#160;&#160;&lt;h1&gt;Hello!&lt;/h1&gt;<br/>&#160;&#160;&#160;&#160;&lt;p&gt;Hi&#160;from&#160;Rust&lt;/p&gt;<br/>&#160;&#160;&lt;/body&gt;<br/>&lt;/html&gt;<br/>
<b>Listing&#160;20-4:&#160;A&#160;sample&#160;HTML&#160;ﬁle&#160;to&#160;return&#160;in&#160;a&#160;response</b><br/>
This is a minimal HTML5 document with a heading and some text. To return this from the<br/>server when a request is received, we’ll modify&#160;&#160;handle_connection&#160;&#160;as shown in Listing 20-5<br/>to read the HTML&#160;ﬁle, add it to the response as a body, and send it.<br/>
Filename: src/main.rs<br/>
use&#160;std::{<br/>&#160;&#160;&#160;&#160;fs,<br/>&#160;&#160;&#160;&#160;io::{prelude::*,&#160;BufReader},<br/>&#160;&#160;&#160;&#160;net::{TcpListener,&#160;TcpStream},<br/>};<br/>//&#160;--snip--<br/>
fn&#160;handle_connection(mut&#160;stream:&#160;TcpStream)&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;buf_reader&#160;=&#160;BufReader::new(&amp;mut&#160;stream);<br/>&#160;&#160;&#160;&#160;let&#160;http_request:&#160;Vec&lt;_&gt;&#160;=&#160;buf_reader<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.lines()<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.map(|result|&#160;result.unwrap())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.take_while(|line|&#160;!line.is_empty())<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.collect();<br/>
&#160;&#160;&#160;&#160;let&#160;status_line&#160;=&#160;&#34;HTTP/1.1&#160;200&#160;OK&#34;;<br/>&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;fs::read_to_string(&#34;hello.html&#34;).unwrap();<br/>&#160;&#160;&#160;&#160;let&#160;length&#160;=&#160;contents.len();<br/>
&#160;&#160;&#160;&#160;let&#160;response&#160;=<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;format!(&#34;{status_line}\r\nContent-Length:&#160;{length}\r\n\r\n{contents}&#34;);<br/>
&#160;&#160;&#160;&#160;stream.write_all(response.as_bytes()).unwrap();<br/>}<br/>
<b>Listing&#160;20-5:&#160;Sending&#160;the&#160;contents&#160;of&#160;<i>hello.html</i></b><b>&#160;as&#160;the&#160;body&#160;of&#160;the&#160;response</b><br/>
We’ve added&#160;&#160;fs&#160;&#160;to the&#160;&#160;use&#160;&#160;statement to bring the standard library’s&#160;ﬁlesystem module<br/>into scope. The code for reading the contents of a&#160;ﬁle to a string should look familiar; we<br/>used it in Chapter 12 when we read the contents of a&#160;ﬁle for our I/O project in Listing 12-4.<br/>
Next, we use&#160;&#160;format!&#160;&#160;to add the&#160;ﬁle’s contents as the body of the success response. To<br/>ensure a valid HTTP response, we add the&#160;&#160;Content-Length&#160;&#160;header which is set to the size<br/>
https://doc.rust-lang.org/book/print.html<br/>
567/627<br/>
<hr/>
<a name=568></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
of our response body, in this case the size of&#160;&#160;hello.html&#160;.<br/>
Run this code with&#160;&#160;cargo&#160;run&#160;&#160;and load&#160;<i>127.0.0.1:7878</i>&#160;in your browser; you should see your<br/>HTML rendered!<br/>
Currently, we’re ignoring the request data in&#160;&#160;http_request&#160;&#160;and just sending back the<br/>contents of the HTML&#160;ﬁle unconditionally. That means if you try requesting<br/><i>127.0.0.1:7878/something-else</i>&#160;in your browser, you’ll still get back this same HTML response.<br/>At the moment, our server is very limited and does not do what most web servers do. We<br/>want to customize our responses depending on the request and only send back the HTML<br/>ﬁle for a well-formed request to&#160;<i>/</i>.<br/>
<a href="tests.html#568"><b>Validating&#160;the&#160;Request&#160;and&#160;Selectively&#160;Responding</b></a><br/>
Right now, our web server will return the HTML in the&#160;ﬁle no matter what the client<br/>requested. Let’s add functionality to check that the browser is requesting&#160;<i>/</i>&#160;before returning<br/>the HTML&#160;ﬁle and return an error if the browser requests anything else. For this we need to<br/>modify&#160;&#160;handle_connection&#160;, as shown in Listing 20-6. This new code checks the content of<br/>the request received against what we know a request for&#160;<i>/</i>&#160;looks like and adds&#160;&#160;if&#160;&#160;and&#160;&#160;else<br/>blocks to treat requests diﬀerently.<br/>
Filename: src/main.rs<br/>
//&#160;--snip--<br/>
fn&#160;handle_connection(mut&#160;stream:&#160;TcpStream)&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;buf_reader&#160;=&#160;BufReader::new(&amp;mut&#160;stream);<br/>&#160;&#160;&#160;&#160;let&#160;request_line&#160;=&#160;buf_reader.lines().next().unwrap().unwrap();<br/>
&#160;&#160;&#160;&#160;if&#160;request_line&#160;==&#160;&#34;GET&#160;/&#160;HTTP/1.1&#34;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;status_line&#160;=&#160;&#34;HTTP/1.1&#160;200&#160;OK&#34;;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;fs::read_to_string(&#34;hello.html&#34;).unwrap();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;length&#160;=&#160;contents.len();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;response&#160;=&#160;format!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;{status_line}\r\nContent-Length:&#160;{length}\r\n\r\n{contents}&#34;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;stream.write_all(response.as_bytes()).unwrap();<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;some&#160;other&#160;request<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;20-6:&#160;Handling&#160;requests&#160;to&#160;<i>/</i></b><b>&#160;diﬀerently&#160;from&#160;other&#160;requests</b><br/>
We’re only going to be looking at the&#160;ﬁrst line of the HTTP request, so rather than reading<br/>the entire request into a vector, we’re calling&#160;&#160;next&#160;&#160;to get the&#160;ﬁrst item from the iterator.<br/>The&#160;ﬁrst&#160;&#160;unwrap&#160;&#160;takes care of the&#160;&#160;Option&#160;&#160;and stops the program if the iterator has no<br/>
https://doc.rust-lang.org/book/print.html<br/>
568/627<br/>
<hr/>
<a name=569></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
items. The second&#160;&#160;unwrap&#160;&#160;handles the&#160;&#160;Result&#160;&#160;and has the same eﬀect as the&#160;&#160;unwrap&#160;&#160;that<br/>was in the&#160;&#160;map&#160;&#160;added in Listing 20-2.<br/>
Next, we check the&#160;&#160;request_line&#160;&#160;to see if it equals the request line of a GET request to the<br/><i>/</i>&#160;path. If it does, the&#160;&#160;if&#160;&#160;block returns the contents of our HTML&#160;ﬁle.<br/>
If the&#160;&#160;request_line&#160;&#160;does&#160;<i>not</i>&#160;equal the GET request to the&#160;<i>/</i>&#160;path, it means we’ve received<br/>some other request. We’ll add code to the&#160;&#160;else&#160;&#160;block in a moment to respond to all other<br/>requests.<br/>
Run this code now and request&#160;<i>127.0.0.1:7878</i>; you should get the HTML in&#160;<i>hello.html</i>. If you<br/>make any other request, such as&#160;<i>127.0.0.1:7878/something-else</i>, you’ll get a connection error<br/>like those you saw when running the code in Listing 20-1 and Listing 20-2.<br/>
Now let’s add the code in Listing 20-7 to the&#160;&#160;else&#160;&#160;block to return a response with the status<br/>code 404, which signals that the content for the request was not found. We’ll also return<br/>some HTML for a page to render in the browser indicating the response to the end user.<br/>
Filename: src/main.rs<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;status_line&#160;=&#160;&#34;HTTP/1.1&#160;404&#160;NOT&#160;FOUND&#34;;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;fs::read_to_string(&#34;404.html&#34;).unwrap();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;length&#160;=&#160;contents.len();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;response&#160;=&#160;format!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;{status_line}\r\nContent-Length:&#160;{length}\r\n\r\n{contents}&#34;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;stream.write_all(response.as_bytes()).unwrap();<br/>&#160;&#160;&#160;&#160;}<br/>
<b>Listing&#160;20-7:&#160;Responding&#160;with&#160;status&#160;code&#160;404&#160;and&#160;an&#160;error&#160;page&#160;if&#160;anything&#160;other&#160;than&#160;<i>/</i></b><b>&#160;was&#160;requested</b><br/>
Here, our response has a status line with status code 404 and the reason phrase&#160;&#160;NOT&#160;<br/>FOUND&#160;. The body of the response will be the HTML in the&#160;ﬁle&#160;<i>404.html</i>. You’ll need to create a<br/><i>404.html</i>&#160;ﬁle next to&#160;<i>hello.html</i>&#160;for the error page; again feel free to use any HTML you want<br/>or use the example HTML in Listing 20-8.<br/>
Filename: 404.html<br/>
https://doc.rust-lang.org/book/print.html<br/>
569/627<br/>
<hr/>
<a name=570></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&lt;!DOCTYPE&#160;html&gt;<br/>&lt;html&#160;lang=&#34;en&#34;&gt;<br/>&#160;&#160;&lt;head&gt;<br/>&#160;&#160;&#160;&#160;&lt;meta&#160;charset=&#34;utf-8&#34;&gt;<br/>&#160;&#160;&#160;&#160;&lt;title&gt;Hello!&lt;/title&gt;<br/>&#160;&#160;&lt;/head&gt;<br/>&#160;&#160;&lt;body&gt;<br/>&#160;&#160;&#160;&#160;&lt;h1&gt;Oops!&lt;/h1&gt;<br/>&#160;&#160;&#160;&#160;&lt;p&gt;Sorry,&#160;I&#160;don't&#160;know&#160;what&#160;you're&#160;asking&#160;for.&lt;/p&gt;<br/>&#160;&#160;&lt;/body&gt;<br/>&lt;/html&gt;<br/>
<b>Listing&#160;20-8:&#160;Sample&#160;content&#160;for&#160;the&#160;page&#160;to&#160;send&#160;back&#160;with&#160;any&#160;404&#160;response</b><br/>
With these changes, run your server again. Requesting&#160;<i>127.0.0.1:7878</i>&#160;should return the<br/>contents of&#160;<i>hello.html</i>, and any other request, like&#160;<i>127.0.0.1:7878/foo</i>, should return the error<br/>HTML from&#160;<i>404.html</i>.<br/>
<a href="tests.html#570"><b>A&#160;Touch&#160;of&#160;Refactoring</b></a><br/>
At the moment the&#160;&#160;if&#160;&#160;and&#160;&#160;else&#160;&#160;blocks have a lot of repetition: they’re both reading&#160;ﬁles<br/>and writing the contents of the&#160;ﬁles to the stream. The only diﬀerences are the status line<br/>and the&#160;ﬁlename. Let’s make the code more concise by pulling out those diﬀerences into<br/>separate&#160;&#160;if&#160;&#160;and&#160;&#160;else&#160;&#160;lines that will assign the values of the status line and the&#160;ﬁlename to<br/>variables; we can then use those variables unconditionally in the code to read the&#160;ﬁle and<br/>write the response. Listing 20-9 shows the resulting code after replacing the large&#160;&#160;if&#160;&#160;and<br/>
else&#160;&#160;blocks.<br/>
Filename: src/main.rs<br/>
//&#160;--snip--<br/>
fn&#160;handle_connection(mut&#160;stream:&#160;TcpStream)&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;let&#160;(status_line,&#160;filename)&#160;=&#160;if&#160;request_line&#160;==&#160;&#34;GET&#160;/&#160;HTTP/1.1&#34;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(&#34;HTTP/1.1&#160;200&#160;OK&#34;,&#160;&#34;hello.html&#34;)<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(&#34;HTTP/1.1&#160;404&#160;NOT&#160;FOUND&#34;,&#160;&#34;404.html&#34;)<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;fs::read_to_string(filename).unwrap();<br/>&#160;&#160;&#160;&#160;let&#160;length&#160;=&#160;contents.len();<br/>
&#160;&#160;&#160;&#160;let&#160;response&#160;=<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;format!(&#34;{status_line}\r\nContent-Length:&#160;{length}\r\n\r\n{contents}&#34;);<br/>
&#160;&#160;&#160;&#160;stream.write_all(response.as_bytes()).unwrap();<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
570/627<br/>
<hr/>
<a name=571></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Listing&#160;20-9:&#160;Refactoring&#160;the&#160;&#160;</b>if&#160;<b>&#160;and&#160;&#160;</b>else&#160;<b>&#160;blocks&#160;to&#160;contain&#160;only&#160;the&#160;code&#160;that&#160;diﬀers&#160;between&#160;the&#160;two&#160;cases</b><br/>
Now the&#160;&#160;if&#160;&#160;and&#160;&#160;else&#160;&#160;blocks only return the appropriate values for the status line and<br/>ﬁlename in a tuple; we then use destructuring to assign these two values to&#160;&#160;status_line<br/>and&#160;&#160;filename&#160;&#160;using a pattern in the&#160;&#160;let&#160;&#160;statement, as discussed in Chapter 18.<br/>
The previously duplicated code is now outside the&#160;&#160;if&#160;&#160;and&#160;&#160;else&#160;&#160;blocks and uses the<br/>
status_line&#160;&#160;and&#160;&#160;filename&#160;&#160;variables. This makes it easier to see the diﬀerence between<br/>
the two cases, and it means we have only one place to update the code if we want to change<br/>how the&#160;ﬁle reading and response writing work. The behavior of the code in Listing 20-9 will<br/>be the same as that in Listing 20-8.<br/>
Awesome! We now have a simple web server in approximately 40 lines of Rust code that<br/>responds to one request with a page of content and responds to all other requests with a<br/>404 response.<br/>
Currently, our server runs in a single thread, meaning it can only serve one request at a<br/>time. Let’s examine how that can be a problem by simulating some slow requests. Then we’ll<br/>ﬁx it so our server can handle multiple requests at once.<br/>
https://doc.rust-lang.org/book/print.html<br/>
571/627<br/>
<hr/>
<a name=572></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#572"><b>Turning Our Single-Threaded Server into a Multithreaded<br/>Server</b></a><br/>
Right now, the server will process each request in turn, meaning it won’t process a second<br/>connection until the&#160;ﬁrst is&#160;ﬁnished processing. If the server received more and more<br/>requests, this serial execution would be less and less optimal. If the server receives a<br/>request that takes a long time to process, subsequent requests will have to wait until the<br/>long request is&#160;ﬁnished, even if the new requests can be processed quickly. We’ll need to&#160;ﬁx<br/>this, but&#160;ﬁrst, we’ll look at the problem in action.<br/>
<a href="tests.html#572"><b>Simulating&#160;a&#160;Slow&#160;Request&#160;in&#160;the&#160;Current&#160;Server&#160;Implementation</b></a><br/>
We’ll look at how a slow-processing request can aﬀect other requests made to our current<br/>server implementation. Listing 20-10 implements handling a request to&#160;<i>/sleep</i>&#160;with a<br/>simulated slow response that will cause the server to sleep for 5 seconds before<br/>responding.<br/>
Filename: src/main.rs<br/>
use&#160;std::{<br/>&#160;&#160;&#160;&#160;fs,<br/>&#160;&#160;&#160;&#160;io::{prelude::*,&#160;BufReader},<br/>&#160;&#160;&#160;&#160;net::{TcpListener,&#160;TcpStream},<br/>&#160;&#160;&#160;&#160;thread,<br/>&#160;&#160;&#160;&#160;time::Duration,<br/>};<br/>//&#160;--snip--<br/>
fn&#160;handle_connection(mut&#160;stream:&#160;TcpStream)&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;let&#160;(status_line,&#160;filename)&#160;=&#160;match&#160;&amp;request_line[..]&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;GET&#160;/&#160;HTTP/1.1&#34;&#160;=&gt;&#160;(&#34;HTTP/1.1&#160;200&#160;OK&#34;,&#160;&#34;hello.html&#34;),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;GET&#160;/sleep&#160;HTTP/1.1&#34;&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::sleep(Duration::from_secs(5));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(&#34;HTTP/1.1&#160;200&#160;OK&#34;,&#160;&#34;hello.html&#34;)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_&#160;=&gt;&#160;(&#34;HTTP/1.1&#160;404&#160;NOT&#160;FOUND&#34;,&#160;&#34;404.html&#34;),<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
<b>Listing&#160;20-10:&#160;Simulating&#160;a&#160;slow&#160;request&#160;by&#160;sleeping&#160;for&#160;5&#160;seconds</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
572/627<br/>
<hr/>
<a name=573></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We switched from&#160;&#160;if&#160;&#160;to&#160;&#160;match&#160;&#160;now that we have three cases. We need to explicitly match<br/>on a slice of&#160;&#160;request_line&#160;&#160;to pattern match against the string literal values;&#160;&#160;match&#160;&#160;doesn’t<br/>do automatic referencing and dereferencing like the equality method does.<br/>
The&#160;ﬁrst arm is the same as the&#160;&#160;if&#160;&#160;block from Listing 20-9. The second arm matches a<br/>request to&#160;<i>/sleep</i>. When that request is received, the server will sleep for 5 seconds before<br/>rendering the successful HTML page. The third arm is the same as the&#160;&#160;else&#160;&#160;block from<br/>Listing 20-9.<br/>
You can see how primitive our server is: real libraries would handle the recognition of<br/>multiple requests in a much less verbose way!<br/>
Start the server using&#160;&#160;cargo&#160;run&#160;. Then open two browser windows: one for<br/><i>http://127.0.0.1:7878/</i>&#160;and the other for&#160;<i>http://127.0.0.1:7878/sleep</i>. If you enter the&#160;<i>/</i>&#160;URI a few<br/>times, as before, you’ll see it respond quickly. But if you enter&#160;<i>/sleep</i>&#160;and then load&#160;<i>/</i>, you’ll<br/>see that&#160;<i>/</i>&#160;waits until&#160;&#160;sleep&#160;&#160;has slept for its full 5 seconds before loading.<br/>
There are multiple techniques we could use to avoid requests backing up behind a slow<br/>request; the one we’ll implement is a thread pool.<br/>
<a href="tests.html#573"><b>Improving&#160;Throughput&#160;with&#160;a&#160;Thread&#160;Pool</b></a><br/>
A&#160;<i>thread pool</i>&#160;is a group of spawned threads that are waiting and ready to handle a task.<br/>When the program receives a new task, it assigns one of the threads in the pool to the task,<br/>and that thread will process the task. The remaining threads in the pool are available to<br/>handle any other tasks that come in while the&#160;ﬁrst thread is processing. When the&#160;ﬁrst<br/>thread is done processing its task, it’s returned to the pool of idle threads, ready to handle a<br/>new task. A thread pool allows you to process connections concurrently, increasing the<br/>throughput of your server.<br/>
We’ll limit the number of threads in the pool to a small number to protect us from Denial of<br/>Service (DoS) attacks; if we had our program create a new thread for each request as it<br/>came in, someone making 10 million requests to our server could create havoc by using up<br/>all our server’s resources and grinding the processing of requests to a halt.<br/>
Rather than spawning unlimited threads, then, we’ll have a&#160;ﬁxed number of threads waiting<br/>in the pool. Requests that come in are sent to the pool for processing. The pool will<br/>maintain a queue of incoming requests. Each of the threads in the pool will pop oﬀ&#160;a<br/>request from this queue, handle the request, and then ask the queue for another request.<br/>With this design, we can process up to&#160;&#160;N&#160;&#160;requests concurrently, where&#160;&#160;N&#160;&#160;is the number of<br/>threads. If each thread is responding to a long-running request, subsequent requests can<br/>still back up in the queue, but we’ve increased the number of long-running requests we can<br/>handle before reaching that point.<br/>
This technique is just one of many ways to improve the throughput of a web server. Other<br/>options you might explore are the&#160;<i>fork/join model</i>, the&#160;<i>single-threaded async I/O model</i>, or the<br/>
https://doc.rust-lang.org/book/print.html<br/>
573/627<br/>
<hr/>
<a name=574></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<i>multi-threaded async I/O model</i>. If you’re interested in this topic, you can read more about<br/>other solutions and try to implement them; with a low-level language like Rust, all of these<br/>options are possible.<br/>
Before we begin implementing a thread pool, let’s talk about what using the pool should<br/>look like. When you’re trying to design code, writing the client interface&#160;ﬁrst can help guide<br/>your design. Write the API of the code so it’s structured in the way you want to call it; then<br/>implement the functionality within that structure rather than implementing the functionality<br/>and then designing the public API.<br/>
Similar to how we used test-driven development in the project in Chapter 12, we’ll use<br/>compiler-driven development here. We’ll write the code that calls the functions we want,<br/>and then we’ll look at errors from the compiler to determine what we should change next to<br/>get the code to work. Before we do that, however, we’ll explore the technique we’re not<br/>going to use as a starting point.<br/>
<a href="tests.html#574"><b>Spawning a Thread for Each Request</b></a><br/>
First, let’s explore how our code might look if it did create a new thread for every<br/>connection. As mentioned earlier, this isn’t our&#160;ﬁnal plan due to the problems with<br/>potentially spawning an unlimited number of threads, but it is a starting point to get a<br/>working multithreaded server&#160;ﬁrst. Then we’ll add the thread pool as an improvement, and<br/>contrasting the two solutions will be easier. Listing 20-11 shows the changes to make to<br/>
main&#160;&#160;to spawn a new thread to handle each stream within the&#160;&#160;for&#160;&#160;loop.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;listener&#160;=&#160;TcpListener::bind(&#34;127.0.0.1:7878&#34;).unwrap();<br/>
&#160;&#160;&#160;&#160;for&#160;stream&#160;in&#160;listener.incoming()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;stream&#160;=&#160;stream.unwrap();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::spawn(||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handle_connection(stream);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;20-11:&#160;Spawning&#160;a&#160;new&#160;thread&#160;for&#160;each&#160;stream</b><br/>
As you learned in Chapter 16,&#160;&#160;thread::spawn&#160;&#160;will create a new thread and then run the<br/>code in the closure in the new thread. If you run this code and load&#160;<i>/sleep</i>&#160;in your browser,<br/>then&#160;<i>/</i>&#160;in two more browser tabs, you’ll indeed see that the requests to&#160;<i>/</i>&#160;don’t have to wait<br/>for&#160;<i>/sleep</i>&#160;to&#160;ﬁnish. However, as we mentioned, this will eventually overwhelm the system<br/>because you’d be making new threads without any limit.<br/>
https://doc.rust-lang.org/book/print.html<br/>
574/627<br/>
<hr/>
<a name=575></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#575"><b>Creating a Finite Number of Threads</b></a><br/>
We want our thread pool to work in a similar, familiar way so switching from threads to a<br/>thread pool doesn’t require large changes to the code that uses our API. Listing 20-12 shows<br/>the hypothetical interface for a&#160;&#160;ThreadPool&#160;&#160;struct we want to use instead of<br/>
thread::spawn&#160;.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;listener&#160;=&#160;TcpListener::bind(&#34;127.0.0.1:7878&#34;).unwrap();<br/>&#160;&#160;&#160;&#160;let&#160;pool&#160;=&#160;ThreadPool::new(4);<br/>
&#160;&#160;&#160;&#160;for&#160;stream&#160;in&#160;listener.incoming()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;stream&#160;=&#160;stream.unwrap();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pool.execute(||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handle_connection(stream);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;20-12:&#160;Our&#160;ideal&#160;&#160;</b>ThreadPool&#160;<b>&#160;interface</b><br/>
We use&#160;&#160;ThreadPool::new&#160;&#160;to create a new thread pool with a conﬁgurable number of<br/>threads, in this case four. Then, in the&#160;&#160;for&#160;&#160;loop,&#160;&#160;pool.execute&#160;&#160;has a similar interface as<br/>
thread::spawn&#160;&#160;in that it takes a closure the pool should run for each stream. We need to<br/>
implement&#160;&#160;pool.execute&#160;&#160;so it takes the closure and gives it to a thread in the pool to run.<br/>This code won’t yet compile, but we’ll try so the compiler can guide us in how to&#160;ﬁx it.<br/>
<a href="tests.html#575"><b>Building&#160;</b>ThreadPool<b>&#160;Using Compiler Driven Development</b></a><br/>
Make the changes in Listing 20-12 to&#160;<i>src/main.rs</i>, and then let’s use the compiler errors from<br/>
cargo&#160;check&#160;&#160;to drive our development. Here is the&#160;ﬁrst error we get:<br/>
$&#160;cargo&#160;check<br/>&#160;&#160;&#160;&#160;Checking&#160;hello&#160;v0.1.0&#160;(file:///projects/hello)<br/>error[E0433]:&#160;failed&#160;to&#160;resolve:&#160;use&#160;of&#160;undeclared&#160;type&#160;`ThreadPool`<br/>&#160;&#160;--&gt;&#160;src/main.rs:11:16<br/>&#160;&#160;&#160;|<br/>11&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;pool&#160;=&#160;ThreadPool::new(4);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^&#160;use&#160;of&#160;undeclared&#160;type&#160;`ThreadPool`<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0433`.<br/>error:&#160;could&#160;not&#160;compile&#160;`hello`&#160;due&#160;to&#160;previous&#160;error<br/>
Great! This error tells us we need a&#160;&#160;ThreadPool&#160;&#160;type or module, so we’ll build one now. Our<br/>
ThreadPool&#160;&#160;implementation will be independent of the kind of work our web server is<br/>
doing. So, let’s switch the&#160;&#160;hello&#160;&#160;crate from a binary crate to a library crate to hold our<br/>
https://doc.rust-lang.org/book/print.html<br/>
575/627<br/>
<hr/>
<a name=576></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
ThreadPool&#160;&#160;implementation. After we change to a library crate, we could also use the<br/>
separate thread pool library for any work we want to do using a thread pool, not just for<br/>serving web requests.<br/>
Create a&#160;<i>src/lib.rs</i>&#160;that contains the following, which is the simplest deﬁnition of a<br/>
ThreadPool&#160;&#160;struct that we can have for now:<br/>
Filename: src/lib.rs<br/>
pub&#160;struct&#160;ThreadPool;<br/>
Then edit&#160;<i>main.rs</i>&#160;ﬁle to bring&#160;&#160;ThreadPool&#160;&#160;into scope from the library crate by adding the<br/>following code to the top of&#160;<i>src/main.rs</i>:<br/>
Filename: src/main.rs<br/>
use&#160;hello::ThreadPool;<br/>
This code still won’t work, but let’s check it again to get the next error that we need to<br/>address:<br/>
$&#160;cargo&#160;check<br/>&#160;&#160;&#160;&#160;Checking&#160;hello&#160;v0.1.0&#160;(file:///projects/hello)<br/>error[E0599]:&#160;no&#160;function&#160;or&#160;associated&#160;item&#160;named&#160;`new`&#160;found&#160;for&#160;struct&#160;<br/>`ThreadPool`&#160;in&#160;the&#160;current&#160;scope<br/>&#160;&#160;--&gt;&#160;src/main.rs:12:28<br/>&#160;&#160;&#160;|<br/>12&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;pool&#160;=&#160;ThreadPool::new(4);<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^&#160;function&#160;or&#160;associated&#160;item&#160;not&#160;found&#160;in&#160;<br/>`ThreadPool`<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0599`.<br/>error:&#160;could&#160;not&#160;compile&#160;`hello`&#160;due&#160;to&#160;previous&#160;error<br/>
This error indicates that next we need to create an associated function named&#160;&#160;new&#160;&#160;for<br/>
ThreadPool&#160;. We also know that&#160;&#160;new&#160;&#160;needs to have one parameter that can accept&#160;&#160;4&#160;&#160;as an<br/>
argument and should return a&#160;&#160;ThreadPool&#160;&#160;instance. Let’s implement the simplest&#160;&#160;new<br/>function that will have those characteristics:<br/>
Filename: src/lib.rs<br/>
pub&#160;struct&#160;ThreadPool;<br/>
impl&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(size:&#160;usize)&#160;-&gt;&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ThreadPool<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
576/627<br/>
<hr/>
<a name=577></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
We chose&#160;&#160;usize&#160;&#160;as the type of the&#160;&#160;size&#160;&#160;parameter, because we know that a negative<br/>number of threads doesn’t make any sense. We also know we’ll use this 4 as the number of<br/>elements in a collection of threads, which is what the&#160;&#160;usize&#160;&#160;type is for, as discussed in the<br/><a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types">“Integer Types”</a>&#160;section of Chapter 3.<br/>
Let’s check the code again:<br/>
$&#160;cargo&#160;check<br/>&#160;&#160;&#160;&#160;Checking&#160;hello&#160;v0.1.0&#160;(file:///projects/hello)<br/>error[E0599]:&#160;no&#160;method&#160;named&#160;`execute`&#160;found&#160;for&#160;struct&#160;`ThreadPool`&#160;in&#160;the&#160;<br/>current&#160;scope<br/>&#160;&#160;--&gt;&#160;src/main.rs:17:14<br/>&#160;&#160;&#160;|<br/>17&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pool.execute(||&#160;{<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^&#160;method&#160;not&#160;found&#160;in&#160;`ThreadPool`<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0599`.<br/>error:&#160;could&#160;not&#160;compile&#160;`hello`&#160;due&#160;to&#160;previous&#160;error<br/>
Now the error occurs because we don’t have an&#160;&#160;execute&#160;&#160;method on&#160;&#160;ThreadPool&#160;. Recall<br/><a href="https://doc.rust-lang.org/book/ch20-02-multithreaded.html#creating-a-finite-number-of-threads">from the&#160;“Creating a Finite Number of Threads”</a>&#160;section that we decided our thread pool<br/>should have an interface similar to&#160;&#160;thread::spawn&#160;. In addition, we’ll implement the<br/>
execute&#160;&#160;function so it takes the closure it’s given and gives it to an idle thread in the pool to<br/>
run.<br/>
We’ll deﬁne the&#160;&#160;execute&#160;&#160;method on&#160;&#160;ThreadPool&#160;&#160;to take a closure as a parameter. Recall<br/><a href="https://doc.rust-lang.org/book/ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits">from the&#160;“Moving Captured Values Out of the Closure and the&#160;&#160;Fn&#160;&#160;Traits”</a>&#160;section in Chapter<br/>13 that we can take closures as parameters with three diﬀerent traits:&#160;&#160;Fn&#160;,&#160;&#160;FnMut&#160;, and<br/>
FnOnce&#160;. We need to decide which kind of closure to use here. We know we’ll end up doing<br/>
something similar to the standard library&#160;&#160;thread::spawn&#160;&#160;implementation, so we can look at<br/>what bounds the signature of&#160;&#160;thread::spawn&#160;&#160;has on its parameter. The documentation<br/>shows us the following:<br/>
pub&#160;fn&#160;spawn&lt;F,&#160;T&gt;(f:&#160;F)&#160;-&gt;&#160;JoinHandle&lt;T&gt;<br/>&#160;&#160;&#160;&#160;where<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F:&#160;FnOnce()&#160;-&gt;&#160;T,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F:&#160;Send&#160;+&#160;'static,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;T:&#160;Send&#160;+&#160;'static,<br/>
The&#160;&#160;F&#160;&#160;type parameter is the one we’re concerned with here; the&#160;&#160;T&#160;&#160;type parameter is<br/>related to the return value, and we’re not concerned with that. We can see that&#160;&#160;spawn&#160;&#160;uses<br/>
FnOnce&#160;&#160;as the trait bound on&#160;&#160;F&#160;. This is probably what we want as well, because we’ll<br/>
eventually pass the argument we get in&#160;&#160;execute&#160;&#160;to&#160;&#160;spawn&#160;. We can be further conﬁdent<br/>that&#160;&#160;FnOnce&#160;&#160;is the trait we want to use because the thread for running a request will only<br/>execute that request’s closure one time, which matches the&#160;&#160;Once&#160;&#160;in&#160;&#160;FnOnce&#160;.<br/>
The&#160;&#160;F&#160;&#160;type parameter also has the trait bound&#160;&#160;Send&#160;&#160;and the lifetime bound&#160;&#160;'static&#160;,<br/>which are useful in our situation: we need&#160;&#160;Send&#160;&#160;to transfer the closure from one thread to<br/>
https://doc.rust-lang.org/book/print.html<br/>
577/627<br/>
<hr/>
<a name=578></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
another and&#160;&#160;'static&#160;&#160;because we don’t know how long the thread will take to execute. Let’s<br/>create an&#160;&#160;execute&#160;&#160;method on&#160;&#160;ThreadPool&#160;&#160;that will take a generic parameter of type&#160;&#160;F<br/>with these bounds:<br/>
Filename: src/lib.rs<br/>
impl&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;execute&lt;F&gt;(&amp;self,&#160;f:&#160;F)<br/>&#160;&#160;&#160;&#160;where<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F:&#160;FnOnce()&#160;+&#160;Send&#160;+&#160;'static,<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
We still use the&#160;&#160;()&#160;&#160;after&#160;&#160;FnOnce&#160;&#160;because this&#160;&#160;FnOnce&#160;&#160;represents a closure that takes no<br/>parameters and returns the unit type&#160;&#160;()&#160;. Just like function deﬁnitions, the return type can<br/>be omitted from the signature, but even if we have no parameters, we still need the<br/>parentheses.<br/>
Again, this is the simplest implementation of the&#160;&#160;execute&#160;&#160;method: it does nothing, but<br/>we’re trying only to make our code compile. Let’s check it again:<br/>
$&#160;cargo&#160;check<br/>&#160;&#160;&#160;&#160;Checking&#160;hello&#160;v0.1.0&#160;(file:///projects/hello)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.24s<br/>
It compiles! But note that if you try&#160;&#160;cargo&#160;run&#160;&#160;and make a request in the browser, you’ll see<br/>the errors in the browser that we saw at the beginning of the chapter. Our library isn’t<br/>actually calling the closure passed to&#160;&#160;execute&#160;&#160;yet!<br/>
Note: A saying you might hear about languages with strict compilers, such as Haskell<br/>and Rust, is “if the code compiles, it works.” But this saying is not universally true. Our<br/>project compiles, but it does absolutely nothing! If we were building a real, complete<br/>project, this would be a good time to start writing unit tests to check that the code<br/>compiles&#160;<i>and</i>&#160;has the behavior we want.<br/>
<a href="tests.html#578"><b>Validating the Number of Threads in&#160;</b>new</a><br/>
We aren’t doing anything with the parameters to&#160;&#160;new&#160;&#160;and&#160;&#160;execute&#160;. Let’s implement the<br/>bodies of these functions with the behavior we want. To start, let’s think about&#160;&#160;new&#160;. Earlier<br/>we chose an unsigned type for the&#160;&#160;size&#160;&#160;parameter, because a pool with a negative number<br/>of threads makes no sense. However, a pool with zero threads also makes no sense, yet<br/>zero is a perfectly valid&#160;&#160;usize&#160;. We’ll add code to check that&#160;&#160;size&#160;&#160;is greater than zero<br/>
https://doc.rust-lang.org/book/print.html<br/>
578/627<br/>
<hr/>
<a name=579></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
before we return a&#160;&#160;ThreadPool&#160;&#160;instance and have the program panic if it receives a zero by<br/>using the&#160;&#160;assert!&#160;&#160;macro, as shown in Listing 20-13.<br/>
Filename: src/lib.rs<br/>
impl&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;///&#160;Create&#160;a&#160;new&#160;ThreadPool.<br/>&#160;&#160;&#160;&#160;///<br/>&#160;&#160;&#160;&#160;///&#160;The&#160;size&#160;is&#160;the&#160;number&#160;of&#160;threads&#160;in&#160;the&#160;pool.<br/>&#160;&#160;&#160;&#160;///<br/>&#160;&#160;&#160;&#160;///&#160;#&#160;Panics<br/>&#160;&#160;&#160;&#160;///<br/>&#160;&#160;&#160;&#160;///&#160;The&#160;`new`&#160;function&#160;will&#160;panic&#160;if&#160;the&#160;size&#160;is&#160;zero.<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(size:&#160;usize)&#160;-&gt;&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert!(size&#160;&gt;&#160;0);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ThreadPool<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
<b>Listing&#160;20-13:&#160;Implementing&#160;&#160;</b>ThreadPool::new&#160;<b>&#160;to&#160;panic&#160;if&#160;&#160;</b>size&#160;<b>&#160;is&#160;zero</b><br/>
We’ve also added some documentation for our&#160;&#160;ThreadPool&#160;&#160;with doc comments. Note that<br/>we followed good documentation practices by adding a section that calls out the situations<br/>in which our function can panic, as discussed in Chapter 14. Try running&#160;&#160;cargo&#160;doc&#160;--open<br/>and clicking the&#160;&#160;ThreadPool&#160;&#160;struct to see what the generated docs for&#160;&#160;new&#160;&#160;look like!<br/>
Instead of adding the&#160;&#160;assert!&#160;&#160;macro as we’ve done here, we could change&#160;&#160;new&#160;&#160;into&#160;&#160;build<br/>and return a&#160;&#160;Result&#160;&#160;like we did with&#160;&#160;Config::build&#160;&#160;in the I/O project in Listing 12-9. But<br/>we’ve decided in this case that trying to create a thread pool without any threads should be<br/>an unrecoverable error. If you’re feeling ambitious, try to write a function named&#160;&#160;build<br/>with the following signature to compare with the&#160;&#160;new&#160;&#160;function:<br/>
pub&#160;fn&#160;build(size:&#160;usize)&#160;-&gt;&#160;Result&lt;ThreadPool,&#160;PoolCreationError&gt;&#160;{<br/>
<a href="tests.html#579"><b>Creating Space to Store the Threads</b></a><br/>
Now that we have a way to know we have a valid number of threads to store in the pool, we<br/>can create those threads and store them in the&#160;&#160;ThreadPool&#160;&#160;struct before returning the<br/>struct. But how do we “store” a thread? Let’s take another look at the&#160;&#160;thread::spawn<br/>signature:<br/>
https://doc.rust-lang.org/book/print.html<br/>
579/627<br/>
<hr/>
<a name=580></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;fn&#160;spawn&lt;F,&#160;T&gt;(f:&#160;F)&#160;-&gt;&#160;JoinHandle&lt;T&gt;<br/>&#160;&#160;&#160;&#160;where<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F:&#160;FnOnce()&#160;-&gt;&#160;T,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F:&#160;Send&#160;+&#160;'static,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;T:&#160;Send&#160;+&#160;'static,<br/>
The&#160;&#160;spawn&#160;&#160;function returns a&#160;&#160;JoinHandle&lt;T&gt;&#160;, where&#160;&#160;T&#160;&#160;is the type that the closure returns.<br/>Let’s try using&#160;&#160;JoinHandle&#160;&#160;too and see what happens. In our case, the closures we’re<br/>passing to the thread pool will handle the connection and not return anything, so&#160;&#160;T&#160;&#160;will be<br/>the unit type&#160;&#160;()&#160;.<br/>
The code in Listing 20-14 will compile but doesn’t create any threads yet. We’ve changed the<br/>deﬁnition of&#160;&#160;ThreadPool&#160;&#160;to hold a vector of&#160;&#160;thread::JoinHandle&lt;()&gt;&#160;&#160;instances, initialized<br/>the vector with a capacity of&#160;&#160;size&#160;, set up a&#160;&#160;for&#160;&#160;loop that will run some code to create the<br/>threads, and returned a&#160;&#160;ThreadPool&#160;&#160;instance containing them.<br/>
Filename: src/lib.rs<br/>
use&#160;std::thread;<br/>
pub&#160;struct&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;threads:&#160;Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,<br/>}<br/>
impl&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(size:&#160;usize)&#160;-&gt;&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert!(size&#160;&gt;&#160;0);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;threads&#160;=&#160;Vec::with_capacity(size);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;_&#160;in&#160;0..size&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;create&#160;some&#160;threads&#160;and&#160;store&#160;them&#160;in&#160;the&#160;vector<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ThreadPool&#160;{&#160;threads&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
<b>Listing&#160;20-14:&#160;Creating&#160;a&#160;vector&#160;for&#160;&#160;</b>ThreadPool&#160;<b>&#160;to&#160;hold&#160;the&#160;threads</b><br/>
We’ve brought&#160;&#160;std::thread&#160;&#160;into scope in the library crate, because we’re using<br/>
thread::JoinHandle&#160;&#160;as the type of the items in the vector in&#160;&#160;ThreadPool&#160;.<br/>
Once a valid size is received, our&#160;&#160;ThreadPool&#160;&#160;creates a new vector that can hold&#160;&#160;size<br/>items. The&#160;&#160;with_capacity&#160;&#160;function performs the same task as&#160;&#160;Vec::new&#160;&#160;but with an<br/>important diﬀerence: it preallocates space in the vector. Because we know we need to store<br/>
size&#160;&#160;elements in the vector, doing this allocation up front is slightly more eﬃcient than<br/>
using&#160;&#160;Vec::new&#160;, which resizes itself as elements are inserted.<br/>
https://doc.rust-lang.org/book/print.html<br/>
580/627<br/>
<hr/>
<a name=581></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
When you run&#160;&#160;cargo&#160;check&#160;&#160;again, it should succeed.<br/>
<a href="tests.html#581"><b>A&#160;</b>Worker<b>&#160;Struct Responsible for Sending Code from the&#160;</b>ThreadPool<b>&#160;to a Thread</b></a><br/>
We left a comment in the&#160;&#160;for&#160;&#160;loop in Listing 20-14 regarding the creation of threads. Here,<br/>we’ll look at how we actually create threads. The standard library provides&#160;&#160;thread::spawn<br/>as a way to create threads, and&#160;&#160;thread::spawn&#160;&#160;expects to get some code the thread should<br/>run as soon as the thread is created. However, in our case, we want to create the threads<br/>and have them&#160;<i>wait</i>&#160;for code that we’ll send later. The standard library’s implementation of<br/>threads doesn’t include any way to do that; we have to implement it manually.<br/>
We’ll implement this behavior by introducing a new data structure between the&#160;&#160;ThreadPool<br/>and the threads that will manage this new behavior. We’ll call this data structure&#160;<i>Worker</i>,<br/>which is a common term in pooling implementations. The Worker picks up code that needs<br/>to be run and runs the code in the Worker’s thread. Think of people working in the kitchen<br/>at a restaurant: the workers wait until orders come in from customers, and then they’re<br/>responsible for taking those orders and fulﬁlling them.<br/>
Instead of storing a vector of&#160;&#160;JoinHandle&lt;()&gt;&#160;&#160;instances in the thread pool, we’ll store<br/>instances of the&#160;&#160;Worker&#160;&#160;struct. Each&#160;&#160;Worker&#160;&#160;will store a single&#160;&#160;JoinHandle&lt;()&gt;&#160;&#160;instance.<br/>Then we’ll implement a method on&#160;&#160;Worker&#160;&#160;that will take a closure of code to run and send<br/>it to the already running thread for execution. We’ll also give each worker an&#160;&#160;id&#160;&#160;so we can<br/>distinguish between the diﬀerent workers in the pool when logging or debugging.<br/>
Here is the new process that will happen when we create a&#160;&#160;ThreadPool&#160;. We’ll implement<br/>the code that sends the closure to the thread after we have&#160;&#160;Worker&#160;&#160;set up in this way:<br/>
1.&#160;Deﬁne a&#160;&#160;Worker&#160;&#160;struct that holds an&#160;&#160;id&#160;&#160;and a&#160;&#160;JoinHandle&lt;()&gt;&#160;.<br/>2.&#160;Change&#160;&#160;ThreadPool&#160;&#160;to hold a vector of&#160;&#160;Worker&#160;&#160;instances.<br/>3.&#160;Deﬁne a&#160;&#160;Worker::new&#160;&#160;function that takes an&#160;&#160;id&#160;&#160;number and returns a&#160;&#160;Worker<br/>
instance that holds the&#160;&#160;id&#160;&#160;and a thread spawned with an empty closure.<br/>
4.&#160;In&#160;&#160;ThreadPool::new&#160;, use the&#160;&#160;for&#160;&#160;loop counter to generate an&#160;&#160;id&#160;, create a new<br/>
Worker&#160;&#160;with that&#160;&#160;id&#160;, and store the worker in the vector.<br/>
If you’re up for a challenge, try implementing these changes on your own before looking at<br/>the code in Listing 20-15.<br/>
Ready? Here is Listing 20-15 with one way to make the preceding modiﬁcations.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
581/627<br/>
<hr/>
<a name=582></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::thread;<br/>
pub&#160;struct&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;workers:&#160;Vec&lt;Worker&gt;,<br/>}<br/>
impl&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(size:&#160;usize)&#160;-&gt;&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert!(size&#160;&gt;&#160;0);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;workers&#160;=&#160;Vec::with_capacity(size);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;id&#160;in&#160;0..size&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;workers.push(Worker::new(id));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ThreadPool&#160;{&#160;workers&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
struct&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;id:&#160;usize,<br/>&#160;&#160;&#160;&#160;thread:&#160;thread::JoinHandle&lt;()&gt;,<br/>}<br/>
impl&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;new(id:&#160;usize)&#160;-&gt;&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;thread&#160;=&#160;thread::spawn(||&#160;{});<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Worker&#160;{&#160;id,&#160;thread&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;20-15:&#160;Modifying&#160;&#160;</b>ThreadPool&#160;<b>&#160;to&#160;hold&#160;&#160;</b>Worker&#160;<b>&#160;instances&#160;instead&#160;of&#160;holding&#160;threads&#160;directly</b><br/>
We’ve changed the name of the&#160;ﬁeld on&#160;&#160;ThreadPool&#160;&#160;from&#160;&#160;threads&#160;&#160;to&#160;&#160;workers&#160;&#160;because it’s<br/>now holding&#160;&#160;Worker&#160;&#160;instances instead of&#160;&#160;JoinHandle&lt;()&gt;&#160;&#160;instances. We use the counter in<br/>the&#160;&#160;for&#160;&#160;loop as an argument to&#160;&#160;Worker::new&#160;, and we store each new&#160;&#160;Worker&#160;&#160;in the vector<br/>named&#160;&#160;workers&#160;.<br/>
External code (like our server in&#160;<i>src/main.rs</i>) doesn’t need to know the implementation<br/>details regarding using a&#160;&#160;Worker&#160;&#160;struct within&#160;&#160;ThreadPool&#160;, so we make the&#160;&#160;Worker&#160;&#160;struct<br/>and its&#160;&#160;new&#160;&#160;function private. The&#160;&#160;Worker::new&#160;&#160;function uses the&#160;&#160;id&#160;&#160;we give it and stores a<br/>
JoinHandle&lt;()&gt;&#160;&#160;instance that is created by spawning a new thread using an empty closure.<br/>
Note: If the operating system can’t create a thread because there aren’t enough<br/>system resources,&#160;&#160;thread::spawn&#160;&#160;will panic. That will cause our whole server to panic,<br/>even though the creation of some threads might succeed. For simplicity’s sake, this<br/>
https://doc.rust-lang.org/book/print.html<br/>
582/627<br/>
<hr/>
<a name=583></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
behavior is&#160;ﬁne, but in a production thread pool implementation, you’d likely want to<br/>use&#160;&#160;<a href="https://doc.rust-lang.org/std/thread/struct.Builder.html">std::thread::Builder&#160;&#160;and its&#160;&#160;</a><a href="https://doc.rust-lang.org/std/thread/struct.Builder.html#method.spawn">spawn&#160;&#160;method that returns&#160;&#160;</a>Result&#160;&#160;instead.<br/>
This code will compile and will store the number of&#160;&#160;Worker&#160;&#160;instances we speciﬁed as an<br/>argument to&#160;&#160;ThreadPool::new&#160;. But we’re&#160;<i>still</i>&#160;not processing the closure that we get in<br/>
execute&#160;. Let’s look at how to do that next.<br/>
<a href="tests.html#583"><b>Sending Requests to Threads via Channels</b></a><br/>
The next problem we’ll tackle is that the closures given to&#160;&#160;thread::spawn&#160;&#160;do absolutely<br/>nothing. Currently, we get the closure we want to execute in the&#160;&#160;execute&#160;&#160;method. But we<br/>need to give&#160;&#160;thread::spawn&#160;&#160;a closure to run when we create each&#160;&#160;Worker&#160;&#160;during the<br/>creation of the&#160;&#160;ThreadPool&#160;.<br/>
We want the&#160;&#160;Worker&#160;&#160;structs that we just created to fetch the code to run from a queue held<br/>in the&#160;&#160;ThreadPool&#160;&#160;and send that code to its thread to run.<br/>
The channels we learned about in Chapter 16—a simple way to communicate between two<br/>threads—would be perfect for this use case. We’ll use a channel to function as the queue of<br/>jobs, and&#160;&#160;execute&#160;&#160;will send a job from the&#160;&#160;ThreadPool&#160;&#160;to the&#160;&#160;Worker&#160;&#160;instances, which will<br/>send the job to its thread. Here is the plan:<br/>
1.&#160;The&#160;&#160;ThreadPool&#160;&#160;will create a channel and hold on to the sender.<br/>2.&#160;Each&#160;&#160;Worker&#160;&#160;will hold on to the receiver.<br/>3.&#160;We’ll create a new&#160;&#160;Job&#160;&#160;struct that will hold the closures we want to send down the<br/>
channel.<br/>
4.&#160;The&#160;&#160;execute&#160;&#160;method will send the job it wants to execute through the sender.<br/>5.&#160;In its thread, the&#160;&#160;Worker&#160;&#160;will loop over its receiver and execute the closures of any<br/>
jobs it receives.<br/>
Let’s start by creating a channel in&#160;&#160;ThreadPool::new&#160;&#160;and holding the sender in the<br/>
ThreadPool&#160;&#160;instance, as shown in Listing 20-16. The&#160;&#160;Job&#160;&#160;struct doesn’t hold anything for<br/>
now but will be the type of item we’re sending down the channel.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
583/627<br/>
<hr/>
<a name=584></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::{sync::mpsc,&#160;thread};<br/>
pub&#160;struct&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;workers:&#160;Vec&lt;Worker&gt;,<br/>&#160;&#160;&#160;&#160;sender:&#160;mpsc::Sender&lt;Job&gt;,<br/>}<br/>
struct&#160;Job;<br/>
impl&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(size:&#160;usize)&#160;-&gt;&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert!(size&#160;&gt;&#160;0);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;(sender,&#160;receiver)&#160;=&#160;mpsc::channel();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;workers&#160;=&#160;Vec::with_capacity(size);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;id&#160;in&#160;0..size&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;workers.push(Worker::new(id));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ThreadPool&#160;{&#160;workers,&#160;sender&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
<b>Listing&#160;20-16:&#160;Modifying&#160;&#160;</b>ThreadPool&#160;<b>&#160;to&#160;store&#160;the&#160;sender&#160;of&#160;a&#160;channel&#160;that&#160;transmits&#160;&#160;</b>Job&#160;<b>&#160;instances</b><br/>
In&#160;&#160;ThreadPool::new&#160;, we create our new channel and have the pool hold the sender. This<br/>will successfully compile.<br/>
Let’s try passing a receiver of the channel into each worker as the thread pool creates the<br/>channel. We know we want to use the receiver in the thread that the workers spawn, so we’ll<br/>reference the&#160;&#160;receiver&#160;&#160;parameter in the closure. The code in Listing 20-17 won’t quite<br/>compile yet.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
584/627<br/>
<hr/>
<a name=585></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
impl&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(size:&#160;usize)&#160;-&gt;&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert!(size&#160;&gt;&#160;0);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;(sender,&#160;receiver)&#160;=&#160;mpsc::channel();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;workers&#160;=&#160;Vec::with_capacity(size);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;id&#160;in&#160;0..size&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;workers.push(Worker::new(id,&#160;receiver));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ThreadPool&#160;{&#160;workers,&#160;sender&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
//&#160;--snip--<br/>
impl&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;new(id:&#160;usize,&#160;receiver:&#160;mpsc::Receiver&lt;Job&gt;)&#160;-&gt;&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;thread&#160;=&#160;thread::spawn(||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;receiver;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Worker&#160;{&#160;id,&#160;thread&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;20-17:&#160;Passing&#160;the&#160;receiver&#160;to&#160;the&#160;workers</b><br/>
We’ve made some small and straightforward changes: we pass the receiver into<br/>
Worker::new&#160;, and then we use it inside the closure.<br/>
When we try to check this code, we get this error:<br/>
$&#160;cargo&#160;check<br/>&#160;&#160;&#160;&#160;Checking&#160;hello&#160;v0.1.0&#160;(file:///projects/hello)<br/>error[E0382]:&#160;use&#160;of&#160;moved&#160;value:&#160;`receiver`<br/>&#160;&#160;--&gt;&#160;src/lib.rs:26:42<br/>&#160;&#160;&#160;|<br/>21&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;(sender,&#160;receiver)&#160;=&#160;mpsc::channel();<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;--------&#160;move&#160;occurs&#160;because&#160;`receiver`&#160;has&#160;type&#160;<br/>`std::sync::mpsc::Receiver&lt;Job&gt;`,&#160;which&#160;does&#160;not&#160;implement&#160;the&#160;`Copy`&#160;trait<br/>...<br/>26&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;workers.push(Worker::new(id,&#160;receiver));<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^&#160;value&#160;moved&#160;here,&#160;in&#160;<br/>previous&#160;iteration&#160;of&#160;loop<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0382`.<br/>error:&#160;could&#160;not&#160;compile&#160;`hello`&#160;due&#160;to&#160;previous&#160;error<br/>
https://doc.rust-lang.org/book/print.html<br/>
585/627<br/>
<hr/>
<a name=586></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The code is trying to pass&#160;&#160;receiver&#160;&#160;to multiple&#160;&#160;Worker&#160;&#160;instances. This won’t work, as you’ll<br/>recall from Chapter 16: the channel implementation that Rust provides is multiple&#160;<i>producer</i>,<br/>single&#160;<i>consumer</i>. This means we can’t just clone the consuming end of the channel to&#160;ﬁx this<br/>code. We also don’t want to send a message multiple times to multiple consumers; we want<br/>one list of messages with multiple workers such that each message gets processed once.<br/>
Additionally, taking a job oﬀ&#160;the channel queue involves mutating the&#160;&#160;receiver&#160;, so the<br/>threads need a safe way to share and modify&#160;&#160;receiver&#160;; otherwise, we might get race<br/>conditions (as covered in Chapter 16).<br/>
Recall the thread-safe smart pointers discussed in Chapter 16: to share ownership across<br/>multiple threads and allow the threads to mutate the value, we need to use&#160;&#160;Arc&lt;Mutex&lt;T&gt;&gt;&#160;.<br/>The&#160;&#160;Arc&#160;&#160;type will let multiple workers own the receiver, and&#160;&#160;Mutex&#160;&#160;will ensure that only<br/>one worker gets a job from the receiver at a time. Listing 20-18 shows the changes we need<br/>to make.<br/>
Filename: src/lib.rs<br/>
use&#160;std::{<br/>&#160;&#160;&#160;&#160;sync::{mpsc,&#160;Arc,&#160;Mutex},<br/>&#160;&#160;&#160;&#160;thread,<br/>};<br/>//&#160;--snip--<br/>
impl&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(size:&#160;usize)&#160;-&gt;&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert!(size&#160;&gt;&#160;0);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;(sender,&#160;receiver)&#160;=&#160;mpsc::channel();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;receiver&#160;=&#160;Arc::new(Mutex::new(receiver));<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;workers&#160;=&#160;Vec::with_capacity(size);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;id&#160;in&#160;0..size&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;workers.push(Worker::new(id,&#160;Arc::clone(&amp;receiver)));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ThreadPool&#160;{&#160;workers,&#160;sender&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;//&#160;--snip--<br/>}<br/>
//&#160;--snip--<br/>
impl&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;new(id:&#160;usize,&#160;receiver:&#160;Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;)&#160;-&gt;&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
586/627<br/>
<hr/>
<a name=587></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Listing&#160;20-18:&#160;Sharing&#160;the&#160;receiver&#160;among&#160;the&#160;workers&#160;using&#160;&#160;</b>Arc&#160;<b>&#160;and&#160;&#160;</b>Mutex<br/>
In&#160;&#160;ThreadPool::new&#160;, we put the receiver in an&#160;&#160;Arc&#160;&#160;and a&#160;&#160;Mutex&#160;. For each new worker, we<br/>clone the&#160;&#160;Arc&#160;&#160;to bump the reference count so the workers can share ownership of the<br/>receiver.<br/>
With these changes, the code compiles! We’re getting there!<br/>
<a href="tests.html#587"><b>Implementing the&#160;</b>execute<b>&#160;Method</b></a><br/>
Let’s&#160;ﬁnally implement the&#160;&#160;execute&#160;&#160;method on&#160;&#160;ThreadPool&#160;. We’ll also change&#160;&#160;Job&#160;&#160;from a<br/>struct to a type alias for a trait object that holds the type of closure that&#160;&#160;execute&#160;&#160;receives.<br/>As discussed in the&#160;<a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">“Creating Type Synonyms with Type Aliases”&#160;section of Chapter 19, type<br/></a>aliases allow us to make long types shorter for ease of use. Look at Listing 20-19.<br/>
Filename: src/lib.rs<br/>
//&#160;--snip--<br/>
type&#160;Job&#160;=&#160;Box&lt;dyn&#160;FnOnce()&#160;+&#160;Send&#160;+&#160;'static&gt;;<br/>
impl&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;pub&#160;fn&#160;execute&lt;F&gt;(&amp;self,&#160;f:&#160;F)<br/>&#160;&#160;&#160;&#160;where<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F:&#160;FnOnce()&#160;+&#160;Send&#160;+&#160;'static,<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;job&#160;=&#160;Box::new(f);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.sender.send(job).unwrap();<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
//&#160;--snip--<br/>
<b>Listing&#160;20-19:&#160;Creating&#160;a&#160;&#160;</b>Job&#160;<b>&#160;type&#160;alias&#160;for&#160;a&#160;&#160;</b>Box&#160;<b>&#160;that&#160;holds&#160;each&#160;closure&#160;and&#160;then&#160;sending&#160;the&#160;job&#160;down&#160;the<br/>channel</b><br/>
After creating a new&#160;&#160;Job&#160;&#160;instance using the closure we get in&#160;&#160;execute&#160;, we send that job<br/>down the sending end of the channel. We’re calling&#160;&#160;unwrap&#160;&#160;on&#160;&#160;send&#160;&#160;for the case that<br/>sending fails. This might happen if, for example, we stop all our threads from executing,<br/>meaning the receiving end has stopped receiving new messages. At the moment, we can’t<br/>stop our threads from executing: our threads continue executing as long as the pool exists.<br/>The reason we use&#160;&#160;unwrap&#160;&#160;is that we know the failure case won’t happen, but the compiler<br/>doesn’t know that.<br/>
But we’re not quite done yet! In the worker, our closure being passed to&#160;&#160;thread::spawn&#160;&#160;still<br/>only&#160;<i>references</i>&#160;the receiving end of the channel. Instead, we need the closure to loop<br/>
https://doc.rust-lang.org/book/print.html<br/>
587/627<br/>
<hr/>
<a name=588></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
forever, asking the receiving end of the channel for a job and running the job when it gets<br/>one. Let’s make the change shown in Listing 20-20 to&#160;&#160;Worker::new&#160;.<br/>
Filename: src/lib.rs<br/>
//&#160;--snip--<br/>
impl&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;new(id:&#160;usize,&#160;receiver:&#160;Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;)&#160;-&gt;&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;thread&#160;=&#160;thread::spawn(move&#160;||&#160;loop&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;job&#160;=&#160;receiver.lock().unwrap().recv().unwrap();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Worker&#160;{id}&#160;got&#160;a&#160;job;&#160;executing.&#34;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;job();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Worker&#160;{&#160;id,&#160;thread&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;20-20:&#160;Receiving&#160;and&#160;executing&#160;the&#160;jobs&#160;in&#160;the&#160;worker’s&#160;thread</b><br/>
Here, we&#160;ﬁrst call&#160;&#160;lock&#160;&#160;on the&#160;&#160;receiver&#160;&#160;to acquire the mutex, and then we call&#160;&#160;unwrap&#160;&#160;to<br/>panic on any errors. Acquiring a lock might fail if the mutex is in a&#160;<i>poisoned</i>&#160;state, which can<br/>happen if some other thread panicked while holding the lock rather than releasing the lock.<br/>In this situation, calling&#160;&#160;unwrap&#160;&#160;to have this thread panic is the correct action to take. Feel<br/>free to change this&#160;&#160;unwrap&#160;&#160;to an&#160;&#160;expect&#160;&#160;with an error message that is meaningful to you.<br/>
If we get the lock on the mutex, we call&#160;&#160;recv&#160;&#160;to receive a&#160;&#160;Job&#160;&#160;from the channel. A&#160;ﬁnal<br/>
unwrap&#160;&#160;moves past any errors here as well, which might occur if the thread holding the<br/>
sender has shut down, similar to how the&#160;&#160;send&#160;&#160;method returns&#160;&#160;Err&#160;&#160;if the receiver shuts<br/>down.<br/>
The call to&#160;&#160;recv&#160;&#160;blocks, so if there is no job yet, the current thread will wait until a job<br/>becomes available. The&#160;&#160;Mutex&lt;T&gt;&#160;&#160;ensures that only one&#160;&#160;Worker&#160;&#160;thread at a time is trying<br/>to request a job.<br/>
Our thread pool is now in a working state! Give it a&#160;&#160;cargo&#160;run&#160;&#160;and make some requests:<br/>
https://doc.rust-lang.org/book/print.html<br/>
588/627<br/>
<hr/>
<a name=589></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;hello&#160;v0.1.0&#160;(file:///projects/hello)<br/>warning:&#160;field&#160;is&#160;never&#160;read:&#160;`workers`<br/>&#160;--&gt;&#160;src/lib.rs:7:5<br/>&#160;&#160;|<br/>7&#160;|&#160;&#160;&#160;&#160;&#160;workers:&#160;Vec&lt;Worker&gt;,<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^^^^^<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;`#[warn(dead_code)]`&#160;on&#160;by&#160;default<br/>
warning:&#160;field&#160;is&#160;never&#160;read:&#160;`id`<br/>&#160;&#160;--&gt;&#160;src/lib.rs:48:5<br/>&#160;&#160;&#160;|<br/>48&#160;|&#160;&#160;&#160;&#160;&#160;id:&#160;usize,<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^<br/>
warning:&#160;field&#160;is&#160;never&#160;read:&#160;`thread`<br/>&#160;&#160;--&gt;&#160;src/lib.rs:49:5<br/>&#160;&#160;&#160;|<br/>49&#160;|&#160;&#160;&#160;&#160;&#160;thread:&#160;thread::JoinHandle&lt;()&gt;,<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br/>
warning:&#160;`hello`&#160;(lib)&#160;generated&#160;3&#160;warnings<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;1.40s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/hello`<br/>Worker&#160;0&#160;got&#160;a&#160;job;&#160;executing.<br/>Worker&#160;2&#160;got&#160;a&#160;job;&#160;executing.<br/>Worker&#160;1&#160;got&#160;a&#160;job;&#160;executing.<br/>Worker&#160;3&#160;got&#160;a&#160;job;&#160;executing.<br/>Worker&#160;0&#160;got&#160;a&#160;job;&#160;executing.<br/>Worker&#160;2&#160;got&#160;a&#160;job;&#160;executing.<br/>Worker&#160;1&#160;got&#160;a&#160;job;&#160;executing.<br/>Worker&#160;3&#160;got&#160;a&#160;job;&#160;executing.<br/>Worker&#160;0&#160;got&#160;a&#160;job;&#160;executing.<br/>Worker&#160;2&#160;got&#160;a&#160;job;&#160;executing.<br/>
Success! We now have a thread pool that executes connections asynchronously. There are<br/>never more than four threads created, so our system won’t get overloaded if the server<br/>receives a lot of requests. If we make a request to&#160;<i>/sleep</i>, the server will be able to serve<br/>other requests by having another thread run them.<br/>
Note: if you open&#160;<i>/sleep</i>&#160;in multiple browser windows simultaneously, they might load<br/>one at a time in 5 second intervals. Some web browsers execute multiple instances of<br/>the same request sequentially for caching reasons. This limitation is not caused by our<br/>web server.<br/>
After learning about the&#160;&#160;while&#160;let&#160;&#160;loop in Chapter 18, you might be wondering why we<br/>didn’t write the worker thread code as shown in Listing 20-21.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
589/627<br/>
<hr/>
<a name=590></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
//&#160;--snip--<br/>
impl&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;new(id:&#160;usize,&#160;receiver:&#160;Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;)&#160;-&gt;&#160;Wor<a href="https://doc.rust-lang.org/book/ch00-00-introduction.html#ferris">ker&#160;{<br/></a>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;thread&#160;=&#160;thread::spawn(move&#160;||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while&#160;let&#160;Ok(job)&#160;=&#160;receiver.lock().unwrap().recv()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Worker&#160;{id}&#160;got&#160;a&#160;job;&#160;executing.&#34;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;job();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Worker&#160;{&#160;id,&#160;thread&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;20-21:&#160;An&#160;alternative&#160;implementation&#160;of&#160;&#160;</b>Worker::new&#160;<b>&#160;using&#160;&#160;</b>while&#160;let<br/>
This code compiles and runs but doesn’t result in the desired threading behavior: a slow<br/>request will still cause other requests to wait to be processed. The reason is somewhat<br/>subtle: the&#160;&#160;Mutex&#160;&#160;struct has no public&#160;&#160;unlock&#160;&#160;method because the ownership of the lock is<br/>based on the lifetime of the&#160;&#160;MutexGuard&lt;T&gt;&#160;&#160;within the&#160;&#160;LockResult&lt;MutexGuard&lt;T&gt;&gt;&#160;&#160;that<br/>the&#160;&#160;lock&#160;&#160;method returns. At compile time, the borrow checker can then enforce the rule<br/>that a resource guarded by a&#160;&#160;Mutex&#160;&#160;cannot be accessed unless we hold the lock. However,<br/>this implementation can also result in the lock being held longer than intended if we aren’t<br/>mindful of the lifetime of the&#160;&#160;MutexGuard&lt;T&gt;&#160;.<br/>
The code in Listing 20-20 that uses&#160;&#160;let&#160;job&#160;=&#160;<br/>receiver.lock().unwrap().recv().unwrap();&#160;&#160;works because with&#160;&#160;let&#160;, any temporary<br/>values used in the expression on the right hand side of the equals sign are immediately<br/>dropped when the&#160;&#160;let&#160;&#160;statement ends. However,&#160;&#160;while&#160;let&#160;&#160;(and&#160;&#160;if&#160;let&#160;&#160;and&#160;&#160;match&#160;)<br/>does not drop temporary values until the end of the associated block. In Listing 20-21, the<br/>lock remains held for the duration of the call to&#160;&#160;job()&#160;, meaning other workers cannot<br/>receive jobs.<br/>
https://doc.rust-lang.org/book/print.html<br/>
590/627<br/>
<hr/>
<a name=591></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#591"><b>Graceful Shutdown and Cleanup</b></a><br/>
The code in Listing 20-20 is responding to requests asynchronously through the use of a<br/>thread pool, as we intended. We get some warnings about the&#160;&#160;workers&#160;,&#160;&#160;id&#160;, and&#160;&#160;thread<br/>ﬁelds that we’re not using in a direct way that reminds us we’re not cleaning up anything.<br/>When we use the less elegant&#160;ctrl-c&#160;method to halt the main thread, all other threads are<br/>stopped immediately as well, even if they’re in the middle of serving a request.<br/>
Next, then, we’ll implement the&#160;&#160;Drop&#160;&#160;trait to call&#160;&#160;join&#160;&#160;on each of the threads in the pool so<br/>they can&#160;ﬁnish the requests they’re working on before closing. Then we’ll implement a way<br/>to tell the threads they should stop accepting new requests and shut down. To see this code<br/>in action, we’ll modify our server to accept only two requests before gracefully shutting<br/>down its thread pool.<br/>
<a href="tests.html#591"><b>Implementing&#160;the&#160;</b>Drop<b>&#160;Trait&#160;on&#160;</b>ThreadPool</a><br/>
Let’s start with implementing&#160;&#160;Drop&#160;&#160;on our thread pool. When the pool is dropped, our<br/>threads should all join to make sure they&#160;ﬁnish their work. Listing 20-22 shows a&#160;ﬁrst<br/>attempt at a&#160;&#160;Drop&#160;&#160;implementation; this code won’t quite work yet.<br/>
Filename: src/lib.rs<br/>
impl&#160;Drop&#160;for&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;drop(&amp;mut&#160;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;worker&#160;in&#160;&amp;mut&#160;self.workers&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Shutting&#160;down&#160;worker&#160;{}&#34;,&#160;worker.id);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;worker.thread.join().unwrap();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;20-22:&#160;Joining&#160;each&#160;thread&#160;when&#160;the&#160;thread&#160;pool&#160;goes&#160;out&#160;of&#160;scope</b><br/>
First, we loop through each of the thread pool&#160;&#160;workers&#160;. We use&#160;&#160;&amp;mut&#160;&#160;for this because<br/>
self&#160;&#160;is a mutable reference, and we also need to be able to mutate&#160;&#160;worker&#160;. For each<br/>
worker, we print a message saying that this particular worker is shutting down, and then we<br/>call&#160;&#160;join&#160;&#160;on that worker’s thread. If the call to&#160;&#160;join&#160;&#160;fails, we use&#160;&#160;unwrap&#160;&#160;to make Rust<br/>panic and go into an ungraceful shutdown.<br/>
Here is the error we get when we compile this code:<br/>
https://doc.rust-lang.org/book/print.html<br/>
591/627<br/>
<hr/>
<a name=592></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;check<br/>&#160;&#160;&#160;&#160;Checking&#160;hello&#160;v0.1.0&#160;(file:///projects/hello)<br/>error[E0507]:&#160;cannot&#160;move&#160;out&#160;of&#160;`worker.thread`&#160;which&#160;is&#160;behind&#160;a&#160;mutable&#160;<br/>reference<br/>&#160;&#160;--&gt;&#160;src/lib.rs:52:13<br/>&#160;&#160;&#160;|<br/>52&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;worker.thread.join().unwrap();<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^^^^^^^^&#160;------&#160;`worker.thread`&#160;moved&#160;due&#160;to&#160;this&#160;method&#160;<br/>call<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;move&#160;occurs&#160;because&#160;`worker.thread`&#160;has&#160;type&#160;`JoinHandle&lt;()&gt;`,&#160;<br/>which&#160;does&#160;not&#160;implement&#160;the&#160;`Copy`&#160;trait<br/>&#160;&#160;&#160;|<br/>note:&#160;this&#160;function&#160;takes&#160;ownership&#160;of&#160;the&#160;receiver&#160;`self`,&#160;which&#160;moves&#160;<br/>`worker.thread`<br/>&#160;&#160;--&gt;&#160;<br/>/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/mod.rs:1<br/>581:17<br/>
For&#160;more&#160;information&#160;about&#160;this&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0507`.<br/>error:&#160;could&#160;not&#160;compile&#160;`hello`&#160;due&#160;to&#160;previous&#160;error<br/>
The error tells us we can’t call&#160;&#160;join&#160;&#160;because we only have a mutable borrow of each<br/>
worker&#160;&#160;and&#160;&#160;join&#160;&#160;takes ownership of its argument. To solve this issue, we need to move<br/>
the thread out of the&#160;&#160;Worker&#160;&#160;instance that owns&#160;&#160;thread&#160;&#160;so&#160;&#160;join&#160;&#160;can consume the thread.<br/>We did this in Listing 17-15: if&#160;&#160;Worker&#160;&#160;holds an&#160;&#160;Option&lt;thread::JoinHandle&lt;()&gt;&gt;&#160;&#160;instead,<br/>we can call the&#160;&#160;take&#160;&#160;method on the&#160;&#160;Option&#160;&#160;to move the value out of the&#160;&#160;Some&#160;&#160;variant and<br/>leave a&#160;&#160;None&#160;&#160;variant in its place. In other words, a&#160;&#160;Worker&#160;&#160;that is running will have a&#160;&#160;Some<br/>variant in&#160;&#160;thread&#160;, and when we want to clean up a&#160;&#160;Worker&#160;, we’ll replace&#160;&#160;Some&#160;&#160;with&#160;&#160;None<br/>so the&#160;&#160;Worker&#160;&#160;doesn’t have a thread to run.<br/>
So we know we want to update the deﬁnition of&#160;&#160;Worker&#160;&#160;like this:<br/>
Filename: src/lib.rs<br/>
struct&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;id:&#160;usize,<br/>&#160;&#160;&#160;&#160;thread:&#160;Option&lt;thread::JoinHandle&lt;()&gt;&gt;,<br/>}<br/>
Now let’s lean on the compiler to&#160;ﬁnd the other places that need to change. Checking this<br/>code, we get two errors:<br/>
https://doc.rust-lang.org/book/print.html<br/>
592/627<br/>
<hr/>
<a name=593></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;cargo&#160;check<br/>&#160;&#160;&#160;&#160;Checking&#160;hello&#160;v0.1.0&#160;(file:///projects/hello)<br/>error[E0599]:&#160;no&#160;method&#160;named&#160;`join`&#160;found&#160;for&#160;enum&#160;`Option`&#160;in&#160;the&#160;current&#160;<br/>scope<br/>&#160;&#160;--&gt;&#160;src/lib.rs:52:27<br/>&#160;&#160;&#160;|<br/>52&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;worker.thread.join().unwrap();<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^&#160;method&#160;not&#160;found&#160;in&#160;<br/>`Option&lt;JoinHandle&lt;()&gt;&gt;`<br/>&#160;&#160;&#160;|<br/>note:&#160;the&#160;method&#160;`join`&#160;exists&#160;on&#160;the&#160;type&#160;`JoinHandle&lt;()&gt;`<br/>&#160;&#160;--&gt;&#160;<br/>/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/mod.rs:1<br/>581:5<br/>help:&#160;consider&#160;using&#160;`Option::expect`&#160;to&#160;unwrap&#160;the&#160;`JoinHandle&lt;()&gt;`&#160;value,&#160;<br/>panicking&#160;if&#160;the&#160;value&#160;is&#160;an&#160;`Option::None`<br/>&#160;&#160;&#160;|<br/>52&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;worker.thread.expect(&#34;REASON&#34;).join().unwrap();<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+++++++++++++++++<br/>
error[E0308]:&#160;mismatched&#160;types<br/>&#160;&#160;--&gt;&#160;src/lib.rs:72:22<br/>&#160;&#160;&#160;|<br/>72&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Worker&#160;{&#160;id,&#160;thread&#160;}<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^&#160;expected&#160;enum&#160;`Option`,&#160;found&#160;struct&#160;<br/>`JoinHandle`<br/>&#160;&#160;&#160;|<br/>&#160;&#160;&#160;=&#160;note:&#160;expected&#160;enum&#160;`Option&lt;JoinHandle&lt;()&gt;&gt;`<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;found&#160;struct&#160;`JoinHandle&lt;_&gt;`<br/>help:&#160;try&#160;wrapping&#160;the&#160;expression&#160;in&#160;`Some`<br/>&#160;&#160;&#160;|<br/>72&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Worker&#160;{&#160;id,&#160;thread:&#160;Some(thread)&#160;}<br/>&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+++++++++++++&#160;&#160;&#160;&#160;&#160;&#160;+<br/>
Some&#160;errors&#160;have&#160;detailed&#160;explanations:&#160;E0308,&#160;E0599.<br/>For&#160;more&#160;information&#160;about&#160;an&#160;error,&#160;try&#160;`rustc&#160;--explain&#160;E0308`.<br/>error:&#160;could&#160;not&#160;compile&#160;`hello`&#160;due&#160;to&#160;2&#160;previous&#160;errors<br/>
Let’s address the second error, which points to the code at the end of&#160;&#160;Worker::new&#160;; we<br/>need to wrap the&#160;&#160;thread&#160;&#160;value in&#160;&#160;Some&#160;&#160;when we create a new&#160;&#160;Worker&#160;. Make the following<br/>changes to&#160;ﬁx this error:<br/>
Filename: src/lib.rs<br/>
impl&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;new(id:&#160;usize,&#160;receiver:&#160;Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;)&#160;-&gt;&#160;Wor<a href="https://doc.rust-lang.org/book/ch00-00-introduction.html#ferris">ker&#160;{<br/></a>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;id,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread:&#160;Some(thread),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
593/627<br/>
<hr/>
<a name=594></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The&#160;ﬁrst error is in our&#160;&#160;Drop&#160;&#160;implementation. We mentioned earlier that we intended to call<br/>
take&#160;&#160;on the&#160;&#160;Option&#160;&#160;value to move&#160;&#160;thread&#160;&#160;out of&#160;&#160;worker&#160;. The following changes will do<br/>
so:<br/>
Filename: src/lib.rs<br/>
impl&#160;Drop&#160;for&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;drop(&amp;mut&#160;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;worker&#160;in&#160;&amp;mut&#160;self.workers&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Shutting&#160;down&#160;worker&#160;{}&#34;,&#160;worker.id);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;let&#160;Some(thread)&#160;=&#160;worker.thread.take()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread.join().unwrap();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
As discussed in Chapter 17, the&#160;&#160;take&#160;&#160;method on&#160;&#160;Option&#160;&#160;takes the&#160;&#160;Some&#160;&#160;variant out and<br/>leaves&#160;&#160;None&#160;&#160;in its place. We’re using&#160;&#160;if&#160;let&#160;&#160;to destructure the&#160;&#160;Some&#160;&#160;and get the thread;<br/>then we call&#160;&#160;join&#160;&#160;on the thread. If a worker’s thread is already&#160;&#160;None&#160;, we know that worker<br/>has already had its thread cleaned up, so nothing happens in that case.<br/>
<a href="tests.html#594"><b>Signaling&#160;to&#160;the&#160;Threads&#160;to&#160;Stop&#160;Listening&#160;for&#160;Jobs</b></a><br/>
With all the changes we’ve made, our code compiles without any warnings. However, the<br/>bad news is this code doesn’t function the way we want it to yet. The key is the logic in the<br/>closures run by the threads of the&#160;&#160;Worker&#160;&#160;instances: at the moment, we call&#160;&#160;join&#160;, but that<br/>won’t shut down the threads because they&#160;&#160;loop&#160;&#160;forever looking for jobs. If we try to drop<br/>our&#160;&#160;ThreadPool&#160;&#160;with our current implementation of&#160;&#160;drop&#160;, the main thread will block<br/>forever waiting for the&#160;ﬁrst thread to&#160;ﬁnish.<br/>
To&#160;ﬁx this problem, we’ll need a change in the&#160;&#160;ThreadPool&#160;&#160;&#160;drop&#160;&#160;implementation and then<br/>a change in the&#160;&#160;Worker&#160;&#160;loop.<br/>
First, we’ll change the&#160;&#160;ThreadPool&#160;&#160;&#160;drop&#160;&#160;implementation to explicitly drop the&#160;&#160;sender<br/>before waiting for the threads to&#160;ﬁnish. Listing 20-23 shows the changes to&#160;&#160;ThreadPool&#160;&#160;to<br/>explicitly drop&#160;&#160;sender&#160;. We use the same&#160;&#160;Option&#160;&#160;and&#160;&#160;take&#160;&#160;technique as we did with the<br/>thread to be able to move&#160;&#160;sender&#160;&#160;out of&#160;&#160;ThreadPool&#160;:<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
594/627<br/>
<hr/>
<a name=595></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
pub&#160;struct&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;workers:&#160;Vec&lt;Worker&gt;,<br/>&#160;&#160;&#160;&#160;sender:&#160;Option&lt;mpsc::Sender&lt;Job&gt;&gt;,<br/>}<br/>//&#160;--snip--<br/>impl&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(size:&#160;usize)&#160;-&gt;&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;--snip--<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;workers,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sender:&#160;Some(sender),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;pub&#160;fn&#160;execute&lt;F&gt;(&amp;self,&#160;f:&#160;F)<br/>&#160;&#160;&#160;&#160;where<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F:&#160;FnOnce()&#160;+&#160;Send&#160;+&#160;'static,<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;job&#160;=&#160;Box::new(f);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.sender.as_ref().unwrap().send(job).unwrap();<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
impl&#160;Drop&#160;for&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;drop(&amp;mut&#160;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drop(self.sender.take());<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;worker&#160;in&#160;&amp;mut&#160;self.workers&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Shutting&#160;down&#160;worker&#160;{}&#34;,&#160;worker.id);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;let&#160;Some(thread)&#160;=&#160;worker.thread.take()&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread.join().unwrap();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;20-23:&#160;Explicitly&#160;drop&#160;&#160;</b>sender&#160;<b>&#160;before&#160;joining&#160;the&#160;worker&#160;threads</b><br/>
Dropping&#160;&#160;sender&#160;&#160;closes the channel, which indicates no more messages will be sent. When<br/>that happens, all the calls to&#160;&#160;recv&#160;&#160;that the workers do in the inﬁnite loop will return an<br/>error. In Listing 20-24, we change the&#160;&#160;Worker&#160;&#160;loop to gracefully exit the loop in that case,<br/>which means the threads will&#160;ﬁnish when the&#160;&#160;ThreadPool&#160;&#160;&#160;drop&#160;&#160;implementation calls&#160;&#160;join<br/>on them.<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
595/627<br/>
<hr/>
<a name=596></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
impl&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;new(id:&#160;usize,&#160;receiver:&#160;Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;)&#160;-&gt;&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;thread&#160;=&#160;thread::spawn(move&#160;||&#160;loop&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;message&#160;=&#160;receiver.lock().unwrap().recv();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;message&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(job)&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Worker&#160;{id}&#160;got&#160;a&#160;job;&#160;executing.&#34;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;job();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(_)&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Worker&#160;{id}&#160;disconnected;&#160;shutting&#160;down.&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;id,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread:&#160;Some(thread),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
<b>Listing&#160;20-24:&#160;Explicitly&#160;break&#160;out&#160;of&#160;the&#160;loop&#160;when&#160;&#160;</b>recv&#160;<b>&#160;returns&#160;an&#160;error</b><br/>
To see this code in action, let’s modify&#160;&#160;main&#160;&#160;to accept only two requests before gracefully<br/>shutting down the server, as shown in Listing 20-25.<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;listener&#160;=&#160;TcpListener::bind(&#34;127.0.0.1:7878&#34;).unwrap();<br/>&#160;&#160;&#160;&#160;let&#160;pool&#160;=&#160;ThreadPool::new(4);<br/>
&#160;&#160;&#160;&#160;for&#160;stream&#160;in&#160;listener.incoming().take(2)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;stream&#160;=&#160;stream.unwrap();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pool.execute(||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handle_connection(stream);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;Shutting&#160;down.&#34;);<br/>}<br/>
<b>Listing&#160;20-25:&#160;Shut&#160;down&#160;the&#160;server&#160;after&#160;serving&#160;two&#160;requests&#160;by&#160;exiting&#160;the&#160;loop</b><br/>
You wouldn’t want a real-world web server to shut down after serving only two requests.<br/>This code just demonstrates that the graceful shutdown and cleanup is in working order.<br/>
https://doc.rust-lang.org/book/print.html<br/>
596/627<br/>
<hr/>
<a name=597></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
The&#160;&#160;take&#160;&#160;method is deﬁned in the&#160;&#160;Iterator&#160;&#160;trait and limits the iteration to the&#160;ﬁrst two<br/>items at most. The&#160;&#160;ThreadPool&#160;&#160;will go out of scope at the end of&#160;&#160;main&#160;, and the&#160;&#160;drop<br/>implementation will run.<br/>
Start the server with&#160;&#160;cargo&#160;run&#160;, and make three requests. The third request should error,<br/>and in your terminal you should see output similar to this:<br/>
$&#160;cargo&#160;run<br/>&#160;&#160;&#160;Compiling&#160;hello&#160;v0.1.0&#160;(file:///projects/hello)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;1.0s<br/>&#160;&#160;&#160;&#160;&#160;Running&#160;`target/debug/hello`<br/>Worker&#160;0&#160;got&#160;a&#160;job;&#160;executing.<br/>Shutting&#160;down.<br/>Shutting&#160;down&#160;worker&#160;0<br/>Worker&#160;3&#160;got&#160;a&#160;job;&#160;executing.<br/>Worker&#160;1&#160;disconnected;&#160;shutting&#160;down.<br/>Worker&#160;2&#160;disconnected;&#160;shutting&#160;down.<br/>Worker&#160;3&#160;disconnected;&#160;shutting&#160;down.<br/>Worker&#160;0&#160;disconnected;&#160;shutting&#160;down.<br/>Shutting&#160;down&#160;worker&#160;1<br/>Shutting&#160;down&#160;worker&#160;2<br/>Shutting&#160;down&#160;worker&#160;3<br/>
You might see a diﬀerent ordering of workers and messages printed. We can see how this<br/>code works from the messages: workers 0 and 3 got the&#160;ﬁrst two requests. The server<br/>stopped accepting connections after the second connection, and the&#160;&#160;Drop&#160;&#160;implementation<br/>on&#160;&#160;ThreadPool&#160;&#160;starts executing before worker 3 even starts its job. Dropping the&#160;&#160;sender<br/>disconnects all the workers and tells them to shut down. The workers each print a message<br/>when they disconnect, and then the thread pool calls&#160;&#160;join&#160;&#160;to wait for each worker thread<br/>to&#160;ﬁnish.<br/>
Notice one interesting aspect of this particular execution: the&#160;&#160;ThreadPool&#160;&#160;dropped the<br/>
sender&#160;, and before any worker received an error, we tried to join worker 0. Worker 0 had<br/>
not yet gotten an error from&#160;&#160;recv&#160;, so the main thread blocked waiting for worker 0 to<br/>ﬁnish. In the meantime, worker 3 received a job and then all threads received an error.<br/>When worker 0&#160;ﬁnished, the main thread waited for the rest of the workers to&#160;ﬁnish. At that<br/>point, they had all exited their loops and stopped.<br/>
Congrats! We’ve now completed our project; we have a basic web server that uses a thread<br/>pool to respond asynchronously. We’re able to perform a graceful shutdown of the server,<br/>which cleans up all the threads in the pool.<br/>
Here’s the full code for reference:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
597/627<br/>
<hr/>
<a name=598></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;hello::ThreadPool;<br/>use&#160;std::fs;<br/>use&#160;std::io::prelude::*;<br/>use&#160;std::net::TcpListener;<br/>use&#160;std::net::TcpStream;<br/>use&#160;std::thread;<br/>use&#160;std::time::Duration;<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;listener&#160;=&#160;TcpListener::bind(&#34;127.0.0.1:7878&#34;).unwrap();<br/>&#160;&#160;&#160;&#160;let&#160;pool&#160;=&#160;ThreadPool::new(4);<br/>
&#160;&#160;&#160;&#160;for&#160;stream&#160;in&#160;listener.incoming().take(2)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;stream&#160;=&#160;stream.unwrap();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pool.execute(||&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handle_connection(stream);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;println!(&#34;Shutting&#160;down.&#34;);<br/>}<br/>
fn&#160;handle_connection(mut&#160;stream:&#160;TcpStream)&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;mut&#160;buffer&#160;=&#160;[0;&#160;1024];<br/>&#160;&#160;&#160;&#160;stream.read(&amp;mut&#160;buffer).unwrap();<br/>
&#160;&#160;&#160;&#160;let&#160;get&#160;=&#160;b&#34;GET&#160;/&#160;HTTP/1.1\r\n&#34;;<br/>&#160;&#160;&#160;&#160;let&#160;sleep&#160;=&#160;b&#34;GET&#160;/sleep&#160;HTTP/1.1\r\n&#34;;<br/>
&#160;&#160;&#160;&#160;let&#160;(status_line,&#160;filename)&#160;=&#160;if&#160;buffer.starts_with(get)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(&#34;HTTP/1.1&#160;200&#160;OK&#34;,&#160;&#34;hello.html&#34;)<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;if&#160;buffer.starts_with(sleep)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread::sleep(Duration::from_secs(5));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(&#34;HTTP/1.1&#160;200&#160;OK&#34;,&#160;&#34;hello.html&#34;)<br/>&#160;&#160;&#160;&#160;}&#160;else&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(&#34;HTTP/1.1&#160;404&#160;NOT&#160;FOUND&#34;,&#160;&#34;404.html&#34;)<br/>&#160;&#160;&#160;&#160;};<br/>
&#160;&#160;&#160;&#160;let&#160;contents&#160;=&#160;fs::read_to_string(filename).unwrap();<br/>
&#160;&#160;&#160;&#160;let&#160;response&#160;=&#160;format!(<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#34;{}\r\nContent-Length:&#160;{}\r\n\r\n{}&#34;,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;status_line,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;contents.len(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;contents<br/>&#160;&#160;&#160;&#160;);<br/>
&#160;&#160;&#160;&#160;stream.write_all(response.as_bytes()).unwrap();<br/>&#160;&#160;&#160;&#160;stream.flush().unwrap();<br/>}<br/>
Filename: src/lib.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
598/627<br/>
<hr/>
<a name=599></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
use&#160;std::{<br/>&#160;&#160;&#160;&#160;sync::{mpsc,&#160;Arc,&#160;Mutex},<br/>&#160;&#160;&#160;&#160;thread,<br/>};<br/>
pub&#160;struct&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;workers:&#160;Vec&lt;Worker&gt;,<br/>&#160;&#160;&#160;&#160;sender:&#160;Option&lt;mpsc::Sender&lt;Job&gt;&gt;,<br/>}<br/>
type&#160;Job&#160;=&#160;Box&lt;dyn&#160;FnOnce()&#160;+&#160;Send&#160;+&#160;'static&gt;;<br/>
impl&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;///&#160;Create&#160;a&#160;new&#160;ThreadPool.<br/>&#160;&#160;&#160;&#160;///<br/>&#160;&#160;&#160;&#160;///&#160;The&#160;size&#160;is&#160;the&#160;number&#160;of&#160;threads&#160;in&#160;the&#160;pool.<br/>&#160;&#160;&#160;&#160;///<br/>&#160;&#160;&#160;&#160;///&#160;#&#160;Panics<br/>&#160;&#160;&#160;&#160;///<br/>&#160;&#160;&#160;&#160;///&#160;The&#160;`new`&#160;function&#160;will&#160;panic&#160;if&#160;the&#160;size&#160;is&#160;zero.<br/>&#160;&#160;&#160;&#160;pub&#160;fn&#160;new(size:&#160;usize)&#160;-&gt;&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assert!(size&#160;&gt;&#160;0);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;(sender,&#160;receiver)&#160;=&#160;mpsc::channel();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;receiver&#160;=&#160;Arc::new(Mutex::new(receiver));<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;mut&#160;workers&#160;=&#160;Vec::with_capacity(size);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;id&#160;in&#160;0..size&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;workers.push(Worker::new(id,&#160;Arc::clone(&amp;receiver)));<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;workers,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sender:&#160;Some(sender),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>
&#160;&#160;&#160;&#160;pub&#160;fn&#160;execute&lt;F&gt;(&amp;self,&#160;f:&#160;F)<br/>&#160;&#160;&#160;&#160;where<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;F:&#160;FnOnce()&#160;+&#160;Send&#160;+&#160;'static,<br/>&#160;&#160;&#160;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;job&#160;=&#160;Box::new(f);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.sender.as_ref().unwrap().send(job).unwrap();<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
impl&#160;Drop&#160;for&#160;ThreadPool&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;drop(&amp;mut&#160;self)&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;drop(self.sender.take());<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for&#160;worker&#160;in&#160;&amp;mut&#160;self.workers&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Shutting&#160;down&#160;worker&#160;{}&#34;,&#160;worker.id);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;let&#160;Some(thread)&#160;=&#160;worker.thread.take()&#160;{<br/>
https://doc.rust-lang.org/book/print.html<br/>
599/627<br/>
<hr/>
<a name=600></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread.join().unwrap();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
struct&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;id:&#160;usize,<br/>&#160;&#160;&#160;&#160;thread:&#160;Option&lt;thread::JoinHandle&lt;()&gt;&gt;,<br/>}<br/>
impl&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;fn&#160;new(id:&#160;usize,&#160;receiver:&#160;Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;)&#160;-&gt;&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;thread&#160;=&#160;thread::spawn(move&#160;||&#160;loop&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;message&#160;=&#160;receiver.lock().unwrap().recv();<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;match&#160;message&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Ok(job)&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Worker&#160;{id}&#160;got&#160;a&#160;job;&#160;executing.&#34;);<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;job();<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Err(_)&#160;=&gt;&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;println!(&#34;Worker&#160;{id}&#160;disconnected;&#160;shutting&#160;down.&#34;);<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;});<br/>
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Worker&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;id,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;thread:&#160;Some(thread),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
We could do more here! If you want to continue enhancing this project, here are some<br/>ideas:<br/>
Add more documentation to&#160;&#160;ThreadPool&#160;&#160;and its public methods.<br/>Add tests of the library’s functionality.<br/>Change calls to&#160;&#160;unwrap&#160;&#160;to more robust error handling.<br/>Use&#160;&#160;ThreadPool&#160;&#160;to perform some task other than serving web requests.<br/><a href="https://crates.io/">Find a thread pool crate on&#160;crates.io</a>&#160;and implement a similar web server using the<br/>crate instead. Then compare its API and robustness to the thread pool we<br/>implemented.<br/>
https://doc.rust-lang.org/book/print.html<br/>
600/627<br/>
<hr/>
<a name=601></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#601"><b>Summary</b></a><br/>
Well done! You’ve made it to the end of the book! We want to thank you for joining us on<br/>this tour of Rust. You’re now ready to implement your own Rust projects and help with<br/>other peoples’ projects. Keep in mind that there is a welcoming community of other<br/>Rustaceans who would love to help you with any challenges you encounter on your Rust<br/>journey.<br/>
https://doc.rust-lang.org/book/print.html<br/>
601/627<br/>
<hr/>
<a name=602></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#602"><b>Appendix</b></a><br/>
The following sections contain reference material you may&#160;ﬁnd useful in your Rust journey.<br/>
https://doc.rust-lang.org/book/print.html<br/>
602/627<br/>
<hr/>
<a name=603></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#603"><b>Appendix A: Keywords</b></a><br/>
The following list contains keywords that are reserved for current or future use by the Rust<br/>language. As such, they cannot be used as identiﬁers (except as raw identiﬁers as we’ll<br/>discuss in the “<a href="https://doc.rust-lang.org/book/appendix-01-keywords.html#raw-identifiers">Raw Identiﬁers</a>” section). Identiﬁers are names of functions, variables,<br/>parameters, struct&#160;ﬁelds, modules, crates, constants, macros, static values, attributes, types,<br/>traits, or lifetimes.<br/>
<a href="tests.html#603"><b>Keywords&#160;Currently&#160;in&#160;Use</b></a><br/>
The following is a list of keywords currently in use, with their functionality described.<br/>
as&#160;&#160;- perform primitive casting, disambiguate the speciﬁc trait containing an item, or<br/>
rename items in&#160;&#160;use&#160;&#160;statements<br/>
async&#160;&#160;- return a&#160;&#160;Future&#160;&#160;instead of blocking the current thread<br/>await&#160;&#160;- suspend execution until the result of a&#160;&#160;Future&#160;&#160;is ready<br/>break&#160;&#160;- exit a loop immediately<br/>const&#160;&#160;- deﬁne constant items or constant raw pointers<br/>continue&#160;&#160;- continue to the next loop iteration<br/>crate&#160;&#160;- in a module path, refers to the crate root<br/>dyn&#160;&#160;- dynamic dispatch to a trait object<br/>else&#160;&#160;- fallback for&#160;&#160;if&#160;&#160;and&#160;&#160;if&#160;let&#160;&#160;control&#160;ﬂow constructs<br/>enum&#160;&#160;- deﬁne an enumeration<br/>extern&#160;&#160;- link an external function or variable<br/>false&#160;&#160;- Boolean false literal<br/>fn&#160;&#160;- deﬁne a function or the function pointer type<br/>for&#160;&#160;- loop over items from an iterator, implement a trait, or specify a higher-ranked<br/>
lifetime<br/>
if&#160;&#160;- branch based on the result of a conditional expression<br/>impl&#160;&#160;- implement inherent or trait functionality<br/>in&#160;&#160;- part of&#160;&#160;for&#160;&#160;loop syntax<br/>let&#160;&#160;- bind a variable<br/>loop&#160;&#160;- loop unconditionally<br/>match&#160;&#160;- match a value to patterns<br/>mod&#160;&#160;- deﬁne a module<br/>move&#160;&#160;- make a closure take ownership of all its captures<br/>mut&#160;&#160;- denote mutability in references, raw pointers, or pattern bindings<br/>pub&#160;&#160;- denote public visibility in struct&#160;ﬁelds,&#160;&#160;impl&#160;&#160;blocks, or modules<br/>ref&#160;&#160;- bind by reference<br/>return&#160;&#160;- return from function<br/>
https://doc.rust-lang.org/book/print.html<br/>
603/627<br/>
<hr/>
<a name=604></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Self&#160;&#160;- a type alias for the type we are deﬁning or implementing<br/>self&#160;&#160;- method subject or current module<br/>static&#160;&#160;- global variable or lifetime lasting the entire program execution<br/>struct&#160;&#160;- deﬁne a structure<br/>super&#160;&#160;- parent module of the current module<br/>trait&#160;&#160;- deﬁne a trait<br/>true&#160;&#160;- Boolean true literal<br/>type&#160;&#160;- deﬁne a type alias or associated type<br/>union&#160;&#160;- deﬁ<a href="https://doc.rust-lang.org/reference/items/unions.html">ne a&#160;union</a>; is only a keyword when used in a union declaration<br/>unsafe&#160;&#160;- denote unsafe code, functions, traits, or implementations<br/>use&#160;&#160;- bring symbols into scope<br/>where&#160;&#160;- denote clauses that constrain a type<br/>while&#160;&#160;- loop conditionally based on the result of an expression<br/>
<a href="tests.html#604"><b>Keywords&#160;Reserved&#160;for&#160;Future&#160;Use</b></a><br/>
The following keywords do not yet have any functionality but are reserved by Rust for<br/>potential future use.<br/>
abstract<br/>become<br/>box<br/>do<br/>final<br/>macro<br/>override<br/>priv<br/>try<br/>typeof<br/>unsized<br/>virtual<br/>yield<br/>
<a href="tests.html#604"><b>Raw&#160;Identiﬁers</b></a><br/>
<i>Raw identiﬁers</i>&#160;are the syntax that lets you use keywords where they wouldn’t normally be<br/>allowed. You use a raw identiﬁer by preﬁxing a keyword with&#160;&#160;r#&#160;.<br/>
For example,&#160;&#160;match&#160;&#160;is a keyword. If you try to compile the following function that uses<br/>
match&#160;&#160;as its name:<br/>
Filename: src/main.rs<br/>
https://doc.rust-lang.org/book/print.html<br/>
604/627<br/>
<hr/>
<a name=605></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
fn&#160;match(needle:&#160;&amp;str,&#160;haystack:&#160;&amp;str)&#160;-&gt;&#160;bool&#160;{<br/>&#160;&#160;&#160;&#160;haystack.contains(needle)<br/>}<br/>
you’ll get this error:<br/>
error:&#160;expected&#160;identifier,&#160;found&#160;keyword&#160;`match`<br/>&#160;--&gt;&#160;src/main.rs:4:4<br/>&#160;&#160;|<br/>4&#160;|&#160;fn&#160;match(needle:&#160;&amp;str,&#160;haystack:&#160;&amp;str)&#160;-&gt;&#160;bool&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;^^^^^&#160;expected&#160;identifier,&#160;found&#160;keyword<br/>
The error shows that you can’t use the keyword&#160;&#160;match&#160;&#160;as the function identiﬁer. To use<br/>
match&#160;&#160;as a function name, you need to use the raw identiﬁer syntax, like this:<br/>
Filename: src/main.rs<br/>
fn&#160;r#match(needle:&#160;&amp;str,&#160;haystack:&#160;&amp;str)&#160;-&gt;&#160;bool&#160;{<br/>&#160;&#160;&#160;&#160;haystack.contains(needle)<br/>}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;assert!(r#match(&#34;foo&#34;,&#160;&#34;foobar&#34;));<br/>}<br/>
This code will compile without any errors. Note the&#160;&#160;r#&#160;&#160;preﬁx on the function name in its<br/>deﬁnition as well as where the function is called in&#160;&#160;main&#160;.<br/>
Raw identiﬁers allow you to use any word you choose as an identiﬁer, even if that word<br/>happens to be a reserved keyword. This gives us more freedom to choose identiﬁer names,<br/>as well as lets us integrate with programs written in a language where these words aren’t<br/>keywords. In addition, raw identiﬁers allow you to use libraries written in a diﬀerent Rust<br/>edition than your crate uses. For example,&#160;&#160;try&#160;&#160;isn’t a keyword in the 2015 edition but is in<br/>the 2018 edition. If you depend on a library that’s written using the 2015 edition and has a<br/>
try&#160;&#160;function, you’ll need to use the raw identiﬁer syntax,&#160;&#160;r#try&#160;&#160;in this case, to call that<br/>
<a href="https://doc.rust-lang.org/book/appendix-05-editions.html">function from your 2018 edition code. See&#160;Appendix E&#160;for more information on editions.</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
605/627<br/>
<hr/>
<a name=606></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#606"><b>Appendix B: Operators and Symbols</b></a><br/>
This appendix contains a glossary of Rust’s syntax, including operators and other symbols<br/>that appear by themselves or in the context of paths, generics, trait bounds, macros,<br/>attributes, comments, tuples, and brackets.<br/>
<a href="tests.html#606"><b>Operators</b></a><br/>
Table B-1 contains the operators in Rust, an example of how the operator would appear in<br/>context, a short explanation, and whether that operator is overloadable. If an operator is<br/>overloadable, the relevant trait to use to overload that operator is listed.<br/>
<b>Table&#160;B-1:&#160;Operators</b><br/>
<b>Operator</b><br/>
<b>Example</b><br/>
<b>Explanation</b><br/>
<b>Overloadable?</b><br/>
ident!(...)&#160;,<br/>
!<br/>
ident!{...}&#160;,<br/>
Macro expansion<br/>
ident![...]<br/>
Bitwise or logical<br/>
!<br/>
!expr<br/>
complement<br/>
Not<br/>
!=<br/>
expr&#160;!=&#160;expr<br/>
Nonequality comparison<br/>
PartialEq<br/>
%<br/>
expr&#160;%&#160;expr<br/>
Arithmetic remainder<br/>
Rem<br/>
Arithmetic remainder and<br/>
%=<br/>
var&#160;%=&#160;expr<br/>
assignment<br/>
RemAssign<br/>
&amp;expr&#160;,&#160;&#160;&amp;mut&#160;<br/>
&amp;<br/>
Borrow<br/>
expr<br/>
&amp;type&#160;,&#160;&#160;&amp;mut&#160;<br/>
type&#160;,&#160;&#160;&amp;'a&#160;<br/>
&amp;<br/>
Borrowed pointer type<br/>
type&#160;,&#160;&#160;&amp;'a&#160;mut&#160;<br/>type<br/>
&amp;<br/>
expr&#160;&amp;&#160;expr<br/>
Bitwise AND<br/>
BitAnd<br/>
Bitwise AND and<br/>
&amp;=<br/>
var&#160;&amp;=&#160;expr<br/>
assignment<br/>
BitAndAssign<br/>
&amp;&amp;<br/>
expr&#160;&amp;&amp;&#160;expr<br/>
Short-circuiting logical AND<br/>
*<br/>
expr&#160;*&#160;expr<br/>
Arithmetic multiplication<br/>
Mul<br/>
Arithmetic multiplication<br/>
*=<br/>
var&#160;*=&#160;expr<br/>
and assignment<br/>
MulAssign<br/>
*<br/>
*expr<br/>
Dereference<br/>
Deref<br/>
https://doc.rust-lang.org/book/print.html<br/>
606/627<br/>
<hr/>
<a name=607></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Operator</b><br/>
<b>Example</b><br/>
<b>Explanation</b><br/>
<b>Overloadable?</b><br/>
*const&#160;type&#160;,<br/>
*<br/>
Raw pointer<br/>
*mut&#160;type<br/>
trait&#160;+&#160;trait&#160;,<br/>
+<br/>
Compound type constraint<br/>
'a&#160;+&#160;trait<br/>
+<br/>
expr&#160;+&#160;expr<br/>
Arithmetic addition<br/>
Add<br/>
Arithmetic addition and<br/>
+=<br/>
var&#160;+=&#160;expr<br/>
assignment<br/>
AddAssign<br/>
Argument and element<br/>
,<br/>
expr,&#160;expr<br/>
separator<br/>
-<br/>
-&#160;expr<br/>
Arithmetic negation<br/>
Neg<br/>
-<br/>
expr&#160;-&#160;expr<br/>
Arithmetic subtraction<br/>
Sub<br/>
Arithmetic subtraction and<br/>
-=<br/>
var&#160;-=&#160;expr<br/>
assignment<br/>
SubAssign<br/>
fn(...)&#160;-&gt;&#160;<br/>
Function and closure return<br/>
-&gt;<br/>
type&#160;,&#160;&#160;|...|&#160;-&gt;&#160;<br/>
type<br/>
type<br/>
.<br/>
expr.ident<br/>
Member access<br/>
..&#160;,&#160;&#160;expr..&#160;,<br/>
..<br/>
..expr&#160;,<br/>
Right-exclusive range literal<br/>
PartialOrd<br/>
expr..expr<br/>
..=expr&#160;,<br/>
..=<br/>
Right-inclusive range literal<br/>
PartialOrd<br/>
expr..=expr<br/>
..<br/>
..expr<br/>
Struct literal update syntax<br/>
variant(x,&#160;<br/>
..)&#160;,<br/>
“And the rest” pattern<br/>
..<br/>
struct_type&#160;{&#160;<br/>
binding<br/>
x,&#160;..&#160;}<br/>
(Deprecated, use&#160;&#160;..=<br/>
...<br/>
expr...expr<br/>
instead) In a pattern:<br/>inclusive range pattern<br/>
/<br/>
expr&#160;/&#160;expr<br/>
Arithmetic division<br/>
Div<br/>
Arithmetic division and<br/>
/=<br/>
var&#160;/=&#160;expr<br/>
assignment<br/>
DivAssign<br/>
pat:&#160;type&#160;,<br/>
:<br/>
Constraints<br/>
ident:&#160;type<br/>
:<br/>
ident:&#160;expr<br/>
Struct&#160;ﬁeld initializer<br/>
'a:&#160;loop&#160;<br/>
:<br/>
Loop label<br/>
{...}<br/>
https://doc.rust-lang.org/book/print.html<br/>
607/627<br/>
<hr/>
<a name=608></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Operator</b><br/>
<b>Example</b><br/>
<b>Explanation</b><br/>
<b>Overloadable?</b><br/>
Statement and item<br/>
;<br/>
expr;<br/>
terminator<br/>Part of&#160;ﬁxed-size array<br/>
;<br/>
[...;&#160;len]<br/>
syntax<br/>
&lt;&lt;<br/>
expr&#160;&lt;&lt;&#160;expr<br/>
Left-shift<br/>
Shl<br/>
&lt;&lt;=<br/>
var&#160;&lt;&lt;=&#160;expr<br/>
Left-shift and assignment<br/>
ShlAssign<br/>
&lt;<br/>
expr&#160;&lt;&#160;expr<br/>
Less than comparison<br/>
PartialOrd<br/>
Less than or equal to<br/>
&lt;=<br/>
expr&#160;&lt;=&#160;expr<br/>
comparison<br/>
PartialOrd<br/>
var&#160;=&#160;expr&#160;,<br/>
=<br/>
Assignment/equivalence<br/>
ident&#160;=&#160;type<br/>
==<br/>
expr&#160;==&#160;expr<br/>
Equality comparison<br/>
PartialEq<br/>
=&gt;<br/>
pat&#160;=&gt;&#160;expr<br/>
Part of match arm syntax<br/>
&gt;<br/>
expr&#160;&gt;&#160;expr<br/>
Greater than comparison<br/>
PartialOrd<br/>
Greater than or equal to<br/>
&gt;=<br/>
expr&#160;&gt;=&#160;expr<br/>
comparison<br/>
PartialOrd<br/>
&gt;&gt;<br/>
expr&#160;&gt;&gt;&#160;expr<br/>
Right-shift<br/>
Shr<br/>
&gt;&gt;=<br/>
var&#160;&gt;&gt;=&#160;expr<br/>
Right-shift and assignment<br/>
ShrAssign<br/>
@<br/>
ident&#160;@&#160;pat<br/>
Pattern binding<br/>
^<br/>
expr&#160;^&#160;expr<br/>
Bitwise exclusive OR<br/>
BitXor<br/>
Bitwise exclusive OR and<br/>
^=<br/>
var&#160;^=&#160;expr<br/>
assignment<br/>
BitXorAssign<br/>
|<br/>
pat&#160;|&#160;pat<br/>
Pattern alternatives<br/>
|<br/>
expr&#160;|&#160;expr<br/>
Bitwise OR<br/>
BitOr<br/>
|=<br/>
var&#160;|=&#160;expr<br/>
Bitwise OR and assignment<br/>
BitOrAssign<br/>
||<br/>
expr&#160;||&#160;expr<br/>
Short-circuiting logical OR<br/>
?<br/>
expr?<br/>
Error propagation<br/>
<a href="tests.html#608"><b>Non-operator&#160;Symbols</b></a><br/>
The following list contains all symbols that don’t function as operators; that is, they don’t<br/>behave like a function or method call.<br/>
Table B-2 shows symbols that appear on their own and are valid in a variety of locations.<br/>
<b>Table&#160;B-2:&#160;Stand-Alone&#160;Syntax</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
608/627<br/>
<hr/>
<a name=609></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Symbol</b><br/>
<b>Explanation</b><br/>
'ident<br/>
Named lifetime or loop label<br/>
...u8&#160;,&#160;&#160;...i32&#160;,&#160;&#160;...f64&#160;,<br/>
Numeric literal of speciﬁc type<br/>
...usize&#160;, etc.<br/>
&#34;...&#34;<br/>
String literal<br/>
r&#34;...&#34;&#160;,&#160;&#160;r#&#34;...&#34;#&#160;,<br/>
Raw string literal, escape characters not<br/>
r##&#34;...&#34;##&#160;, etc.<br/>
processed<br/>Byte string literal; constructs an array of bytes<br/>
b&#34;...&#34;<br/>
instead of a string<br/>
br&#34;...&#34;&#160;,&#160;&#160;br#&#34;...&#34;#&#160;,<br/>
Raw byte string literal, combination of raw and<br/>
br##&#34;...&#34;##&#160;, etc.<br/>
byte string literal<br/>
'...'<br/>
Character literal<br/>
b'...'<br/>
ASCII byte literal<br/>
|...|&#160;expr<br/>
Closure<br/>Always empty bottom type for diverging<br/>
!<br/>
functions<br/>“Ignored” pattern binding; also used to make<br/>
_<br/>
integer literals readable<br/>
Table B-3 shows symbols that appear in the context of a path through the module hierarchy<br/>to an item.<br/>
<b>Table&#160;B-3:&#160;Path-Related&#160;Syntax</b><br/>
<b>Symbol</b><br/>
<b>Explanation</b><br/>
ident::ident<br/>
Namespace path<br/>Path relative to the crate root (i.e., an explicitly<br/>
::path<br/>
absolute path)<br/>Path relative to the current module (i.e., an<br/>
self::path<br/>
explicitly relative path).<br/>
super::path<br/>
Path relative to the parent of the current module<br/>
type::ident&#160;,&#160;&#160;&lt;type&#160;as&#160;<br/>
Associated constants, functions, and types<br/>
trait&gt;::ident<br/>
Associated item for a type that cannot be directly<br/>
&lt;type&gt;::...<br/>
named (e.g.,&#160;&#160;&lt;&amp;T&gt;::...&#160;,&#160;&#160;&lt;[T]&gt;::...&#160;, etc.)<br/>Disambiguating a method call by naming the trait<br/>
trait::method(...)<br/>
that deﬁnes it<br/>Disambiguating a method call by naming the type<br/>
type::method(...)<br/>
for which it’s deﬁned<br/>
https://doc.rust-lang.org/book/print.html<br/>
609/627<br/>
<hr/>
<a name=610></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Symbol</b><br/>
<b>Explanation</b><br/>
&lt;type&#160;as&#160;<br/>
Disambiguating a method call by naming the trait<br/>
trait&gt;::method(...)<br/>
and type<br/>
Table B-4 shows symbols that appear in the context of using generic type parameters.<br/>
<b>Table&#160;B-4:&#160;Generics</b><br/>
<b>Symbol</b><br/>
<b>Explanation</b><br/>
Speciﬁes parameters to generic type in a type (e.g.,<br/>
path&lt;...&gt;<br/>
Vec&lt;u8&gt;&#160;)<br/>
Speciﬁes parameters to generic type, function, or method<br/>
path::&lt;...&gt;&#160;,<br/>
in an expression; often referred to as turboﬁsh (e.g.,<br/>
method::&lt;...&gt;<br/>
&#34;42&#34;.parse::&lt;i32&gt;()&#160;)<br/>
fn&#160;ident&lt;...&gt;&#160;...<br/>
Deﬁne generic function<br/>
struct&#160;ident&lt;...&gt;&#160;<br/>
Deﬁne generic structure<br/>
...<br/>
enum&#160;ident&lt;...&gt;&#160;...<br/>
Deﬁne generic enumeration<br/>
impl&lt;...&gt;&#160;...<br/>
Deﬁne generic implementation<br/>
for&lt;...&gt;&#160;type<br/>
Higher-ranked lifetime bounds<br/>A generic type where one or more associated types have<br/>
type&lt;ident=type&gt;<br/>
speciﬁc assignments (e.g.,&#160;&#160;Iterator&lt;Item=T&gt;&#160;)<br/>
Table B-5 shows symbols that appear in the context of constraining generic type parameters<br/>with trait bounds.<br/>
<b>Table&#160;B-5:&#160;Trait&#160;Bound&#160;Constraints</b><br/>
<b>Symbol</b><br/>
<b>Explanation</b><br/>
T:&#160;U<br/>
Generic parameter&#160;&#160;T&#160;&#160;constrained to types that implement&#160;&#160;U<br/>Generic type&#160;&#160;T&#160;&#160;must outlive lifetime&#160;&#160;'a&#160;&#160;(meaning the type<br/>
T:&#160;'a<br/>
cannot transitively contain any references with lifetimes shorter<br/>than&#160;&#160;'a&#160;)<br/>Generic type&#160;&#160;T&#160;&#160;contains no borrowed references other than<br/>
T:&#160;'static<br/>
'static&#160;&#160;ones<br/>
'b:&#160;'a<br/>
Generic lifetime&#160;&#160;'b&#160;&#160;must outlive lifetime&#160;&#160;'a<br/>
T:&#160;?Sized<br/>
Allow generic type parameter to be a dynamically sized type<br/>
'a&#160;+&#160;trait&#160;,<br/>
Compound type constraint<br/>
trait&#160;+&#160;trait<br/>
Table B-6 shows symbols that appear in the context of calling or deﬁning macros and<br/>specifying attributes on an item.<br/>
https://doc.rust-lang.org/book/print.html<br/>
610/627<br/>
<hr/>
<a name=611></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Table&#160;B-6:&#160;Macros&#160;and&#160;Attributes</b><br/>
<b>Symbol</b><br/>
<b>Explanation</b><br/>
#[meta]<br/>
Outer attribute<br/>
#![meta]<br/>
Inner attribute<br/>
$ident<br/>
Macro substitution<br/>
$ident:kind<br/>
Macro capture<br/>
$(…)…<br/>
Macro repetition<br/>
ident!(...)&#160;,&#160;&#160;ident!{...}&#160;,&#160;&#160;ident![...]<br/>
Macro invocation<br/>
Table B-7 shows symbols that create comments.<br/>
<b>Table&#160;B-7:&#160;Comments</b><br/>
<b>Symbol</b><br/>
<b>Explanation</b><br/>
//<br/>
Line comment<br/>
//!<br/>
Inner line doc comment<br/>
///<br/>
Outer line doc comment<br/>
/*...*/<br/>
Block comment<br/>
/*!...*/<br/>
Inner block doc comment<br/>
/**...*/<br/>
Outer block doc comment<br/>
Table B-8 shows symbols that appear in the context of using tuples.<br/>
<b>Table&#160;B-8:&#160;Tuples</b><br/>
<b>Symbol</b><br/>
<b>Explanation</b><br/>
()<br/>
Empty tuple (aka unit), both literal and type<br/>
(expr)<br/>
Parenthesized expression<br/>
(expr,)<br/>
Single-element tuple expression<br/>
(type,)<br/>
Single-element tuple type<br/>
(expr,&#160;...)<br/>
Tuple expression<br/>
(type,&#160;...)<br/>
Tuple type<br/>Function call expression; also used to initialize tuple&#160;&#160;struct&#160;s<br/>
expr(expr,&#160;...)<br/>
and tuple&#160;&#160;enum&#160;&#160;variants<br/>
expr.0&#160;,&#160;&#160;expr.1&#160;,<br/>
Tuple indexing<br/>
etc.<br/>
Table B-9 shows the contexts in which curly braces are used.<br/>
<b>Table&#160;B-9:&#160;Curly&#160;Brackets</b><br/>
https://doc.rust-lang.org/book/print.html<br/>
611/627<br/>
<hr/>
<a name=612></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<b>Context</b><br/>
<b>Explanation</b><br/>
{...}<br/>
Block expression<br/>
Type&#160;{...}<br/>
struct&#160;&#160;literal<br/>
Table B-10 shows the contexts in which square brackets are used.<br/>
<b>Table&#160;B-10:&#160;Square&#160;Brackets</b><br/>
<b>Context</b><br/>
<b>Explanation</b><br/>
[...]<br/>
Array literal<br/>
[expr;&#160;len]<br/>
Array literal containing&#160;&#160;len&#160;&#160;copies of&#160;&#160;expr<br/>
[type;&#160;len]<br/>
Array type containing&#160;&#160;len&#160;&#160;instances of&#160;&#160;type<br/>
expr[expr]<br/>
Collection indexing. Overloadable (&#160;Index&#160;,&#160;&#160;IndexMut&#160;)<br/>Collection indexing pretending to be collection slicing,<br/>
expr[..]&#160;,&#160;&#160;expr[a..]&#160;,<br/>
using&#160;&#160;Range&#160;,&#160;&#160;RangeFrom&#160;,&#160;&#160;RangeTo&#160;, or&#160;&#160;RangeFull&#160;&#160;as<br/>
expr[..b]&#160;,&#160;&#160;expr[a..b]<br/>
the “index”<br/>
https://doc.rust-lang.org/book/print.html<br/>
612/627<br/>
<hr/>
<a name=613></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#613"><b>Appendix C: Derivable Traits</b></a><br/>
In various places in the book, we’ve discussed the&#160;&#160;derive&#160;&#160;attribute, which you can apply to<br/>a struct or enum deﬁnition. The&#160;&#160;derive&#160;&#160;attribute generates code that will implement a trait<br/>with its own default implementation on the type you’ve annotated with the&#160;&#160;derive&#160;&#160;syntax.<br/>
In this appendix, we provide a reference of all the traits in the standard library that you can<br/>use with&#160;&#160;derive&#160;. Each section covers:<br/>
What operators and methods deriving this trait will enable<br/>What the implementation of the trait provided by&#160;&#160;derive&#160;&#160;does<br/>What implementing the trait signiﬁes about the type<br/>The conditions in which you’re allowed or not allowed to implement the trait<br/>Examples of operations that require the trait<br/>
If you want diﬀerent behavior from that provided by the&#160;&#160;derive&#160;&#160;attribute, consult the<br/><a href="https://doc.rust-lang.org/std/index.html">standard library documentation&#160;for each trait for details of how to manually implement<br/></a>them.<br/>
These traits listed here are the only ones deﬁned by the standard library that can be<br/>implemented on your types using&#160;&#160;derive&#160;. Other traits deﬁned in the standard library don’t<br/>have sensible default behavior, so it’s up to you to implement them in the way that makes<br/>sense for what you’re trying to accomplish.<br/>
An example of a trait that can’t be derived is&#160;&#160;Display&#160;, which handles formatting for end<br/>users. You should always consider the appropriate way to display a type to an end user.<br/>What parts of the type should an end user be allowed to see? What parts would they&#160;ﬁnd<br/>relevant? What format of the data would be most relevant to them? The Rust compiler<br/>doesn’t have this insight, so it can’t provide appropriate default behavior for you.<br/>
The list of derivable traits provided in this appendix is not comprehensive: libraries can<br/>implement&#160;&#160;derive&#160;&#160;for their own traits, making the list of traits you can use&#160;&#160;derive&#160;&#160;with<br/>truly open-ended. Implementing&#160;&#160;derive&#160;&#160;involves using a procedural macro, which is<br/><a href="https://doc.rust-lang.org/book/ch19-06-macros.html#macros">covered in the&#160;“Macros”</a>&#160;section of Chapter 19.<br/>
<a href="tests.html#613">Debug<b>&#160;for&#160;Programmer&#160;Output</b></a><br/>
The&#160;&#160;Debug&#160;&#160;trait enables debug formatting in format strings, which you indicate by adding<br/>
:?&#160;&#160;within&#160;&#160;{}&#160;&#160;placeholders.<br/>
The&#160;&#160;Debug&#160;&#160;trait allows you to print instances of a type for debugging purposes, so you and<br/>other programmers using your type can inspect an instance at a particular point in a<br/>
https://doc.rust-lang.org/book/print.html<br/>
613/627<br/>
<hr/>
<a name=614></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
program’s execution.<br/>
The&#160;&#160;Debug&#160;&#160;trait is required, for example, in use of the&#160;&#160;assert_eq!&#160;&#160;macro. This macro prints<br/>the values of instances given as arguments if the equality assertion fails so programmers<br/>can see why the two instances weren’t equal.<br/>
<a href="tests.html#614">PartialEq<b>&#160;and&#160;</b>Eq<b>&#160;for&#160;Equality&#160;Comparisons</b></a><br/>
The&#160;&#160;PartialEq&#160;&#160;trait allows you to compare instances of a type to check for equality and<br/>enables use of the&#160;&#160;==&#160;&#160;and&#160;&#160;!=&#160;&#160;operators.<br/>
Deriving&#160;&#160;PartialEq&#160;&#160;implements the&#160;&#160;eq&#160;&#160;method. When&#160;&#160;PartialEq&#160;&#160;is derived on structs,<br/>two instances are equal only if&#160;<i>all</i>&#160;ﬁelds are equal, and the instances are not equal if any<br/>ﬁelds are not equal. When derived on enums, each variant is equal to itself and not equal to<br/>the other variants.<br/>
The&#160;&#160;PartialEq&#160;&#160;trait is required, for example, with the use of the&#160;&#160;assert_eq!&#160;&#160;macro, which<br/>needs to be able to compare two instances of a type for equality.<br/>
The&#160;&#160;Eq&#160;&#160;trait has no methods. Its purpose is to signal that for every value of the annotated<br/>type, the value is equal to itself. The&#160;&#160;Eq&#160;&#160;trait can only be applied to types that also<br/>implement&#160;&#160;PartialEq&#160;, although not all types that implement&#160;&#160;PartialEq&#160;&#160;can implement<br/>
Eq&#160;. One example of this is&#160;ﬂoating point number types: the implementation of&#160;ﬂoating<br/>
point numbers states that two instances of the not-a-number (&#160;NaN&#160;) value are not equal to<br/>each other.<br/>
An example of when&#160;&#160;Eq&#160;&#160;is required is for keys in a&#160;&#160;HashMap&lt;K,&#160;V&gt;&#160;&#160;so the&#160;&#160;HashMap&lt;K,&#160;V&gt;<br/>can tell whether two keys are the same.<br/>
<a href="tests.html#614">PartialOrd<b>&#160;and&#160;</b>Ord<b>&#160;for&#160;Ordering&#160;Comparisons</b></a><br/>
The&#160;&#160;PartialOrd&#160;&#160;trait allows you to compare instances of a type for sorting purposes. A type<br/>that implements&#160;&#160;PartialOrd&#160;&#160;can be used with the&#160;&#160;&lt;&#160;,&#160;&#160;&gt;&#160;,&#160;&#160;&lt;=&#160;, and&#160;&#160;&gt;=&#160;&#160;operators. You can<br/>only apply the&#160;&#160;PartialOrd&#160;&#160;trait to types that also implement&#160;&#160;PartialEq&#160;.<br/>
Deriving&#160;&#160;PartialOrd&#160;&#160;implements the&#160;&#160;partial_cmp&#160;&#160;method, which returns an<br/>
Option&lt;Ordering&gt;&#160;&#160;that will be&#160;&#160;None&#160;&#160;when the values given don’t produce an ordering. An<br/>
example of a value that doesn’t produce an ordering, even though most values of that type<br/>can be compared, is the not-a-number (&#160;NaN&#160;)&#160;ﬂoating point value. Calling&#160;&#160;partial_cmp&#160;&#160;with<br/>any&#160;ﬂoating point number and the&#160;&#160;NaN&#160;&#160;ﬂoating point value will return&#160;&#160;None&#160;.<br/>
When derived on structs,&#160;&#160;PartialOrd&#160;&#160;compares two instances by comparing the value in<br/>each&#160;ﬁeld in the order in which the&#160;ﬁelds appear in the struct deﬁnition. When derived on<br/>
https://doc.rust-lang.org/book/print.html<br/>
614/627<br/>
<hr/>
<a name=615></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
enums, variants of the enum declared earlier in the enum deﬁnition are considered less<br/>than the variants listed later.<br/>
The&#160;&#160;PartialOrd&#160;&#160;trait is required, for example, for the&#160;&#160;gen_range&#160;&#160;method from the&#160;&#160;rand<br/>crate that generates a random value in the range speciﬁed by a range expression.<br/>
The&#160;&#160;Ord&#160;&#160;trait allows you to know that for any two values of the annotated type, a valid<br/>ordering will exist. The&#160;&#160;Ord&#160;&#160;trait implements the&#160;&#160;cmp&#160;&#160;method, which returns an&#160;&#160;Ordering<br/>rather than an&#160;&#160;Option&lt;Ordering&gt;&#160;&#160;because a valid ordering will always be possible. You can<br/>only apply the&#160;&#160;Ord&#160;&#160;trait to types that also implement&#160;&#160;PartialOrd&#160;&#160;and&#160;&#160;Eq&#160;&#160;(and&#160;&#160;Eq&#160;&#160;requires<br/>
PartialEq&#160;). When derived on structs and enums,&#160;&#160;cmp&#160;&#160;behaves the same way as the<br/>
derived implementation for&#160;&#160;partial_cmp&#160;&#160;does with&#160;&#160;PartialOrd&#160;.<br/>
An example of when&#160;&#160;Ord&#160;&#160;is required is when storing values in a&#160;&#160;BTreeSet&lt;T&gt;&#160;, a data<br/>structure that stores data based on the sort order of the values.<br/>
<a href="tests.html#615">Clone<b>&#160;and&#160;</b>Copy<b>&#160;for&#160;Duplicating&#160;Values</b></a><br/>
The&#160;&#160;Clone&#160;&#160;trait allows you to explicitly create a deep copy of a value, and the duplication<br/><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone">process might involve running arbitrary code and copying heap data. See the&#160;“Ways<br/>Variables and Data Interact: Clone”&#160;section in Chapter 4 for more information on&#160;&#160;Cl</a>one&#160;.<br/>
Deriving&#160;&#160;Clone&#160;&#160;implements the&#160;&#160;clone&#160;&#160;method, which when implemented for the whole<br/>type, calls&#160;&#160;clone&#160;&#160;on each of the parts of the type. This means all the&#160;ﬁelds or values in the<br/>type must also implement&#160;&#160;Clone&#160;&#160;to derive&#160;&#160;Clone&#160;.<br/>
An example of when&#160;&#160;Clone&#160;&#160;is required is when calling the&#160;&#160;to_vec&#160;&#160;method on a slice. The<br/>slice doesn’t own the type instances it contains, but the vector returned from&#160;&#160;to_vec&#160;&#160;will<br/>need to own its instances, so&#160;&#160;to_vec&#160;&#160;calls&#160;&#160;clone&#160;&#160;on each item. Thus, the type stored in the<br/>slice must implement&#160;&#160;Clone&#160;.<br/>
The&#160;&#160;Copy&#160;&#160;trait allows you to duplicate a value by only copying bits stored on the stack; no<br/><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#stack-only-data-copy">arbitrary code is necessary. See the&#160;“Stack-Only Data: Copy”&#160;section in Chapter 4 for more<br/></a>information on&#160;&#160;Copy&#160;.<br/>
The&#160;&#160;Copy&#160;&#160;trait doesn’t deﬁne any methods to prevent programmers from overloading<br/>those methods and violating the assumption that no arbitrary code is being run. That way,<br/>all programmers can assume that copying a value will be very fast.<br/>
You can derive&#160;&#160;Copy&#160;&#160;on any type whose parts all implement&#160;&#160;Copy&#160;. A type that implements<br/>
Copy&#160;&#160;must also implement&#160;&#160;Clone&#160;, because a type that implements&#160;&#160;Copy&#160;&#160;has a trivial<br/>
implementation of&#160;&#160;Clone&#160;&#160;that performs the same task as&#160;&#160;Copy&#160;.<br/>
The&#160;&#160;Copy&#160;&#160;trait is rarely required; types that implement&#160;&#160;Copy&#160;&#160;have optimizations available,<br/>meaning you don’t have to call&#160;&#160;clone&#160;, which makes the code more concise.<br/>
https://doc.rust-lang.org/book/print.html<br/>
615/627<br/>
<hr/>
<a name=616></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Everything possible with&#160;&#160;Copy&#160;&#160;you can also accomplish with&#160;&#160;Clone&#160;, but the code might be<br/>slower or have to use&#160;&#160;clone&#160;&#160;in places.<br/>
<a href="tests.html#616">Hash<b>&#160;for&#160;Mapping&#160;a&#160;Value&#160;to&#160;a&#160;Value&#160;of&#160;Fixed&#160;Size</b></a><br/>
The&#160;&#160;Hash&#160;&#160;trait allows you to take an instance of a type of arbitrary size and map that<br/>instance to a value of&#160;ﬁxed size using a hash function. Deriving&#160;&#160;Hash&#160;&#160;implements the&#160;&#160;hash<br/>method. The derived implementation of the&#160;&#160;hash&#160;&#160;method combines the result of calling<br/>
hash&#160;&#160;on each of the parts of the type, meaning all&#160;ﬁelds or values must also implement<br/>Hash&#160;&#160;to derive&#160;&#160;Hash&#160;.<br/>
An example of when&#160;&#160;Hash&#160;&#160;is required is in storing keys in a&#160;&#160;HashMap&lt;K,&#160;V&gt;&#160;&#160;to store data<br/>eﬃciently.<br/>
<a href="tests.html#616">Default<b>&#160;for&#160;Default&#160;Values</b></a><br/>
The&#160;&#160;Default&#160;&#160;trait allows you to create a default value for a type. Deriving&#160;&#160;Default<br/>implements the&#160;&#160;default&#160;&#160;function. The derived implementation of the&#160;&#160;default&#160;&#160;function<br/>calls the&#160;&#160;default&#160;&#160;function on each part of the type, meaning all&#160;ﬁelds or values in the type<br/>must also implement&#160;&#160;Default&#160;&#160;to derive&#160;&#160;Default&#160;.<br/>
The&#160;&#160;Default::default&#160;&#160;function is commonly used in combination with the struct update<br/><a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">syntax discussed in the&#160;“Creating Instances From Other Instances With Struct Update<br/>Syntax”&#160;section in Chapter 5. You can customize a few&#160;ﬁelds of a struct and then set and use<br/></a>a default value for the rest of the&#160;ﬁelds by using&#160;&#160;..Default::default()&#160;.<br/>
The&#160;&#160;Default&#160;&#160;trait is required when you use the method&#160;&#160;unwrap_or_default&#160;&#160;on&#160;&#160;Option&lt;T&gt;<br/>instances, for example. If the&#160;&#160;Option&lt;T&gt;&#160;&#160;is&#160;&#160;None&#160;, the method&#160;&#160;unwrap_or_default&#160;&#160;will<br/>return the result of&#160;&#160;Default::default&#160;&#160;for the type&#160;&#160;T&#160;&#160;stored in the&#160;&#160;Option&lt;T&gt;&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
616/627<br/>
<hr/>
<a name=617></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#617"><b>Appendix D - Useful Development Tools</b></a><br/>
In this appendix, we talk about some useful development tools that the Rust project<br/>provides. We’ll look at automatic formatting, quick ways to apply warning&#160;ﬁxes, a linter, and<br/>integrating with IDEs.<br/>
<a href="tests.html#617"><b>Automatic&#160;Formatting&#160;with&#160;</b>rustfmt</a><br/>
The&#160;&#160;rustfmt&#160;&#160;tool reformats your code according to the community code style. Many<br/>collaborative projects use&#160;&#160;rustfmt&#160;&#160;to prevent arguments about which style to use when<br/>writing Rust: everyone formats their code using the tool.<br/>
To install&#160;&#160;rustfmt&#160;, enter the following:<br/>
$&#160;rustup&#160;component&#160;add&#160;rustfmt<br/>
This command gives you&#160;&#160;rustfmt&#160;&#160;and&#160;&#160;cargo-fmt&#160;, similar to how Rust gives you both<br/>
rustc&#160;&#160;and&#160;&#160;cargo&#160;. To format any Cargo project, enter the following:<br/>
$&#160;cargo&#160;fmt<br/>
Running this command reformats all the Rust code in the current crate. This should only<br/><a href="https://github.com/rust-lang/rustfmt">change the code style, not the code semantics. For more information on&#160;&#160;rustfmt&#160;, see&#160;its<br/>documentation.</a><br/>
<a href="tests.html#617"><b>Fix&#160;Your&#160;Code&#160;with&#160;</b>rustfix</a><br/>
The rustﬁx tool is included with Rust installations and can automatically&#160;ﬁx compiler<br/>warnings that have a clear way to correct the problem that’s likely what you want. It’s likely<br/>you’ve seen compiler warnings before. For example, consider this code:<br/>
Filename: src/main.rs<br/>
fn&#160;do_something()&#160;{}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;for&#160;i&#160;in&#160;0..100&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;do_something();<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
https://doc.rust-lang.org/book/print.html<br/>
617/627<br/>
<hr/>
<a name=618></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
Here, we’re calling the&#160;&#160;do_something&#160;&#160;function 100 times, but we never use the variable&#160;&#160;i<br/>in the body of the&#160;&#160;for&#160;&#160;loop. Rust warns us about that:<br/>
$&#160;cargo&#160;build<br/>&#160;&#160;&#160;Compiling&#160;myprogram&#160;v0.1.0&#160;(file:///projects/myprogram)<br/>warning:&#160;unused&#160;variable:&#160;`i`<br/>&#160;--&gt;&#160;src/main.rs:4:9<br/>&#160;&#160;|<br/>4&#160;|&#160;&#160;&#160;&#160;&#160;for&#160;i&#160;in&#160;0..100&#160;{<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^&#160;help:&#160;consider&#160;using&#160;`_i`&#160;instead<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;#[warn(unused_variables)]&#160;on&#160;by&#160;default<br/>
&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.50s<br/>
The warning suggests that we use&#160;&#160;_i&#160;&#160;as a name instead: the underscore indicates that we<br/>intend for this variable to be unused. We can automatically apply that suggestion using the<br/>
rustfix&#160;&#160;tool by running the command&#160;&#160;cargo&#160;fix&#160;:<br/>
$&#160;cargo&#160;fix<br/>&#160;&#160;&#160;&#160;Checking&#160;myprogram&#160;v0.1.0&#160;(file:///projects/myprogram)<br/>&#160;&#160;&#160;&#160;&#160;&#160;Fixing&#160;src/main.rs&#160;(1&#160;fix)<br/>&#160;&#160;&#160;&#160;Finished&#160;dev&#160;[unoptimized&#160;+&#160;debuginfo]&#160;target(s)&#160;in&#160;0.59s<br/>
When we look at&#160;<i>src/main.rs</i>&#160;again, we’ll see that&#160;&#160;cargo&#160;fix&#160;&#160;has changed the code:<br/>
Filename: src/main.rs<br/>
fn&#160;do_something()&#160;{}<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;for&#160;_i&#160;in&#160;0..100&#160;{<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;do_something();<br/>&#160;&#160;&#160;&#160;}<br/>}<br/>
The&#160;&#160;for&#160;&#160;loop variable is now named&#160;&#160;_i&#160;, and the warning no longer appears.<br/>
You can also use the&#160;&#160;cargo&#160;fix&#160;&#160;command to transition your code between diﬀerent Rust<br/>editions. Editions are covered in Appendix E.<br/>
<a href="tests.html#618"><b>More&#160;Lints&#160;with&#160;Clippy</b></a><br/>
The Clippy tool is a collection of lints to analyze your code so you can catch common<br/>mistakes and improve your Rust code.<br/>
To install Clippy, enter the following:<br/>
https://doc.rust-lang.org/book/print.html<br/>
618/627<br/>
<hr/>
<a name=619></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
$&#160;rustup&#160;component&#160;add&#160;clippy<br/>
To run Clippy’s lints on any Cargo project, enter the following:<br/>
$&#160;cargo&#160;clippy<br/>
For example, say you write a program that uses an approximation of a mathematical<br/>constant, such as pi, as this program does:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;3.1415;<br/>&#160;&#160;&#160;&#160;let&#160;r&#160;=&#160;8.0;<br/>&#160;&#160;&#160;&#160;println!(&#34;the&#160;area&#160;of&#160;the&#160;circle&#160;is&#160;{}&#34;,&#160;x&#160;*&#160;r&#160;*&#160;r);<br/>}<br/>
Running&#160;&#160;cargo&#160;clippy&#160;&#160;on this project results in this error:<br/>
error:&#160;approximate&#160;value&#160;of&#160;`f{32,&#160;64}::consts::PI`&#160;found<br/>&#160;--&gt;&#160;src/main.rs:2:13<br/>&#160;&#160;|<br/>2&#160;|&#160;&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;3.1415;<br/>&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;^^^^^^<br/>&#160;&#160;|<br/>&#160;&#160;=&#160;note:&#160;`#[deny(clippy::approx_constant)]`&#160;on&#160;by&#160;default<br/>&#160;&#160;=&#160;help:&#160;consider&#160;using&#160;the&#160;constant&#160;directly<br/>&#160;&#160;=&#160;help:&#160;for&#160;further&#160;information&#160;visit&#160;https://rust-lang.github.io/rust-<br/>clippy/master/index.html#approx_constant<br/>
This error lets you know that Rust already has a more precise&#160;&#160;PI&#160;&#160;constant deﬁned, and that<br/>your program would be more correct if you used the constant instead. You would then<br/>change your code to use the&#160;&#160;PI&#160;&#160;constant. The following code doesn’t result in any errors or<br/>warnings from Clippy:<br/>
Filename: src/main.rs<br/>
fn&#160;main()&#160;{<br/>&#160;&#160;&#160;&#160;let&#160;x&#160;=&#160;std::f64::consts::PI;<br/>&#160;&#160;&#160;&#160;let&#160;r&#160;=&#160;8.0;<br/>&#160;&#160;&#160;&#160;println!(&#34;the&#160;area&#160;of&#160;the&#160;circle&#160;is&#160;{}&#34;,&#160;x&#160;*&#160;r&#160;*&#160;r);<br/>}<br/>
For more information on Clippy, see&#160;<a href="https://github.com/rust-lang/rust-clippy">its documentation.</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
619/627<br/>
<hr/>
<a name=620></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#620"><b>IDE&#160;Integration&#160;Using&#160;</b>rust-analyzer</a><br/>
To help IDE integration, the Rust community recommends using&#160;&#160;<a href="https://rust-analyzer.github.io/">rust-analyzer&#160;</a>. This tool is<br/>a set of compiler-centric utilities that speaks the&#160;<a href="http://langserver.org/">Language Server Protocol, which is a<br/></a>speciﬁcation for IDEs and programming languages to communicate with each other.<br/><a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">Diﬀerent clients can use&#160;&#160;rust-analyzer&#160;, such as&#160;the Rust analyzer plug-in for Visual Studio<br/>Code.</a><br/>
Visit the&#160;&#160;rust-analyzer&#160;<a href="https://rust-analyzer.github.io/">&#160;project’s&#160;home page&#160;for installation instructions, then install the<br/></a>language server support in your particular IDE. Your IDE will gain abilities such as<br/>autocompletion, jump to deﬁnition, and inline errors.<br/>
https://doc.rust-lang.org/book/print.html<br/>
620/627<br/>
<hr/>
<a name=621></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#621"><b>Appendix E - Editions</b></a><br/>
In Chapter 1, you saw that&#160;&#160;cargo&#160;new&#160;&#160;adds a bit of metadata to your&#160;<i>Cargo.toml</i>&#160;ﬁle about<br/>an edition. This appendix talks about what that means!<br/>
The Rust language and compiler have a six-week release cycle, meaning users get a constant<br/>stream of new features. Other programming languages release larger changes less often;<br/>Rust releases smaller updates more frequently. After a while, all of these tiny changes add<br/>up. But from release to release, it can be diﬃcult to look back and say, “Wow, between Rust<br/>1.10 and Rust 1.31, Rust has changed a lot!”<br/>
Every two or three years, the Rust team produces a new Rust&#160;<i>edition</i>. Each edition brings<br/>together the features that have landed into a clear package with fully updated<br/>documentation and tooling. New editions ship as part of the usual six-week release process.<br/>
Editions serve diﬀerent purposes for diﬀerent people:<br/>
For active Rust users, a new edition brings together incremental changes into an easy-<br/>to-understand package.<br/>For non-users, a new edition signals that some major advancements have landed,<br/>which might make Rust worth another look.<br/>For those developing Rust, a new edition provides a rallying point for the project as a<br/>whole.<br/>
At the time of this writing, three Rust editions are available: Rust 2015, Rust 2018, and Rust<br/>2021. This book is written using Rust 2021 edition idioms.<br/>
The&#160;&#160;edition&#160;&#160;key in&#160;<i>Cargo.toml</i>&#160;indicates which edition the compiler should use for your<br/>code. If the key doesn’t exist, Rust uses&#160;&#160;2015&#160;&#160;as the edition value for backward<br/>compatibility reasons.<br/>
Each project can opt in to an edition other than the default 2015 edition. Editions can<br/>contain incompatible changes, such as including a new keyword that conﬂicts with<br/>identiﬁers in code. However, unless you opt in to those changes, your code will continue to<br/>compile even as you upgrade the Rust compiler version you use.<br/>
All Rust compiler versions support any edition that existed prior to that compiler’s release,<br/>and they can link crates of any supported editions together. Edition changes only aﬀect the<br/>way the compiler initially parses code. Therefore, if you’re using Rust 2015 and one of your<br/>dependencies uses Rust 2018, your project will compile and be able to use that dependency.<br/>The opposite situation, where your project uses Rust 2018 and a dependency uses Rust<br/>2015, works as well.<br/>
https://doc.rust-lang.org/book/print.html<br/>
621/627<br/>
<hr/>
<a name=622></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
To be clear: most features will be available on all editions. Developers using any Rust edition<br/>will continue to see improvements as new stable releases are made. However, in some<br/>cases, mainly when new keywords are added, some new features might only be available in<br/>later editions. You will need to switch editions if you want to take advantage of such<br/>features.<br/>
For more details, the&#160;<a href="https://doc.rust-lang.org/stable/edition-guide/"><i>Edition Guide</i></a>&#160;is a complete book about editions that enumerates the<br/>diﬀerences between editions and explains how to automatically upgrade your code to a<br/>new edition via&#160;&#160;cargo&#160;fix&#160;.<br/>
https://doc.rust-lang.org/book/print.html<br/>
622/627<br/>
<hr/>
<a name=623></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#623"><b>Appendix F: Translations of the Book</b></a><br/>
<a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">For resources in languages other than English. Most are still in progress; see&#160;the<br/>Translations label&#160;to help or let us know about a new translation!</a><br/>
<a href="https://github.com/rust-br/rust-book-pt-br">Português&#160;(BR)<br/></a><a href="https://github.com/nunojesus/rust-book-pt-pt">Português&#160;(PT)<br/></a><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文<br/></a><a href="https://github.com/rust-tw/book-tw">正體中文<br/></a><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська<br/></a><a href="https://github.com/thecodix/book">Español,&#160;</a><a href="https://github.com/ManRR/rust-book-es">alternate<br/></a><a href="https://github.com/EmanueleGurini/book_it">Italiano<br/></a><a href="https://github.com/rust-lang-ru/book">Русский<br/></a><a href="https://github.com/rinthel/rust-lang-book-ko">한국어<br/></a><a href="https://github.com/rust-lang-ja/book-ja">日本語<br/></a><a href="https://github.com/Jimskapt/rust-book-fr">Français<br/></a><a href="https://github.com/paytchoo/book-pl">Polski<br/></a><a href="https://github.com/agentzero1/book">Cebuano<br/></a><a href="https://github.com/josephace135/book">Tagalog<br/></a><a href="https://github.com/psychoslave/Rust-libro">Esperanto<br/></a><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική<br/></a><a href="https://github.com/sebras/book">Svenska<br/></a><a href="https://github.com/pomokhtari/rust-book-fa">Farsi<br/></a><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a><br/>
<a href="https://github.com/venkatarun95/rust-book-hindi">हद</a><br/>
<a href="https://github.com/rust-lang-th/book-th">ไทย<br/></a><a href="https://github.com/DanKHansen/book-dk">Danske</a><br/>
https://doc.rust-lang.org/book/print.html<br/>
623/627<br/>
<hr/>
<a name=624></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
<a href="tests.html#624"><b>Appendix G - How Rust is Made and “Nightly Rust”</b></a><br/>
This appendix is about how Rust is made and how that aﬀects you as a Rust developer.<br/>
<a href="tests.html#624"><b>Stability&#160;Without&#160;Stagnation</b></a><br/>
As a language, Rust cares a&#160;<i>lot</i>&#160;about the stability of your code. We want Rust to be a rock-<br/>solid foundation you can build on, and if things were constantly changing, that would be<br/>impossible. At the same time, if we can’t experiment with new features, we may not&#160;ﬁnd out<br/>important&#160;ﬂaws until after their release, when we can no longer change things.<br/>
Our solution to this problem is what we call “stability without stagnation”, and our guiding<br/>principle is this: you should never have to fear upgrading to a new version of stable Rust.<br/>Each upgrade should be painless, but should also bring you new features, fewer bugs, and<br/>faster compile times.<br/>
<a href="tests.html#624"><b>Choo,&#160;Choo!&#160;Release&#160;Channels&#160;and&#160;Riding&#160;the&#160;Trains</b></a><br/>
Rust development operates on a&#160;<i>train schedule</i>. That is, all development is done on the<br/>
master&#160;&#160;branch of the Rust repository. Releases follow a software release train model,<br/>
which has been used by Cisco IOS and other software projects. There are three&#160;<i>release<br/>channels</i>&#160;for Rust:<br/>
Nightly<br/>Beta<br/>Stable<br/>
Most Rust developers primarily use the stable channel, but those who want to try out<br/>experimental new features may use nightly or beta.<br/>
Here’s an example of how the development and release process works: let’s assume that<br/>the Rust team is working on the release of Rust 1.5. That release happened in December of<br/>2015, but it will provide us with realistic version numbers. A new feature is added to Rust: a<br/>new commit lands on the&#160;&#160;master&#160;&#160;branch. Each night, a new nightly version of Rust is<br/>produced. Every day is a release day, and these releases are created by our release<br/>infrastructure automatically. So as time passes, our releases look like this, once a night:<br/>
nightly:&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*<br/>
Every six weeks, it’s time to prepare a new release! The&#160;&#160;beta&#160;&#160;branch of the Rust repository<br/>branches oﬀ&#160;from the&#160;&#160;master&#160;&#160;branch used by nightly. Now, there are two releases:<br/>
https://doc.rust-lang.org/book/print.html<br/>
624/627<br/>
<hr/>
<a name=625></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
nightly:&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>beta:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*<br/>
Most Rust users do not use beta releases actively, but test against beta in their CI system to<br/>help Rust discover possible regressions. In the meantime, there’s still a nightly release every<br/>night:<br/>
nightly:&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>beta:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*<br/>
Let’s say a regression is found. Good thing we had some time to test the beta release before<br/>the regression snuck into a stable release! The&#160;ﬁx is applied to&#160;&#160;master&#160;, so that nightly is<br/>ﬁxed, and then the&#160;ﬁx is backported to the&#160;&#160;beta&#160;&#160;branch, and a new release of beta is<br/>produced:<br/>
nightly:&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>beta:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*&#160;-&#160;-&#160;-&#160;-&#160;-&#160;-&#160;-&#160;-&#160;*<br/>
Six weeks after the&#160;ﬁrst beta was created, it’s time for a stable release! The&#160;&#160;stable&#160;&#160;branch<br/>is produced from the&#160;&#160;beta&#160;&#160;branch:<br/>
nightly:&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;*&#160;-&#160;*<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>beta:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*&#160;-&#160;-&#160;-&#160;-&#160;-&#160;-&#160;-&#160;-&#160;*<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>stable:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*<br/>
Hooray! Rust 1.5 is done! However, we’ve forgotten one thing: because the six weeks have<br/>gone by, we also need a new beta of the&#160;<i>next</i>&#160;version of Rust, 1.6. So after&#160;&#160;stable&#160;&#160;branches<br/>oﬀ&#160;of&#160;&#160;beta&#160;, the next version of&#160;&#160;beta&#160;&#160;branches oﬀ&#160;of&#160;&#160;nightly&#160;&#160;again:<br/>
nightly:&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;-&#160;*&#160;-&#160;*&#160;-&#160;*<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>beta:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*&#160;-&#160;-&#160;-&#160;-&#160;-&#160;-&#160;-&#160;-&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;*<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|<br/>stable:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;*<br/>
This is called the “train model” because every six weeks, a release “leaves the station”, but<br/>still has to take a journey through the beta channel before it arrives as a stable release.<br/>
Rust releases every six weeks, like clockwork. If you know the date of one Rust release, you<br/>can know the date of the next one: it’s six weeks later. A nice aspect of having releases<br/>scheduled every six weeks is that the next train is coming soon. If a feature happens to miss<br/>a particular release, there’s no need to worry: another one is happening in a short time! This<br/>
https://doc.rust-lang.org/book/print.html<br/>
625/627<br/>
<hr/>
<a name=626></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
helps reduce pressure to sneak possibly unpolished features in close to the release<br/>deadline.<br/>
Thanks to this process, you can always check out the next build of Rust and verify for<br/>yourself that it’s easy to upgrade to: if a beta release doesn’t work as expected, you can<br/>report it to the team and get it&#160;ﬁxed before the next stable release happens! Breakage in a<br/>beta release is relatively rare, but&#160;&#160;rustc&#160;&#160;is still a piece of software, and bugs do exist.<br/>
<a href="tests.html#626"><b>Unstable&#160;Features</b></a><br/>
There’s one more catch with this release model: unstable features. Rust uses a technique<br/>called “feature&#160;ﬂags” to determine what features are enabled in a given release. If a new<br/>feature is under active development, it lands on&#160;&#160;master&#160;, and therefore, in nightly, but<br/>behind a&#160;<i>feature&#160;ﬂag</i>. If you, as a user, wish to try out the work-in-progress feature, you can,<br/>but you must be using a nightly release of Rust and annotate your source code with the<br/>appropriate&#160;ﬂag to opt in.<br/>
If you’re using a beta or stable release of Rust, you can’t use any feature&#160;ﬂags. This is the key<br/>that allows us to get practical use with new features before we declare them stable forever.<br/>Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid<br/>experience can stick with stable and know that their code won’t break. Stability without<br/>stagnation.<br/>
This book only contains information about stable features, as in-progress features are still<br/>changing, and surely they’ll be diﬀerent between when this book was written and when they<br/>get enabled in stable builds. You can&#160;ﬁnd documentation for nightly-only features online.<br/>
<a href="tests.html#626"><b>Rustup&#160;and&#160;the&#160;Role&#160;of&#160;Rust&#160;Nightly</b></a><br/>
Rustup makes it easy to change between diﬀerent release channels of Rust, on a global or<br/>per-project basis. By default, you’ll have stable Rust installed. To install nightly, for example:<br/>
$&#160;rustup&#160;toolchain&#160;install&#160;nightly<br/>
You can see all of the&#160;<i>toolchains</i>&#160;(releases of Rust and associated components) you have<br/>installed with&#160;&#160;rustup&#160;&#160;as well. Here’s an example on one of your authors’ Windows<br/>computer:<br/>
&gt;&#160;rustup&#160;toolchain&#160;list<br/>stable-x86_64-pc-windows-msvc&#160;(default)<br/>beta-x86_64-pc-windows-msvc<br/>nightly-x86_64-pc-windows-msvc<br/>
https://doc.rust-lang.org/book/print.html<br/>
626/627<br/>
<hr/>
<a name=627></a>14/08/2023,&#160;15:52<br/>
The&#160;Rust&#160;Programming&#160;Language<br/>
As you can see, the stable toolchain is the default. Most Rust users use stable most of the<br/>time. You might want to use stable most of the time, but use nightly on a speciﬁc project,<br/>because you care about a cutting-edge feature. To do so, you can use&#160;&#160;rustup&#160;override&#160;&#160;in<br/>that project’s directory to set the nightly toolchain as the one&#160;&#160;rustup&#160;&#160;should use when<br/>you’re in that directory:<br/>
$&#160;cd&#160;~/projects/needs-nightly<br/>$&#160;rustup&#160;override&#160;set&#160;nightly<br/>
Now, every time you call&#160;&#160;rustc&#160;&#160;or&#160;&#160;cargo&#160;&#160;inside of&#160;<i>~/projects/needs-nightly</i>,&#160;&#160;rustup&#160;&#160;will<br/>make sure that you are using nightly Rust, rather than your default of stable Rust. This<br/>comes in handy when you have a lot of Rust projects!<br/>
<a href="tests.html#627"><b>The&#160;RFC&#160;Process&#160;and&#160;Teams</b></a><br/>
So how do you learn about these new features? Rust’s development model follows a&#160;<i>Request<br/>For Comments (RFC) process</i>. If you’d like an improvement in Rust, you can write up a<br/>proposal, called an RFC.<br/>
Anyone can write RFCs to improve Rust, and the proposals are reviewed and discussed by<br/>the Rust team, which is comprised of many topic subteams. There’s a full list of the teams<br/><a href="https://www.rust-lang.org/governance">on Rust’s website, which includes teams for each area of the project: language design,<br/></a>compiler implementation, infrastructure, documentation, and more. The appropriate team<br/>reads the proposal and the comments, writes some comments of their own, and eventually,<br/>there’s consensus to accept or reject the feature.<br/>
If the feature is accepted, an issue is opened on the Rust repository, and someone can<br/>implement it. The person who implements it very well may not be the person who proposed<br/>the feature in the&#160;ﬁrst place! When the implementation is ready, it lands on the&#160;&#160;master<br/>branch behind a feature gate, as we discussed in the&#160;<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html#unstable-features">“Unstable Features”&#160;section.</a><br/>
After some time, once Rust developers who use nightly releases have been able to try out<br/>the new feature, team members will discuss the feature, how it’s worked out on nightly, and<br/>decide if it should make it into stable Rust or not. If the decision is to move forward, the<br/>feature gate is removed, and the feature is now considered stable! It rides the trains into a<br/>new stable release of Rust.<br/>
https://doc.rust-lang.org/book/print.html<br/>
627/627<br/>
<hr/>
</body>
</html>
